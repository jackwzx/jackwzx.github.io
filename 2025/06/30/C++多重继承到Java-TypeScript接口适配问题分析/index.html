<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-888YX9GKW2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-888YX9GKW2');
</script>
<!-- End Google Analytics -->


  
<!-- Google AdSense -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1587619220496591"
     crossorigin="anonymous"></script>
<!-- End Google AdSense -->
 
  
  <title>C++多重继承到Java/TypeScript接口适配问题分析 | Xujing的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="引言在跨语言开发中，经常需要将C++的多重继承类转换为Java或TypeScript对象。这种转换过程中，接口适配是一个关键问题，特别是当使用void*存储指针并进行强制类型转换时，可能会遇到一些陷阱。本文将从技术角度深入分析这个问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++多重继承到Java&#x2F;TypeScript接口适配问题分析">
<meta property="og:url" content="https://jackwzx.github.io/2025/06/30/C++%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%88%B0Java-TypeScript%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Xujing的博客">
<meta property="og:description" content="引言在跨语言开发中，经常需要将C++的多重继承类转换为Java或TypeScript对象。这种转换过程中，接口适配是一个关键问题，特别是当使用void*存储指针并进行强制类型转换时，可能会遇到一些陷阱。本文将从技术角度深入分析这个问题。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-06-30T02:00:00.000Z">
<meta property="article:modified_time" content="2025-06-30T08:15:07.435Z">
<meta property="article:author" content="Xujing">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="TypeScript">
<meta property="article:tag" content="设计模式">
<meta property="article:tag" content="接口适配">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Xujing的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Xujing的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap" style="display: none;">
        <!-- 已由本地搜索替代 -->
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-C++多重继承到Java-TypeScript接口适配问题分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/06/30/C++%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%88%B0Java-TypeScript%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2025-06-30T02:00:00.000Z" itemprop="datePublished">2025-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/">编程技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++多重继承到Java/TypeScript接口适配问题分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在跨语言开发中，经常需要将C++的多重继承类转换为Java或TypeScript对象。这种转换过程中，接口适配是一个关键问题，特别是当使用<code>void*</code>存储指针并进行强制类型转换时，可能会遇到一些陷阱。本文将从技术角度深入分析这个问题。</p>
<span id="more"></span>

<h2 id="C-多重继承的内存布局"><a href="#C-多重继承的内存布局" class="headerlink" title="C++多重继承的内存布局"></a>C++多重继承的内存布局</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>C++的多重继承允许一个类同时继承多个基类，这带来了复杂的内存布局问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> data1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> data2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> derivedData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="内存布局分析"><a href="#内存布局分析" class="headerlink" title="内存布局分析"></a>内存布局分析</h3><p>在C++中，多重继承的对象内存布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Derived对象内存布局：</span><br><span class="line">+------------------+</span><br><span class="line">| Base1 vtable ptr |  &lt;- 对象起始地址</span><br><span class="line">+------------------+</span><br><span class="line">| data1            |</span><br><span class="line">+------------------+</span><br><span class="line">| Base2 vtable ptr |  &lt;- 偏移量</span><br><span class="line">+------------------+</span><br><span class="line">| data2            |</span><br><span class="line">+------------------+</span><br><span class="line">| derivedData      |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure>

<h2 id="虚继承与非虚继承的区别"><a href="#虚继承与非虚继承的区别" class="headerlink" title="虚继承与非虚继承的区别"></a>虚继承与非虚继承的区别</h2><h3 id="菱形继承问题"><a href="#菱形继承问题" class="headerlink" title="菱形继承问题"></a>菱形继承问题</h3><p>当存在菱形继承时，虚继承与非虚继承的内存布局差异变得明显：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非虚继承 - 存在数据重复</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> baseData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> derived1Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> derived2Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Final</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> finalData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="非虚继承的内存布局"><a href="#非虚继承的内存布局" class="headerlink" title="非虚继承的内存布局"></a>非虚继承的内存布局</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Final对象内存布局（非虚继承）：</span><br><span class="line">+------------------+</span><br><span class="line">| Derived1 vtable  |  &lt;- 对象起始地址</span><br><span class="line">+------------------+</span><br><span class="line">| baseData         |  &lt;- Base数据副本1</span><br><span class="line">+------------------+</span><br><span class="line">| derived1Data     |</span><br><span class="line">+------------------+</span><br><span class="line">| Derived2 vtable  |  &lt;- 偏移量</span><br><span class="line">+------------------+</span><br><span class="line">| baseData         |  &lt;- Base数据副本2（重复！）</span><br><span class="line">+------------------+</span><br><span class="line">| derived2Data     |</span><br><span class="line">+------------------+</span><br><span class="line">| finalData        |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure>

<h3 id="虚继承的内存布局"><a href="#虚继承的内存布局" class="headerlink" title="虚继承的内存布局"></a>虚继承的内存布局</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚继承 - 解决数据重复</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> baseData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> derived1Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> derived2Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Final</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> finalData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Final对象内存布局（虚继承）：</span><br><span class="line">+------------------+</span><br><span class="line">| Derived1 vtable  |  &lt;- 对象起始地址</span><br><span class="line">+------------------+</span><br><span class="line">| derived1Data     |</span><br><span class="line">+------------------+</span><br><span class="line">| Derived2 vtable  |  &lt;- 偏移量</span><br><span class="line">+------------------+</span><br><span class="line">| derived2Data     |</span><br><span class="line">+------------------+</span><br><span class="line">| finalData        |</span><br><span class="line">+------------------+</span><br><span class="line">| Base vtable      |  &lt;- 共享的Base部分</span><br><span class="line">+------------------+</span><br><span class="line">| baseData         |  &lt;- 只有一份Base数据</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure>

<h3 id="虚继承的指针偏移复杂性"><a href="#虚继承的指针偏移复杂性" class="headerlink" title="虚继承的指针偏移复杂性"></a>虚继承的指针偏移复杂性</h3><p>虚继承引入了更复杂的指针偏移机制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚继承的指针偏移示例</span></span><br><span class="line">Final* <span class="keyword">final</span> = <span class="keyword">new</span> <span class="built_in">Final</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Base指针需要特殊处理</span></span><br><span class="line">Base* base = <span class="keyword">final</span>;  <span class="comment">// 编译器自动计算到共享Base部分的偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动计算偏移（危险！）</span></span><br><span class="line"><span class="type">void</span>* voidPtr = <span class="keyword">final</span>;</span><br><span class="line">Base* base2 = <span class="built_in">static_cast</span>&lt;Base*&gt;(voidPtr);  <span class="comment">// 错误！无法正确计算偏移</span></span><br></pre></td></tr></table></figure>

<h2 id="虚继承对接口适配的影响"><a href="#虚继承对接口适配的影响" class="headerlink" title="虚继承对接口适配的影响"></a>虚继承对接口适配的影响</h2><h3 id="1-更复杂的指针偏移计算"><a href="#1-更复杂的指针偏移计算" class="headerlink" title="1. 更复杂的指针偏移计算"></a>1. 更复杂的指针偏移计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚继承情况下的错误包装</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VirtualWrapper</span>(<span class="type">void</span>* p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于虚继承，这种转换是危险的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例 - 存在问题</span></span><br><span class="line">Final* <span class="keyword">final</span> = <span class="keyword">new</span> <span class="built_in">Final</span>();</span><br><span class="line"><span class="function">VirtualWrapper <span class="title">wrapper</span><span class="params">(<span class="keyword">final</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些转换可能失败或指向错误位置</span></span><br><span class="line">Base* base = wrapper.<span class="built_in">get</span>&lt;Base&gt;();        <span class="comment">// 可能错误</span></span><br><span class="line">Derived1* d1 = wrapper.<span class="built_in">get</span>&lt;Derived1&gt;();  <span class="comment">// 可能错误</span></span><br><span class="line">Derived2* d2 = wrapper.<span class="built_in">get</span>&lt;Derived2&gt;();  <span class="comment">// 可能错误</span></span><br></pre></td></tr></table></figure>

<h3 id="2-虚函数表访问的复杂性"><a href="#2-虚函数表访问的复杂性" class="headerlink" title="2. 虚函数表访问的复杂性"></a>2. 虚函数表访问的复杂性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚继承的虚函数表结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">VirtualBase</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualDerived</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> VirtualBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">derivedMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚函数表访问问题</span></span><br><span class="line"><span class="type">void</span>* ptr = <span class="keyword">new</span> <span class="built_in">VirtualDerived</span>();</span><br><span class="line">VirtualBase* base = <span class="built_in">static_cast</span>&lt;VirtualBase*&gt;(ptr);</span><br><span class="line">base-&gt;<span class="built_in">method</span>();  <span class="comment">// 可能访问错误的虚函数表</span></span><br></pre></td></tr></table></figure>

<h2 id="针对虚继承的解决方案"><a href="#针对虚继承的解决方案" class="headerlink" title="针对虚继承的解决方案"></a>针对虚继承的解决方案</h2><h3 id="1-使用dynamic-cast进行安全转换"><a href="#1-使用dynamic-cast进行安全转换" class="headerlink" title="1. 使用dynamic_cast进行安全转换"></a>1. 使用dynamic_cast进行安全转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全的虚继承包装器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualSafeWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VirtualSafeWrapper</span>(T* p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    U* <span class="title">safeCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用dynamic_cast处理虚继承</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;U*&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">canCast</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;U*&gt;(ptr) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Final* <span class="keyword">final</span> = <span class="keyword">new</span> <span class="built_in">Final</span>();</span><br><span class="line"><span class="function">VirtualSafeWrapper&lt;Final&gt; <span class="title">wrapper</span><span class="params">(<span class="keyword">final</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的类型转换</span></span><br><span class="line"><span class="keyword">if</span> (wrapper.<span class="built_in">canCast</span>&lt;Base&gt;()) &#123;</span><br><span class="line">    Base* base = wrapper.<span class="built_in">safeCast</span>&lt;Base&gt;();</span><br><span class="line">    base-&gt;<span class="built_in">method</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-虚继承感知的工厂模式"><a href="#2-虚继承感知的工厂模式" class="headerlink" title="2. 虚继承感知的工厂模式"></a>2. 虚继承感知的工厂模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualInterfaceFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Target, <span class="keyword">typename</span> Source&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> Target* <span class="title">createInterface</span><span class="params">(Source* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否存在虚继承关系</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_base_of_v&lt;Target, Source&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_virtual_base_of_v&lt;Target, Source&gt;)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 虚继承：使用dynamic_cast</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;Target*&gt;(ptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非虚继承：可以使用static_cast</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Target*&gt;(ptr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-类型信息增强的包装器"><a href="#3-类型信息增强的包装器" class="headerlink" title="3. 类型信息增强的包装器"></a>3. 类型信息增强的包装器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualTypeInfo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">InheritanceType</span> &#123;</span><br><span class="line">        NORMAL,</span><br><span class="line">        VIRTUAL</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> InheritanceType <span class="title">getInheritanceType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查T是否包含虚继承</span></span><br><span class="line">        <span class="keyword">return</span> std::is_virtual_base_of_v&lt;T, T&gt; ? </span><br><span class="line">               InheritanceType::VIRTUAL : InheritanceType::NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EnhancedWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">    VirtualTypeInfo::InheritanceType inheritanceType;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EnhancedWrapper</span>(T* p) : <span class="built_in">ptr</span>(p), </span><br><span class="line">        <span class="built_in">inheritanceType</span>(VirtualTypeInfo::<span class="built_in">getInheritanceType</span>&lt;T&gt;()) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    U* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inheritanceType == VirtualTypeInfo::InheritanceType::VIRTUAL) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;U*&gt;(ptr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;U*&gt;(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="虚继承与非虚继承的解决方案对比"><a href="#虚继承与非虚继承的解决方案对比" class="headerlink" title="虚继承与非虚继承的解决方案对比"></a>虚继承与非虚继承的解决方案对比</h2><h3 id="非虚继承场景"><a href="#非虚继承场景" class="headerlink" title="非虚继承场景"></a>非虚继承场景</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非虚继承：相对简单的指针偏移</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonVirtualWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于非虚继承，static_cast相对安全</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="虚继承场景"><a href="#虚继承场景" class="headerlink" title="虚继承场景"></a>虚继承场景</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚继承：需要更复杂的处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于虚继承，必须使用dynamic_cast</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="混合场景的处理"><a href="#混合场景的处理" class="headerlink" title="混合场景的处理"></a>混合场景的处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理混合继承场景</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HybridWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    std::type_info* originalType;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">HybridWrapper</span><span class="params">(T* p)</span> : ptr(p), type(&amp;typeid(T)) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    U* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否为虚继承关系</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">hasVirtualInheritance</span>&lt;U&gt;()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;U*&gt;(ptr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;U*&gt;(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">hasVirtualInheritance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现虚继承检测逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 简化实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="接口适配的常见方案"><a href="#接口适配的常见方案" class="headerlink" title="接口适配的常见方案"></a>接口适配的常见方案</h2><h3 id="方案1：使用void-指针存储"><a href="#方案1：使用void-指针存储" class="headerlink" title="方案1：使用void*指针存储"></a>方案1：使用void*指针存储</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 包装层</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Wrapper</span>(<span class="type">void</span>* p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">getRaw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="function">Wrapper <span class="title">wrapper</span><span class="params">(derived)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Base1接口</span></span><br><span class="line">Base1* base1 = wrapper.<span class="built_in">get</span>&lt;Base1&gt;();</span><br><span class="line"><span class="comment">// 获取Base2接口  </span></span><br><span class="line">Base2* base2 = wrapper.<span class="built_in">get</span>&lt;Base2&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="方案2：类型安全的接口映射"><a href="#方案2：类型安全的接口映射" class="headerlink" title="方案2：类型安全的接口映射"></a>方案2：类型安全的接口映射</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更安全的包装方案</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    std::type_info* type;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SafeWrapper</span><span class="params">(T* p)</span> : ptr(p), type(&amp;typeid(T)) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">typeid</span>(T) == *type) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="1-指针偏移问题"><a href="#1-指针偏移问题" class="headerlink" title="1. 指针偏移问题"></a>1. 指针偏移问题</h3><p>当使用<code>void*</code>存储多重继承对象时，直接强制转换可能导致指针偏移错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="type">void</span>* voidPtr = derived;  <span class="comment">// 存储Derived*的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：直接转换到Base2</span></span><br><span class="line">Base2* base2 = <span class="built_in">static_cast</span>&lt;Base2*&gt;(voidPtr);  <span class="comment">// 可能指向错误位置</span></span><br></pre></td></tr></table></figure>

<p><strong>问题原因</strong>：<code>void*</code>存储的是<code>Derived</code>对象的起始地址，但<code>Base2</code>的虚函数表在偏移位置，直接转换会得到错误的地址。</p>
<h3 id="2-虚函数表访问错误"><a href="#2-虚函数表访问错误" class="headerlink" title="2. 虚函数表访问错误"></a>2. 虚函数表访问错误</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="type">void</span>* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Base2* base2 = <span class="built_in">static_cast</span>&lt;Base2*&gt;(ptr);</span><br><span class="line">base2-&gt;<span class="built_in">method2</span>();  <span class="comment">// 可能访问错误的虚函数表</span></span><br></pre></td></tr></table></figure>

<h3 id="3-类型信息丢失"><a href="#3-类型信息丢失" class="headerlink" title="3. 类型信息丢失"></a>3. 类型信息丢失</h3><p>使用<code>void*</code>会丢失类型信息，无法进行运行时类型检查：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="comment">// 无法知道ptr实际指向什么类型</span></span><br><span class="line"><span class="comment">// 无法进行安全的类型转换</span></span><br></pre></td></tr></table></figure>

<h2 id="Java-TypeScript接口适配方案"><a href="#Java-TypeScript接口适配方案" class="headerlink" title="Java/TypeScript接口适配方案"></a>Java/TypeScript接口适配方案</h2><h3 id="Java接口映射"><a href="#Java接口映射" class="headerlink" title="Java接口映射"></a>Java接口映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Base1Interface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Base2Interface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CppWrapper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> nativePtr;  <span class="comment">// 存储C++对象指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CppWrapper</span><span class="params">(<span class="type">long</span> ptr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nativePtr = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过JNI调用C++方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取原始指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getNativePtr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nativePtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript接口映射"><a href="#TypeScript接口映射" class="headerlink" title="TypeScript接口映射"></a>TypeScript接口映射</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript接口定义</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Base1Interface</span> &#123;</span><br><span class="line">    <span class="title function_">method1</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Base2Interface</span> &#123;</span><br><span class="line">    <span class="title function_">method2</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CppWrapper</span> <span class="keyword">implements</span> <span class="title class_">Base1Interface</span>, <span class="title class_">Base2Interface</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">nativePtr</span>: <span class="built_in">number</span>;  <span class="comment">// 存储C++对象指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">ptr: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">nativePtr</span> = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过FFI调用C++方法</span></span><br><span class="line">    <span class="title function_">method1</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 调用native方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">callNativeMethod</span>(<span class="variable language_">this</span>.<span class="property">nativePtr</span>, <span class="string">&#x27;method1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">method2</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">callNativeMethod</span>(<span class="variable language_">this</span>.<span class="property">nativePtr</span>, <span class="string">&#x27;method2&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">callNativeMethod</span>(<span class="attr">ptr</span>: <span class="built_in">number</span>, <span class="attr">methodName</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 实现native调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="正确的解决方案"><a href="#正确的解决方案" class="headerlink" title="正确的解决方案"></a>正确的解决方案</h2><h3 id="1-使用类型安全的包装器"><a href="#1-使用类型安全的包装器" class="headerlink" title="1. 使用类型安全的包装器"></a>1. 使用类型安全的包装器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypedWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TypedWrapper</span>(T* p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    U* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;U*&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="function">TypedWrapper&lt;Derived&gt; <span class="title">wrapper</span><span class="params">(derived)</span></span>;</span><br><span class="line"></span><br><span class="line">Base1* base1 = wrapper.<span class="built_in">cast</span>&lt;Base1&gt;();</span><br><span class="line">Base2* base2 = wrapper.<span class="built_in">cast</span>&lt;Base2&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="2-接口分离原则"><a href="#2-接口分离原则" class="headerlink" title="2. 接口分离原则"></a>2. 接口分离原则</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为每个接口创建独立的包装器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1Wrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Base1* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1Wrapper</span>(Base1* p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123; ptr-&gt;<span class="built_in">method1</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2Wrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Base2* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2Wrapper</span>(Base2* p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123; ptr-&gt;<span class="built_in">method2</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-工厂模式创建接口"><a href="#3-工厂模式创建接口" class="headerlink" title="3. 工厂模式创建接口"></a>3. 工厂模式创建接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterfaceFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> T* <span class="title">createInterface</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据类型信息正确计算偏移量</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_base_of_v&lt;T, Derived&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h2><h3 id="1-避免使用void-进行类型转换"><a href="#1-避免使用void-进行类型转换" class="headerlink" title="1. 避免使用void*进行类型转换"></a>1. 避免使用void*进行类型转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="type">void</span>* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Base2* base2 = <span class="built_in">static_cast</span>&lt;Base2*&gt;(ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Base2* base2 = derived;  <span class="comment">// 编译器自动处理偏移</span></span><br></pre></td></tr></table></figure>

<h3 id="2-使用智能指针管理生命周期"><a href="#2-使用智能指针管理生命周期" class="headerlink" title="2. 使用智能指针管理生命周期"></a>2. 使用智能指针管理生命周期</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Derived&gt; derived = std::<span class="built_in">make_unique</span>&lt;Derived&gt;();</span><br><span class="line">std::unique_ptr&lt;Base1&gt; base1 = std::<span class="built_in">move</span>(derived);</span><br></pre></td></tr></table></figure>

<h3 id="3-提供类型安全的接口"><a href="#3-提供类型安全的接口" class="headerlink" title="3. 提供类型安全的接口"></a>3. 提供类型安全的接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SafeInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SafeInterface</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">as</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">is</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> T*&gt;(<span class="keyword">this</span>) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++多重继承转换为Java/TypeScript时，使用<code>void*</code>存储指针并进行强制类型转换确实存在严重问题：</p>
<ol>
<li><strong>指针偏移错误</strong>：直接转换会忽略多重继承的内存布局</li>
<li><strong>虚函数表访问错误</strong>：可能导致调用错误的虚函数</li>
<li><strong>类型安全缺失</strong>：无法进行运行时类型检查</li>
</ol>
<p><strong>推荐解决方案</strong>：</p>
<ul>
<li>使用类型安全的包装器</li>
<li>实现接口分离</li>
<li>采用工厂模式创建接口</li>
<li>避免直接使用<code>void*</code>进行类型转换</li>
</ul>
<p>通过这些方案，可以确保C++多重继承类在转换为Java/TypeScript时能够正确适配接口，避免运行时错误。</p>
<h2 id="虚继承与非虚继承的关键差异总结"><a href="#虚继承与非虚继承的关键差异总结" class="headerlink" title="虚继承与非虚继承的关键差异总结"></a>虚继承与非虚继承的关键差异总结</h2><h3 id="内存布局差异"><a href="#内存布局差异" class="headerlink" title="内存布局差异"></a>内存布局差异</h3><table>
<thead>
<tr>
<th>特性</th>
<th>非虚继承</th>
<th>虚继承</th>
</tr>
</thead>
<tbody><tr>
<td>数据重复</td>
<td>存在重复的基类数据</td>
<td>共享基类数据</td>
</tr>
<tr>
<td>内存布局</td>
<td>相对简单，线性排列</td>
<td>复杂，包含虚基类指针</td>
</tr>
<tr>
<td>指针偏移</td>
<td>固定偏移量</td>
<td>动态计算的偏移量</td>
</tr>
</tbody></table>
<h3 id="接口适配策略差异"><a href="#接口适配策略差异" class="headerlink" title="接口适配策略差异"></a>接口适配策略差异</h3><table>
<thead>
<tr>
<th>转换方式</th>
<th>非虚继承</th>
<th>虚继承</th>
</tr>
</thead>
<tbody><tr>
<td>static_cast</td>
<td>相对安全</td>
<td>危险，可能导致错误偏移</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>可选，但开销较大</td>
<td>必需，保证类型安全</td>
</tr>
<tr>
<td>void*转换</td>
<td>可能工作，但不推荐</td>
<td>几乎总是失败</td>
</tr>
</tbody></table>
<h3 id="解决方案选择"><a href="#解决方案选择" class="headerlink" title="解决方案选择"></a>解决方案选择</h3><p><strong>非虚继承场景</strong>：</p>
<ul>
<li>可以使用<code>static_cast</code>进行类型转换</li>
<li>指针偏移计算相对简单</li>
<li>包装器实现相对直接</li>
</ul>
<p><strong>虚继承场景</strong>：</p>
<ul>
<li>必须使用<code>dynamic_cast</code>进行类型转换</li>
<li>需要复杂的指针偏移计算</li>
<li>包装器需要特殊处理虚基类</li>
</ul>
<p><strong>混合场景</strong>：</p>
<ul>
<li>需要检测继承类型</li>
<li>根据继承类型选择不同的转换策略</li>
<li>实现更复杂的包装器逻辑</li>
</ul>
<h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><ol>
<li><strong>非虚继承</strong>：<code>static_cast</code>开销小，适合性能敏感场景</li>
<li><strong>虚继承</strong>：<code>dynamic_cast</code>开销大，但保证类型安全</li>
<li><strong>混合场景</strong>：需要运行时类型检查，性能开销最大</li>
</ol>
<h3 id="最佳实践建议-1"><a href="#最佳实践建议-1" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h3><ol>
<li><strong>设计阶段</strong>：尽量避免复杂的多重继承，特别是虚继承</li>
<li><strong>接口设计</strong>：为每个接口创建独立的包装器</li>
<li><strong>类型安全</strong>：优先使用<code>dynamic_cast</code>而非<code>static_cast</code></li>
<li><strong>错误处理</strong>：始终检查类型转换的返回值</li>
<li><strong>文档化</strong>：明确记录继承关系和转换策略</li>
</ol>
<p>通过这些差异化的处理策略，可以确保C++多重继承类在跨语言接口适配中既保证类型安全，又兼顾性能需求。</p>
<h2 id="SWIG解决方案分析"><a href="#SWIG解决方案分析" class="headerlink" title="SWIG解决方案分析"></a>SWIG解决方案分析</h2><h3 id="SWIG简介"><a href="#SWIG简介" class="headerlink" title="SWIG简介"></a>SWIG简介</h3><p>SWIG（Simplified Wrapper and Interface Generator）是一个强大的跨语言接口生成工具，能够自动为C++代码生成多种语言的绑定，包括Java、Python、C#等。SWIG通过分析C++代码的语法结构，自动处理复杂的类型转换和内存管理问题。</p>
<h3 id="SWIG处理多重继承的机制"><a href="#SWIG处理多重继承的机制" class="headerlink" title="SWIG处理多重继承的机制"></a>SWIG处理多重继承的机制</h3><h4 id="1-自动类型映射"><a href="#1-自动类型映射" class="headerlink" title="1. 自动类型映射"></a>1. 自动类型映射</h4><p>SWIG使用类型映射（Type Mapping）机制来处理C++类型到目标语言的转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 多重继承类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base1</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base2</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SWIG接口文件 (.i)</span><br><span class="line">%module example</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">#include &quot;example.h&quot;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%include &quot;example.h&quot;</span><br><span class="line"></span><br><span class="line">// 类型映射配置</span><br><span class="line">%typemap(javabase) Base1 &quot;java.lang.Object&quot;</span><br><span class="line">%typemap(javabase) Base2 &quot;java.lang.Object&quot;</span><br><span class="line">%typemap(javabase) Derived &quot;Base1, Base2&quot;</span><br></pre></td></tr></table></figure>

<h4 id="2-自动生成包装类"><a href="#2-自动生成包装类" class="headerlink" title="2. 自动生成包装类"></a>2. 自动生成包装类</h4><p>SWIG会自动为每个C++类生成对应的包装类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG自动生成的Java包装类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base1</span> <span class="keyword">implements</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> swigCPtr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> swigCMemOwn;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Derived</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(exampleJNI.new_Derived(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Derived</span><span class="params">(<span class="type">long</span> cPtr, <span class="type">boolean</span> cMemoryOwn)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(exampleJNI.Derived_SWIGUpcast(cPtr), cMemoryOwn);</span><br><span class="line">        swigCPtr = cPtr;</span><br><span class="line">        swigCMemOwn = cMemoryOwn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        exampleJNI.Derived_method1(swigCPtr, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        exampleJNI.Derived_method2(swigCPtr, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SWIG的解决方案策略"><a href="#SWIG的解决方案策略" class="headerlink" title="SWIG的解决方案策略"></a>SWIG的解决方案策略</h3><h4 id="1-类型安全的包装器（Type-Safe-Wrapper）"><a href="#1-类型安全的包装器（Type-Safe-Wrapper）" class="headerlink" title="1. 类型安全的包装器（Type-Safe Wrapper）"></a>1. 类型安全的包装器（Type-Safe Wrapper）</h4><p>SWIG采用类型安全的包装器策略，而不是使用<code>void*</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG内部生成的C++包装代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SWIG_Derived</span> : <span class="keyword">public</span> Derived &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* swig_self;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SWIG_Derived</span>() : <span class="built_in">swig_self</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型安全的指针获取</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 安全的类型转换</span></span><br><span class="line">    <span class="function">Base1* <span class="title">as_Base1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Base1*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Base2* <span class="title">as_Base2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Base2*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-接口分离原则（Interface-Segregation）"><a href="#2-接口分离原则（Interface-Segregation）" class="headerlink" title="2. 接口分离原则（Interface Segregation）"></a>2. 接口分离原则（Interface Segregation）</h4><p>SWIG为每个基类接口生成独立的包装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG生成的接口分离</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base1</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Object &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> swigCPtr;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> swigCMemOwn;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Base1</span><span class="params">(<span class="type">long</span> cPtr, <span class="type">boolean</span> cMemoryOwn)</span> &#123;</span><br><span class="line">        swigCPtr = cPtr;</span><br><span class="line">        swigCMemOwn = cMemoryOwn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        exampleJNI.Base1_method1(swigCPtr, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base2</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Object &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> swigCPtr;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> swigCMemOwn;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Base2</span><span class="params">(<span class="type">long</span> cPtr, <span class="type">boolean</span> cMemoryOwn)</span> &#123;</span><br><span class="line">        swigCPtr = cPtr;</span><br><span class="line">        swigCMemOwn = cMemoryOwn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        exampleJNI.Base2_method2(swigCPtr, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-工厂模式创建接口-1"><a href="#3-工厂模式创建接口-1" class="headerlink" title="3. 工厂模式创建接口"></a>3. 工厂模式创建接口</h4><p>SWIG使用工厂模式来创建和管理接口实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG内部工厂实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SWIG_InterfaceFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> T* <span class="title">create_interface</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">const</span> std::type_info&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据类型信息创建正确的接口</span></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="built_in">typeid</span>(Derived)) &#123;</span><br><span class="line">            Derived* derived = <span class="built_in">static_cast</span>&lt;Derived*&gt;(ptr);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(derived);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> Base1* <span class="title">create_Base1_interface</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">create_interface</span>&lt;Base1&gt;(ptr, <span class="built_in">typeid</span>(*<span class="built_in">static_cast</span>&lt;Derived*&gt;(ptr)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> Base2* <span class="title">create_Base2_interface</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">create_interface</span>&lt;Base2&gt;(ptr, <span class="built_in">typeid</span>(*<span class="built_in">static_cast</span>&lt;Derived*&gt;(ptr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="SWIG处理虚继承的特殊机制"><a href="#SWIG处理虚继承的特殊机制" class="headerlink" title="SWIG处理虚继承的特殊机制"></a>SWIG处理虚继承的特殊机制</h3><h4 id="1-虚继承感知的类型转换"><a href="#1-虚继承感知的类型转换" class="headerlink" title="1. 虚继承感知的类型转换"></a>1. 虚继承感知的类型转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚继承场景</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">VirtualBase</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualDerived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> VirtualBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualDerived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> VirtualBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Final</span> : <span class="keyword">public</span> VirtualDerived1, <span class="keyword">public</span> VirtualDerived2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SWIG虚继承处理</span><br><span class="line">%module virtual_example</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">#include &quot;virtual_example.h&quot;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">// 虚继承特殊处理</span><br><span class="line">%feature(&quot;director&quot;) VirtualBase;</span><br><span class="line">%feature(&quot;director&quot;) VirtualDerived1;</span><br><span class="line">%feature(&quot;director&quot;) VirtualDerived2;</span><br><span class="line"></span><br><span class="line">%include &quot;virtual_example.h&quot;</span><br></pre></td></tr></table></figure>

<h4 id="2-动态类型检查"><a href="#2-动态类型检查" class="headerlink" title="2. 动态类型检查"></a>2. 动态类型检查</h4><p>SWIG为虚继承提供动态类型检查：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG生成的虚继承安全代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Final</span> <span class="keyword">extends</span> <span class="title class_">VirtualDerived1</span> <span class="keyword">implements</span> <span class="title class_">VirtualDerived2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> swigCPtr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> swigCMemOwn;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Final</span><span class="params">(<span class="type">long</span> cPtr, <span class="type">boolean</span> cMemoryOwn)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(exampleJNI.Final_SWIGUpcast(cPtr), cMemoryOwn);</span><br><span class="line">        swigCPtr = cPtr;</span><br><span class="line">        swigCMemOwn = cMemoryOwn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 安全的虚基类访问</span></span><br><span class="line">    <span class="keyword">public</span> VirtualBase <span class="title function_">as_VirtualBase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">cPtr</span> <span class="operator">=</span> exampleJNI.Final_as_VirtualBase(swigCPtr, <span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (cPtr == <span class="number">0</span>) ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">VirtualBase</span>(cPtr, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        exampleJNI.Final_method(swigCPtr, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SWIG的JNI层实现"><a href="#SWIG的JNI层实现" class="headerlink" title="SWIG的JNI层实现"></a>SWIG的JNI层实现</h3><h4 id="1-自动生成的JNI代码"><a href="#1-自动生成的JNI代码" class="headerlink" title="1. 自动生成的JNI代码"></a>1. 自动生成的JNI代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG生成的JNI代码</span></span><br><span class="line"><span class="function">SWIGEXPORT jlong JNICALL <span class="title">Java_exampleJNI_new_1Derived</span><span class="params">(JNIEnv *jenv, jclass jcls)</span> </span>&#123;</span><br><span class="line">    jlong jresult = <span class="number">0</span>;</span><br><span class="line">    Derived *result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    (<span class="type">void</span>)jenv;</span><br><span class="line">    (<span class="type">void</span>)jcls;</span><br><span class="line">    result = (Derived *)<span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    *(Derived **)&amp;jresult = result;</span><br><span class="line">    <span class="keyword">return</span> jresult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SWIGEXPORT jlong JNICALL <span class="title">Java_exampleJNI_Derived_1SWIGUpcast</span><span class="params">(JNIEnv *jenv, jclass jcls, jlong jarg1)</span> </span>&#123;</span><br><span class="line">    jlong jresult = <span class="number">0</span>;</span><br><span class="line">    Derived *arg1 = (Derived *) <span class="number">0</span>;</span><br><span class="line">    Base1 *result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    (<span class="type">void</span>)jenv;</span><br><span class="line">    (<span class="type">void</span>)jcls;</span><br><span class="line">    arg1 = *(Derived **)&amp;jarg1;</span><br><span class="line">    result = (Base1 *)arg1;</span><br><span class="line">    *(Base1 **)&amp;jresult = result;</span><br><span class="line">    <span class="keyword">return</span> jresult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-类型安全的指针管理"><a href="#2-类型安全的指针管理" class="headerlink" title="2. 类型安全的指针管理"></a>2. 类型安全的指针管理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG的智能指针管理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SWIG_PointerManager</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;<span class="type">void</span>*, <span class="type">int</span>&gt; reference_count;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">add_reference</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            reference_count[ptr]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">remove_reference</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr &amp;&amp; --reference_count[ptr] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            reference_count.<span class="built_in">erase</span>(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="SWIG的优势与局限性"><a href="#SWIG的优势与局限性" class="headerlink" title="SWIG的优势与局限性"></a>SWIG的优势与局限性</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li><strong>自动化程度高</strong>：自动处理复杂的类型转换和内存管理</li>
<li><strong>类型安全</strong>：使用类型安全的包装器而非<code>void*</code></li>
<li><strong>多语言支持</strong>：支持Java、Python、C#等多种语言</li>
<li><strong>虚继承支持</strong>：能够正确处理虚继承的复杂情况</li>
<li><strong>性能优化</strong>：生成的代码经过优化，性能较好</li>
</ol>
<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ol>
<li><strong>学习曲线</strong>：需要学习SWIG的语法和配置</li>
<li><strong>调试困难</strong>：生成的代码复杂，调试相对困难</li>
<li><strong>定制化限制</strong>：某些特殊需求可能需要复杂的配置</li>
<li><strong>编译依赖</strong>：需要额外的编译步骤和依赖</li>
</ol>
<h3 id="SWIG配置最佳实践"><a href="#SWIG配置最佳实践" class="headerlink" title="SWIG配置最佳实践"></a>SWIG配置最佳实践</h3><h4 id="1-接口文件配置"><a href="#1-接口文件配置" class="headerlink" title="1. 接口文件配置"></a>1. 接口文件配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%module mymodule</span><br><span class="line"></span><br><span class="line">// 启用异常处理</span><br><span class="line">%exception &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        $action</span><br><span class="line">    &#125; catch (const std::exception&amp; e) &#123;</span><br><span class="line">        SWIG_exception(SWIG_RuntimeError, e.what());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类型映射配置</span><br><span class="line">%typemap(javacode) Derived %&#123;</span><br><span class="line">    // 自定义Java代码</span><br><span class="line">    public void customMethod() &#123;</span><br><span class="line">        // 实现自定义方法</span><br><span class="line">    &#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%include &quot;mymodule.h&quot;</span><br></pre></td></tr></table></figure>

<h4 id="2-内存管理配置"><a href="#2-内存管理配置" class="headerlink" title="2. 内存管理配置"></a>2. 内存管理配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 智能指针支持</span><br><span class="line">%include &lt;std_shared_ptr.i&gt;</span><br><span class="line">%shared_ptr(Derived)</span><br><span class="line"></span><br><span class="line">// 自定义内存管理</span><br><span class="line">%typemap(javafinalize) Derived &quot;&quot;</span><br><span class="line">%typemap(javadestruct) Derived &#123;</span><br><span class="line">    if (swigCPtr != 0) &#123;</span><br><span class="line">        if (swigCMemOwn) &#123;</span><br><span class="line">            swigCMemOwn = false;</span><br><span class="line">            exampleJNI.delete_Derived(swigCPtr);</span><br><span class="line">        &#125;</span><br><span class="line">        swigCPtr = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>SWIG采用了<strong>综合策略</strong>来解决C++多重继承的接口适配问题：</p>
<ol>
<li><strong>类型安全的包装器</strong>：避免使用<code>void*</code>，使用类型安全的模板包装器</li>
<li><strong>接口分离原则</strong>：为每个基类生成独立的包装类</li>
<li><strong>工厂模式</strong>：使用工厂模式创建和管理接口实例</li>
<li><strong>动态类型检查</strong>：为虚继承提供运行时类型检查</li>
<li><strong>智能内存管理</strong>：自动处理对象生命周期和引用计数</li>
</ol>
<p>SWIG的解决方案相比手动实现具有以下优势：</p>
<ul>
<li><strong>自动化程度高</strong>：减少手动编写包装代码的工作量</li>
<li><strong>类型安全性好</strong>：自动处理复杂的类型转换</li>
<li><strong>维护成本低</strong>：接口变更时自动更新绑定代码</li>
<li><strong>多语言支持</strong>：一套配置支持多种目标语言</li>
</ul>
<p>对于复杂的C++多重继承项目，SWIG是一个值得考虑的解决方案，特别是当需要支持多种目标语言时。</p>
<h2 id="实际案例：基于void-的改进方案"><a href="#实际案例：基于void-的改进方案" class="headerlink" title="实际案例：基于void*的改进方案"></a>实际案例：基于void*的改进方案</h2><h3 id="问题代码分析"><a href="#问题代码分析" class="headerlink" title="问题代码分析"></a>问题代码分析</h3><p>以下是一个实际使用<code>void*</code>存储指针的代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CODE_GEN_BASE_OBJ</span> : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> *self;  <span class="comment">// 问题：使用void*存储指针</span></span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最小改动解决方案"><a href="#最小改动解决方案" class="headerlink" title="最小改动解决方案"></a>最小改动解决方案</h3><h4 id="方案1：类型信息增强（推荐）"><a href="#方案1：类型信息增强（推荐）" class="headerlink" title="方案1：类型信息增强（推荐）"></a>方案1：类型信息增强（推荐）</h4><p>在保持<code>void* self</code>的基础上，添加类型信息来支持安全的类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CODE_GEN_BASE_OBJ</span> : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> *self;  <span class="comment">// 保持原有接口</span></span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增：类型信息存储</span></span><br><span class="line">    std::type_info* original_type;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增：安全的类型转换方法</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">safe_cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (original_type &amp;&amp; *original_type == <span class="built_in">typeid</span>(T)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">can_cast</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> original_type &amp;&amp; *original_type == <span class="built_in">typeid</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增：类型安全的接口获取</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">can_cast</span>&lt;T&gt;()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">safe_cast</span>&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试dynamic_cast（如果支持RTTI）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;T*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(self));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有方法保持不变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方案2：模板化存储（改动稍大但更安全）"><a href="#方案2：模板化存储（改动稍大但更安全）" class="headerlink" title="方案2：模板化存储（改动稍大但更安全）"></a>方案2：模板化存储（改动稍大但更安全）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP, <span class="keyword">typename</span> STORED_TYPE = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> CODE_GEN_BASE_OBJ : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP, STORED_TYPE&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用模板化存储替代void*</span></span><br><span class="line">    STORED_TYPE* self;</span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型安全的转换</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_base_of_v&lt;T, STORED_TYPE&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;T*&gt;(self);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容原有void*接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">get_raw_ptr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(self); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有方法保持不变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP, STORED_TYPE&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方案3：智能指针包装（最安全但改动最大）"><a href="#方案3：智能指针包装（最安全但改动最大）" class="headerlink" title="方案3：智能指针包装（最安全但改动最大）"></a>方案3：智能指针包装（最安全但改动最大）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CODE_GEN_BASE_OBJ</span> : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用智能指针管理</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">void</span>&gt; self_ptr;</span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容原有void*接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">get_self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> self_ptr.<span class="built_in">get</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型安全的访问</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    std::shared_ptr&lt;T&gt; <span class="title">get_typed_ptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">static_pointer_cast</span>&lt;T&gt;(self_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self_ptr.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有方法保持不变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="改进后的Cast方法实现"><a href="#改进后的Cast方法实现" class="headerlink" title="改进后的Cast方法实现"></a>改进后的Cast方法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="type">void</span> CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;::<span class="built_in">Cast</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (info.<span class="built_in">Length</span>() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(Djsi::Value::<span class="built_in">Undefined</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取目标类型名称</span></span><br><span class="line">    std::string target_type = info[<span class="number">0</span>].<span class="built_in">As</span>&lt;Djsi::String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用类型安全的转换</span></span><br><span class="line">    <span class="keyword">if</span> (target_type == <span class="string">&quot;Base1&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span>* base1 = <span class="built_in">get_interface</span>&lt;Base1&gt;()) &#123;</span><br><span class="line">            <span class="comment">// 创建新的包装对象</span></span><br><span class="line">            <span class="keyword">auto</span> wrapper = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;(info);</span><br><span class="line">            wrapper-&gt;self = base1;</span><br><span class="line">            wrapper-&gt;owned = <span class="literal">false</span>;  <span class="comment">// 不拥有对象</span></span><br><span class="line">            wrapper-&gt;info = <span class="built_in">get_type_info</span>&lt;Base1&gt;();</span><br><span class="line">            info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(wrapper-&gt;<span class="built_in">ObjSharedPtr</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target_type == <span class="string">&quot;Base2&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span>* base2 = <span class="built_in">get_interface</span>&lt;Base2&gt;()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> wrapper = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;(info);</span><br><span class="line">            wrapper-&gt;self = base2;</span><br><span class="line">            wrapper-&gt;owned = <span class="literal">false</span>;</span><br><span class="line">            wrapper-&gt;info = <span class="built_in">get_type_info</span>&lt;Base2&gt;();</span><br><span class="line">            info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(wrapper-&gt;<span class="built_in">ObjSharedPtr</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">    info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(Djsi::Value::<span class="built_in">Undefined</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数改进"><a href="#构造函数改进" class="headerlink" title="构造函数改进"></a>构造函数改进</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line">CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;::<span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="comment">// 存储原始类型信息</span></span><br><span class="line">    <span class="keyword">if</span> (self) &#123;</span><br><span class="line">        original_type = &amp;<span class="built_in">typeid</span>(*<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(self));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他初始化代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用改进后的类型安全接口</span></span><br><span class="line"><span class="keyword">auto</span> obj = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;MyWrapper&gt;&gt;(info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的类型转换</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span>* base1 = obj-&gt;<span class="built_in">get_interface</span>&lt;Base1&gt;()) &#123;</span><br><span class="line">    base1-&gt;<span class="built_in">method1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span>* base2 = obj-&gt;<span class="built_in">get_interface</span>&lt;Base2&gt;()) &#123;</span><br><span class="line">    base2-&gt;<span class="built_in">method2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查类型转换是否可能</span></span><br><span class="line"><span class="keyword">if</span> (obj-&gt;<span class="built_in">can_cast</span>&lt;Base1&gt;()) &#123;</span><br><span class="line">    <span class="comment">// 安全的转换</span></span><br><span class="line">    <span class="keyword">auto</span>* base1 = obj-&gt;<span class="built_in">safe_cast</span>&lt;Base1&gt;();</span><br><span class="line">    <span class="comment">// 使用base1...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h3><table>
<thead>
<tr>
<th>方案</th>
<th>改动程度</th>
<th>类型安全性</th>
<th>性能影响</th>
<th>兼容性</th>
</tr>
</thead>
<tbody><tr>
<td>方案1（类型信息增强）</td>
<td>最小</td>
<td>中等</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>方案2（模板化存储）</td>
<td>中等</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>方案3（智能指针包装）</td>
<td>最大</td>
<td>最高</td>
<td>中等</td>
<td>低</td>
</tr>
</tbody></table>
<h3 id="推荐方案"><a href="#推荐方案" class="headerlink" title="推荐方案"></a>推荐方案</h3><p><strong>推荐使用方案1（类型信息增强）</strong>，原因如下：</p>
<ol>
<li><strong>改动最小</strong>：保持原有的<code>void* self</code>接口</li>
<li><strong>向后兼容</strong>：现有代码无需大幅修改</li>
<li><strong>渐进式改进</strong>：可以逐步替换不安全的类型转换</li>
<li><strong>性能影响小</strong>：只增加类型信息存储的开销</li>
</ol>
<h3 id="实施步骤"><a href="#实施步骤" class="headerlink" title="实施步骤"></a>实施步骤</h3><ol>
<li><strong>第一步</strong>：添加类型信息存储和安全的转换方法</li>
<li><strong>第二步</strong>：逐步替换现有的不安全的<code>static_cast</code>调用</li>
<li><strong>第三步</strong>：在Cast方法中使用类型安全的转换</li>
<li><strong>第四步</strong>：添加运行时类型检查</li>
</ol>
<p>这种方案既解决了类型安全问题，又保持了代码的兼容性，是一个相对改动较小的改进方案。</p>
<h2 id="无RTTI环境下的方案重新分析"><a href="#无RTTI环境下的方案重新分析" class="headerlink" title="无RTTI环境下的方案重新分析"></a>无RTTI环境下的方案重新分析</h2><h3 id="RTTI限制的影响"><a href="#RTTI限制的影响" class="headerlink" title="RTTI限制的影响"></a>RTTI限制的影响</h3><p>在不开启RTTI（Runtime Type Information）的环境下，<code>std::type_info</code>、<code>typeid</code>、<code>dynamic_cast</code>等特性都无法使用，这会对我们的解决方案产生重要影响。</p>
<h4 id="方案1在无RTTI环境下的问题"><a href="#方案1在无RTTI环境下的问题" class="headerlink" title="方案1在无RTTI环境下的问题"></a>方案1在无RTTI环境下的问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案1在无RTTI环境下无法工作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CODE_GEN_BASE_OBJ</span> : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> *self;</span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题：在无RTTI环境下，这些都无法使用</span></span><br><span class="line">    std::type_info* original_type;  <span class="comment">// ❌ 无法获取</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">safe_cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ❌ typeid无法使用</span></span><br><span class="line">        <span class="keyword">if</span> (original_type &amp;&amp; *original_type == <span class="built_in">typeid</span>(T)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">can_cast</span>&lt;T&gt;()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">safe_cast</span>&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ❌ dynamic_cast无法使用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;T*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(self));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="无RTTI环境下的改进方案"><a href="#无RTTI环境下的改进方案" class="headerlink" title="无RTTI环境下的改进方案"></a>无RTTI环境下的改进方案</h3><h4 id="方案1改进：手动类型标识"><a href="#方案1改进：手动类型标识" class="headerlink" title="方案1改进：手动类型标识"></a>方案1改进：手动类型标识</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CODE_GEN_BASE_OBJ</span> : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> *self;</span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用枚举替代type_info</span></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ObjectType</span> &#123;</span><br><span class="line">        UNKNOWN,</span><br><span class="line">        BASE1,</span><br><span class="line">        BASE2,</span><br><span class="line">        DERIVED,</span><br><span class="line">        <span class="comment">// 根据需要添加更多类型</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ObjectType object_type;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手动类型检查</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">can_cast</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T, Base1&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> object_type == ObjectType::BASE1 || </span><br><span class="line">                   object_type == ObjectType::DERIVED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, Base2&gt;) &#123;</span><br><span class="line">            <span class="keyword">return</span> object_type == ObjectType::BASE2 || </span><br><span class="line">                   object_type == ObjectType::DERIVED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, Derived&gt;) &#123;</span><br><span class="line">            <span class="keyword">return</span> object_type == ObjectType::DERIVED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 安全的类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">safe_cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">can_cast</span>&lt;T&gt;()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型安全的接口获取</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">safe_cast</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置对象类型</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_object_type</span><span class="params">(ObjectType type)</span> </span>&#123;</span><br><span class="line">        object_type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有方法保持不变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方案2改进：编译时类型检查"><a href="#方案2改进：编译时类型检查" class="headerlink" title="方案2改进：编译时类型检查"></a>方案2改进：编译时类型检查</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP, <span class="keyword">typename</span> STORED_TYPE = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> CODE_GEN_BASE_OBJ : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP, STORED_TYPE&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    STORED_TYPE* self;</span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译时类型检查</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_base_of_v&lt;T, STORED_TYPE&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在无RTTI环境下，无法使用dynamic_cast</span></span><br><span class="line">            <span class="comment">// 返回nullptr或抛出异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译时类型检查</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">can_cast</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::is_base_of_v&lt;T, STORED_TYPE&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容原有void*接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">get_raw_ptr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(self); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有方法保持不变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP, STORED_TYPE&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方案3改进：类型擦除的智能指针"><a href="#方案3改进：类型擦除的智能指针" class="headerlink" title="方案3改进：类型擦除的智能指针"></a>方案3改进：类型擦除的智能指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CODE_GEN_BASE_OBJ</span> : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类型擦除的智能指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TypeErasedPtr</span> &#123;</span><br><span class="line">        <span class="type">void</span>* ptr;</span><br><span class="line">        <span class="built_in">void</span> (*deleter)(<span class="type">void</span>*);</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">        <span class="title">TypeErasedPtr</span><span class="params">(T* p)</span> : ptr(p), deleter([](void* p) &#123;</span> <span class="keyword">delete</span> <span class="built_in">static_cast</span>&lt;T*&gt;(p); &#125;) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        ~<span class="built_in">TypeErasedPtr</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr &amp;&amp; deleter) &#123;</span><br><span class="line">                <span class="built_in">deleter</span>(ptr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::shared_ptr&lt;TypeErasedPtr&gt; self_ptr;</span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容原有void*接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">get_self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> self_ptr ? self_ptr-&gt;ptr : <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型安全的访问（需要手动指定类型）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self_ptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self_ptr-&gt;ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有方法保持不变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="无RTTI环境下的构造函数实现"><a href="#无RTTI环境下的构造函数实现" class="headerlink" title="无RTTI环境下的构造函数实现"></a>无RTTI环境下的构造函数实现</h3><h4 id="方案1的构造函数"><a href="#方案1的构造函数" class="headerlink" title="方案1的构造函数"></a>方案1的构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line">CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;::<span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="comment">// 需要手动设置对象类型</span></span><br><span class="line">    object_type = ObjectType::UNKNOWN;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据实际创建的对象类型设置</span></span><br><span class="line">    <span class="comment">// 这需要在创建对象时明确指定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; </span><br><span class="line"><span class="built_in">create_wrapper</span>(Base1* obj, <span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="keyword">auto</span> wrapper = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;(info);</span><br><span class="line">    wrapper-&gt;self = obj;</span><br><span class="line">    wrapper-&gt;<span class="built_in">set_object_type</span>(CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;::ObjectType::BASE1);</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; </span><br><span class="line"><span class="built_in">create_wrapper</span>(Base2* obj, <span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="keyword">auto</span> wrapper = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;(info);</span><br><span class="line">    wrapper-&gt;self = obj;</span><br><span class="line">    wrapper-&gt;<span class="built_in">set_object_type</span>(CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;::ObjectType::BASE2);</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方案2的构造函数"><a href="#方案2的构造函数" class="headerlink" title="方案2的构造函数"></a>方案2的构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP, <span class="keyword">typename</span> STORED_TYPE&gt;</span><br><span class="line">CODE_GEN_BASE_OBJ&lt;OBJ_WRAP, STORED_TYPE&gt;::<span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="comment">// 模板参数已经确定了存储类型</span></span><br><span class="line">    <span class="comment">// 编译时就能确定类型关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">auto</span> wrapper1 = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;MyWrapper, Base1&gt;&gt;(info);</span><br><span class="line"><span class="keyword">auto</span> wrapper2 = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;MyWrapper, Base2&gt;&gt;(info);</span><br><span class="line"><span class="keyword">auto</span> wrapper3 = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;MyWrapper, Derived&gt;&gt;(info);</span><br></pre></td></tr></table></figure>

<h3 id="无RTTI环境下的Cast方法实现"><a href="#无RTTI环境下的Cast方法实现" class="headerlink" title="无RTTI环境下的Cast方法实现"></a>无RTTI环境下的Cast方法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="type">void</span> CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;::<span class="built_in">Cast</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (info.<span class="built_in">Length</span>() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(Djsi::Value::<span class="built_in">Undefined</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::string target_type = info[<span class="number">0</span>].<span class="built_in">As</span>&lt;Djsi::String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方案1：使用手动类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (target_type == <span class="string">&quot;Base1&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">can_cast</span>&lt;Base1&gt;()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>* base1 = <span class="built_in">safe_cast</span>&lt;Base1&gt;();</span><br><span class="line">            <span class="keyword">auto</span> wrapper = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;(info);</span><br><span class="line">            wrapper-&gt;self = base1;</span><br><span class="line">            wrapper-&gt;<span class="built_in">set_object_type</span>(ObjectType::BASE1);</span><br><span class="line">            wrapper-&gt;owned = <span class="literal">false</span>;</span><br><span class="line">            info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(wrapper-&gt;<span class="built_in">ObjSharedPtr</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target_type == <span class="string">&quot;Base2&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">can_cast</span>&lt;Base2&gt;()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>* base2 = <span class="built_in">safe_cast</span>&lt;Base2&gt;();</span><br><span class="line">            <span class="keyword">auto</span> wrapper = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;(info);</span><br><span class="line">            wrapper-&gt;self = base2;</span><br><span class="line">            wrapper-&gt;<span class="built_in">set_object_type</span>(ObjectType::BASE2);</span><br><span class="line">            wrapper-&gt;owned = <span class="literal">false</span>;</span><br><span class="line">            info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(wrapper-&gt;<span class="built_in">ObjSharedPtr</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(Djsi::Value::<span class="built_in">Undefined</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无RTTI环境下的方案对比"><a href="#无RTTI环境下的方案对比" class="headerlink" title="无RTTI环境下的方案对比"></a>无RTTI环境下的方案对比</h3><table>
<thead>
<tr>
<th>方案</th>
<th>RTTI依赖</th>
<th>类型安全性</th>
<th>实现复杂度</th>
<th>性能</th>
<th>兼容性</th>
</tr>
</thead>
<tbody><tr>
<td>方案1（手动类型标识）</td>
<td>无</td>
<td>中等</td>
<td>中等</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>方案2（编译时检查）</td>
<td>无</td>
<td>高</td>
<td>低</td>
<td>最高</td>
<td>中等</td>
</tr>
<tr>
<td>方案3（类型擦除）</td>
<td>无</td>
<td>中等</td>
<td>高</td>
<td>中等</td>
<td>中等</td>
</tr>
</tbody></table>
<h3 id="无RTTI环境下的推荐方案"><a href="#无RTTI环境下的推荐方案" class="headerlink" title="无RTTI环境下的推荐方案"></a>无RTTI环境下的推荐方案</h3><p><strong>在无RTTI环境下，推荐使用方案2（编译时类型检查）</strong>，原因如下：</p>
<ol>
<li><strong>无RTTI依赖</strong>：完全基于编译时类型检查</li>
<li><strong>类型安全性高</strong>：编译时就能发现类型错误</li>
<li><strong>性能最好</strong>：无运行时开销</li>
<li><strong>实现简单</strong>：利用C++模板特性</li>
</ol>
<h4 id="方案2的使用示例"><a href="#方案2的使用示例" class="headerlink" title="方案2的使用示例"></a>方案2的使用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为不同类型创建专门的包装器</span></span><br><span class="line"><span class="keyword">using</span> Base1Wrapper = CODE_GEN_BASE_OBJ&lt;MyWrapper, Base1&gt;;</span><br><span class="line"><span class="keyword">using</span> Base2Wrapper = CODE_GEN_BASE_OBJ&lt;MyWrapper, Base2&gt;;</span><br><span class="line"><span class="keyword">using</span> DerivedWrapper = CODE_GEN_BASE_OBJ&lt;MyWrapper, Derived&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">auto</span> base1_obj = std::<span class="built_in">make_shared</span>&lt;Base1Wrapper&gt;(info);</span><br><span class="line"><span class="keyword">auto</span> base2_obj = std::<span class="built_in">make_shared</span>&lt;Base2Wrapper&gt;(info);</span><br><span class="line"><span class="keyword">auto</span> derived_obj = std::<span class="built_in">make_shared</span>&lt;DerivedWrapper&gt;(info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时类型检查</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span>* base1 = base1_obj-&gt;<span class="built_in">cast</span>&lt;Base1&gt;()) &#123;</span><br><span class="line">    base1-&gt;<span class="built_in">method1</span>();  <span class="comment">// 编译时确保类型正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>在无RTTI环境下：</p>
<ol>
<li><strong>方案1</strong>需要手动管理类型信息，实现复杂度增加</li>
<li><strong>方案2</strong>成为最佳选择，利用编译时类型检查</li>
<li><strong>方案3</strong>仍然可行，但实现复杂度较高</li>
</ol>
<p><strong>最终推荐</strong>：如果项目不开启RTTI，建议使用<strong>方案2（编译时类型检查）</strong>，它提供了最好的类型安全性和性能。</p>
<hr>
<p><em>本文分析了C++多重继承在跨语言接口适配中的技术难点，希望对相关开发者有所帮助。</em> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jackwzx.github.io/2025/06/30/C++%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%88%B0Java-TypeScript%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" data-id="cmih5kqng0000veco59gmhqgj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D/" rel="tag">接口适配</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/30/c++%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          c++迭代器
        
      </div>
    </a>
  
  
    <a href="/2025/06/25/C++%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">C++原子操作函数详解：多线程编程的利器</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E7%BC%96%E7%A8%8B/">C++编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93/">图形渲染</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%B6%E5%BA%AD%E6%95%99%E8%82%B2/">家庭教育</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/">技术分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/">编程技术</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/C/">C++</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/3D%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">3D图形学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GLSL/" rel="tag">GLSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/" rel="tag">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSAO/" rel="tag">SSAO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shader/" rel="tag">Shader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-11/" rel="tag">c++11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openGL/" rel="tag">openGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ruby/" rel="tag">ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6%E5%8D%95/" rel="tag">书单</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%B2%E5%AD%90/" rel="tag">亲子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%84%BF%E7%AB%A5%E6%95%99%E8%82%B2/" rel="tag">儿童教育</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E5%BA%93/" rel="tag">动态库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" rel="tag">原子操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">图形学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/" rel="tag">图形编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%8F%E5%AE%9A%E4%B9%89/" rel="tag">宏定义</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%8B%E6%9C%BA%E6%88%90%E7%98%BE/" rel="tag">手机成瘾</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D/" rel="tag">接口适配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/" rel="tag">插值算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%92%AD%E5%AE%A2/" rel="tag">播客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%99%E8%82%B2/" rel="tag">教育</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" rel="tag">构造函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BC%98%E5%8C%96/" rel="tag">移动端优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" rel="tag">线性代数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1/" rel="tag">编程陷阱</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">计算机图形学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%85%E8%AF%BB/" rel="tag">阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/" rel="tag">预处理器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/" rel="tag">颜色空间</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/3D%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 12px;">3D图形学</a> <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/C/" style="font-size: 16px;">C++</a> <a href="/tags/C-11/" style="font-size: 18px;">C++11</a> <a href="/tags/GLSL/" style="font-size: 10px;">GLSL</a> <a href="/tags/JNI/" style="font-size: 10px;">JNI</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/OpenGL/" style="font-size: 12px;">OpenGL</a> <a href="/tags/SSAO/" style="font-size: 10px;">SSAO</a> <a href="/tags/Shader/" style="font-size: 10px;">Shader</a> <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a> <a href="/tags/c-11/" style="font-size: 10px;">c++11</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/openGL/" style="font-size: 18px;">openGL</a> <a href="/tags/ruby/" style="font-size: 10px;">ruby</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/%E4%B9%A6%E5%8D%95/" style="font-size: 10px;">书单</a> <a href="/tags/%E4%BA%B2%E5%AD%90/" style="font-size: 12px;">亲子</a> <a href="/tags/%E5%84%BF%E7%AB%A5%E6%95%99%E8%82%B2/" style="font-size: 10px;">儿童教育</a> <a href="/tags/%E5%8A%A8%E6%80%81%E5%BA%93/" style="font-size: 10px;">动态库</a> <a href="/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" style="font-size: 10px;">原子操作</a> <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 10px;">图形学</a> <a href="/tags/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">图形编程</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/tags/%E5%AE%8F%E5%AE%9A%E4%B9%89/" style="font-size: 10px;">宏定义</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">并发编程</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E6%89%8B%E6%9C%BA%E6%88%90%E7%98%BE/" style="font-size: 10px;">手机成瘾</a> <a href="/tags/%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D/" style="font-size: 10px;">接口适配</a> <a href="/tags/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/" style="font-size: 10px;">插值算法</a> <a href="/tags/%E6%92%AD%E5%AE%A2/" style="font-size: 10px;">播客</a> <a href="/tags/%E6%95%99%E8%82%B2/" style="font-size: 10px;">教育</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 12px;">数学</a> <a href="/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" style="font-size: 10px;">构造函数</a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BC%98%E5%8C%96/" style="font-size: 10px;">移动端优化</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" style="font-size: 12px;">线性代数</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1/" style="font-size: 10px;">编程陷阱</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 14px;">计算机图形学</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%98%85%E8%AF%BB/" style="font-size: 12px;">阅读</a> <a href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/" style="font-size: 10px;">预处理器</a> <a href="/tags/%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/" style="font-size: 10px;">颜色空间</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/11/">November 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/11/12/java%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/">Java中的布尔类型</a>
          </li>
        
          <li>
            <a href="/2025/08/05/%E4%B8%BA%E4%BB%80%E4%B9%88ASan%E9%9C%80%E8%A6%81-fsanitize=address%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E6%9B%BF%E6%8D%A2%E5%8A%A8%E6%80%81%E5%BA%93/">为什么 ASan 需要 `-fsanitize=address` 编译选项，而不仅仅是替换动态库？</a>
          </li>
        
          <li>
            <a href="/2025/06/30/3D%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%B3%95%E5%90%91%E9%87%8F%E8%AF%A6%E8%A7%A3/">3D图形学中的平面方程：从线性代数到Vector4f表示</a>
          </li>
        
          <li>
            <a href="/2025/06/30/c++%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/">c++迭代器</a>
          </li>
        
          <li>
            <a href="/2025/06/30/C++%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%88%B0Java-TypeScript%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">C++多重继承到Java/TypeScript接口适配问题分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 Xujing<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
  <div class="local-search-popup">
  <div class="local-search-box">
    <div class="local-search-input-wrapper">
      <input id="local-search-input" type="text" placeholder="搜索..." />
    </div>
    <span class="search-close-button">×</span>
  </div>
  <div id="local-search-result"></div>
</div>

<script>
// 搜索功能实现
window.addEventListener('DOMContentLoaded', function() {
  var isXml = true;
  var searchPath = "search.xml";
  if (searchPath.length === 0) {
    searchPath = "search.xml";
  } else if (/json$/i.test(searchPath)) {
    isXml = false;
  }
  var path = "/" + searchPath;
  var input = document.getElementById("local-search-input");
  var resultContent = document.getElementById("local-search-result");
  var searchData = [];

  // 加载搜索索引
  loadSearchData();

  function loadSearchData() {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', path, true);
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          if (isXml) {
            var xmlDoc = new DOMParser().parseFromString(xhr.responseText, "text/xml");
            var entries = xmlDoc.getElementsByTagName("entry");
            searchData = Array.from(entries).map(function(entry) {
              return {
                title: entry.getElementsByTagName("title")[0].textContent,
                content: entry.getElementsByTagName("content")[0].textContent,
                url: entry.getElementsByTagName("url")[0].textContent
              };
            });
          } else {
            searchData = JSON.parse(xhr.responseText);
          }
          
          // 添加搜索事件监听
          input.addEventListener('input', search);
        }
      }
    };
    xhr.send();
  }

  function search() {
    var searchText = input.value.trim().toLowerCase();
    var keywords = searchText.split(/[\s\-]+/);
    resultContent.innerHTML = "";
    
    if (searchText.length > 0) {
      // 执行搜索
      searchData.forEach(function(data) {
        var isMatch = true;
        var dataTitle = data.title.trim().toLowerCase();
        var dataContent = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
        var dataUrl = data.url;
        var indexTitle = -1;
        var indexContent = -1;
        var firstOccur = -1;
        
        // 只匹配非空关键字
        if (keywords.length > 0) {
          keywords.forEach(function(keyword, i) {
            indexTitle = dataTitle.indexOf(keyword);
            indexContent = dataContent.indexOf(keyword);
            if (indexTitle < 0 && indexContent < 0) {
              isMatch = false;
            } else {
              if (indexContent < 0) {
                indexContent = 0;
              }
              if (i == 0) {
                firstOccur = indexContent;
              }
            }
          });
        }
        
        // 显示搜索结果
        if (isMatch) {
          var resultItem = document.createElement("div");
          resultItem.className = "search-result-item";
          
          // 标题
          var resultTitle = document.createElement("div");
          resultTitle.className = "search-result-title";
          var resultLink = document.createElement("a");
          resultLink.href = dataUrl;
          resultLink.textContent = data.title;
          resultTitle.appendChild(resultLink);
          resultItem.appendChild(resultTitle);
          
          // 内容
          if (firstOccur >= 0) {
            // 截取内容
            var content = dataContent;
            var start = Math.max(0, firstOccur - 20);
            var end = Math.min(content.length, firstOccur + 80);
            if (start > 0) {
              content = '...' + content.substring(start, end) + '...';
            } else {
              content = content.substring(start, end) + '...';
            }
            
            // 高亮关键字
            keywords.forEach(function(keyword) {
              var regS = new RegExp(keyword, "gi");
              content = content.replace(regS, '<strong class="search-keyword">' + keyword + '</strong>');
            });
            
            var resultContentDiv = document.createElement("div");
            resultContentDiv.className = "search-result-content";
            resultContentDiv.innerHTML = content;
            resultItem.appendChild(resultContentDiv);
          }
          
          resultContent.appendChild(resultItem);
        }
      });
    }
  }

  // 搜索框弹出与关闭
  var searchBtn = document.getElementById("nav-search-btn");
  var searchPopup = document.querySelector(".local-search-popup");
  var closeBtn = document.querySelector(".search-close-button");
  
  if (searchBtn) {
    searchBtn.addEventListener('click', function(e) {
      e.preventDefault();
      searchPopup.style.display = "block";
      input.focus();
    });
  }
  
  if (closeBtn) {
    closeBtn.addEventListener('click', function() {
      searchPopup.style.display = "none";
    });
  }
  
  document.addEventListener('keyup', function(e) {
    if (e.key === "Escape") {
      searchPopup.style.display = "none";
    }
  });
});
</script> 
</body>
</html>