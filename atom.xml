<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xujing的博客</title>
  <icon>https://jackwzx.github.io/icon.png</icon>
  
  <link href="https://jackwzx.github.io/atom.xml" rel="self"/>
  
  <link href="https://jackwzx.github.io/"/>
  <updated>2025-12-28T06:34:42.526Z</updated>
  <id>https://jackwzx.github.io/</id>
  
  <author>
    <name>Xujing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git 浅克隆之后如何切换分支</title>
    <link href="https://jackwzx.github.io/2025/12/26/git%20%E6%B5%85%E5%85%8B%E9%9A%86%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF/"/>
    <id>https://jackwzx.github.io/2025/12/26/git%20%E6%B5%85%E5%85%8B%E9%9A%86%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF/</id>
    <published>2025-12-26T12:05:03.000Z</published>
    <updated>2025-12-28T06:34:42.526Z</updated>
    
    
    <summary type="html">&lt;p&gt;当你使用 &lt;code&gt;git clone --depth 1&lt;/code&gt; 进行浅克隆时，Git 默认只会追踪远程的&lt;strong&gt;默认分支&lt;/strong&gt;（通常是 &lt;code&gt;main&lt;/code&gt; 或 &lt;code&gt;master&lt;/code&gt;），并且不会获取其他分支的信息。&lt;/p&gt;
&lt;p&gt;要切换到其他远程分支，可以根据你的需求选择以下几种方法：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ARM64函数调用栈寄存器分配</title>
    <link href="https://jackwzx.github.io/2025/12/26/ARM64%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D/"/>
    <id>https://jackwzx.github.io/2025/12/26/ARM64%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D/</id>
    <published>2025-12-26T01:01:29.000Z</published>
    <updated>2025-12-28T06:35:22.109Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 ARM64（AArch64）架构下，理解函数调用栈、寄存器分配以及参数传递是底层开发和调试的核心。ARM64 的函数调用遵循 &lt;strong&gt;AAPCS64&lt;/strong&gt;（Procedure Call Standard for the ARM 64-bit Architecture）。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>c++函数返回值存在了哪里</title>
    <link href="https://jackwzx.github.io/2025/12/23/c++%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%AD%98%E5%9C%A8%E4%BA%86%E5%93%AA%E9%87%8C/"/>
    <id>https://jackwzx.github.io/2025/12/23/c++%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%AD%98%E5%9C%A8%E4%BA%86%E5%93%AA%E9%87%8C/</id>
    <published>2025-12-23T13:04:42.000Z</published>
    <updated>2025-12-28T06:35:52.397Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个非常深入且经典的问题。你的直觉很准：&lt;strong&gt;如果变量在函数内部的栈帧里，函数返回后栈帧销毁，引用必然指向一片非法内存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但这里的关键在于：&lt;strong&gt;返回的对象并不在“已经销毁”的那个函数栈帧里。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>std::vector&lt;T&gt; clear详解</title>
    <link href="https://jackwzx.github.io/2025/12/21/std%20vector%20clear%20%E5%88%86%E6%9E%90/"/>
    <id>https://jackwzx.github.io/2025/12/21/std%20vector%20clear%20%E5%88%86%E6%9E%90/</id>
    <published>2025-12-21T10:09:26.000Z</published>
    <updated>2025-12-21T10:09:52.981Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个非常核心的问题。在 C++ 标准库中，&lt;code&gt;std::vector::clear()&lt;/code&gt; 的行为是非常明确的。为了让你彻底理解，我们从&lt;strong&gt;逻辑行为&lt;/strong&gt;、&lt;strong&gt;源码实现（以 GCC 的 libstdc++ 为例）&lt;/strong&gt;以及&lt;strong&gt;内存状态&lt;/strong&gt;三个维度来剖析。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>AArch64寄存器</title>
    <link href="https://jackwzx.github.io/2025/12/21/AArch64%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>https://jackwzx.github.io/2025/12/21/AArch64%E5%AF%84%E5%AD%98%E5%99%A8/</id>
    <published>2025-12-21T07:35:43.000Z</published>
    <updated>2025-12-28T06:36:32.381Z</updated>
    
    
    <summary type="html">&lt;p&gt;ARM64（AArch64）的函数调用规则主要遵循 &lt;strong&gt;AAPCS64&lt;/strong&gt; (Procedure Call Standard for the ARM 64-bit Architecture)。了解这些规则对于编写汇编代码、调试程序或进行性能优化至关重要。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Jni NewGlobalRef</title>
    <link href="https://jackwzx.github.io/2025/12/17/JNI%E5%B1%80%E9%83%A8%E5%BC%95%E7%94%A8%E5%92%8C%E5%85%A8%E5%B1%80%E5%BC%95%E7%94%A8/"/>
    <id>https://jackwzx.github.io/2025/12/17/JNI%E5%B1%80%E9%83%A8%E5%BC%95%E7%94%A8%E5%92%8C%E5%85%A8%E5%B1%80%E5%BC%95%E7%94%A8/</id>
    <published>2025-12-17T03:36:01.000Z</published>
    <updated>2025-12-28T06:39:44.140Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个非常核心的 JNI 知识点。要理解为什么你的代码会崩，以及 &lt;code&gt;NewGlobalRef&lt;/code&gt; 到底做了什么，我们需要深入到底层机制。&lt;/p&gt;
&lt;p&gt;我们把 JNI 的引用想象成 &lt;strong&gt;“指针”&lt;/strong&gt; 或 &lt;strong&gt;“句柄”&lt;/strong&gt;，它们指向 Java 堆内存中的真实对象。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>这是一个非常经典的 JNI 性能优化问题。</title>
    <link href="https://jackwzx.github.io/2025/12/16/JNI%E8%B0%83%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>https://jackwzx.github.io/2025/12/16/JNI%E8%B0%83%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</id>
    <published>2025-12-16T05:27:31.000Z</published>
    <updated>2025-12-16T05:27:31.782Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个非常经典的 JNI 性能优化问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接结论：&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;调用一次自定义 Java 函数（Scenario A）的性能绝对优于调用多次 Java API（Scenario B），即使 Scenario B 已经缓存了 &lt;code&gt;jclass&lt;/code&gt; 和 &lt;code&gt;jmethodID&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Unreal Engine (UE) 之所以强大，很大程度上归功于其构建在 C++ 之上的一套**自定义对象系统**。</title>
    <link href="https://jackwzx.github.io/2025/12/16/UnrealEngine%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/"/>
    <id>https://jackwzx.github.io/2025/12/16/UnrealEngine%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/</id>
    <published>2025-12-16T05:10:33.000Z</published>
    <updated>2025-12-16T05:10:33.604Z</updated>
    
    
    <summary type="html">&lt;p&gt;Unreal Engine (UE) 之所以强大，很大程度上归功于其构建在 C++ 之上的一套&lt;strong&gt;自定义对象系统&lt;/strong&gt;。C++ 标准本身缺乏运行时反射（Reflection）和自动内存管理（GC），因此 Epic Games 自己实现了一套名为 &lt;strong&gt;Unreal Object Handling&lt;/strong&gt; 的系统。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Objective-C 属性（`@property`）中的 `atomic` 和 `nonatomic` 关键字。</title>
    <link href="https://jackwzx.github.io/2025/12/15/atomic%E5%92%8Cnonatomic%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://jackwzx.github.io/2025/12/15/atomic%E5%92%8Cnonatomic%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2025-12-15T04:00:34.000Z</published>
    <updated>2025-12-15T04:00:52.805Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两个宏定义的区别完全对应 Objective-C 属性（&lt;code&gt;@property&lt;/code&gt;）中的 &lt;code&gt;atomic&lt;/code&gt; 和 &lt;code&gt;nonatomic&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;h3 id=&quot;1-核心区别表格&quot;&gt;&lt;a href=&quot;#1-核心区别表格&quot; class=&quot;headerlink&quot; title=&quot;1. 核心区别表格&quot;&gt;&lt;/a&gt;1. 核心区别表格&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>面对INTP（内向、直觉、思维、感知）性格的孩子，家长最头疼的往往就是**“虽然聪明，但执行力极差”**。</title>
    <link href="https://jackwzx.github.io/2025/12/14/INTP%E5%AD%A9%E5%AD%90%E5%86%99%E4%BD%9C%E4%B8%9A/"/>
    <id>https://jackwzx.github.io/2025/12/14/INTP%E5%AD%A9%E5%AD%90%E5%86%99%E4%BD%9C%E4%B8%9A/</id>
    <published>2025-12-14T09:43:28.000Z</published>
    <updated>2025-12-14T09:43:28.456Z</updated>
    
    
    <summary type="html">&lt;p&gt;面对INTP（内向、直觉、思维、感知）性格的孩子，家长最头疼的往往就是&lt;strong&gt;“虽然聪明，但执行力极差”&lt;/strong&gt;。他们通常被称为“逻辑学家”或“思想家”，大脑里在构建宏伟宇宙，现实中却连一支铅笔都懒得削。&lt;br&gt;针对INTP孩子“散漫、拖拉、低效”的作业辅导，核心逻辑不能是“监控和施压”，而应该是“外包执行力”与“智力博弈”。&lt;br&gt;以下是分维度的具体操作指南：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;理解底层逻辑：为什么他会这样？&lt;br&gt;首先，你要知道他不是笨，也不是故意气你。&lt;br&gt;• Ti (内向思考)： 他们追求的是“弄懂原理”。一旦他觉得这道题原理懂了，重复的抄写和练习对他来说就是纯粹的折磨，毫无意义。&lt;br&gt;• Ne (外向直觉)： 他们的思维是发散的。写着写着作业，看到橡皮上的花纹，可能联想到了分形几何，然后就发呆（其实脑子在飞速运转）了。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>着色器中非线性深度转换成线性深度</title>
    <link href="https://jackwzx.github.io/2025/12/11/%E7%9D%80%E8%89%B2%E5%99%A8%E4%B8%AD%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BA%BF%E6%80%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>https://jackwzx.github.io/2025/12/11/%E7%9D%80%E8%89%B2%E5%99%A8%E4%B8%AD%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BA%BF%E6%80%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2025-12-11T06:07:47.000Z</published>
    <updated>2025-12-11T06:08:19.745Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 OpenGL 中，深度缓冲（Depth Buffer）中存储的值（通常记为 $z_{buffer}$ 或 $d$）是非线性的。这意味着深度值 $0.5$ 并不代表物体位于 &lt;code&gt;near&lt;/code&gt; 和 &lt;code&gt;far&lt;/code&gt; 平面的正中间。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android机型性能分级方案</title>
    <link href="https://jackwzx.github.io/2025/12/11/Android%E6%9C%BA%E5%9E%8B%E6%80%A7%E8%83%BD%E5%88%86%E7%BA%A7%E6%96%B9%E6%A1%88/"/>
    <id>https://jackwzx.github.io/2025/12/11/Android%E6%9C%BA%E5%9E%8B%E6%80%A7%E8%83%BD%E5%88%86%E7%BA%A7%E6%96%B9%E6%A1%88/</id>
    <published>2025-12-11T03:13:50.000Z</published>
    <updated>2025-12-11T03:14:16.784Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 Android 生态中，由于设备碎片化极其严重（成千上万种机型，涵盖高通、联发科、三星、紫光展锐等不同芯片），仅通过“机型白名单”是不现实的。&lt;/p&gt;
&lt;p&gt;目前业界主流的方案通常采用 **“分级策略” (Tiering Strategy)**，结合 &lt;strong&gt;静态检测&lt;/strong&gt;（硬件规格）和 &lt;strong&gt;动态调整&lt;/strong&gt;（运行时监控）。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Depth24Stencil8介绍</title>
    <link href="https://jackwzx.github.io/2025/12/10/Depth24Stencil8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://jackwzx.github.io/2025/12/10/Depth24Stencil8%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-12-10T04:49:16.000Z</published>
    <updated>2025-12-10T04:49:34.662Z</updated>
    
    
    <summary type="html">&lt;p&gt;直接回答你的问题：&lt;strong&gt;不是浮点型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Depth24Stencil8&lt;/code&gt; (通常在 OpenGL 中对应 &lt;code&gt;GL_DEPTH24_STENCIL8&lt;/code&gt;，在 DirectX/Vulkan 中对应 &lt;code&gt;D24_UNORM_S8_UINT&lt;/code&gt;) 中的 &lt;strong&gt;Depth24&lt;/strong&gt; 部分，存储的是 **无符号归一化整型 (Unsigned Normalized Integer, UNORM)**。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Analyzing Format Trade-offs R11G11B10F</title>
    <link href="https://jackwzx.github.io/2025/12/10/Analyzing%20Format%20Trade-offs%20R11G11B10F/"/>
    <id>https://jackwzx.github.io/2025/12/10/Analyzing%20Format%20Trade-offs%20R11G11B10F/</id>
    <published>2025-12-10T03:20:35.000Z</published>
    <updated>2025-12-10T03:21:07.024Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Analyzing Format Trade-offs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I’ve been drilling down on the nuances of &lt;code&gt;RGB8&lt;/code&gt; versus &lt;code&gt;R11G11B10F&lt;/code&gt;. My focus is on understanding the situations where the floating-point precision of &lt;code&gt;R11G11B10F&lt;/code&gt; justifies its increased memory footprint compared to the compact &lt;code&gt;RGB8&lt;/code&gt;. I’m starting to grasp the implications for HDR rendering and light accumulation scenarios where the extra range is crucial. Current thinking focuses on the actual trade-offs that have to be made with a limited memory budget.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Framebuffer 复用问题</title>
    <link href="https://jackwzx.github.io/2025/12/09/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E4%B8%93%E4%B8%9A%E4%B8%94%E5%88%87%E4%B8%AD%E8%A6%81%E5%AE%B3%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://jackwzx.github.io/2025/12/09/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E4%B8%93%E4%B8%9A%E4%B8%94%E5%88%87%E4%B8%AD%E8%A6%81%E5%AE%B3%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2025-12-09T12:49:57.000Z</published>
    <updated>2025-12-28T06:40:24.656Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个非常专业且切中要害的问题。直接回答你的结论：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在绝大多数情况下，尝试让“阴影生成（Shadow Calculation）”和“延迟渲染的光照计算（Lighting Pass）”共用同一个 Framebuffer Object (FBO) 是不可行的，且不会带来性能提升，反而可能导致严重的逻辑错误或性能下降。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>移动端模板测试与Eary-z分析</title>
    <link href="https://jackwzx.github.io/2025/12/09/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%83%A8%E5%85%89%E6%BA%90%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E5%92%8C%E9%98%B4%E5%BD%B1%E8%AE%A1%E7%AE%97%E5%85%B1%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AAFramebuffer%20%E4%BC%9A%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E5%90%97/"/>
    <id>https://jackwzx.github.io/2025/12/09/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%83%A8%E5%85%89%E6%BA%90%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E5%92%8C%E9%98%B4%E5%BD%B1%E8%AE%A1%E7%AE%97%E5%85%B1%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AAFramebuffer%20%E4%BC%9A%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E5%90%97/</id>
    <published>2025-12-09T12:45:31.000Z</published>
    <updated>2025-12-09T12:45:59.004Z</updated>
    
    
    <summary type="html">&lt;p&gt;在移动端（特别是基于 TBDR 架构的 GPU，如 Adreno, Mali, Apple GPU）使用模版缓存（Stencil Buffer）时，导致 Early-Z 失效并引起 Fragment Shader（片元着色器）占用率上升，主要原因是 &lt;strong&gt;GPU 无法在着色器执行前确定深度和模版测试的最终结果，从而被迫回退到 Late-Z（后期深度测试）模式。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>高通骁龙性能分析器指标解读</title>
    <link href="https://jackwzx.github.io/2025/12/08/%E9%AB%98%E9%80%9A%E9%AA%81%E9%BE%99%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%99%A8%E6%8C%87%E6%A0%87%E8%A7%A3%E8%AF%BB/"/>
    <id>https://jackwzx.github.io/2025/12/08/%E9%AB%98%E9%80%9A%E9%AA%81%E9%BE%99%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%99%A8%E6%8C%87%E6%A0%87%E8%A7%A3%E8%AF%BB/</id>
    <published>2025-12-08T12:16:05.000Z</published>
    <updated>2025-12-08T12:16:35.640Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个关于 &lt;strong&gt;Qualcomm Snapdragon Profiler&lt;/strong&gt; (高通骁龙性能分析器) 中各项性能指标的详细中文解释。这些指标对于分析 Android 游戏或图形应用的 GPU 瓶颈（Bottleneck）至关重要。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Transform Feedback计算蒙皮技术</title>
    <link href="https://jackwzx.github.io/2025/12/07/Transform%20Feedback%E8%AE%A1%E7%AE%97%E8%92%99%E7%9A%AE%E6%8A%80%E6%9C%AF/"/>
    <id>https://jackwzx.github.io/2025/12/07/Transform%20Feedback%E8%AE%A1%E7%AE%97%E8%92%99%E7%9A%AE%E6%8A%80%E6%9C%AF/</id>
    <published>2025-12-07T10:18:44.000Z</published>
    <updated>2025-12-07T10:19:17.224Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Transform Feedback (变换反馈)&lt;/strong&gt; 进行蒙皮计算，是一种利用 GPU 的 &lt;strong&gt;Vertex Shader (顶点着色器)&lt;/strong&gt; 计算蒙皮，并将计算后的顶点位置&lt;strong&gt;写回显存（Buffer）&lt;/strong&gt;，而不是直接拿去渲染像素的技术。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>invalidDepth FrameBuffer之后提交同一个framebuffer draw 性能问题</title>
    <link href="https://jackwzx.github.io/2025/12/07/invalidDepth%20FrameBuffer%E4%B9%8B%E5%90%8E%E6%8F%90%E4%BA%A4%E5%90%8C%E4%B8%80%E4%B8%AAframebuffer%20draw%20%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/"/>
    <id>https://jackwzx.github.io/2025/12/07/invalidDepth%20FrameBuffer%E4%B9%8B%E5%90%8E%E6%8F%90%E4%BA%A4%E5%90%8C%E4%B8%80%E4%B8%AAframebuffer%20draw%20%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</id>
    <published>2025-12-07T09:51:52.000Z</published>
    <updated>2025-12-07T09:53:14.416Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个非常经典且深度的移动端图形优化问题。你观察到的现象（CPU 飙升 7%、开销与 DrawCall 数据量无关）直指移动端 GPU 架构的核心痛点：&lt;strong&gt;Tile-Based Rendering (TBR) 架构下的 Render Pass 打断（Render Pass Split）&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在 Bash Shell 中，单引号和双引号的主要区别</title>
    <link href="https://jackwzx.github.io/2025/12/04/Shell%E4%B8%AD%E5%8D%95%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/"/>
    <id>https://jackwzx.github.io/2025/12/04/Shell%E4%B8%AD%E5%8D%95%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</id>
    <published>2025-12-04T07:44:48.000Z</published>
    <updated>2025-12-04T07:45:19.431Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 Bash Shell 中，单引号 (&lt;code&gt;&amp;#39; &amp;#39;&lt;/code&gt;) 和双引号 (&lt;code&gt;&amp;quot; &amp;quot;&lt;/code&gt;) 的主要区别在于 &lt;strong&gt;对特殊字符和变量的处理方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简单总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  &lt;strong&gt;单引号 (强引用)&lt;strong&gt;：&lt;/strong&gt;所见即所得&lt;/strong&gt;。单引号内的所有内容都会被当作普通字符，&lt;strong&gt;不进行&lt;/strong&gt;变量替换或命令执行。&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;双引号 (弱引用)&lt;strong&gt;：&lt;/strong&gt;允许解析&lt;/strong&gt;。双引号内的内容大部分被当作普通字符，但会&lt;strong&gt;保留&lt;/strong&gt;变量 (&lt;code&gt;$&lt;/code&gt;)、命令替换 (&lt;code&gt;`&lt;/code&gt; 或 &lt;code&gt;$()&lt;/code&gt;) 和转义符 (&lt;code&gt;\&lt;/code&gt;) 的功能。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
