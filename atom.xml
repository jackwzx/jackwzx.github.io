<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xujing的博客</title>
  <icon>https://jackwzx.github.io/icon.png</icon>
  
  <link href="https://jackwzx.github.io/atom.xml" rel="self"/>
  
  <link href="https://jackwzx.github.io/"/>
  <updated>2025-06-12T08:08:28.440Z</updated>
  <id>https://jackwzx.github.io/</id>
  
  <author>
    <name>Xujing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++类型转换陷阱：有符号和无符号整数比较</title>
    <link href="https://jackwzx.github.io/2025/06/08/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%99%B7%E9%98%B1-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%AF%94%E8%BE%83/"/>
    <id>https://jackwzx.github.io/2025/06/08/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%99%B7%E9%98%B1-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%AF%94%E8%BE%83/</id>
    <published>2025-06-08T02:00:00.000Z</published>
    <updated>2025-06-12T08:08:28.440Z</updated>
    
    
    <summary type="html">&lt;p&gt;在C++编程中，有一些看似简单的操作可能会带来意想不到的结果。今天我们要讨论一个常见但容易被忽视的问题：有符号整数（signed）和无符号整数（unsigned）的比较操作。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技术" scheme="https://jackwzx.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://jackwzx.github.io/tags/C/"/>
    
    <category term="编程陷阱" scheme="https://jackwzx.github.io/tags/%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1/"/>
    
    <category term="类型转换" scheme="https://jackwzx.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>培养孩子阅读习惯的优质书单推荐</title>
    <link href="https://jackwzx.github.io/2025/06/07/%E5%9F%B9%E5%85%BB%E5%AD%A9%E5%AD%90%E9%98%85%E8%AF%BB%E4%B9%A0%E6%83%AF%E7%9A%84%E4%BC%98%E8%B4%A8%E4%B9%A6%E5%8D%95%E6%8E%A8%E8%8D%90/"/>
    <id>https://jackwzx.github.io/2025/06/07/%E5%9F%B9%E5%85%BB%E5%AD%A9%E5%AD%90%E9%98%85%E8%AF%BB%E4%B9%A0%E6%83%AF%E7%9A%84%E4%BC%98%E8%B4%A8%E4%B9%A6%E5%8D%95%E6%8E%A8%E8%8D%90/</id>
    <published>2025-06-07T10:30:00.000Z</published>
    <updated>2025-06-07T09:51:05.668Z</updated>
    
    
    <summary type="html">&lt;p&gt;选择合适的书籍是培养孩子阅读兴趣的关键第一步。本文根据不同年龄段孩子的认知特点和兴趣偏好，精心整理了一份优质书单，帮助家长为孩子挑选最适合的读物。&lt;/p&gt;</summary>
    
    
    
    <category term="家庭教育" scheme="https://jackwzx.github.io/categories/%E5%AE%B6%E5%BA%AD%E6%95%99%E8%82%B2/"/>
    
    
    <category term="阅读" scheme="https://jackwzx.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
    <category term="书单" scheme="https://jackwzx.github.io/tags/%E4%B9%A6%E5%8D%95/"/>
    
    <category term="儿童教育" scheme="https://jackwzx.github.io/tags/%E5%84%BF%E7%AB%A5%E6%95%99%E8%82%B2/"/>
    
    <category term="亲子" scheme="https://jackwzx.github.io/tags/%E4%BA%B2%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>如何让孩子戒掉手机爱上阅读：实用策略指南</title>
    <link href="https://jackwzx.github.io/2025/06/07/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AD%A9%E5%AD%90%E6%88%92%E6%8E%89%E6%89%8B%E6%9C%BA%E7%88%B1%E4%B8%8A%E9%98%85%E8%AF%BB-%E5%AE%9E%E7%94%A8%E7%AD%96%E7%95%A5%E6%8C%87%E5%8D%97/"/>
    <id>https://jackwzx.github.io/2025/06/07/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AD%A9%E5%AD%90%E6%88%92%E6%8E%89%E6%89%8B%E6%9C%BA%E7%88%B1%E4%B8%8A%E9%98%85%E8%AF%BB-%E5%AE%9E%E7%94%A8%E7%AD%96%E7%95%A5%E6%8C%87%E5%8D%97/</id>
    <published>2025-06-07T10:00:00.000Z</published>
    <updated>2025-06-07T09:40:37.530Z</updated>
    
    
    <summary type="html">&lt;p&gt;在数字化时代，如何引导孩子从手机屏幕转向书本页面，是每个家长都关心的话题。本文将分享一些经过实践验证的策略，帮助您的孩子逐步减少对手机的依赖，培养良好的阅读习惯。&lt;/p&gt;</summary>
    
    
    
    <category term="家庭教育" scheme="https://jackwzx.github.io/categories/%E5%AE%B6%E5%BA%AD%E6%95%99%E8%82%B2/"/>
    
    
    <category term="阅读" scheme="https://jackwzx.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
    <category term="亲子" scheme="https://jackwzx.github.io/tags/%E4%BA%B2%E5%AD%90/"/>
    
    <category term="教育" scheme="https://jackwzx.github.io/tags/%E6%95%99%E8%82%B2/"/>
    
    <category term="手机成瘾" scheme="https://jackwzx.github.io/tags/%E6%89%8B%E6%9C%BA%E6%88%90%E7%98%BE/"/>
    
  </entry>
  
  <entry>
    <title>type script</title>
    <link href="https://jackwzx.github.io/2025/03/15/type-script/"/>
    <id>https://jackwzx.github.io/2025/03/15/type-script/</id>
    <published>2025-03-15T15:23:39.000Z</published>
    <updated>2025-03-15T15:26:08.876Z</updated>
    
    
    <summary type="html">&lt;p&gt;TypeScript 是一种由 &lt;strong&gt;Microsoft&lt;/strong&gt; 开发的开源编程语言，它是 &lt;strong&gt;JavaScript 的超集&lt;/strong&gt;，为 JavaScript 添加了可选的静态类型系统和现代语言特性。TypeScript 的目标是提高 JavaScript 代码的可维护性、可读性和开发效率，同时保持与 JavaScript 的完全兼容。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>what is mpx</title>
    <link href="https://jackwzx.github.io/2025/03/15/what-is-mpx/"/>
    <id>https://jackwzx.github.io/2025/03/15/what-is-mpx/</id>
    <published>2025-03-15T15:04:48.000Z</published>
    <updated>2025-03-15T15:09:28.145Z</updated>
    
    
    <summary type="html">&lt;p&gt;MPX 是一个 &lt;strong&gt;面向小程序开发的前端框架&lt;/strong&gt;，由滴滴出行团队开源，专为提升小程序开发效率和性能而设计。它基于 Vue.js 的语法和特性，同时针对小程序的特点进行了深度优化和扩展。以下是 MPX 的核心特性和详细介绍：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>命令行通配符</title>
    <link href="https://jackwzx.github.io/2024/11/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    <id>https://jackwzx.github.io/2024/11/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%9A%E9%85%8D%E7%AC%A6/</id>
    <published>2024-11-04T09:14:07.000Z</published>
    <updated>2025-06-07T09:16:19.436Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;这是因为-shell-中的通配符（-）展开行为不同：&quot;&gt;&lt;a href=&quot;#这是因为-shell-中的通配符（-）展开行为不同：&quot; class=&quot;headerlink&quot; title=&quot;这是因为 shell 中的通配符（*）展开行为不同：&quot;&gt;&lt;/a&gt;这是因为 shell 中的通配符（&lt;code&gt;*&lt;/code&gt;）展开行为不同：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;unzip *.zip&lt;/code&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;shell 会先展开 &lt;code&gt;*.zip&lt;/code&gt;，如果当前目录有多个 zip 文件&lt;/li&gt;
&lt;li&gt;命令会变成 &lt;code&gt;unzip file1.zip file2.zip file3.zip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;这可能导致 unzip 命令收到多个参数而报错&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>正则与通配符区别</title>
    <link href="https://jackwzx.github.io/2024/10/11/%E6%AD%A3%E5%88%99%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%BA%E5%88%AB/"/>
    <id>https://jackwzx.github.io/2024/10/11/%E6%AD%A3%E5%88%99%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%BA%E5%88%AB/</id>
    <published>2024-10-11T11:11:45.000Z</published>
    <updated>2025-02-20T13:07:48.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;正则表达式（Regular Expressions）和通配符（Wildcards）都是用于模式匹配的工具，但它们在功能、语法和应用场景上有显著的区别。以下是它们之间的主要区别：&lt;/p&gt;
&lt;h3 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1. 定义&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>std::nth_element实现</title>
    <link href="https://jackwzx.github.io/2024/10/08/std-nth-element%E5%AE%9E%E7%8E%B0/"/>
    <id>https://jackwzx.github.io/2024/10/08/std-nth-element%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-10-08T09:37:18.000Z</published>
    <updated>2025-02-20T13:07:48.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;std::nth_element&lt;/code&gt; 是 C++ 标准库中的一个算法，用于在一个范围内重新排列元素，使得第 &lt;code&gt;n&lt;/code&gt; 个元素位于其最终位置，并且该元素左侧的所有元素都小于或等于它，右侧的所有元素都大于或等于它。这个算法的时间复杂度为 O(n) 平均情况下，最坏情况下为 O(n^2)。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>texelFetch</title>
    <link href="https://jackwzx.github.io/2024/10/06/texelFetch/"/>
    <id>https://jackwzx.github.io/2024/10/06/texelFetch/</id>
    <published>2024-10-06T10:16:59.000Z</published>
    <updated>2025-02-20T13:07:48.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;texelFetch&lt;/code&gt; 是一个在着色器编程中用于从纹理中获取特定纹素（texel）的函数。与常规的纹理采样不同，&lt;code&gt;texelFetch&lt;/code&gt; 使用整数纹理坐标来直接访问纹理数据，不进行过滤或插值。&lt;/p&gt;
&lt;p&gt;在 OpenGL 的 GLSL（OpenGL Shading Language）中，&lt;code&gt;texelFetch&lt;/code&gt; 的用法如下：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>traits设计和用法</title>
    <link href="https://jackwzx.github.io/2024/09/29/traits%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%94%A8%E6%B3%95/"/>
    <id>https://jackwzx.github.io/2024/09/29/traits%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%94%A8%E6%B3%95/</id>
    <published>2024-09-29T09:25:47.000Z</published>
    <updated>2025-02-20T13:07:48.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 C++ 中，&lt;strong&gt;Traits&lt;/strong&gt;（特性）是一种设计模式，通常用于提供类型信息或行为的模板类。Traits 允许在编译时获取类型的特性，从而实现更灵活和可扩展的代码。Traits 模式广泛应用于标准库和现代 C++ 编程中，尤其是在模板编程和泛型编程中。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>shell和子shell环境变量</title>
    <link href="https://jackwzx.github.io/2024/09/29/shell%E5%92%8C%E5%AD%90shell%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://jackwzx.github.io/2024/09/29/shell%E5%92%8C%E5%AD%90shell%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2024-09-29T06:12:02.000Z</published>
    <updated>2025-02-20T13:07:48.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 Shell 脚本中，命令替换（command substitution）是指将命令的输出作为字符串插入到另一个命令中。命令替换通常使用反引号（&lt;code&gt;`command`&lt;/code&gt;）或 &lt;code&gt;$()&lt;/code&gt; 语法来实现。命令替换会在一个子 Shell 中执行指定的命令，这意味着在子 Shell 中定义的变量不会影响父 Shell 中的变量。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>分支预测</title>
    <link href="https://jackwzx.github.io/2024/09/27/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/"/>
    <id>https://jackwzx.github.io/2024/09/27/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/</id>
    <published>2024-09-27T01:25:37.000Z</published>
    <updated>2025-02-20T13:07:48.000Z</updated>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;宏定义解释&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; likely(x) __builtin_expect(!!(x), 1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; unlikely(x) __builtin_expect(!!(x), 0)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>c++模版函数delete防止隐士类型转换.md</title>
    <link href="https://jackwzx.github.io/2024/09/26/c-%E6%A8%A1%E7%89%88%E5%87%BD%E6%95%B0delete%E9%98%B2%E6%AD%A2%E9%9A%90%E5%A3%AB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-md/"/>
    <id>https://jackwzx.github.io/2024/09/26/c-%E6%A8%A1%E7%89%88%E5%87%BD%E6%95%B0delete%E9%98%B2%E6%AD%A2%E9%9A%90%E5%A3%AB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-md/</id>
    <published>2024-09-26T06:29:27.000Z</published>
    <updated>2025-06-07T09:19:58.875Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文展示如何使用C++模板函数的&lt;code&gt;delete&lt;/code&gt;关键字来防止不必要的隐式类型转换。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>AndoirdEGLContext销毁管理</title>
    <link href="https://jackwzx.github.io/2024/08/01/AndoirdEGLContext%E9%94%80%E6%AF%81%E7%AE%A1%E7%90%86/"/>
    <id>https://jackwzx.github.io/2024/08/01/AndoirdEGLContext%E9%94%80%E6%AF%81%E7%AE%A1%E7%90%86/</id>
    <published>2024-07-31T16:19:32.000Z</published>
    <updated>2025-02-20T13:07:48.000Z</updated>
    
    
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;EGLContextFactory&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    EGLContext &lt;span class=&quot;title function_&quot;&gt;createContext&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(EGL10 egl, EGLDisplay display, EGLConfig eglConfig)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;destroyContext&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(EGL10 egl, EGLDisplay display, EGLContext context)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗&quot;&gt;&lt;a href=&quot;#EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗&quot; class=&quot;headerlink&quot; title=&quot;EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗&quot;&gt;&lt;/a&gt;EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵</title>
    <link href="https://jackwzx.github.io/2024/07/30/%E4%BB%8E%E5%8C%85%E5%90%AB%E5%B9%B3%E7%A7%BB%E3%80%81%E6%97%8B%E8%BD%AC%E5%92%8C%E7%BC%A9%E6%94%BE%E7%9A%84%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BB%85%E5%8C%85%E5%90%AB%E5%B9%B3%E7%A7%BB%E5%92%8C%E6%97%8B%E8%BD%AC%E7%9A%84%E7%9F%A9%E9%98%B5/"/>
    <id>https://jackwzx.github.io/2024/07/30/%E4%BB%8E%E5%8C%85%E5%90%AB%E5%B9%B3%E7%A7%BB%E3%80%81%E6%97%8B%E8%BD%AC%E5%92%8C%E7%BC%A9%E6%94%BE%E7%9A%84%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BB%85%E5%8C%85%E5%90%AB%E5%B9%B3%E7%A7%BB%E5%92%8C%E6%97%8B%E8%BD%AC%E7%9A%84%E7%9F%A9%E9%98%B5/</id>
    <published>2024-07-30T04:26:12.000Z</published>
    <updated>2025-02-20T13:07:48.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;要从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵，您需要对原矩阵进行一些操作。原矩阵通常是一个3x3或4x4的矩阵。&lt;/p&gt;
&lt;h3 id=&quot;对于3x3矩阵：&quot;&gt;&lt;a href=&quot;#对于3x3矩阵：&quot; class=&quot;headerlink&quot; title=&quot;对于3x3矩阵：&quot;&gt;&lt;/a&gt;对于3x3矩阵：&lt;/h3&gt;&lt;p&gt;原3x3矩阵的形式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;| a  b  tx |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| c  d  ty |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 0  0  1  |&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>OpenGLE_VAO局部影响vs全局影响</title>
    <link href="https://jackwzx.github.io/2024/07/28/OpenGLE-VAO%E5%B1%80%E9%83%A8%E5%BD%B1%E5%93%8Dvs%E5%85%A8%E5%B1%80%E5%BD%B1%E5%93%8D/"/>
    <id>https://jackwzx.github.io/2024/07/28/OpenGLE-VAO%E5%B1%80%E9%83%A8%E5%BD%B1%E5%93%8Dvs%E5%85%A8%E5%B1%80%E5%BD%B1%E5%93%8D/</id>
    <published>2024-07-28T08:57:48.000Z</published>
    <updated>2025-02-20T13:07:48.000Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;全局顶点属性数组使能状态&quot;&gt;&lt;a href=&quot;#全局顶点属性数组使能状态&quot; class=&quot;headerlink&quot; title=&quot;全局顶点属性数组使能状态&quot;&gt;&lt;/a&gt;全局顶点属性数组使能状态&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>OpenGLES设置顶点属性的默认值</title>
    <link href="https://jackwzx.github.io/2024/07/28/OpenGLES%E8%AE%BE%E7%BD%AE%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
    <id>https://jackwzx.github.io/2024/07/28/OpenGLES%E8%AE%BE%E7%BD%AE%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/</id>
    <published>2024-07-28T08:53:57.000Z</published>
    <updated>2025-02-20T13:07:48.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 OpenGL ES 中，设置顶点属性的默认值和通过顶点缓冲对象（VBO）上传顶点属性是两种不同的处理顶点属性的方法。以下是详细的解释：&lt;/p&gt;
&lt;h3 id=&quot;设置顶点属性默认值&quot;&gt;&lt;a href=&quot;#设置顶点属性默认值&quot; class=&quot;headerlink&quot; title=&quot;设置顶点属性默认值&quot;&gt;&lt;/a&gt;设置顶点属性默认值&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>AddressSanitizer实现原理</title>
    <link href="https://jackwzx.github.io/2024/07/28/AddressSanitizer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://jackwzx.github.io/2024/07/28/AddressSanitizer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2024-07-28T04:23:56.000Z</published>
    <updated>2025-02-20T13:07:48.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;AddressSanitizer（简称ASan）是一种内存错误检测工具，用于捕捉诸如缓冲区溢出、使用已释放内存、堆栈溢出等内存错误。ASan在编译时和运行时对程序进行处理，以检测和报告内存相关的错误。以下是AddressSanitizer的实现原理的详细解释：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>pthread_create设置栈size</title>
    <link href="https://jackwzx.github.io/2024/07/28/pthread-create%E8%AE%BE%E7%BD%AE%E6%A0%88size/"/>
    <id>https://jackwzx.github.io/2024/07/28/pthread-create%E8%AE%BE%E7%BD%AE%E6%A0%88size/</id>
    <published>2024-07-28T02:44:09.000Z</published>
    <updated>2025-06-07T09:24:45.445Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文演示如何在使用 &lt;code&gt;pthread_create&lt;/code&gt; 创建线程时设置自定义的栈大小。通过 &lt;code&gt;pthread_attr_setstacksize&lt;/code&gt; 函数可以控制线程的栈空间大小，这在需要大量栈空间或者优化内存使用时非常有用。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用__asan_unpoison_memory_region屏蔽某处内存检查</title>
    <link href="https://jackwzx.github.io/2024/07/22/%E4%BD%BF%E7%94%A8-asan-unpoison-memory-region%E5%B1%8F%E8%94%BD%E6%9F%90%E5%A4%84%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5/"/>
    <id>https://jackwzx.github.io/2024/07/22/%E4%BD%BF%E7%94%A8-asan-unpoison-memory-region%E5%B1%8F%E8%94%BD%E6%9F%90%E5%A4%84%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5/</id>
    <published>2024-07-22T00:45:16.000Z</published>
    <updated>2025-02-20T13:07:48.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;__asan_unpoison_memory_region&lt;/code&gt; 是 AddressSanitizer (ASan) 库中的一个函数。ASan 是一个用于检测内存错误的工具，主要用于 C 和 C++ 程序开发者。&lt;code&gt;__asan_unpoison_memory_region&lt;/code&gt; 的作用是标记一段内存区域为“未污染”状态，这意味着这段内存可以被访问且不会触发 ASan 的错误报告。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
