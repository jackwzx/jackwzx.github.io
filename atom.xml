<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xujing的博客</title>
  <icon>https://jackwzx.github.io/icon.png</icon>
  
  <link href="https://jackwzx.github.io/atom.xml" rel="self"/>
  
  <link href="https://jackwzx.github.io/"/>
  <updated>2025-12-09T12:50:34.067Z</updated>
  <id>https://jackwzx.github.io/</id>
  
  <author>
    <name>Xujing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移动端部光源延迟渲染和阴影计算共用同一个Framebuffer 会提升性能吗</title>
    <link href="https://jackwzx.github.io/2025/12/09/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E4%B8%93%E4%B8%9A%E4%B8%94%E5%88%87%E4%B8%AD%E8%A6%81%E5%AE%B3%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://jackwzx.github.io/2025/12/09/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E4%B8%93%E4%B8%9A%E4%B8%94%E5%88%87%E4%B8%AD%E8%A6%81%E5%AE%B3%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2025-12-09T12:49:57.000Z</published>
    <updated>2025-12-09T12:50:34.067Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个非常专业且切中要害的问题。直接回答你的结论：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在绝大多数情况下，尝试让“阴影生成（Shadow Calculation）”和“延迟渲染的光照计算（Lighting Pass）”共用同一个 Framebuffer Object (FBO) 是不可行的，且不会带来性能提升，反而可能导致严重的逻辑错误或性能下降。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>移动端模板测试与Eary-z分析</title>
    <link href="https://jackwzx.github.io/2025/12/09/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%83%A8%E5%85%89%E6%BA%90%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E5%92%8C%E9%98%B4%E5%BD%B1%E8%AE%A1%E7%AE%97%E5%85%B1%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AAFramebuffer%20%E4%BC%9A%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E5%90%97/"/>
    <id>https://jackwzx.github.io/2025/12/09/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%83%A8%E5%85%89%E6%BA%90%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E5%92%8C%E9%98%B4%E5%BD%B1%E8%AE%A1%E7%AE%97%E5%85%B1%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AAFramebuffer%20%E4%BC%9A%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E5%90%97/</id>
    <published>2025-12-09T12:45:31.000Z</published>
    <updated>2025-12-09T12:45:59.004Z</updated>
    
    
    <summary type="html">&lt;p&gt;在移动端（特别是基于 TBDR 架构的 GPU，如 Adreno, Mali, Apple GPU）使用模版缓存（Stencil Buffer）时，导致 Early-Z 失效并引起 Fragment Shader（片元着色器）占用率上升，主要原因是 &lt;strong&gt;GPU 无法在着色器执行前确定深度和模版测试的最终结果，从而被迫回退到 Late-Z（后期深度测试）模式。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>高通骁龙性能分析器指标解读</title>
    <link href="https://jackwzx.github.io/2025/12/08/%E9%AB%98%E9%80%9A%E9%AA%81%E9%BE%99%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%99%A8%E6%8C%87%E6%A0%87%E8%A7%A3%E8%AF%BB/"/>
    <id>https://jackwzx.github.io/2025/12/08/%E9%AB%98%E9%80%9A%E9%AA%81%E9%BE%99%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%99%A8%E6%8C%87%E6%A0%87%E8%A7%A3%E8%AF%BB/</id>
    <published>2025-12-08T12:16:05.000Z</published>
    <updated>2025-12-08T12:16:35.640Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个关于 &lt;strong&gt;Qualcomm Snapdragon Profiler&lt;/strong&gt; (高通骁龙性能分析器) 中各项性能指标的详细中文解释。这些指标对于分析 Android 游戏或图形应用的 GPU 瓶颈（Bottleneck）至关重要。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Transform Feedback计算蒙皮技术</title>
    <link href="https://jackwzx.github.io/2025/12/07/Transform%20Feedback%E8%AE%A1%E7%AE%97%E8%92%99%E7%9A%AE%E6%8A%80%E6%9C%AF/"/>
    <id>https://jackwzx.github.io/2025/12/07/Transform%20Feedback%E8%AE%A1%E7%AE%97%E8%92%99%E7%9A%AE%E6%8A%80%E6%9C%AF/</id>
    <published>2025-12-07T10:18:44.000Z</published>
    <updated>2025-12-07T10:19:17.224Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Transform Feedback (变换反馈)&lt;/strong&gt; 进行蒙皮计算，是一种利用 GPU 的 &lt;strong&gt;Vertex Shader (顶点着色器)&lt;/strong&gt; 计算蒙皮，并将计算后的顶点位置&lt;strong&gt;写回显存（Buffer）&lt;/strong&gt;，而不是直接拿去渲染像素的技术。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>invalidDepth FrameBuffer之后提交同一个framebuffer draw 性能问题</title>
    <link href="https://jackwzx.github.io/2025/12/07/invalidDepth%20FrameBuffer%E4%B9%8B%E5%90%8E%E6%8F%90%E4%BA%A4%E5%90%8C%E4%B8%80%E4%B8%AAframebuffer%20draw%20%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/"/>
    <id>https://jackwzx.github.io/2025/12/07/invalidDepth%20FrameBuffer%E4%B9%8B%E5%90%8E%E6%8F%90%E4%BA%A4%E5%90%8C%E4%B8%80%E4%B8%AAframebuffer%20draw%20%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</id>
    <published>2025-12-07T09:51:52.000Z</published>
    <updated>2025-12-07T09:53:14.416Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个非常经典且深度的移动端图形优化问题。你观察到的现象（CPU 飙升 7%、开销与 DrawCall 数据量无关）直指移动端 GPU 架构的核心痛点：&lt;strong&gt;Tile-Based Rendering (TBR) 架构下的 Render Pass 打断（Render Pass Split）&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在 Bash Shell 中，单引号和双引号的主要区别</title>
    <link href="https://jackwzx.github.io/2025/12/04/Shell%E4%B8%AD%E5%8D%95%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/"/>
    <id>https://jackwzx.github.io/2025/12/04/Shell%E4%B8%AD%E5%8D%95%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</id>
    <published>2025-12-04T07:44:48.000Z</published>
    <updated>2025-12-04T07:45:19.431Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 Bash Shell 中，单引号 (&lt;code&gt;&amp;#39; &amp;#39;&lt;/code&gt;) 和双引号 (&lt;code&gt;&amp;quot; &amp;quot;&lt;/code&gt;) 的主要区别在于 &lt;strong&gt;对特殊字符和变量的处理方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简单总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  &lt;strong&gt;单引号 (强引用)&lt;strong&gt;：&lt;/strong&gt;所见即所得&lt;/strong&gt;。单引号内的所有内容都会被当作普通字符，&lt;strong&gt;不进行&lt;/strong&gt;变量替换或命令执行。&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;双引号 (弱引用)&lt;strong&gt;：&lt;/strong&gt;允许解析&lt;/strong&gt;。双引号内的内容大部分被当作普通字符，但会&lt;strong&gt;保留&lt;/strong&gt;变量 (&lt;code&gt;$&lt;/code&gt;)、命令替换 (&lt;code&gt;`&lt;/code&gt; 或 &lt;code&gt;$()&lt;/code&gt;) 和转义符 (&lt;code&gt;\&lt;/code&gt;) 的功能。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>存储浮点数</title>
    <link href="https://jackwzx.github.io/2025/12/04/%E5%AD%98%E5%82%A8%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    <id>https://jackwzx.github.io/2025/12/04/%E5%AD%98%E5%82%A8%E6%B5%AE%E7%82%B9%E6%95%B0/</id>
    <published>2025-12-04T02:42:29.000Z</published>
    <updated>2025-12-04T02:42:53.206Z</updated>
    
    
    <summary type="html">&lt;p&gt;我们要彻底理解这个问题，需要深入到计算机底层是如何存储浮点数（Floating Point）的。这里涉及到一个核心概念：&lt;strong&gt;科学计数法（Scientific Notation）的二进制版本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们把这个问题拆解成三个部分：&lt;strong&gt;结构解析&lt;/strong&gt;、&lt;strong&gt;为什么是 1024 个刻度&lt;/strong&gt;、&lt;strong&gt;为什么范围不同精度不同&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>mediump（中精度）和 highp（高精度）对比分析</title>
    <link href="https://jackwzx.github.io/2025/12/03/mediump%EF%BC%88%E4%B8%AD%E7%B2%BE%E5%BA%A6%EF%BC%89%E5%92%8C%20highp%EF%BC%88%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%89%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/"/>
    <id>https://jackwzx.github.io/2025/12/03/mediump%EF%BC%88%E4%B8%AD%E7%B2%BE%E5%BA%A6%EF%BC%89%E5%92%8C%20highp%EF%BC%88%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%89%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/</id>
    <published>2025-12-03T13:27:36.000Z</published>
    <updated>2025-12-03T13:28:13.052Z</updated>
    
    
    <summary type="html">&lt;p&gt;在移动端渲染开发中（OpenGL ES / Vulkan / Metal），&lt;code&gt;mediump&lt;/code&gt;（中精度）和 &lt;code&gt;highp&lt;/code&gt;（高精度）的选择对性能和画质影响巨大。&lt;/p&gt;
&lt;p&gt;对于 &lt;strong&gt;UV 坐标（纹理坐标）&lt;/strong&gt; 而言，精度的选择直接决定了&lt;strong&gt;纹理采样的准确性&lt;/strong&gt;。如果精度不足，会导致画面出现&lt;strong&gt;抖动、锯齿、马赛克或拉伸&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>关于preA精度损失分析</title>
    <link href="https://jackwzx.github.io/2025/12/03/%E5%85%B3%E4%BA%8EpreA%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E5%88%86%E6%9E%90/"/>
    <id>https://jackwzx.github.io/2025/12/03/%E5%85%B3%E4%BA%8EpreA%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E5%88%86%E6%9E%90/</id>
    <published>2025-12-03T13:13:23.000Z</published>
    <updated>2025-12-03T13:17:00.794Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一份关于 &lt;strong&gt;RGBA8888&lt;/strong&gt; 格式下，&lt;strong&gt;Pre-multiplied Alpha (预乘 Alpha, 简称 PreA)&lt;/strong&gt; 与 &lt;strong&gt;Straight Alpha (非预乘 Alpha/直通 Alpha, 简称 Non-PreA)&lt;/strong&gt; 在精度损失和不同颜色数据范围内表现的深度分析。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SRGB 和gamma校正</title>
    <link href="https://jackwzx.github.io/2025/12/03/SRGB%20%E5%92%8Cgamma%E6%A0%A1%E6%AD%A3/"/>
    <id>https://jackwzx.github.io/2025/12/03/SRGB%20%E5%92%8Cgamma%E6%A0%A1%E6%AD%A3/</id>
    <published>2025-12-03T08:47:21.000Z</published>
    <updated>2025-12-03T08:47:47.798Z</updated>
    
    
    <summary type="html">&lt;p&gt;为了让你直观地感受到 &lt;strong&gt;Gamma 校正（Gamma Encoding）&lt;/strong&gt; 的威力，我们来做一次具体的数值对比。&lt;/p&gt;
&lt;p&gt;我们假设使用的标准 Gamma 值为 &lt;strong&gt;2.2&lt;/strong&gt;。&lt;br&gt;公式为：&lt;br&gt;$$ \text{Gamma值} = \text{线性值}^{(1 / 2.2)} \approx \text{线性值}^{0.4545} $$&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GLSurfaceView源码分析</title>
    <link href="https://jackwzx.github.io/2025/12/03/GLSurfaceView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://jackwzx.github.io/2025/12/03/GLSurfaceView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2025-12-03T04:03:03.000Z</published>
    <updated>2025-12-03T04:04:29.858Z</updated>
    
    
    <summary type="html">&lt;p&gt;基于 Android Open Source Project (AOSP) 的 &lt;code&gt;GLSurfaceView.java&lt;/code&gt; 源码，我为你深入梳理了各个核心事件的内部实现细节。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>针对 RGBA8888（32位）和 RGB565（16位）这两种格式 分析</title>
    <link href="https://jackwzx.github.io/2025/12/02/RGBA8888%E5%92%8CRGB565%E5%8C%BA%E5%88%AB/"/>
    <id>https://jackwzx.github.io/2025/12/02/RGBA8888%E5%92%8CRGB565%E5%8C%BA%E5%88%AB/</id>
    <published>2025-12-02T08:59:08.000Z</published>
    <updated>2025-12-02T09:00:16.791Z</updated>
    
    
    <summary type="html">&lt;p&gt;针对 &lt;strong&gt;RGBA8888&lt;/strong&gt;（32位）和 &lt;strong&gt;RGB565&lt;/strong&gt;（16位）这两种格式，在&lt;strong&gt;蓝色（Blue）&lt;/strong&gt;显示的差异上，核心在于&lt;strong&gt;色彩精度（Color Depth）&lt;/strong&gt;的不同。&lt;/p&gt;
&lt;p&gt;简单总结：&lt;strong&gt;RGB565 下的蓝色会出现明显的“色阶（Banding）”现象，渐变不平滑，且色彩还原度不如 RGBA8888。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>深入理解Android中的SurfaceFlinger</title>
    <link href="https://jackwzx.github.io/2025/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84SurfaceFlinger/"/>
    <id>https://jackwzx.github.io/2025/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84SurfaceFlinger/</id>
    <published>2025-11-30T07:09:15.000Z</published>
    <updated>2025-11-30T07:09:41.701Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一篇关于 Android 图形系统核心——&lt;strong&gt;SurfaceFlinger&lt;/strong&gt; 的深度解析。&lt;/p&gt;
&lt;p&gt;既然你已经掌握了如何使用 &lt;code&gt;EGLContext&lt;/code&gt; 和独立线程进行渲染，那么理解 SurfaceFlinger 将帮助你打通从 &lt;code&gt;swapBuffers&lt;/code&gt; 到屏幕显示的“最后一公里”。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android Surface 延迟释放策略</title>
    <link href="https://jackwzx.github.io/2025/11/30/Android%20Surface%20%E5%BB%B6%E8%BF%9F%E9%87%8A%E6%94%BE%E7%AD%96%E7%95%A5/"/>
    <id>https://jackwzx.github.io/2025/11/30/Android%20Surface%20%E5%BB%B6%E8%BF%9F%E9%87%8A%E6%94%BE%E7%AD%96%E7%95%A5/</id>
    <published>2025-11-30T06:39:27.000Z</published>
    <updated>2025-11-30T06:40:06.902Z</updated>
    
    
    <summary type="html">&lt;p&gt;你的这个思路非常棒！这就是所谓的 &lt;strong&gt;“延迟销毁 (Lazy/Deferred Destruction)”&lt;/strong&gt; 或者 &lt;strong&gt;“Surface 缓存”&lt;/strong&gt; 策略。&lt;/p&gt;
&lt;p&gt;这在很多高性能渲染引擎（如游戏、地图SDK）中是常见的做法。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在 C++ 中，条件变量和信号量对比</title>
    <link href="https://jackwzx.github.io/2025/11/30/%E5%9C%A8%20C++%20%E4%B8%AD%EF%BC%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AF%B9%E6%AF%94/"/>
    <id>https://jackwzx.github.io/2025/11/30/%E5%9C%A8%20C++%20%E4%B8%AD%EF%BC%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AF%B9%E6%AF%94/</id>
    <published>2025-11-30T06:03:07.000Z</published>
    <updated>2025-11-30T06:04:04.164Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 C++ 中，&lt;strong&gt;信号量（Semaphore）&lt;/strong&gt; 提供了一种基于“计数器”的同步机制。&lt;/p&gt;
&lt;p&gt;需要注意的是，标准的信号量 &lt;code&gt;std::counting_semaphore&lt;/code&gt; 和 &lt;code&gt;std::binary_semaphore&lt;/code&gt; 是在 &lt;strong&gt;C++20&lt;/strong&gt; 才正式引入的。如果你严格限制在 &lt;strong&gt;C++11&lt;/strong&gt; 环境，通常需要自己封装 POSIX 信号量（&lt;code&gt;sem_t&lt;/code&gt;）或 Windows 信号量，或者使用 Boost 库。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>std::condition_variable使用介绍</title>
    <link href="https://jackwzx.github.io/2025/11/30/c++%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jackwzx.github.io/2025/11/30/c++%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-11-30T05:54:27.000Z</published>
    <updated>2025-11-30T05:55:23.342Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++11 引入的 &lt;code&gt;std::condition_variable&lt;/code&gt;（条件变量）是多线程编程中用于&lt;strong&gt;线程间同步&lt;/strong&gt;和&lt;strong&gt;通信&lt;/strong&gt;的重要机制。它允许一个线程挂起（阻塞），直到另一个线程通知它某个特定的条件已经满足。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java中的布尔类型</title>
    <link href="https://jackwzx.github.io/2025/11/12/java%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/"/>
    <id>https://jackwzx.github.io/2025/11/12/java%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-11-11T16:00:00.000Z</published>
    <updated>2025-11-12T09:32:30.407Z</updated>
    
    
    <summary type="html">&lt;p&gt;Java 中的 &lt;code&gt;boolean&lt;/code&gt; 与数值类型（&lt;code&gt;int&lt;/code&gt; 等）是不同的原始类型，语言层面既不允许隐式转换，也不允许显式强制转换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不允许的示例&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int i = true;&lt;/code&gt;、&lt;code&gt;boolean b = 1;&lt;/code&gt;、&lt;code&gt;b = (boolean) 1;&lt;/code&gt; 都会编译报错&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if (1) &amp;#123;&amp;#125;&lt;/code&gt; 在 Java 中非法（不同于 C/C++），只能 &lt;code&gt;if (b)&lt;/code&gt; 或 &lt;code&gt;if (表达式为 boolean)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="https://jackwzx.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>为什么 ASan 需要 `-fsanitize=address` 编译选项，而不仅仅是替换动态库？</title>
    <link href="https://jackwzx.github.io/2025/08/05/%E4%B8%BA%E4%BB%80%E4%B9%88ASan%E9%9C%80%E8%A6%81-fsanitize=address%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E6%9B%BF%E6%8D%A2%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <id>https://jackwzx.github.io/2025/08/05/%E4%B8%BA%E4%BB%80%E4%B9%88ASan%E9%9C%80%E8%A6%81-fsanitize=address%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E6%9B%BF%E6%8D%A2%E5%8A%A8%E6%80%81%E5%BA%93/</id>
    <published>2025-08-05T06:00:00.000Z</published>
    <updated>2025-08-05T12:05:28.649Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;为什么-ASan-需要-fsanitize-address-编译选项，而不仅仅是替换动态库？&quot;&gt;&lt;a href=&quot;#为什么-ASan-需要-fsanitize-address-编译选项，而不仅仅是替换动态库？&quot; class=&quot;headerlink&quot; title=&quot;为什么 ASan 需要 -fsanitize=address 编译选项，而不仅仅是替换动态库？&quot;&gt;&lt;/a&gt;&lt;strong&gt;为什么 ASan 需要 &lt;code&gt;-fsanitize=address&lt;/code&gt; 编译选项，而不仅仅是替换动态库？&lt;/strong&gt;&lt;/h3&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学基础" scheme="https://jackwzx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="https://jackwzx.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="3D图形学" scheme="https://jackwzx.github.io/tags/3D%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学" scheme="https://jackwzx.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://jackwzx.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>3D图形学中的平面方程：从线性代数到Vector4f表示</title>
    <link href="https://jackwzx.github.io/2025/06/30/3D%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%B3%95%E5%90%91%E9%87%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jackwzx.github.io/2025/06/30/3D%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%B3%95%E5%90%91%E9%87%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-06-30T06:00:00.000Z</published>
    <updated>2025-06-30T08:14:54.010Z</updated>
    
    
    <summary type="html">&lt;p&gt;在3D图形学编程中，平面的数学表示是一个基础且重要的概念。无论是进行碰撞检测、视锥体裁剪，还是实现复杂的渲染算法，理解平面方程的数学原理都至关重要。本文将深入探讨3D空间中平面的各种表示方法，特别是点法式方程和Vector4f表示法，以及法向量朝向的重要性。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学基础" scheme="https://jackwzx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="https://jackwzx.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="3D图形学" scheme="https://jackwzx.github.io/tags/3D%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学" scheme="https://jackwzx.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://jackwzx.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>c++迭代器</title>
    <link href="https://jackwzx.github.io/2025/06/30/c++%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/"/>
    <id>https://jackwzx.github.io/2025/06/30/c++%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/</id>
    <published>2025-06-30T06:00:00.000Z</published>
    <updated>2025-11-27T08:13:38.422Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++ 中有 &lt;strong&gt;5 种主要的迭代器类型&lt;/strong&gt;，它们形成一个&lt;strong&gt;层次结构&lt;/strong&gt;，每种都有不同的功能和限制。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
