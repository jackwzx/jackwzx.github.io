<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xujing的博客</title>
  <icon>https://jackwzx.github.io/icon.png</icon>
  
  <link href="https://jackwzx.github.io/atom.xml" rel="self"/>
  
  <link href="https://jackwzx.github.io/"/>
  <updated>2025-12-03T13:28:13.052Z</updated>
  <id>https://jackwzx.github.io/</id>
  
  <author>
    <name>Xujing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mediump（中精度）和 highp（高精度）对比分析</title>
    <link href="https://jackwzx.github.io/2025/12/03/mediump%EF%BC%88%E4%B8%AD%E7%B2%BE%E5%BA%A6%EF%BC%89%E5%92%8C%20highp%EF%BC%88%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%89%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/"/>
    <id>https://jackwzx.github.io/2025/12/03/mediump%EF%BC%88%E4%B8%AD%E7%B2%BE%E5%BA%A6%EF%BC%89%E5%92%8C%20highp%EF%BC%88%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%89%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/</id>
    <published>2025-12-03T13:27:36.000Z</published>
    <updated>2025-12-03T13:28:13.052Z</updated>
    
    
    <summary type="html">&lt;p&gt;在移动端渲染开发中（OpenGL ES / Vulkan / Metal），&lt;code&gt;mediump&lt;/code&gt;（中精度）和 &lt;code&gt;highp&lt;/code&gt;（高精度）的选择对性能和画质影响巨大。&lt;/p&gt;
&lt;p&gt;对于 &lt;strong&gt;UV 坐标（纹理坐标）&lt;/strong&gt; 而言，精度的选择直接决定了&lt;strong&gt;纹理采样的准确性&lt;/strong&gt;。如果精度不足，会导致画面出现&lt;strong&gt;抖动、锯齿、马赛克或拉伸&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>关于preA精度损失分析</title>
    <link href="https://jackwzx.github.io/2025/12/03/%E5%85%B3%E4%BA%8EpreA%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E5%88%86%E6%9E%90/"/>
    <id>https://jackwzx.github.io/2025/12/03/%E5%85%B3%E4%BA%8EpreA%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E5%88%86%E6%9E%90/</id>
    <published>2025-12-03T13:13:23.000Z</published>
    <updated>2025-12-03T13:17:00.794Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一份关于 &lt;strong&gt;RGBA8888&lt;/strong&gt; 格式下，&lt;strong&gt;Pre-multiplied Alpha (预乘 Alpha, 简称 PreA)&lt;/strong&gt; 与 &lt;strong&gt;Straight Alpha (非预乘 Alpha/直通 Alpha, 简称 Non-PreA)&lt;/strong&gt; 在精度损失和不同颜色数据范围内表现的深度分析。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SRGB 和gamma校正</title>
    <link href="https://jackwzx.github.io/2025/12/03/SRGB%20%E5%92%8Cgamma%E6%A0%A1%E6%AD%A3/"/>
    <id>https://jackwzx.github.io/2025/12/03/SRGB%20%E5%92%8Cgamma%E6%A0%A1%E6%AD%A3/</id>
    <published>2025-12-03T08:47:21.000Z</published>
    <updated>2025-12-03T08:47:47.798Z</updated>
    
    
    <summary type="html">&lt;p&gt;为了让你直观地感受到 &lt;strong&gt;Gamma 校正（Gamma Encoding）&lt;/strong&gt; 的威力，我们来做一次具体的数值对比。&lt;/p&gt;
&lt;p&gt;我们假设使用的标准 Gamma 值为 &lt;strong&gt;2.2&lt;/strong&gt;。&lt;br&gt;公式为：&lt;br&gt;$$ \text{Gamma值} = \text{线性值}^{(1 / 2.2)} \approx \text{线性值}^{0.4545} $$&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GLSurfaceView源码分析</title>
    <link href="https://jackwzx.github.io/2025/12/03/GLSurfaceView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://jackwzx.github.io/2025/12/03/GLSurfaceView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2025-12-03T04:03:03.000Z</published>
    <updated>2025-12-03T04:04:29.858Z</updated>
    
    
    <summary type="html">&lt;p&gt;基于 Android Open Source Project (AOSP) 的 &lt;code&gt;GLSurfaceView.java&lt;/code&gt; 源码，我为你深入梳理了各个核心事件的内部实现细节。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>针对 RGBA8888（32位）和 RGB565（16位）这两种格式 分析</title>
    <link href="https://jackwzx.github.io/2025/12/02/RGBA8888%E5%92%8CRGB565%E5%8C%BA%E5%88%AB/"/>
    <id>https://jackwzx.github.io/2025/12/02/RGBA8888%E5%92%8CRGB565%E5%8C%BA%E5%88%AB/</id>
    <published>2025-12-02T08:59:08.000Z</published>
    <updated>2025-12-02T09:00:16.791Z</updated>
    
    
    <summary type="html">&lt;p&gt;针对 &lt;strong&gt;RGBA8888&lt;/strong&gt;（32位）和 &lt;strong&gt;RGB565&lt;/strong&gt;（16位）这两种格式，在&lt;strong&gt;蓝色（Blue）&lt;/strong&gt;显示的差异上，核心在于&lt;strong&gt;色彩精度（Color Depth）&lt;/strong&gt;的不同。&lt;/p&gt;
&lt;p&gt;简单总结：&lt;strong&gt;RGB565 下的蓝色会出现明显的“色阶（Banding）”现象，渐变不平滑，且色彩还原度不如 RGBA8888。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>深入理解Android中的SurfaceFlinger</title>
    <link href="https://jackwzx.github.io/2025/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84SurfaceFlinger/"/>
    <id>https://jackwzx.github.io/2025/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84SurfaceFlinger/</id>
    <published>2025-11-30T07:09:15.000Z</published>
    <updated>2025-11-30T07:09:41.701Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一篇关于 Android 图形系统核心——&lt;strong&gt;SurfaceFlinger&lt;/strong&gt; 的深度解析。&lt;/p&gt;
&lt;p&gt;既然你已经掌握了如何使用 &lt;code&gt;EGLContext&lt;/code&gt; 和独立线程进行渲染，那么理解 SurfaceFlinger 将帮助你打通从 &lt;code&gt;swapBuffers&lt;/code&gt; 到屏幕显示的“最后一公里”。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android Surface 延迟释放策略</title>
    <link href="https://jackwzx.github.io/2025/11/30/Android%20Surface%20%E5%BB%B6%E8%BF%9F%E9%87%8A%E6%94%BE%E7%AD%96%E7%95%A5/"/>
    <id>https://jackwzx.github.io/2025/11/30/Android%20Surface%20%E5%BB%B6%E8%BF%9F%E9%87%8A%E6%94%BE%E7%AD%96%E7%95%A5/</id>
    <published>2025-11-30T06:39:27.000Z</published>
    <updated>2025-11-30T06:40:06.902Z</updated>
    
    
    <summary type="html">&lt;p&gt;你的这个思路非常棒！这就是所谓的 &lt;strong&gt;“延迟销毁 (Lazy/Deferred Destruction)”&lt;/strong&gt; 或者 &lt;strong&gt;“Surface 缓存”&lt;/strong&gt; 策略。&lt;/p&gt;
&lt;p&gt;这在很多高性能渲染引擎（如游戏、地图SDK）中是常见的做法。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在 C++ 中，条件变量和信号量对比</title>
    <link href="https://jackwzx.github.io/2025/11/30/%E5%9C%A8%20C++%20%E4%B8%AD%EF%BC%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AF%B9%E6%AF%94/"/>
    <id>https://jackwzx.github.io/2025/11/30/%E5%9C%A8%20C++%20%E4%B8%AD%EF%BC%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AF%B9%E6%AF%94/</id>
    <published>2025-11-30T06:03:07.000Z</published>
    <updated>2025-11-30T06:04:04.164Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 C++ 中，&lt;strong&gt;信号量（Semaphore）&lt;/strong&gt; 提供了一种基于“计数器”的同步机制。&lt;/p&gt;
&lt;p&gt;需要注意的是，标准的信号量 &lt;code&gt;std::counting_semaphore&lt;/code&gt; 和 &lt;code&gt;std::binary_semaphore&lt;/code&gt; 是在 &lt;strong&gt;C++20&lt;/strong&gt; 才正式引入的。如果你严格限制在 &lt;strong&gt;C++11&lt;/strong&gt; 环境，通常需要自己封装 POSIX 信号量（&lt;code&gt;sem_t&lt;/code&gt;）或 Windows 信号量，或者使用 Boost 库。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>std::condition_variable使用介绍</title>
    <link href="https://jackwzx.github.io/2025/11/30/c++%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jackwzx.github.io/2025/11/30/c++%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-11-30T05:54:27.000Z</published>
    <updated>2025-11-30T05:55:23.342Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++11 引入的 &lt;code&gt;std::condition_variable&lt;/code&gt;（条件变量）是多线程编程中用于&lt;strong&gt;线程间同步&lt;/strong&gt;和&lt;strong&gt;通信&lt;/strong&gt;的重要机制。它允许一个线程挂起（阻塞），直到另一个线程通知它某个特定的条件已经满足。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java中的布尔类型</title>
    <link href="https://jackwzx.github.io/2025/11/12/java%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/"/>
    <id>https://jackwzx.github.io/2025/11/12/java%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-11-11T16:00:00.000Z</published>
    <updated>2025-11-12T09:32:30.407Z</updated>
    
    
    <summary type="html">&lt;p&gt;Java 中的 &lt;code&gt;boolean&lt;/code&gt; 与数值类型（&lt;code&gt;int&lt;/code&gt; 等）是不同的原始类型，语言层面既不允许隐式转换，也不允许显式强制转换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不允许的示例&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int i = true;&lt;/code&gt;、&lt;code&gt;boolean b = 1;&lt;/code&gt;、&lt;code&gt;b = (boolean) 1;&lt;/code&gt; 都会编译报错&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if (1) &amp;#123;&amp;#125;&lt;/code&gt; 在 Java 中非法（不同于 C/C++），只能 &lt;code&gt;if (b)&lt;/code&gt; 或 &lt;code&gt;if (表达式为 boolean)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="https://jackwzx.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>为什么 ASan 需要 `-fsanitize=address` 编译选项，而不仅仅是替换动态库？</title>
    <link href="https://jackwzx.github.io/2025/08/05/%E4%B8%BA%E4%BB%80%E4%B9%88ASan%E9%9C%80%E8%A6%81-fsanitize=address%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E6%9B%BF%E6%8D%A2%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <id>https://jackwzx.github.io/2025/08/05/%E4%B8%BA%E4%BB%80%E4%B9%88ASan%E9%9C%80%E8%A6%81-fsanitize=address%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E6%9B%BF%E6%8D%A2%E5%8A%A8%E6%80%81%E5%BA%93/</id>
    <published>2025-08-05T06:00:00.000Z</published>
    <updated>2025-08-05T12:05:28.649Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;为什么-ASan-需要-fsanitize-address-编译选项，而不仅仅是替换动态库？&quot;&gt;&lt;a href=&quot;#为什么-ASan-需要-fsanitize-address-编译选项，而不仅仅是替换动态库？&quot; class=&quot;headerlink&quot; title=&quot;为什么 ASan 需要 -fsanitize=address 编译选项，而不仅仅是替换动态库？&quot;&gt;&lt;/a&gt;&lt;strong&gt;为什么 ASan 需要 &lt;code&gt;-fsanitize=address&lt;/code&gt; 编译选项，而不仅仅是替换动态库？&lt;/strong&gt;&lt;/h3&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学基础" scheme="https://jackwzx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="https://jackwzx.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="3D图形学" scheme="https://jackwzx.github.io/tags/3D%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学" scheme="https://jackwzx.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://jackwzx.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>3D图形学中的平面方程：从线性代数到Vector4f表示</title>
    <link href="https://jackwzx.github.io/2025/06/30/3D%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%B3%95%E5%90%91%E9%87%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jackwzx.github.io/2025/06/30/3D%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%B3%95%E5%90%91%E9%87%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-06-30T06:00:00.000Z</published>
    <updated>2025-06-30T08:14:54.010Z</updated>
    
    
    <summary type="html">&lt;p&gt;在3D图形学编程中，平面的数学表示是一个基础且重要的概念。无论是进行碰撞检测、视锥体裁剪，还是实现复杂的渲染算法，理解平面方程的数学原理都至关重要。本文将深入探讨3D空间中平面的各种表示方法，特别是点法式方程和Vector4f表示法，以及法向量朝向的重要性。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学基础" scheme="https://jackwzx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="https://jackwzx.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="3D图形学" scheme="https://jackwzx.github.io/tags/3D%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学" scheme="https://jackwzx.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://jackwzx.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>c++迭代器</title>
    <link href="https://jackwzx.github.io/2025/06/30/c++%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/"/>
    <id>https://jackwzx.github.io/2025/06/30/c++%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/</id>
    <published>2025-06-30T06:00:00.000Z</published>
    <updated>2025-11-27T08:13:38.422Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++ 中有 &lt;strong&gt;5 种主要的迭代器类型&lt;/strong&gt;，它们形成一个&lt;strong&gt;层次结构&lt;/strong&gt;，每种都有不同的功能和限制。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++多重继承到Java/TypeScript接口适配问题分析</title>
    <link href="https://jackwzx.github.io/2025/06/30/C++%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%88%B0Java-TypeScript%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>https://jackwzx.github.io/2025/06/30/C++%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%88%B0Java-TypeScript%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</id>
    <published>2025-06-30T02:00:00.000Z</published>
    <updated>2025-06-30T08:15:07.435Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在跨语言开发中，经常需要将C++的多重继承类转换为Java或TypeScript对象。这种转换过程中，接口适配是一个关键问题，特别是当使用&lt;code&gt;void*&lt;/code&gt;存储指针并进行强制类型转换时，可能会遇到一些陷阱。本文将从技术角度深入分析这个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技术" scheme="https://jackwzx.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://jackwzx.github.io/tags/C/"/>
    
    <category term="Java" scheme="https://jackwzx.github.io/tags/Java/"/>
    
    <category term="TypeScript" scheme="https://jackwzx.github.io/tags/TypeScript/"/>
    
    <category term="设计模式" scheme="https://jackwzx.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="接口适配" scheme="https://jackwzx.github.io/tags/%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>C++原子操作函数详解：多线程编程的利器</title>
    <link href="https://jackwzx.github.io/2025/06/25/C++%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jackwzx.github.io/2025/06/25/C++%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-06-25T02:00:00.000Z</published>
    <updated>2025-06-25T04:57:46.377Z</updated>
    
    
    <summary type="html">&lt;p&gt;在多线程编程中，数据竞争和同步问题一直是开发者面临的挑战。C++11引入的原子操作（atomic operations）为解决这些问题提供了强有力的工具。本文将详细介绍几个重要的原子操作函数：&lt;code&gt;atomic_store&lt;/code&gt;、&lt;code&gt;atomic_compare_exchange_strong_explicit&lt;/code&gt;、&lt;code&gt;atomic_load_explicit&lt;/code&gt; 和 &lt;code&gt;atomic_fetch_sub_explicit&lt;/code&gt;，帮助你在多线程编程中正确使用这些函数。&lt;/p&gt;</summary>
    
    
    
    <category term="C++编程" scheme="https://jackwzx.github.io/categories/C-%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://jackwzx.github.io/tags/C/"/>
    
    <category term="多线程" scheme="https://jackwzx.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="原子操作" scheme="https://jackwzx.github.io/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    
    <category term="并发编程" scheme="https://jackwzx.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>GLSL中的smoothstep函数详解</title>
    <link href="https://jackwzx.github.io/2025/06/24/GLSL%E4%B8%AD%E7%9A%84smoothstep%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jackwzx.github.io/2025/06/24/GLSL%E4%B8%AD%E7%9A%84smoothstep%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-06-24T12:00:00.000Z</published>
    <updated>2025-06-24T09:01:55.360Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在GLSL(OpenGL Shading Language)编程中，&lt;code&gt;smoothstep&lt;/code&gt;函数是一个非常有用且常用的内置函数。它能够在两个值之间创建平滑的插值，广泛应用于边缘软化、渐变效果、动画过渡等场景。本文将深入介绍smoothstep函数的用法、数学原理和实际应用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="GLSL" scheme="https://jackwzx.github.io/tags/GLSL/"/>
    
    <category term="Shader" scheme="https://jackwzx.github.io/tags/Shader/"/>
    
    <category term="图形编程" scheme="https://jackwzx.github.io/tags/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>HSV颜色空间和插值优势详解</title>
    <link href="https://jackwzx.github.io/2025/06/24/HSV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E5%92%8C%E6%8F%92%E5%80%BC%E4%BC%98%E5%8A%BF%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jackwzx.github.io/2025/06/24/HSV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E5%92%8C%E6%8F%92%E5%80%BC%E4%BC%98%E5%8A%BF%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-06-24T09:00:00.000Z</published>
    <updated>2025-06-24T09:01:19.878Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;HSV颜色空间和插值优势详解&quot;&gt;&lt;a href=&quot;#HSV颜色空间和插值优势详解&quot; class=&quot;headerlink&quot; title=&quot;HSV颜色空间和插值优势详解&quot;&gt;&lt;/a&gt;HSV颜色空间和插值优势详解&lt;/h2&gt;&lt;p&gt;在计算机图形学和图像处理中，颜色空间的选择对最终效果有着重要影响。本文将深入探讨 HSV 颜色空间的特点，以及为什么在颜色插值时，HSV 比传统的 RGB 能产生更自然、更符合人眼感知的效果。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="颜色空间" scheme="https://jackwzx.github.io/tags/%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/"/>
    
    <category term="插值算法" scheme="https://jackwzx.github.io/tags/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++11 委托构造函数和继承构造函数</title>
    <link href="https://jackwzx.github.io/2025/06/24/C++11%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://jackwzx.github.io/2025/06/24/C++11%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2025-06-24T08:30:00.000Z</published>
    <updated>2025-06-24T09:01:16.877Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;C-11-委托构造函数和继承构造函数&quot;&gt;&lt;a href=&quot;#C-11-委托构造函数和继承构造函数&quot; class=&quot;headerlink&quot; title=&quot;C++11 委托构造函数和继承构造函数&quot;&gt;&lt;/a&gt;C++11 委托构造函数和继承构造函数&lt;/h2&gt;&lt;p&gt;C++11 引入了两个重要的构造函数特性：委托构造函数（Delegating Constructors）和继承构造函数（Inheriting Constructors）。这两个特性都旨在减少代码重复，提高代码的可维护性和可读性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++11" scheme="https://jackwzx.github.io/tags/C-11/"/>
    
    <category term="构造函数" scheme="https://jackwzx.github.io/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++宏定义陷阱与#、##操作符详解 - 播客分析</title>
    <link href="https://jackwzx.github.io/2025/06/15/cpp-macro-analysis-podcast/"/>
    <id>https://jackwzx.github.io/2025/06/15/cpp-macro-analysis-podcast/</id>
    <published>2025-06-15T02:00:00.000Z</published>
    <updated>2025-06-15T03:13:50.380Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;播客分析：C-宏定义的陷阱与-、-操作符详解&quot;&gt;&lt;a href=&quot;#播客分析：C-宏定义的陷阱与-、-操作符详解&quot; class=&quot;headerlink&quot; title=&quot;播客分析：C++宏定义的陷阱与#、##操作符详解&quot;&gt;&lt;/a&gt;播客分析：C++宏定义的陷阱与#、##操作符详解&lt;/h2&gt;&lt;h3 id=&quot;C-宏中的-和-操作符详解&quot;&gt;&lt;a href=&quot;#C-宏中的-和-操作符详解&quot; class=&quot;headerlink&quot; title=&quot;C++宏中的#和##操作符详解&quot;&gt;&lt;/a&gt;C++宏中的#和##操作符详解&lt;/h3&gt;</summary>
    
    
    
    <category term="编程技术" scheme="https://jackwzx.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C++" scheme="https://jackwzx.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/C/"/>
    
    
    <category term="C++" scheme="https://jackwzx.github.io/tags/C/"/>
    
    <category term="宏定义" scheme="https://jackwzx.github.io/tags/%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    
    <category term="预处理器" scheme="https://jackwzx.github.io/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
    <category term="播客" scheme="https://jackwzx.github.io/tags/%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++类型转换陷阱：有符号和无符号整数比较</title>
    <link href="https://jackwzx.github.io/2025/06/08/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%99%B7%E9%98%B1-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%AF%94%E8%BE%83/"/>
    <id>https://jackwzx.github.io/2025/06/08/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%99%B7%E9%98%B1-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%AF%94%E8%BE%83/</id>
    <published>2025-06-08T02:00:00.000Z</published>
    <updated>2025-06-12T08:08:28.440Z</updated>
    
    
    <summary type="html">&lt;p&gt;在C++编程中，有一些看似简单的操作可能会带来意想不到的结果。今天我们要讨论一个常见但容易被忽视的问题：有符号整数（signed）和无符号整数（unsigned）的比较操作。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技术" scheme="https://jackwzx.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://jackwzx.github.io/tags/C/"/>
    
    <category term="编程陷阱" scheme="https://jackwzx.github.io/tags/%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1/"/>
    
    <category term="类型转换" scheme="https://jackwzx.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
</feed>
