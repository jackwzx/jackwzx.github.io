<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xujing的博客</title>
  <icon>https://jackwzx.github.io/icon.png</icon>
  
  <link href="https://jackwzx.github.io/atom.xml" rel="self"/>
  
  <link href="https://jackwzx.github.io/"/>
  <updated>2025-11-30T07:09:41.701Z</updated>
  <id>https://jackwzx.github.io/</id>
  
  <author>
    <name>Xujing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解Android中的SurfaceFlinger</title>
    <link href="https://jackwzx.github.io/2025/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84SurfaceFlinger/"/>
    <id>https://jackwzx.github.io/2025/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84SurfaceFlinger/</id>
    <published>2025-11-30T07:09:15.000Z</published>
    <updated>2025-11-30T07:09:41.701Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一篇关于 Android 图形系统核心——&lt;strong&gt;SurfaceFlinger&lt;/strong&gt; 的深度解析。&lt;/p&gt;
&lt;p&gt;既然你已经掌握了如何使用 &lt;code&gt;EGLContext&lt;/code&gt; 和独立线程进行渲染，那么理解 SurfaceFlinger 将帮助你打通从 &lt;code&gt;swapBuffers&lt;/code&gt; 到屏幕显示的“最后一公里”。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android Surface 延迟释放策略</title>
    <link href="https://jackwzx.github.io/2025/11/30/Android%20Surface%20%E5%BB%B6%E8%BF%9F%E9%87%8A%E6%94%BE%E7%AD%96%E7%95%A5/"/>
    <id>https://jackwzx.github.io/2025/11/30/Android%20Surface%20%E5%BB%B6%E8%BF%9F%E9%87%8A%E6%94%BE%E7%AD%96%E7%95%A5/</id>
    <published>2025-11-30T06:39:27.000Z</published>
    <updated>2025-11-30T06:40:06.902Z</updated>
    
    
    <summary type="html">&lt;p&gt;你的这个思路非常棒！这就是所谓的 &lt;strong&gt;“延迟销毁 (Lazy/Deferred Destruction)”&lt;/strong&gt; 或者 &lt;strong&gt;“Surface 缓存”&lt;/strong&gt; 策略。&lt;/p&gt;
&lt;p&gt;这在很多高性能渲染引擎（如游戏、地图SDK）中是常见的做法。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在 C++ 中，条件变量和信号量对比</title>
    <link href="https://jackwzx.github.io/2025/11/30/%E5%9C%A8%20C++%20%E4%B8%AD%EF%BC%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AF%B9%E6%AF%94/"/>
    <id>https://jackwzx.github.io/2025/11/30/%E5%9C%A8%20C++%20%E4%B8%AD%EF%BC%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AF%B9%E6%AF%94/</id>
    <published>2025-11-30T06:03:07.000Z</published>
    <updated>2025-11-30T06:04:04.164Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 C++ 中，&lt;strong&gt;信号量（Semaphore）&lt;/strong&gt; 提供了一种基于“计数器”的同步机制。&lt;/p&gt;
&lt;p&gt;需要注意的是，标准的信号量 &lt;code&gt;std::counting_semaphore&lt;/code&gt; 和 &lt;code&gt;std::binary_semaphore&lt;/code&gt; 是在 &lt;strong&gt;C++20&lt;/strong&gt; 才正式引入的。如果你严格限制在 &lt;strong&gt;C++11&lt;/strong&gt; 环境，通常需要自己封装 POSIX 信号量（&lt;code&gt;sem_t&lt;/code&gt;）或 Windows 信号量，或者使用 Boost 库。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>std::condition_variable使用介绍</title>
    <link href="https://jackwzx.github.io/2025/11/30/c++%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jackwzx.github.io/2025/11/30/c++%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-11-30T05:54:27.000Z</published>
    <updated>2025-11-30T05:55:23.342Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++11 引入的 &lt;code&gt;std::condition_variable&lt;/code&gt;（条件变量）是多线程编程中用于&lt;strong&gt;线程间同步&lt;/strong&gt;和&lt;strong&gt;通信&lt;/strong&gt;的重要机制。它允许一个线程挂起（阻塞），直到另一个线程通知它某个特定的条件已经满足。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java中的布尔类型</title>
    <link href="https://jackwzx.github.io/2025/11/12/java%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/"/>
    <id>https://jackwzx.github.io/2025/11/12/java%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-11-11T16:00:00.000Z</published>
    <updated>2025-11-12T09:32:30.407Z</updated>
    
    
    <summary type="html">&lt;p&gt;Java 中的 &lt;code&gt;boolean&lt;/code&gt; 与数值类型（&lt;code&gt;int&lt;/code&gt; 等）是不同的原始类型，语言层面既不允许隐式转换，也不允许显式强制转换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不允许的示例&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int i = true;&lt;/code&gt;、&lt;code&gt;boolean b = 1;&lt;/code&gt;、&lt;code&gt;b = (boolean) 1;&lt;/code&gt; 都会编译报错&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if (1) &amp;#123;&amp;#125;&lt;/code&gt; 在 Java 中非法（不同于 C/C++），只能 &lt;code&gt;if (b)&lt;/code&gt; 或 &lt;code&gt;if (表达式为 boolean)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="https://jackwzx.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>为什么 ASan 需要 `-fsanitize=address` 编译选项，而不仅仅是替换动态库？</title>
    <link href="https://jackwzx.github.io/2025/08/05/%E4%B8%BA%E4%BB%80%E4%B9%88ASan%E9%9C%80%E8%A6%81-fsanitize=address%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E6%9B%BF%E6%8D%A2%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <id>https://jackwzx.github.io/2025/08/05/%E4%B8%BA%E4%BB%80%E4%B9%88ASan%E9%9C%80%E8%A6%81-fsanitize=address%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E6%9B%BF%E6%8D%A2%E5%8A%A8%E6%80%81%E5%BA%93/</id>
    <published>2025-08-05T06:00:00.000Z</published>
    <updated>2025-08-05T12:05:28.649Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;为什么-ASan-需要-fsanitize-address-编译选项，而不仅仅是替换动态库？&quot;&gt;&lt;a href=&quot;#为什么-ASan-需要-fsanitize-address-编译选项，而不仅仅是替换动态库？&quot; class=&quot;headerlink&quot; title=&quot;为什么 ASan 需要 -fsanitize=address 编译选项，而不仅仅是替换动态库？&quot;&gt;&lt;/a&gt;&lt;strong&gt;为什么 ASan 需要 &lt;code&gt;-fsanitize=address&lt;/code&gt; 编译选项，而不仅仅是替换动态库？&lt;/strong&gt;&lt;/h3&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学基础" scheme="https://jackwzx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="https://jackwzx.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="3D图形学" scheme="https://jackwzx.github.io/tags/3D%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学" scheme="https://jackwzx.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://jackwzx.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>3D图形学中的平面方程：从线性代数到Vector4f表示</title>
    <link href="https://jackwzx.github.io/2025/06/30/3D%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%B3%95%E5%90%91%E9%87%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jackwzx.github.io/2025/06/30/3D%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%B3%95%E5%90%91%E9%87%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-06-30T06:00:00.000Z</published>
    <updated>2025-06-30T08:14:54.010Z</updated>
    
    
    <summary type="html">&lt;p&gt;在3D图形学编程中，平面的数学表示是一个基础且重要的概念。无论是进行碰撞检测、视锥体裁剪，还是实现复杂的渲染算法，理解平面方程的数学原理都至关重要。本文将深入探讨3D空间中平面的各种表示方法，特别是点法式方程和Vector4f表示法，以及法向量朝向的重要性。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学基础" scheme="https://jackwzx.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="https://jackwzx.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="3D图形学" scheme="https://jackwzx.github.io/tags/3D%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学" scheme="https://jackwzx.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://jackwzx.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>c++迭代器</title>
    <link href="https://jackwzx.github.io/2025/06/30/c++%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/"/>
    <id>https://jackwzx.github.io/2025/06/30/c++%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/</id>
    <published>2025-06-30T06:00:00.000Z</published>
    <updated>2025-11-27T08:13:38.422Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++ 中有 &lt;strong&gt;5 种主要的迭代器类型&lt;/strong&gt;，它们形成一个&lt;strong&gt;层次结构&lt;/strong&gt;，每种都有不同的功能和限制。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++多重继承到Java/TypeScript接口适配问题分析</title>
    <link href="https://jackwzx.github.io/2025/06/30/C++%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%88%B0Java-TypeScript%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>https://jackwzx.github.io/2025/06/30/C++%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%88%B0Java-TypeScript%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</id>
    <published>2025-06-30T02:00:00.000Z</published>
    <updated>2025-06-30T08:15:07.435Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在跨语言开发中，经常需要将C++的多重继承类转换为Java或TypeScript对象。这种转换过程中，接口适配是一个关键问题，特别是当使用&lt;code&gt;void*&lt;/code&gt;存储指针并进行强制类型转换时，可能会遇到一些陷阱。本文将从技术角度深入分析这个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技术" scheme="https://jackwzx.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://jackwzx.github.io/tags/C/"/>
    
    <category term="Java" scheme="https://jackwzx.github.io/tags/Java/"/>
    
    <category term="TypeScript" scheme="https://jackwzx.github.io/tags/TypeScript/"/>
    
    <category term="设计模式" scheme="https://jackwzx.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="接口适配" scheme="https://jackwzx.github.io/tags/%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>C++原子操作函数详解：多线程编程的利器</title>
    <link href="https://jackwzx.github.io/2025/06/25/C++%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jackwzx.github.io/2025/06/25/C++%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-06-25T02:00:00.000Z</published>
    <updated>2025-06-25T04:57:46.377Z</updated>
    
    
    <summary type="html">&lt;p&gt;在多线程编程中，数据竞争和同步问题一直是开发者面临的挑战。C++11引入的原子操作（atomic operations）为解决这些问题提供了强有力的工具。本文将详细介绍几个重要的原子操作函数：&lt;code&gt;atomic_store&lt;/code&gt;、&lt;code&gt;atomic_compare_exchange_strong_explicit&lt;/code&gt;、&lt;code&gt;atomic_load_explicit&lt;/code&gt; 和 &lt;code&gt;atomic_fetch_sub_explicit&lt;/code&gt;，帮助你在多线程编程中正确使用这些函数。&lt;/p&gt;</summary>
    
    
    
    <category term="C++编程" scheme="https://jackwzx.github.io/categories/C-%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://jackwzx.github.io/tags/C/"/>
    
    <category term="多线程" scheme="https://jackwzx.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="原子操作" scheme="https://jackwzx.github.io/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    
    <category term="并发编程" scheme="https://jackwzx.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>GLSL中的smoothstep函数详解</title>
    <link href="https://jackwzx.github.io/2025/06/24/GLSL%E4%B8%AD%E7%9A%84smoothstep%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jackwzx.github.io/2025/06/24/GLSL%E4%B8%AD%E7%9A%84smoothstep%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-06-24T12:00:00.000Z</published>
    <updated>2025-06-24T09:01:55.360Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在GLSL(OpenGL Shading Language)编程中，&lt;code&gt;smoothstep&lt;/code&gt;函数是一个非常有用且常用的内置函数。它能够在两个值之间创建平滑的插值，广泛应用于边缘软化、渐变效果、动画过渡等场景。本文将深入介绍smoothstep函数的用法、数学原理和实际应用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="GLSL" scheme="https://jackwzx.github.io/tags/GLSL/"/>
    
    <category term="Shader" scheme="https://jackwzx.github.io/tags/Shader/"/>
    
    <category term="图形编程" scheme="https://jackwzx.github.io/tags/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>HSV颜色空间和插值优势详解</title>
    <link href="https://jackwzx.github.io/2025/06/24/HSV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E5%92%8C%E6%8F%92%E5%80%BC%E4%BC%98%E5%8A%BF%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jackwzx.github.io/2025/06/24/HSV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E5%92%8C%E6%8F%92%E5%80%BC%E4%BC%98%E5%8A%BF%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-06-24T09:00:00.000Z</published>
    <updated>2025-06-24T09:01:19.878Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;HSV颜色空间和插值优势详解&quot;&gt;&lt;a href=&quot;#HSV颜色空间和插值优势详解&quot; class=&quot;headerlink&quot; title=&quot;HSV颜色空间和插值优势详解&quot;&gt;&lt;/a&gt;HSV颜色空间和插值优势详解&lt;/h2&gt;&lt;p&gt;在计算机图形学和图像处理中，颜色空间的选择对最终效果有着重要影响。本文将深入探讨 HSV 颜色空间的特点，以及为什么在颜色插值时，HSV 比传统的 RGB 能产生更自然、更符合人眼感知的效果。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机图形学" scheme="https://jackwzx.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="颜色空间" scheme="https://jackwzx.github.io/tags/%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/"/>
    
    <category term="插值算法" scheme="https://jackwzx.github.io/tags/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++11 委托构造函数和继承构造函数</title>
    <link href="https://jackwzx.github.io/2025/06/24/C++11%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://jackwzx.github.io/2025/06/24/C++11%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2025-06-24T08:30:00.000Z</published>
    <updated>2025-06-24T09:01:16.877Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;C-11-委托构造函数和继承构造函数&quot;&gt;&lt;a href=&quot;#C-11-委托构造函数和继承构造函数&quot; class=&quot;headerlink&quot; title=&quot;C++11 委托构造函数和继承构造函数&quot;&gt;&lt;/a&gt;C++11 委托构造函数和继承构造函数&lt;/h2&gt;&lt;p&gt;C++11 引入了两个重要的构造函数特性：委托构造函数（Delegating Constructors）和继承构造函数（Inheriting Constructors）。这两个特性都旨在减少代码重复，提高代码的可维护性和可读性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++11" scheme="https://jackwzx.github.io/tags/C-11/"/>
    
    <category term="构造函数" scheme="https://jackwzx.github.io/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++宏定义陷阱与#、##操作符详解 - 播客分析</title>
    <link href="https://jackwzx.github.io/2025/06/15/cpp-macro-analysis-podcast/"/>
    <id>https://jackwzx.github.io/2025/06/15/cpp-macro-analysis-podcast/</id>
    <published>2025-06-15T02:00:00.000Z</published>
    <updated>2025-06-15T03:13:50.380Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;播客分析：C-宏定义的陷阱与-、-操作符详解&quot;&gt;&lt;a href=&quot;#播客分析：C-宏定义的陷阱与-、-操作符详解&quot; class=&quot;headerlink&quot; title=&quot;播客分析：C++宏定义的陷阱与#、##操作符详解&quot;&gt;&lt;/a&gt;播客分析：C++宏定义的陷阱与#、##操作符详解&lt;/h2&gt;&lt;h3 id=&quot;C-宏中的-和-操作符详解&quot;&gt;&lt;a href=&quot;#C-宏中的-和-操作符详解&quot; class=&quot;headerlink&quot; title=&quot;C++宏中的#和##操作符详解&quot;&gt;&lt;/a&gt;C++宏中的#和##操作符详解&lt;/h3&gt;</summary>
    
    
    
    <category term="编程技术" scheme="https://jackwzx.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C++" scheme="https://jackwzx.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/C/"/>
    
    
    <category term="C++" scheme="https://jackwzx.github.io/tags/C/"/>
    
    <category term="宏定义" scheme="https://jackwzx.github.io/tags/%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    
    <category term="预处理器" scheme="https://jackwzx.github.io/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
    <category term="播客" scheme="https://jackwzx.github.io/tags/%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++类型转换陷阱：有符号和无符号整数比较</title>
    <link href="https://jackwzx.github.io/2025/06/08/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%99%B7%E9%98%B1-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%AF%94%E8%BE%83/"/>
    <id>https://jackwzx.github.io/2025/06/08/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%99%B7%E9%98%B1-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%AF%94%E8%BE%83/</id>
    <published>2025-06-08T02:00:00.000Z</published>
    <updated>2025-06-12T08:08:28.440Z</updated>
    
    
    <summary type="html">&lt;p&gt;在C++编程中，有一些看似简单的操作可能会带来意想不到的结果。今天我们要讨论一个常见但容易被忽视的问题：有符号整数（signed）和无符号整数（unsigned）的比较操作。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技术" scheme="https://jackwzx.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://jackwzx.github.io/tags/C/"/>
    
    <category term="编程陷阱" scheme="https://jackwzx.github.io/tags/%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1/"/>
    
    <category term="类型转换" scheme="https://jackwzx.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>培养孩子阅读习惯的优质书单推荐</title>
    <link href="https://jackwzx.github.io/2025/06/07/%E5%9F%B9%E5%85%BB%E5%AD%A9%E5%AD%90%E9%98%85%E8%AF%BB%E4%B9%A0%E6%83%AF%E7%9A%84%E4%BC%98%E8%B4%A8%E4%B9%A6%E5%8D%95%E6%8E%A8%E8%8D%90/"/>
    <id>https://jackwzx.github.io/2025/06/07/%E5%9F%B9%E5%85%BB%E5%AD%A9%E5%AD%90%E9%98%85%E8%AF%BB%E4%B9%A0%E6%83%AF%E7%9A%84%E4%BC%98%E8%B4%A8%E4%B9%A6%E5%8D%95%E6%8E%A8%E8%8D%90/</id>
    <published>2025-06-07T10:30:00.000Z</published>
    <updated>2025-06-07T09:51:05.668Z</updated>
    
    
    <summary type="html">&lt;p&gt;选择合适的书籍是培养孩子阅读兴趣的关键第一步。本文根据不同年龄段孩子的认知特点和兴趣偏好，精心整理了一份优质书单，帮助家长为孩子挑选最适合的读物。&lt;/p&gt;</summary>
    
    
    
    <category term="家庭教育" scheme="https://jackwzx.github.io/categories/%E5%AE%B6%E5%BA%AD%E6%95%99%E8%82%B2/"/>
    
    
    <category term="亲子" scheme="https://jackwzx.github.io/tags/%E4%BA%B2%E5%AD%90/"/>
    
    <category term="阅读" scheme="https://jackwzx.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
    <category term="书单" scheme="https://jackwzx.github.io/tags/%E4%B9%A6%E5%8D%95/"/>
    
    <category term="儿童教育" scheme="https://jackwzx.github.io/tags/%E5%84%BF%E7%AB%A5%E6%95%99%E8%82%B2/"/>
    
  </entry>
  
  <entry>
    <title>如何让孩子戒掉手机爱上阅读：实用策略指南</title>
    <link href="https://jackwzx.github.io/2025/06/07/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AD%A9%E5%AD%90%E6%88%92%E6%8E%89%E6%89%8B%E6%9C%BA%E7%88%B1%E4%B8%8A%E9%98%85%E8%AF%BB-%E5%AE%9E%E7%94%A8%E7%AD%96%E7%95%A5%E6%8C%87%E5%8D%97/"/>
    <id>https://jackwzx.github.io/2025/06/07/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AD%A9%E5%AD%90%E6%88%92%E6%8E%89%E6%89%8B%E6%9C%BA%E7%88%B1%E4%B8%8A%E9%98%85%E8%AF%BB-%E5%AE%9E%E7%94%A8%E7%AD%96%E7%95%A5%E6%8C%87%E5%8D%97/</id>
    <published>2025-06-07T10:00:00.000Z</published>
    <updated>2025-06-07T09:40:37.530Z</updated>
    
    
    <summary type="html">&lt;p&gt;在数字化时代，如何引导孩子从手机屏幕转向书本页面，是每个家长都关心的话题。本文将分享一些经过实践验证的策略，帮助您的孩子逐步减少对手机的依赖，培养良好的阅读习惯。&lt;/p&gt;</summary>
    
    
    
    <category term="家庭教育" scheme="https://jackwzx.github.io/categories/%E5%AE%B6%E5%BA%AD%E6%95%99%E8%82%B2/"/>
    
    
    <category term="教育" scheme="https://jackwzx.github.io/tags/%E6%95%99%E8%82%B2/"/>
    
    <category term="亲子" scheme="https://jackwzx.github.io/tags/%E4%BA%B2%E5%AD%90/"/>
    
    <category term="阅读" scheme="https://jackwzx.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
    <category term="手机成瘾" scheme="https://jackwzx.github.io/tags/%E6%89%8B%E6%9C%BA%E6%88%90%E7%98%BE/"/>
    
  </entry>
  
  <entry>
    <title>type script</title>
    <link href="https://jackwzx.github.io/2025/03/15/type-script/"/>
    <id>https://jackwzx.github.io/2025/03/15/type-script/</id>
    <published>2025-03-15T15:23:39.000Z</published>
    <updated>2025-03-15T15:26:08.876Z</updated>
    
    
    <summary type="html">&lt;p&gt;TypeScript 是一种由 &lt;strong&gt;Microsoft&lt;/strong&gt; 开发的开源编程语言，它是 &lt;strong&gt;JavaScript 的超集&lt;/strong&gt;，为 JavaScript 添加了可选的静态类型系统和现代语言特性。TypeScript 的目标是提高 JavaScript 代码的可维护性、可读性和开发效率，同时保持与 JavaScript 的完全兼容。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>what is mpx</title>
    <link href="https://jackwzx.github.io/2025/03/15/what-is-mpx/"/>
    <id>https://jackwzx.github.io/2025/03/15/what-is-mpx/</id>
    <published>2025-03-15T15:04:48.000Z</published>
    <updated>2025-03-15T15:09:28.145Z</updated>
    
    
    <summary type="html">&lt;p&gt;MPX 是一个 &lt;strong&gt;面向小程序开发的前端框架&lt;/strong&gt;，由滴滴出行团队开源，专为提升小程序开发效率和性能而设计。它基于 Vue.js 的语法和特性，同时针对小程序的特点进行了深度优化和扩展。以下是 MPX 的核心特性和详细介绍：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>高性能std::string实现分析</title>
    <link href="https://jackwzx.github.io/2025/01/27/high-performance-string-implementation/"/>
    <id>https://jackwzx.github.io/2025/01/27/high-performance-string-implementation/</id>
    <published>2025-01-27T02:00:00.000Z</published>
    <updated>2025-06-15T03:42:06.156Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;高性能std-string实现分析&quot;&gt;&lt;a href=&quot;#高性能std-string实现分析&quot; class=&quot;headerlink&quot; title=&quot;高性能std::string实现分析&quot;&gt;&lt;/a&gt;高性能std::string实现分析&lt;/h1&gt;&lt;h2 id=&quot;1-字符串存储策略&quot;&gt;&lt;a href=&quot;#1-字符串存储策略&quot; class=&quot;headerlink&quot; title=&quot;1. 字符串存储策略&quot;&gt;&lt;/a&gt;1. 字符串存储策略&lt;/h2&gt;</summary>
    
    
    
    <category term="编程技术" scheme="https://jackwzx.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://jackwzx.github.io/tags/C/"/>
    
    <category term="字符串" scheme="https://jackwzx.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="性能优化" scheme="https://jackwzx.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
