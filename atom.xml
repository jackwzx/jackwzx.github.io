<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xujing的博客</title>
  <icon>https://jackwzx.github.io/icon.png</icon>
  
  <link href="https://jackwzx.github.io/atom.xml" rel="self"/>
  
  <link href="https://jackwzx.github.io/"/>
  <updated>2026-01-25T10:46:04.382Z</updated>
  <id>https://jackwzx.github.io/</id>
  
  <author>
    <name>Xujing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android NDK 编译参数最终构建顺序  **。</title>
    <link href="https://jackwzx.github.io/2026/01/21/Android%20NDK%20%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0%E6%9C%80%E7%BB%88%E6%9E%84%E5%BB%BA%E9%A1%BA%E5%BA%8F/"/>
    <id>https://jackwzx.github.io/2026/01/21/Android%20NDK%20%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0%E6%9C%80%E7%BB%88%E6%9E%84%E5%BB%BA%E9%A1%BA%E5%BA%8F/</id>
    <published>2026-01-21T12:41:16.000Z</published>
    <updated>2026-01-25T10:46:04.382Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 Android NDK 的构建体系中，链接参数的组合顺序非常重要，因为对于冲突的参数（如 &lt;code&gt;-O2&lt;/code&gt; 和 &lt;code&gt;-O3&lt;/code&gt;），&lt;strong&gt;排在后面的参数通常会覆盖前面的参数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这些参数的流向和最终组合顺序如下：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>静态库设置强制导出后，动态库一定包含此符号吗</title>
    <link href="https://jackwzx.github.io/2026/01/21/%E9%9D%99%E6%80%81%E5%BA%93%E8%AE%BE%E7%BD%AE%E5%BC%BA%E5%88%B6%E5%AF%BC%E5%87%BA%E5%90%8E%EF%BC%8C%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%80%E5%AE%9A%E5%8C%85%E5%90%AB%E6%AD%A4%E7%AC%A6%E5%8F%B7%E5%90%97/"/>
    <id>https://jackwzx.github.io/2026/01/21/%E9%9D%99%E6%80%81%E5%BA%93%E8%AE%BE%E7%BD%AE%E5%BC%BA%E5%88%B6%E5%AF%BC%E5%87%BA%E5%90%8E%EF%BC%8C%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%80%E5%AE%9A%E5%8C%85%E5%90%AB%E6%AD%A4%E7%AC%A6%E5%8F%B7%E5%90%97/</id>
    <published>2026-01-21T06:10:34.000Z</published>
    <updated>2026-01-25T10:46:56.247Z</updated>
    
    
    <summary type="html">&lt;p&gt;在开发中，这是一个经典且容易踩坑的链接行为。简单结论是：&lt;strong&gt;默认情况下，打出来的 &lt;code&gt;.so&lt;/code&gt; 不会包含该函数。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-为什么“强制导出”无效？&quot;&gt;&lt;a href=&quot;#1-为什么“强制导出”无效？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么“强制导出”无效？&quot;&gt;&lt;/a&gt;1. 为什么“强制导出”无效？&lt;/h3&gt;&lt;p&gt;静态库（&lt;code&gt;.a&lt;/code&gt; 或 &lt;code&gt;.lib&lt;/code&gt;）本质上是一堆对象文件（&lt;code&gt;.o&lt;/code&gt; 或 &lt;code&gt;.obj&lt;/code&gt;）的“压缩包”。链接器在构建动态库（&lt;code&gt;.so&lt;/code&gt;）时，遵循以下逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  &lt;strong&gt;按需提取：&lt;/strong&gt; 链接器只有在发现动态库的代码中存在一个“未定义引用（Undefined Reference）”时，才会去静态库里寻找对应的符号，并将包含该符号的整个 &lt;code&gt;.o&lt;/code&gt; 文件拉进结果中。&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;无视属性：&lt;/strong&gt; 虽然你在代码里写了 &lt;code&gt;__attribute__((visibility(&amp;quot;default&amp;quot;)))&lt;/code&gt;（Linux）或 &lt;code&gt;__declspec(dllexport)&lt;/code&gt;（Windows），但这只是该符号在 &lt;code&gt;.o&lt;/code&gt; 文件里的一个“标记”。&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;结果：&lt;/strong&gt; 如果你的动态库没有代码调用这个函数，链接器根本就不会去加载那个 &lt;code&gt;.o&lt;/code&gt; 文件。既然文件没被加载，里面的“导出标记”自然也就不会生效，最终 &lt;code&gt;.so&lt;/code&gt; 的导出表里就不会有它。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>子Shell以及返回值运行机制</title>
    <link href="https://jackwzx.github.io/2026/01/20/%E5%AD%90Shell%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://jackwzx.github.io/2026/01/20/%E5%AD%90Shell%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2026-01-20T11:11:26.000Z</published>
    <updated>2026-01-25T10:47:25.607Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个非常经典且重要的 Shell 执行机制问题。直接给结论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;会新建子进程（子 Shell）吗？&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;会。&lt;/strong&gt; 使用 &lt;code&gt;bash $PushAssets&lt;/code&gt; 会启动一个新的 Bash 进程来运行该脚本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;set -e&lt;/code&gt; 能触发退出吗？&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;能。&lt;/strong&gt; 如果子脚本返回非 0 值，父脚本在 &lt;code&gt;set -e&lt;/code&gt; 模式下会立即终止。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>c++ 析构函数的三种变体</title>
    <link href="https://jackwzx.github.io/2026/01/20/c++%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8F%98%E4%BD%93/"/>
    <id>https://jackwzx.github.io/2026/01/20/c++%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8F%98%E4%BD%93/</id>
    <published>2026-01-20T06:56:25.000Z</published>
    <updated>2026-01-25T10:48:02.066Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 C++ 的 &lt;strong&gt;Itanium ABI&lt;/strong&gt;（应用二进制接口，被 GCC 和 Clang 等主流编译器广泛采用）中，为了处理复杂的继承（尤其是虚继承）和不同的对象生命周期管理需求，编译器会为同一个类生成三种主要的析构函数变体：&lt;strong&gt;D0&lt;/strong&gt;、&lt;strong&gt;D1&lt;/strong&gt; 和 &lt;strong&gt;D2&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android Class loader介绍</title>
    <link href="https://jackwzx.github.io/2026/01/15/Android%20Class%20loader%E4%BB%8B%E7%BB%8D/"/>
    <id>https://jackwzx.github.io/2026/01/15/Android%20Class%20loader%E4%BB%8B%E7%BB%8D/</id>
    <published>2026-01-15T09:25:26.000Z</published>
    <updated>2026-01-25T10:48:46.313Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 Android 中，这是一个非常经典且常见的 JNI 问题。核心原因在于 &lt;strong&gt;类加载器（ClassLoader）的差异&lt;/strong&gt; 以及 &lt;strong&gt;JNI 如何查找类&lt;/strong&gt; 的机制。&lt;/p&gt;
&lt;p&gt;以下是详细的机制分析：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android ShareContext Demo</title>
    <link href="https://jackwzx.github.io/2026/01/15/Android%20ShareContext%20Demo/"/>
    <id>https://jackwzx.github.io/2026/01/15/Android%20ShareContext%20Demo/</id>
    <published>2026-01-15T04:09:39.000Z</published>
    <updated>2026-01-25T10:49:19.492Z</updated>
    
    
    <summary type="html">&lt;p&gt;了解了，你的需求是：&lt;strong&gt;只有一个 &lt;code&gt;GLSurfaceView&lt;/code&gt;（拥有一个渲染线程），但你需要开启另一个后台线程（子线程）并在该线程中操作 OpenGL 资源（如异步加载纹理），这两个线程需要共享同一个 Context。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>git 浅克隆之后如何切换分支</title>
    <link href="https://jackwzx.github.io/2025/12/26/git%20%E6%B5%85%E5%85%8B%E9%9A%86%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF/"/>
    <id>https://jackwzx.github.io/2025/12/26/git%20%E6%B5%85%E5%85%8B%E9%9A%86%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF/</id>
    <published>2025-12-26T12:05:03.000Z</published>
    <updated>2025-12-28T06:34:42.526Z</updated>
    
    
    <summary type="html">&lt;p&gt;当你使用 &lt;code&gt;git clone --depth 1&lt;/code&gt; 进行浅克隆时，Git 默认只会追踪远程的&lt;strong&gt;默认分支&lt;/strong&gt;（通常是 &lt;code&gt;main&lt;/code&gt; 或 &lt;code&gt;master&lt;/code&gt;），并且不会获取其他分支的信息。&lt;/p&gt;
&lt;p&gt;要切换到其他远程分支，可以根据你的需求选择以下几种方法：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ARM64函数调用栈寄存器分配</title>
    <link href="https://jackwzx.github.io/2025/12/26/ARM64%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D/"/>
    <id>https://jackwzx.github.io/2025/12/26/ARM64%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D/</id>
    <published>2025-12-26T01:01:29.000Z</published>
    <updated>2025-12-28T06:35:22.109Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 ARM64（AArch64）架构下，理解函数调用栈、寄存器分配以及参数传递是底层开发和调试的核心。ARM64 的函数调用遵循 &lt;strong&gt;AAPCS64&lt;/strong&gt;（Procedure Call Standard for the ARM 64-bit Architecture）。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>c++函数返回值存在了哪里</title>
    <link href="https://jackwzx.github.io/2025/12/23/c++%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%AD%98%E5%9C%A8%E4%BA%86%E5%93%AA%E9%87%8C/"/>
    <id>https://jackwzx.github.io/2025/12/23/c++%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%AD%98%E5%9C%A8%E4%BA%86%E5%93%AA%E9%87%8C/</id>
    <published>2025-12-23T13:04:42.000Z</published>
    <updated>2025-12-28T06:35:52.397Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个非常深入且经典的问题。你的直觉很准：&lt;strong&gt;如果变量在函数内部的栈帧里，函数返回后栈帧销毁，引用必然指向一片非法内存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但这里的关键在于：&lt;strong&gt;返回的对象并不在“已经销毁”的那个函数栈帧里。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>std::vector&lt;T&gt; clear详解</title>
    <link href="https://jackwzx.github.io/2025/12/21/std%20vector%20clear%20%E5%88%86%E6%9E%90/"/>
    <id>https://jackwzx.github.io/2025/12/21/std%20vector%20clear%20%E5%88%86%E6%9E%90/</id>
    <published>2025-12-21T10:09:26.000Z</published>
    <updated>2025-12-21T10:09:52.981Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个非常核心的问题。在 C++ 标准库中，&lt;code&gt;std::vector::clear()&lt;/code&gt; 的行为是非常明确的。为了让你彻底理解，我们从&lt;strong&gt;逻辑行为&lt;/strong&gt;、&lt;strong&gt;源码实现（以 GCC 的 libstdc++ 为例）&lt;/strong&gt;以及&lt;strong&gt;内存状态&lt;/strong&gt;三个维度来剖析。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>AArch64寄存器</title>
    <link href="https://jackwzx.github.io/2025/12/21/AArch64%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>https://jackwzx.github.io/2025/12/21/AArch64%E5%AF%84%E5%AD%98%E5%99%A8/</id>
    <published>2025-12-21T07:35:43.000Z</published>
    <updated>2025-12-28T06:36:32.381Z</updated>
    
    
    <summary type="html">&lt;p&gt;ARM64（AArch64）的函数调用规则主要遵循 &lt;strong&gt;AAPCS64&lt;/strong&gt; (Procedure Call Standard for the ARM 64-bit Architecture)。了解这些规则对于编写汇编代码、调试程序或进行性能优化至关重要。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Jni NewGlobalRef</title>
    <link href="https://jackwzx.github.io/2025/12/17/JNI%E5%B1%80%E9%83%A8%E5%BC%95%E7%94%A8%E5%92%8C%E5%85%A8%E5%B1%80%E5%BC%95%E7%94%A8/"/>
    <id>https://jackwzx.github.io/2025/12/17/JNI%E5%B1%80%E9%83%A8%E5%BC%95%E7%94%A8%E5%92%8C%E5%85%A8%E5%B1%80%E5%BC%95%E7%94%A8/</id>
    <published>2025-12-17T03:36:01.000Z</published>
    <updated>2025-12-28T06:39:44.140Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个非常核心的 JNI 知识点。要理解为什么你的代码会崩，以及 &lt;code&gt;NewGlobalRef&lt;/code&gt; 到底做了什么，我们需要深入到底层机制。&lt;/p&gt;
&lt;p&gt;我们把 JNI 的引用想象成 &lt;strong&gt;“指针”&lt;/strong&gt; 或 &lt;strong&gt;“句柄”&lt;/strong&gt;，它们指向 Java 堆内存中的真实对象。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>这是一个非常经典的 JNI 性能优化问题。</title>
    <link href="https://jackwzx.github.io/2025/12/16/JNI%E8%B0%83%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>https://jackwzx.github.io/2025/12/16/JNI%E8%B0%83%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</id>
    <published>2025-12-16T05:27:31.000Z</published>
    <updated>2025-12-16T05:27:31.782Z</updated>
    
    
    <summary type="html">&lt;p&gt;这是一个非常经典的 JNI 性能优化问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接结论：&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;调用一次自定义 Java 函数（Scenario A）的性能绝对优于调用多次 Java API（Scenario B），即使 Scenario B 已经缓存了 &lt;code&gt;jclass&lt;/code&gt; 和 &lt;code&gt;jmethodID&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Unreal Engine (UE) 之所以强大，很大程度上归功于其构建在 C++ 之上的一套**自定义对象系统**。</title>
    <link href="https://jackwzx.github.io/2025/12/16/UnrealEngine%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/"/>
    <id>https://jackwzx.github.io/2025/12/16/UnrealEngine%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/</id>
    <published>2025-12-16T05:10:33.000Z</published>
    <updated>2025-12-16T05:10:33.604Z</updated>
    
    
    <summary type="html">&lt;p&gt;Unreal Engine (UE) 之所以强大，很大程度上归功于其构建在 C++ 之上的一套&lt;strong&gt;自定义对象系统&lt;/strong&gt;。C++ 标准本身缺乏运行时反射（Reflection）和自动内存管理（GC），因此 Epic Games 自己实现了一套名为 &lt;strong&gt;Unreal Object Handling&lt;/strong&gt; 的系统。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Objective-C 属性（`@property`）中的 `atomic` 和 `nonatomic` 关键字。</title>
    <link href="https://jackwzx.github.io/2025/12/15/atomic%E5%92%8Cnonatomic%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://jackwzx.github.io/2025/12/15/atomic%E5%92%8Cnonatomic%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2025-12-15T04:00:34.000Z</published>
    <updated>2025-12-15T04:00:52.805Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两个宏定义的区别完全对应 Objective-C 属性（&lt;code&gt;@property&lt;/code&gt;）中的 &lt;code&gt;atomic&lt;/code&gt; 和 &lt;code&gt;nonatomic&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;h3 id=&quot;1-核心区别表格&quot;&gt;&lt;a href=&quot;#1-核心区别表格&quot; class=&quot;headerlink&quot; title=&quot;1. 核心区别表格&quot;&gt;&lt;/a&gt;1. 核心区别表格&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>面对INTP（内向、直觉、思维、感知）性格的孩子，家长最头疼的往往就是**“虽然聪明，但执行力极差”**。</title>
    <link href="https://jackwzx.github.io/2025/12/14/INTP%E5%AD%A9%E5%AD%90%E5%86%99%E4%BD%9C%E4%B8%9A/"/>
    <id>https://jackwzx.github.io/2025/12/14/INTP%E5%AD%A9%E5%AD%90%E5%86%99%E4%BD%9C%E4%B8%9A/</id>
    <published>2025-12-14T09:43:28.000Z</published>
    <updated>2025-12-14T09:43:28.456Z</updated>
    
    
    <summary type="html">&lt;p&gt;面对INTP（内向、直觉、思维、感知）性格的孩子，家长最头疼的往往就是&lt;strong&gt;“虽然聪明，但执行力极差”&lt;/strong&gt;。他们通常被称为“逻辑学家”或“思想家”，大脑里在构建宏伟宇宙，现实中却连一支铅笔都懒得削。&lt;br&gt;针对INTP孩子“散漫、拖拉、低效”的作业辅导，核心逻辑不能是“监控和施压”，而应该是“外包执行力”与“智力博弈”。&lt;br&gt;以下是分维度的具体操作指南：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;理解底层逻辑：为什么他会这样？&lt;br&gt;首先，你要知道他不是笨，也不是故意气你。&lt;br&gt;• Ti (内向思考)： 他们追求的是“弄懂原理”。一旦他觉得这道题原理懂了，重复的抄写和练习对他来说就是纯粹的折磨，毫无意义。&lt;br&gt;• Ne (外向直觉)： 他们的思维是发散的。写着写着作业，看到橡皮上的花纹，可能联想到了分形几何，然后就发呆（其实脑子在飞速运转）了。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>着色器中非线性深度转换成线性深度</title>
    <link href="https://jackwzx.github.io/2025/12/11/%E7%9D%80%E8%89%B2%E5%99%A8%E4%B8%AD%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BA%BF%E6%80%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>https://jackwzx.github.io/2025/12/11/%E7%9D%80%E8%89%B2%E5%99%A8%E4%B8%AD%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BA%BF%E6%80%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2025-12-11T06:07:47.000Z</published>
    <updated>2025-12-11T06:08:19.745Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 OpenGL 中，深度缓冲（Depth Buffer）中存储的值（通常记为 $z_{buffer}$ 或 $d$）是非线性的。这意味着深度值 $0.5$ 并不代表物体位于 &lt;code&gt;near&lt;/code&gt; 和 &lt;code&gt;far&lt;/code&gt; 平面的正中间。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android机型性能分级方案</title>
    <link href="https://jackwzx.github.io/2025/12/11/Android%E6%9C%BA%E5%9E%8B%E6%80%A7%E8%83%BD%E5%88%86%E7%BA%A7%E6%96%B9%E6%A1%88/"/>
    <id>https://jackwzx.github.io/2025/12/11/Android%E6%9C%BA%E5%9E%8B%E6%80%A7%E8%83%BD%E5%88%86%E7%BA%A7%E6%96%B9%E6%A1%88/</id>
    <published>2025-12-11T03:13:50.000Z</published>
    <updated>2025-12-11T03:14:16.784Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 Android 生态中，由于设备碎片化极其严重（成千上万种机型，涵盖高通、联发科、三星、紫光展锐等不同芯片），仅通过“机型白名单”是不现实的。&lt;/p&gt;
&lt;p&gt;目前业界主流的方案通常采用 **“分级策略” (Tiering Strategy)**，结合 &lt;strong&gt;静态检测&lt;/strong&gt;（硬件规格）和 &lt;strong&gt;动态调整&lt;/strong&gt;（运行时监控）。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Depth24Stencil8介绍</title>
    <link href="https://jackwzx.github.io/2025/12/10/Depth24Stencil8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://jackwzx.github.io/2025/12/10/Depth24Stencil8%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-12-10T04:49:16.000Z</published>
    <updated>2025-12-10T04:49:34.662Z</updated>
    
    
    <summary type="html">&lt;p&gt;直接回答你的问题：&lt;strong&gt;不是浮点型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Depth24Stencil8&lt;/code&gt; (通常在 OpenGL 中对应 &lt;code&gt;GL_DEPTH24_STENCIL8&lt;/code&gt;，在 DirectX/Vulkan 中对应 &lt;code&gt;D24_UNORM_S8_UINT&lt;/code&gt;) 中的 &lt;strong&gt;Depth24&lt;/strong&gt; 部分，存储的是 **无符号归一化整型 (Unsigned Normalized Integer, UNORM)**。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Analyzing Format Trade-offs R11G11B10F</title>
    <link href="https://jackwzx.github.io/2025/12/10/Analyzing%20Format%20Trade-offs%20R11G11B10F/"/>
    <id>https://jackwzx.github.io/2025/12/10/Analyzing%20Format%20Trade-offs%20R11G11B10F/</id>
    <published>2025-12-10T03:20:35.000Z</published>
    <updated>2025-12-10T03:21:07.024Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Analyzing Format Trade-offs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I’ve been drilling down on the nuances of &lt;code&gt;RGB8&lt;/code&gt; versus &lt;code&gt;R11G11B10F&lt;/code&gt;. My focus is on understanding the situations where the floating-point precision of &lt;code&gt;R11G11B10F&lt;/code&gt; justifies its increased memory footprint compared to the compact &lt;code&gt;RGB8&lt;/code&gt;. I’m starting to grasp the implications for HDR rendering and light accumulation scenarios where the extra range is crucial. Current thinking focuses on the actual trade-offs that have to be made with a limited memory budget.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
