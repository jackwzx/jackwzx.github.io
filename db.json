{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/baidu_verify.html","hash":"c122504f727ea8ff038abc082ce498bf44bb4128","modified":1749285300402},{"_id":"source/.DS_Store","hash":"bac5a892d4d7fabdfae66400255e3519a1309ca8","modified":1749283366513},{"_id":"source/googlef6f290aede027823.html","hash":"9543bec41cf242b21f83e87b0480898a0ef578ba","modified":1749285812509},{"_id":"source/google_verify.html","hash":"a8c5ff3508f30c751eb16e1146b3274ba14ec907","modified":1749285292410},{"_id":"source/robots.txt","hash":"2f88235dff1bbf48f7841075a244dde57037345f","modified":1749285284892},{"_id":"source/_posts/AddressSanitizer实现原理.md","hash":"308bad60421cc0fa9f11ebeb76bd9133e4c845b2","modified":1740056868000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1666528838000},{"_id":"source/_posts/C++-智能指针.md","hash":"c96893723adc35dec3bf88e925a993ccfeb89770","modified":1740056868000},{"_id":"source/_posts/C++中operator的重载.md","hash":"c3184c3ad48c6d62b0a0fb289ed096917b7591eb","modified":1740056868000},{"_id":"source/_posts/AndoirdEGLContext销毁管理.md","hash":"fed0322b95d57c55f97b74163dc438431921775c","modified":1740056868000},{"_id":"source/_posts/C++实现完美转发.md","hash":"7ae1a4318ad2c2ea8999b45250e225c1732a574a","modified":1740056868000},{"_id":"source/_posts/C++右值引用.md","hash":"58981687a1982cf532f1d770a6cac8e93455c16e","modified":1740056868000},{"_id":"source/_posts/CALayer-opaque.md","hash":"d7522f9aacbdea74344b44352173765566f9187a","modified":1740056868000},{"_id":"source/_posts/C++构造函数.md","hash":"6690e714d570ebc825f4131eb72e60bbe222f662","modified":1740056868000},{"_id":"source/_posts/How to build Apple Watch App.md","hash":"2520dba99fc20ad966689919aa93391a413cf76d","modified":1740056868000},{"_id":"source/_posts/MacOS下ruby安装.md","hash":"3f71b14964c96da93e0411ee2eaece253a101611","modified":1740056868000},{"_id":"source/_posts/CALayer的presentLayer那点事.md","hash":"af82e11e1745d65389117f6ae40d8f5f6beee65d","modified":1740056868000},{"_id":"source/_posts/CALayer属性positon和anchor.md","hash":"792de5cb4a535d8c168f8c7ebf3f945e547e864f","modified":1740056868000},{"_id":"source/_posts/OpenGL-VBO.md","hash":"25bcfa10e6a6abfcec24e7d2d474be055f40ca3a","modified":1740056868000},{"_id":"source/_posts/OpenGL-uniform和attribute.md","hash":"21003e0a8fca07b7051c4bc2dea1f03fd9fd8f86","modified":1740056868000},{"_id":"source/_posts/OpenGL-纹理贴图.md","hash":"4413e1025c062dff341b5ed28e10619c162c6756","modified":1740056868000},{"_id":"source/_posts/OpenGL-光照学习.md","hash":"42bb93bb87fbdd1940720e9db6b919c873b159f2","modified":1740056868000},{"_id":"source/_posts/OpenGL-基本框架搭建和绘制一个简单图形.md","hash":"e1aec3369a5014404c6cafc61fcda02871b70b56","modified":1740056868000},{"_id":"source/_posts/OpenGLE-VAO局部影响vs全局影响.md","hash":"e9c884f45e1ffe8e506da6f353065f6aca6fdaaa","modified":1740056868000},{"_id":"source/_posts/SDF实现CornerRadius.md","hash":"94c56d77f7ee1bca94663dbea81517f03b6a9416","modified":1740056868000},{"_id":"source/_posts/OpenGL模板测试流程.md","hash":"475341f02bc6cc776e8f68051cdb9730c0e26a15","modified":1740056868000},{"_id":"source/_posts/OpenGLES设置顶点属性的默认值.md","hash":"cf545dc8f9a0161d5df22b1249caf1302f1c1e43","modified":1740056868000},{"_id":"source/_posts/add-Image.md","hash":"fa3ffe48c50ab3d06b7df2d29b62982acf15b098","modified":1740056868000},{"_id":"source/_posts/UTF编码内存角度比较-md.md","hash":"c872f6f1dee879dae8e3c1a1bd21b9cc59eec335","modified":1740056868000},{"_id":"source/_posts/c-模版函数delete防止隐士类型转换-md.md","hash":"b9cbbfe7e666c9d35c3f02865368e861bf8c3326","modified":1740056868000},{"_id":"source/_posts/c-可变参数模板.md","hash":"1627e1423222f2b2c5b22063271694fb46949013","modified":1740056868000},{"_id":"source/_posts/c-继承权限.md","hash":"b2630ec4e2d73ad764c280c5d96bd7d10442abe0","modified":1740056868000},{"_id":"source/_posts/iOS-MessageForwarding.md","hash":"9a0a66b214eb08396328e4a042952b7877bfe822","modified":1740056868000},{"_id":"source/_posts/iOS11 Simulator OpenGL Slowly.md","hash":"eaa70b4a2594deea47c90a57499892ddc4b1e6e7","modified":1740056868000},{"_id":"source/_posts/iOS准确计时.md","hash":"ff7ba31fe710f4ee39e3e1255ba2cc0f63d2b3e1","modified":1740056868000},{"_id":"source/_posts/iOS手势事件分发原理.md","hash":"d39f9a97b434d92ed17ec9dd8a1f5934631009e8","modified":1740056868000},{"_id":"source/_posts/pthread-create设置栈size.md","hash":"fdcf8853505e5c2e1c2ea0648183719e393fb618","modified":1740056868000},{"_id":"source/_posts/shell和子shell环境变量.md","hash":"4dc57799c53b3b4566d8850ec0d4bebe64b195d3","modified":1740056868000},{"_id":"source/_posts/lamda-初始化捕获用法.md","hash":"be12a7930b0b239f705965b87e3e1876a6c0f901","modified":1740056868000},{"_id":"source/_posts/smoothStep实现.md","hash":"8ef77f6a693ab5adcb8fa6fc639f7cb719c09139","modified":1740056868000},{"_id":"source/_posts/std-nth-element实现.md","hash":"f493cc4efd1f1f0d93e73a28e830e89c5d754213","modified":1740056868000},{"_id":"source/_posts/tag-dispatch.md","hash":"b5cf4d7f05ffb0bc45abeee92ddeb84dfa1befb2","modified":1740056868000},{"_id":"source/_posts/texelFetch.md","hash":"453e463453b0e1afad158181bc7d4cf20feade38","modified":1740056868000},{"_id":"source/_posts/traits设计和用法.md","hash":"5c434a0c55be7bfb0a8200350d2032f902ff7a0b","modified":1740056868000},{"_id":"source/_posts/tweak使用说明.md","hash":"b7c4d8f1339a1a787c8563d110d66955698c7195","modified":1740056868000},{"_id":"source/_posts/trivially-copyable-拷贝不变.md","hash":"73c431942a040bc77163af24570255075f0b1f50","modified":1740056868000},{"_id":"source/_posts/tweak环境搭建.md","hash":"7fee054633a5e8ece769e641dc07eae507f7a49e","modified":1740056868000},{"_id":"source/_posts/从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵.md","hash":"020036d2019c77c1730984a9bab08f4f700635aa","modified":1740056868000},{"_id":"source/_posts/使用-asan-unpoison-memory-region屏蔽某处内存检查.md","hash":"c95ae15a53a6b4f6029983a9c849041fb539d122","modified":1740056868000},{"_id":"source/_posts/分支预测.md","hash":"411dcd66dbf1077eac718e1afe48a234e6f1754e","modified":1740056868000},{"_id":"source/_posts/命令行通配符.md","hash":"ab3bfde39ca131714cde6d5494227e71a7750e0a","modified":1740056868000},{"_id":"source/_posts/type-script.md","hash":"8ea07dfdd217ba5b2cb27567cc68686ca82d100b","modified":1742052368876},{"_id":"source/_posts/模板规则推导.md","hash":"06306b48d8017c1732aa28ddc2a9e40bafc0a080","modified":1740056868000},{"_id":"source/_posts/正则与通配符区别.md","hash":"992ca4e2d730fb543f201f3278852532585641bc","modified":1740056868000},{"_id":"source/_posts/what-is-mpx.md","hash":"0939b58d470be252abce8f80e90c393c95cf9d4c","modified":1742051368145},{"_id":"source/_posts/电子书目录.md","hash":"191ef11e421a9256c160b7223559a3f2a94bb926","modified":1740056868000},{"_id":"source/_posts/add-Image/sharedptr2.png","hash":"8e51afea16d9407343cefb650097d2c91b00bc39","modified":1740056868000},{"_id":"source/_posts/add-Image/sharedptr1.png","hash":"ef9802a63197339362725253f40a8f6af13991e2","modified":1740056868000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1740056868000},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1740056868000},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1740056868000},{"_id":"themes/landscape/_config.yml","hash":"60bc2dd95c5c0641800809f77d77ec30c16cdbdc","modified":1749284803973},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1740056868000},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1740056868000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1740056868000},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1740056868000},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1740056868000},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1740056868000},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1740056868000},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1740056868000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1740056868000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1740056868000},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1740056868000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1740056868000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1740056868000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1740056868000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1740056868000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1740056868000},{"_id":"themes/landscape/layout/layout.ejs","hash":"fec72d1fe70469ba7f0debe02b69ef228b2841a2","modified":1749286852840},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1740056868000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1740056868000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1740056868000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1740056868000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"d43a28f132e7ac8cc80193652cc3609976994458","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"291183319b7f6df04466136c174b6c8f937b7d56","modified":1749284797251},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"9ea6b90f4477b46901add1d8a22dcb0599a4f2e4","modified":1749286866810},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/google-adsense.ejs","hash":"c270861fe387745a35e708ee27435e86505d920f","modified":1749283969729},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/local-search.ejs","hash":"30a64abebd69dd031336aff9b7ba72c5711dbe7e","modified":1749287394168},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"7e9361b8c9df49fb65a260de383631848ad5b515","modified":1749283977794},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1740056868000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1740056868000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1740056868000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1740056868000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1740056868000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1740056868000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1740056868000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1740056868000},{"_id":"themes/landscape/source/css/style.styl","hash":"134ef546dc91d7301c7496bfd3be895a765ddede","modified":1749286833193},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1740056868000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1740056868000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1740056868000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/search.styl","hash":"4fcf417d0ec4a0521a974599618c0663096c0b30","modified":1749287367042},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1740056868000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1740056868000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1740056868000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1740056868000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1740056868000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1740056868000},{"_id":"public/baidu_verify.html","hash":"50539f0a06697be3c65e24c858d22f4123b6e0e8","modified":1749287463341},{"_id":"public/google_verify.html","hash":"8db3b213ce77708d05b6392946810f8340ef11f0","modified":1749287463341},{"_id":"public/googlef6f290aede027823.html","hash":"933a63c2fa95353be03c88fcc7bba75f695c6f63","modified":1749287463341},{"_id":"public/atom.xml","hash":"0f6142acf672f2a5169a4e6c4d0cf81c66d81fec","modified":1749287463341},{"_id":"public/search.xml","hash":"bce2b7d3545042fb3ab45dd127f2950af10fdf08","modified":1749287463341},{"_id":"public/baidusitemap.xml","hash":"12280d0933be26e86ec5c5fd61d80e081665ecb7","modified":1749287463341},{"_id":"public/sitemap.xml","hash":"f304706e9247eab6b47134dcffd726b0bb3cb666","modified":1749287463341},{"_id":"public/2025/03/15/type-script/index.html","hash":"17ff02a5bf3ece838e6bf1b2acad64bb2d0d0358","modified":1749287463341},{"_id":"public/2025/03/15/what-is-mpx/index.html","hash":"8cd52fdc1616a5012c2a312ce7241dd7d94b1237","modified":1749287463341},{"_id":"public/2024/11/04/命令行通配符/index.html","hash":"f3dcc07d4f536f0fd007b1ddc059c36732a58abb","modified":1749287463341},{"_id":"public/2024/10/11/正则与通配符区别/index.html","hash":"965079235615f3c57c3dac78c5c3150544b529cd","modified":1749287463341},{"_id":"public/2024/10/08/std-nth-element实现/index.html","hash":"b3cacd9a86cad0c86f871dac0b4da5516533ba09","modified":1749287463341},{"_id":"public/2024/10/06/texelFetch/index.html","hash":"de96bddd7866d44d50fcc8e5e2082de5659533fc","modified":1749287463341},{"_id":"public/2024/09/29/traits设计和用法/index.html","hash":"5b40e6937c9e5e09285990b3073311c071200aa3","modified":1749287463341},{"_id":"public/2024/09/29/shell和子shell环境变量/index.html","hash":"a660af5f761226a5b75478e5a884a94d84ef03f0","modified":1749287463341},{"_id":"public/2024/09/27/分支预测/index.html","hash":"aa99af791c1768b649357dc0819ce2f1ecf2fd3d","modified":1749287463341},{"_id":"public/2024/09/26/c-模版函数delete防止隐士类型转换-md/index.html","hash":"42d281d2b87458a11a3d43c18d6be787de90e68c","modified":1749287463341},{"_id":"public/2024/08/01/AndoirdEGLContext销毁管理/index.html","hash":"f38294e4018273fe7ee3a2406a22f107ed750aa5","modified":1749287463341},{"_id":"public/2024/07/30/从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵/index.html","hash":"4b22a130d9f4eea0d0af431942f9f07e882851fd","modified":1749287463341},{"_id":"public/2024/07/28/OpenGLE-VAO局部影响vs全局影响/index.html","hash":"3052ee98ffd79cf8f6b1bf64e6dbe9ab4b60e762","modified":1749287463341},{"_id":"public/2024/07/28/OpenGLES设置顶点属性的默认值/index.html","hash":"662f5b5cbf7cf8000d2aa5baf2dc8366e1de5ac1","modified":1749287463341},{"_id":"public/2024/07/28/AddressSanitizer实现原理/index.html","hash":"ceededd9808736ad07c32a76daa1c60d39bb1b18","modified":1749287463341},{"_id":"public/2024/07/22/使用-asan-unpoison-memory-region屏蔽某处内存检查/index.html","hash":"939ee12977037a698b3baa0d89f8751ba315111d","modified":1749287463341},{"_id":"public/2024/07/28/pthread-create设置栈size/index.html","hash":"a996e4096e4e37dc660900d2ac946564b93b210d","modified":1749287463341},{"_id":"public/2024/07/11/UTF编码内存角度比较-md/index.html","hash":"1ef9bda8770f917e4492470eae527c844b7e48a9","modified":1749287463341},{"_id":"public/2023/12/28/SDF实现CornerRadius/index.html","hash":"c2fda6a43d843d62a6da5e9035836d534b67b02b","modified":1749287463341},{"_id":"public/2023/12/27/lamda-初始化捕获用法/index.html","hash":"436fd26bbb00251b3af491040c339ba44e434b0d","modified":1749287463341},{"_id":"public/2023/12/24/tag-dispatch/index.html","hash":"fbaea5a5651b745108ffd1d831ba2b627c6cf36f","modified":1749287463341},{"_id":"public/2023/12/22/smoothStep实现/index.html","hash":"abd3d53e3fd2bc3e2a8d8b1035ee065d9360d402","modified":1749287463341},{"_id":"public/2023/12/21/模板规则推导/index.html","hash":"987fac69ba5a5012edacc455665c6ed01c39c047","modified":1749287463341},{"_id":"public/2022/12/25/电子书目录/index.html","hash":"86ab7c1be60d7c6eb5c1bc0773a1cb78fbf41a41","modified":1749287463341},{"_id":"public/2022/12/11/c-可变参数模板/index.html","hash":"3c15a7d2c4fae27fa3594d90d46a59db551b4639","modified":1749287463341},{"_id":"public/2022/12/04/c-继承权限/index.html","hash":"02a911910aac15a3892ae983ddde770554c5a61b","modified":1749287463341},{"_id":"public/2022/11/08/OpenGL模板测试流程/index.html","hash":"70f7c88336626c5096a3ea3da72880ac0f32e7b5","modified":1749287463341},{"_id":"public/2022/10/25/trivially-copyable-拷贝不变/index.html","hash":"0a036249f7cd6c65bddeccf04114b049c0d030aa","modified":1749287463341},{"_id":"public/2022/10/23/C++实现完美转发/index.html","hash":"0ad2918b0f07c71fbd1cc6f497fe3b22e3bf4b2a","modified":1749287463341},{"_id":"public/2022/09/25/add-Image/index.html","hash":"14cacf3ddab4f453643c6fb1da33ce972f15baf8","modified":1749287463341},{"_id":"public/2022/09/25/C++-智能指针/index.html","hash":"286615cd434d9faab3fd9849ee9144c7039d8c2c","modified":1749287463341},{"_id":"public/2022/09/18/C++右值引用/index.html","hash":"bdd97e6fd5ff17350e614d8e5589e8860e4dee91","modified":1749287463341},{"_id":"public/2022/09/18/C++中operator的重载/index.html","hash":"2d08ad0bdd9e18fe522fdd6d8402dd6aecbed8b8","modified":1749287463341},{"_id":"public/2022/09/18/C++构造函数/index.html","hash":"1cba465228385443c20dc566f2f74e63c114d420","modified":1749287463341},{"_id":"public/2017/12/14/iOS-MessageForwarding/index.html","hash":"f5699f704f0160fbae8b2a5654faa8afa9e9bdb1","modified":1749287463341},{"_id":"public/2017/11/12/CALayer的presentLayer那点事/index.html","hash":"82682d313f761cb0e115587c238bb9cf1daa6986","modified":1749287463341},{"_id":"public/2017/09/19/MacOS下ruby安装/index.html","hash":"6fb33f3a7ae73095814f6a2b6eef693005fa7151","modified":1749287463341},{"_id":"public/2017/09/17/iOS准确计时/index.html","hash":"16032ae37e10aa2ac62d16ea3be22812146101bb","modified":1749287463341},{"_id":"public/2017/09/19/iOS11 Simulator OpenGL Slowly/index.html","hash":"0f3a5abac804a12f11680c851e5f79fadb46e573","modified":1749287463341},{"_id":"public/2017/07/01/iOS手势事件分发原理/index.html","hash":"31bd3f4707fc9a20fd166f1b8250236f10e08705","modified":1749287463341},{"_id":"public/2017/03/07/tweak使用说明/index.html","hash":"e89268c8fde4f1739dd3d5448a2b896f9d6a7fbc","modified":1749287463341},{"_id":"public/2017/03/07/tweak环境搭建/index.html","hash":"8bdce296ad46baf0576e11db1f07a5a6959cb17a","modified":1749287463341},{"_id":"public/2017/01/03/OpenGL-纹理贴图/index.html","hash":"edf185abad119daa04d342aab4ff4c54f6d0335b","modified":1749287463341},{"_id":"public/2017/01/02/OpenGL-光照学习/index.html","hash":"d7e748ad8da009f347ada44452d89dbf5451c5a0","modified":1749287463341},{"_id":"public/2017/01/02/OpenGL-VBO/index.html","hash":"2b3e567a987f44701c10a25c19c0b12f8eb1de70","modified":1749287463341},{"_id":"public/2016/12/30/OpenGL-uniform和attribute/index.html","hash":"e44a6942b3b51dc31a0f11685d27cfaccc5da178","modified":1749287463341},{"_id":"public/2016/12/30/OpenGL-基本框架搭建和绘制一个简单图形/index.html","hash":"c2a1146ca6ec2bef6af2e9c33f5e0389b81adf47","modified":1749287463341},{"_id":"public/2016/12/30/CALayer-opaque/index.html","hash":"337e24e025de86f4bb32f2388c4c61a18860d031","modified":1749287463341},{"_id":"public/2016/10/26/How to build Apple Watch App/index.html","hash":"af933698abf52094eb8924a6c368bdcfba4782a3","modified":1749287463341},{"_id":"public/2016/10/26/CALayer属性positon和anchor/index.html","hash":"0b18ebcdb4af3a31ba2a13c047ee7d151b7cbb23","modified":1749287463341},{"_id":"public/archives/index.html","hash":"1cd07b87d4d670bf748634f7b20f04b05cb3e219","modified":1749287463341},{"_id":"public/archives/page/2/index.html","hash":"e8345fb574596fba2a6ca83824686bb807bdc139","modified":1749287463341},{"_id":"public/archives/page/3/index.html","hash":"a7a5b9eb635419f5115e87e4d6718f5862da4815","modified":1749287463341},{"_id":"public/archives/page/4/index.html","hash":"b4a085908d60879de529338ccc2d90f962a5a10b","modified":1749287463341},{"_id":"public/archives/page/5/index.html","hash":"03bb3b1ef8e8918db6b74b5905d1b6a42f745dbe","modified":1749287463341},{"_id":"public/archives/2016/index.html","hash":"8d4ae8621ec5a2689733944d6b1c9fd418195189","modified":1749287463341},{"_id":"public/archives/2016/10/index.html","hash":"1692caba830f3d1b1c5384cd8c2f2322bd46c5ab","modified":1749287463341},{"_id":"public/archives/2016/12/index.html","hash":"51c1ecb432938eb1d46d2f3aea502060b230462b","modified":1749287463341},{"_id":"public/archives/2017/index.html","hash":"19bfc605e02441f247607f3c4c0353fc116e7008","modified":1749287463341},{"_id":"public/archives/2017/page/2/index.html","hash":"4db899d04563995853801f326800f25f465d67ef","modified":1749287463341},{"_id":"public/archives/2017/01/index.html","hash":"18b36ba42805a0056909c2e9c95207ba69524d1d","modified":1749287463341},{"_id":"public/archives/2017/03/index.html","hash":"1f233ee7ffb3c491736f00483da215b229ee9aa4","modified":1749287463341},{"_id":"public/archives/2017/07/index.html","hash":"f1c58cda34807ce49cd3939b635016eca6cbd20b","modified":1749287463341},{"_id":"public/archives/2017/09/index.html","hash":"4cd4185dcc1f5592705fb2ec6f75f2063077b70c","modified":1749287463341},{"_id":"public/archives/2017/11/index.html","hash":"c8352a46d77818759c2b8d0f264a4bf9ec4b89f9","modified":1749287463341},{"_id":"public/archives/2017/12/index.html","hash":"28707fa0ba8c94f2235bb1c59c98d8de5d53609e","modified":1749287463341},{"_id":"public/archives/2022/index.html","hash":"ba089380a32ceda03a2ffa5945c9db9c0eb443ce","modified":1749287463341},{"_id":"public/archives/2022/page/2/index.html","hash":"b12f4cb08e78d9ad84418647f616b1acfd20b1e3","modified":1749287463341},{"_id":"public/archives/2022/09/index.html","hash":"0d124acb62312bbb982aaf040ccf42dd690b4cf2","modified":1749287463341},{"_id":"public/archives/2022/10/index.html","hash":"1b2833ae2618bb504c7f829c04677a850fb9bfa8","modified":1749287463341},{"_id":"public/archives/2022/11/index.html","hash":"ae2ed3d075da1aaf0b527fd0b2cf67a82d7dd896","modified":1749287463341},{"_id":"public/archives/2022/12/index.html","hash":"ef4ffd54151b845a59376eed5cfc1c2b26e03390","modified":1749287463341},{"_id":"public/archives/2023/index.html","hash":"71f70d80d657c841635915c6a7c926c697af1c1a","modified":1749287463341},{"_id":"public/archives/2023/12/index.html","hash":"d04a793290336918ef2733b148349b8ea2a5279b","modified":1749287463341},{"_id":"public/archives/2024/index.html","hash":"6a4498a055c5bf62faf690facb6946930eec8118","modified":1749287463341},{"_id":"public/archives/2024/page/2/index.html","hash":"88feaa100d8586125aed4259cb53050fc20c5b74","modified":1749287463341},{"_id":"public/archives/2024/07/index.html","hash":"f56f793f80cc6c957e73deb2743be2f06179bea2","modified":1749287463341},{"_id":"public/archives/2024/08/index.html","hash":"324dbfc6ddd028d900e1850dc8b76ddbbd336109","modified":1749287463341},{"_id":"public/archives/2024/09/index.html","hash":"18548c027f8118b123d0a6631e2dfa9ab327b578","modified":1749287463341},{"_id":"public/archives/2024/10/index.html","hash":"bc0c47bf1bce969d3f42ef63806d1a989ab774fd","modified":1749287463341},{"_id":"public/archives/2024/11/index.html","hash":"6a6f796a4c08a86b30dea4469e3e206e90b758d2","modified":1749287463341},{"_id":"public/archives/2025/index.html","hash":"aec142b110229d998e6753d7571a24c201586d1b","modified":1749287463341},{"_id":"public/archives/2025/03/index.html","hash":"805ee11375d98bc4360058d7596fac9bb15e48b3","modified":1749287463341},{"_id":"public/index.html","hash":"e3a8320791492f5fee43756cbc8b6a7af58149ce","modified":1749287463341},{"_id":"public/page/2/index.html","hash":"09b3cae5934a0d58246a5ef194df2ec2af8d5b1f","modified":1749287463341},{"_id":"public/page/4/index.html","hash":"cc4083219207cb2e35b14c867a27373e7569db3e","modified":1749287463341},{"_id":"public/page/3/index.html","hash":"f41874a4d28339e417147f6e693052ba064c966b","modified":1749287463341},{"_id":"public/page/5/index.html","hash":"3a5356c3109fd3f9fdbdd57f3dc77f426c448f9b","modified":1749287463341},{"_id":"public/tags/C-11/index.html","hash":"f1c620eaa97bd5f01d522df12880b58fbd059554","modified":1749287463341},{"_id":"public/tags/iOS/index.html","hash":"4fc29dcbd849b2dd8c725464db05e496a5cbf094","modified":1749287463341},{"_id":"public/tags/iOS/page/2/index.html","hash":"12d22ada8301ec76b6a718808f9c4881a133d6ee","modified":1749287463341},{"_id":"public/tags/ruby/index.html","hash":"a6de7da3245c8095d117f43ac0a4b813a7328035","modified":1749287463341},{"_id":"public/tags/openGL/index.html","hash":"e18df28fa7f83759bbefad6fe9b31812beffb751","modified":1749287463341},{"_id":"public/tags/test/index.html","hash":"7f19dca38616efb4f1fda31aa8262289468d29f2","modified":1749287463341},{"_id":"public/tags/c-11/index.html","hash":"80111268a127328eb931cfd3f4512be4d25494b9","modified":1749287463341},{"_id":"public/robots.txt","hash":"2f88235dff1bbf48f7841075a244dde57037345f","modified":1749287463341},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1749287463341},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1749287463341},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1749287463341},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1749287463341},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1749287463341},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1749287463341},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1749287463341},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1749287463341},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1749287463341},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1749287463341},{"_id":"public/2022/09/25/add-Image/sharedptr1.png","hash":"ef9802a63197339362725253f40a8f6af13991e2","modified":1749287463341},{"_id":"public/2022/09/25/add-Image/sharedptr2.png","hash":"8e51afea16d9407343cefb650097d2c91b00bc39","modified":1749287463341},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1749287463341},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1749287463341},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1749287463341},{"_id":"public/css/style.css","hash":"e4b6441b12ded91514a6b3d7d22262e452457546","modified":1749287463341},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1749287463341},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1749287463341},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1749287463341},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1749287463341},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1749287463341},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1749287463341},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1749287463341},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1749287463341},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1749287463341}],"Category":[],"Data":[],"Page":[{"layout":"false","_content":"<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>百度网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为百度站长平台提供的验证码 -->\n  <meta name=\"baidu-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> ","source":"baidu_verify.html","raw":"---\nlayout: false\n---\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>百度网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为百度站长平台提供的验证码 -->\n  <meta name=\"baidu-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> ","date":"2025-06-07T08:35:00.402Z","updated":"2025-06-07T08:35:00.402Z","path":"baidu_verify.html","title":"","comments":1,"_id":"cmbm0l99u0000gcco3brv3q4j","content":"<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>百度网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为百度站长平台提供的验证码 -->\n  <meta name=\"baidu-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> ","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>百度网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为百度站长平台提供的验证码 -->\n  <meta name=\"baidu-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> "},{"layout":"false","_content":"<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Google网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为Google Search Console提供的验证码 -->\n  <meta name=\"google-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> ","source":"google_verify.html","raw":"---\nlayout: false\n---\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Google网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为Google Search Console提供的验证码 -->\n  <meta name=\"google-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> ","date":"2025-06-07T08:42:28.428Z","updated":"2025-06-07T08:34:52.410Z","path":"google_verify.html","title":"","comments":1,"_id":"cmbm0l99w0002gcco9n1hehii","content":"<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Google网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为Google Search Console提供的验证码 -->\n  <meta name=\"google-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> ","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Google网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为Google Search Console提供的验证码 -->\n  <meta name=\"google-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> "},{"layout":"false","_content":"google-site-verification: googlef6f290aede027823.html ","source":"googlef6f290aede027823.html","raw":"---\nlayout: false\n---\ngoogle-site-verification: googlef6f290aede027823.html ","date":"2025-06-07T08:43:32.509Z","updated":"2025-06-07T08:43:32.509Z","path":"googlef6f290aede027823.html","title":"","comments":1,"_id":"cmbm0l99x0004gccobsgwc8e2","content":"google-site-verification: googlef6f290aede027823.html ","site":{"data":{}},"excerpt":"","more":"google-site-verification: googlef6f290aede027823.html "}],"Post":[{"title":"AndoirdEGLContext销毁管理","date":"2024-07-31T16:19:32.000Z","_content":"\n```java\npublic interface EGLContextFactory {\n    EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);\n    void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);\n} \n```\n### EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗\n\n### 在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\n\n具体来说，当你调用 `EGLContextFactory` 接口的 `destroyContext` 方法来销毁一个 EGLContext 时，OpenGL ES 会自动处理这个上下文的清理工作，包括删除所有在该上下文中创建的资源。\n\n因此，你不需要手动删除这些资源，销毁上下文的过程会自动处理它们的释放。\n\n不过，如果你需要提前释放某些资源以便在上下文还没有销毁之前释放内存，你可以在合适的时机手动删除这些资源（例如通过调用 `glDeleteBuffers`、`glDeleteTextures`、`glDeleteFramebuffers` 等方法）。","source":"_posts/AndoirdEGLContext销毁管理.md","raw":"---\ntitle: AndoirdEGLContext销毁管理\ndate: 2024-08-01 00:19:32\ntags:\n---\n\n```java\npublic interface EGLContextFactory {\n    EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);\n    void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);\n} \n```\n### EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗\n\n### 在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\n\n具体来说，当你调用 `EGLContextFactory` 接口的 `destroyContext` 方法来销毁一个 EGLContext 时，OpenGL ES 会自动处理这个上下文的清理工作，包括删除所有在该上下文中创建的资源。\n\n因此，你不需要手动删除这些资源，销毁上下文的过程会自动处理它们的释放。\n\n不过，如果你需要提前释放某些资源以便在上下文还没有销毁之前释放内存，你可以在合适的时机手动删除这些资源（例如通过调用 `glDeleteBuffers`、`glDeleteTextures`、`glDeleteFramebuffers` 等方法）。","slug":"AndoirdEGLContext销毁管理","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l99v0001gccocbeefrv0","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">EGLContextFactory</span> &#123;</span><br><span class=\"line\">    EGLContext <span class=\"title function_\">createContext</span><span class=\"params\">(EGL10 egl, EGLDisplay display, EGLConfig eglConfig)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">destroyContext</span><span class=\"params\">(EGL10 egl, EGLDisplay display, EGLContext context)</span>;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<h3 id=\"EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗\"><a href=\"#EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗\" class=\"headerlink\" title=\"EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗\"></a>EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗</h3><h3 id=\"在-OpenGL-ES-中，当一个-EGLContext-被销毁时，所有在该上下文中创建的-OpenGL-资源（如-buffer、texture-和-framebuffer-objects-FBO-等）都会被删除。这是因为这些资源是与特定的-OpenGL-上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\"><a href=\"#在-OpenGL-ES-中，当一个-EGLContext-被销毁时，所有在该上下文中创建的-OpenGL-资源（如-buffer、texture-和-framebuffer-objects-FBO-等）都会被删除。这是因为这些资源是与特定的-OpenGL-上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\" class=\"headerlink\" title=\"在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\"></a>在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。</h3><p>具体来说，当你调用 <code>EGLContextFactory</code> 接口的 <code>destroyContext</code> 方法来销毁一个 EGLContext 时，OpenGL ES 会自动处理这个上下文的清理工作，包括删除所有在该上下文中创建的资源。</p>\n<p>因此，你不需要手动删除这些资源，销毁上下文的过程会自动处理它们的释放。</p>\n<p>不过，如果你需要提前释放某些资源以便在上下文还没有销毁之前释放内存，你可以在合适的时机手动删除这些资源（例如通过调用 <code>glDeleteBuffers</code>、<code>glDeleteTextures</code>、<code>glDeleteFramebuffers</code> 等方法）。</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">EGLContextFactory</span> &#123;</span><br><span class=\"line\">    EGLContext <span class=\"title function_\">createContext</span><span class=\"params\">(EGL10 egl, EGLDisplay display, EGLConfig eglConfig)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">destroyContext</span><span class=\"params\">(EGL10 egl, EGLDisplay display, EGLContext context)</span>;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<h3 id=\"EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗\"><a href=\"#EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗\" class=\"headerlink\" title=\"EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗\"></a>EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗</h3><h3 id=\"在-OpenGL-ES-中，当一个-EGLContext-被销毁时，所有在该上下文中创建的-OpenGL-资源（如-buffer、texture-和-framebuffer-objects-FBO-等）都会被删除。这是因为这些资源是与特定的-OpenGL-上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\"><a href=\"#在-OpenGL-ES-中，当一个-EGLContext-被销毁时，所有在该上下文中创建的-OpenGL-资源（如-buffer、texture-和-framebuffer-objects-FBO-等）都会被删除。这是因为这些资源是与特定的-OpenGL-上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\" class=\"headerlink\" title=\"在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\"></a>在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。</h3><p>具体来说，当你调用 <code>EGLContextFactory</code> 接口的 <code>destroyContext</code> 方法来销毁一个 EGLContext 时，OpenGL ES 会自动处理这个上下文的清理工作，包括删除所有在该上下文中创建的资源。</p>\n<p>因此，你不需要手动删除这些资源，销毁上下文的过程会自动处理它们的释放。</p>\n<p>不过，如果你需要提前释放某些资源以便在上下文还没有销毁之前释放内存，你可以在合适的时机手动删除这些资源（例如通过调用 <code>glDeleteBuffers</code>、<code>glDeleteTextures</code>、<code>glDeleteFramebuffers</code> 等方法）。</p>\n"},{"title":"AddressSanitizer实现原理","date":"2024-07-28T04:23:56.000Z","_content":"\nAddressSanitizer（简称ASan）是一种内存错误检测工具，用于捕捉诸如缓冲区溢出、使用已释放内存、堆栈溢出等内存错误。ASan在编译时和运行时对程序进行处理，以检测和报告内存相关的错误。以下是AddressSanitizer的实现原理的详细解释：\n\n### 1. 编译时插桩\n\nASan在编译时对代码进行插桩，插入额外的检查代码。这些检查代码会在每次内存访问时执行，以验证访问是否合法。具体过程包括：\n\n- **插入检查代码**：在每次内存分配、释放和访问操作前后插入检查代码。\n- **标记内存区域**：在内存分配和释放时，更新内存区域的元数据，以记录该区域的状态（已分配、已释放等）。\n\n### 2. Shadow Memory\n\nASan使用影子内存（Shadow Memory）来记录主内存的状态。影子内存是主内存的一个映射区域，每个字节的影子内存对应主内存的几个字节（通常是8字节）。影子内存的值用于指示主内存的哪些部分是合法访问的，哪些部分是非法的。\n\n- **影子内存布局**：影子内存占用主内存的1/8，因为每个影子字节代表8个主内存字节。\n- **影子内存值**：影子内存中的值表示主内存的状态。例如，0表示所有8个字节都是合法的，负值表示不合法的访问，正值表示部分合法访问。\n\n### 3. 内存分配和释放\n\nASan对内存分配和释放函数（如`malloc`和`free`）进行重载，以维护内存区域的元数据。这些元数据包括：\n\n- **红色区域（Redzones）**：在每个分配的内存块周围添加红色区域，用于检测缓冲区溢出。红色区域被标记为非法访问区域。\n- **元数据**：记录每个内存块的大小、分配堆栈等信息，以便在检测到错误时提供详细报告。\n\n### 4. 运行时检查\n\n在运行时，ASan插入的检查代码会在每次内存访问时执行，检查访问的地址是否在合法范围内。如果访问非法区域，则报告错误并终止程序。\n\n- **内存访问检查**：每次内存读取或写入时，检查影子内存中的值，以确定访问是否合法。\n- **错误报告**：在检测到非法访问时，ASan会生成详细的错误报告，包含访问地址、内存块信息、调用堆栈等。\n\n### 5. 错误类型检测\n\nASan能够检测多种类型的内存错误，包括：\n\n- **缓冲区溢出**：访问数组或内存块的边界外的区域。\n- **使用未初始化内存**：访问未初始化的内存。\n- **使用已释放内存**：访问已经释放的内存。\n- **双重释放**：重复释放同一块内存。\n- **堆栈溢出**：访问栈帧之外的内存。\n\n### 6. 性能与开销\n\nASan在检测内存错误时会引入一定的性能开销和内存开销：\n\n- **性能开销**：由于插入了额外的检查代码，程序的执行速度会有所降低。通常，ASan引入的性能开销在2-3倍左右。\n- **内存开销**：影子内存和红色区域会增加内存使用量，通常内存开销在2倍左右。\n\n### 总结\n\nAddressSanitizer通过编译时插桩、使用影子内存和运行时检查等机制，能够有效地检测和报告内存相关的错误。尽管引入了一定的性能和内存开销，但它在提高程序安全性和稳定性方面具有重要意义，是开发和调试C/C++程序的强大工具。","source":"_posts/AddressSanitizer实现原理.md","raw":"---\ntitle: AddressSanitizer实现原理\ndate: 2024-07-28 12:23:56\ntags:\n---\n\nAddressSanitizer（简称ASan）是一种内存错误检测工具，用于捕捉诸如缓冲区溢出、使用已释放内存、堆栈溢出等内存错误。ASan在编译时和运行时对程序进行处理，以检测和报告内存相关的错误。以下是AddressSanitizer的实现原理的详细解释：\n\n### 1. 编译时插桩\n\nASan在编译时对代码进行插桩，插入额外的检查代码。这些检查代码会在每次内存访问时执行，以验证访问是否合法。具体过程包括：\n\n- **插入检查代码**：在每次内存分配、释放和访问操作前后插入检查代码。\n- **标记内存区域**：在内存分配和释放时，更新内存区域的元数据，以记录该区域的状态（已分配、已释放等）。\n\n### 2. Shadow Memory\n\nASan使用影子内存（Shadow Memory）来记录主内存的状态。影子内存是主内存的一个映射区域，每个字节的影子内存对应主内存的几个字节（通常是8字节）。影子内存的值用于指示主内存的哪些部分是合法访问的，哪些部分是非法的。\n\n- **影子内存布局**：影子内存占用主内存的1/8，因为每个影子字节代表8个主内存字节。\n- **影子内存值**：影子内存中的值表示主内存的状态。例如，0表示所有8个字节都是合法的，负值表示不合法的访问，正值表示部分合法访问。\n\n### 3. 内存分配和释放\n\nASan对内存分配和释放函数（如`malloc`和`free`）进行重载，以维护内存区域的元数据。这些元数据包括：\n\n- **红色区域（Redzones）**：在每个分配的内存块周围添加红色区域，用于检测缓冲区溢出。红色区域被标记为非法访问区域。\n- **元数据**：记录每个内存块的大小、分配堆栈等信息，以便在检测到错误时提供详细报告。\n\n### 4. 运行时检查\n\n在运行时，ASan插入的检查代码会在每次内存访问时执行，检查访问的地址是否在合法范围内。如果访问非法区域，则报告错误并终止程序。\n\n- **内存访问检查**：每次内存读取或写入时，检查影子内存中的值，以确定访问是否合法。\n- **错误报告**：在检测到非法访问时，ASan会生成详细的错误报告，包含访问地址、内存块信息、调用堆栈等。\n\n### 5. 错误类型检测\n\nASan能够检测多种类型的内存错误，包括：\n\n- **缓冲区溢出**：访问数组或内存块的边界外的区域。\n- **使用未初始化内存**：访问未初始化的内存。\n- **使用已释放内存**：访问已经释放的内存。\n- **双重释放**：重复释放同一块内存。\n- **堆栈溢出**：访问栈帧之外的内存。\n\n### 6. 性能与开销\n\nASan在检测内存错误时会引入一定的性能开销和内存开销：\n\n- **性能开销**：由于插入了额外的检查代码，程序的执行速度会有所降低。通常，ASan引入的性能开销在2-3倍左右。\n- **内存开销**：影子内存和红色区域会增加内存使用量，通常内存开销在2倍左右。\n\n### 总结\n\nAddressSanitizer通过编译时插桩、使用影子内存和运行时检查等机制，能够有效地检测和报告内存相关的错误。尽管引入了一定的性能和内存开销，但它在提高程序安全性和稳定性方面具有重要意义，是开发和调试C/C++程序的强大工具。","slug":"AddressSanitizer实现原理","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l99w0003gcco78wnh65w","content":"<p>AddressSanitizer（简称ASan）是一种内存错误检测工具，用于捕捉诸如缓冲区溢出、使用已释放内存、堆栈溢出等内存错误。ASan在编译时和运行时对程序进行处理，以检测和报告内存相关的错误。以下是AddressSanitizer的实现原理的详细解释：</p>\n<h3 id=\"1-编译时插桩\"><a href=\"#1-编译时插桩\" class=\"headerlink\" title=\"1. 编译时插桩\"></a>1. 编译时插桩</h3><p>ASan在编译时对代码进行插桩，插入额外的检查代码。这些检查代码会在每次内存访问时执行，以验证访问是否合法。具体过程包括：</p>\n<ul>\n<li><strong>插入检查代码</strong>：在每次内存分配、释放和访问操作前后插入检查代码。</li>\n<li><strong>标记内存区域</strong>：在内存分配和释放时，更新内存区域的元数据，以记录该区域的状态（已分配、已释放等）。</li>\n</ul>\n<h3 id=\"2-Shadow-Memory\"><a href=\"#2-Shadow-Memory\" class=\"headerlink\" title=\"2. Shadow Memory\"></a>2. Shadow Memory</h3><p>ASan使用影子内存（Shadow Memory）来记录主内存的状态。影子内存是主内存的一个映射区域，每个字节的影子内存对应主内存的几个字节（通常是8字节）。影子内存的值用于指示主内存的哪些部分是合法访问的，哪些部分是非法的。</p>\n<ul>\n<li><strong>影子内存布局</strong>：影子内存占用主内存的1/8，因为每个影子字节代表8个主内存字节。</li>\n<li><strong>影子内存值</strong>：影子内存中的值表示主内存的状态。例如，0表示所有8个字节都是合法的，负值表示不合法的访问，正值表示部分合法访问。</li>\n</ul>\n<h3 id=\"3-内存分配和释放\"><a href=\"#3-内存分配和释放\" class=\"headerlink\" title=\"3. 内存分配和释放\"></a>3. 内存分配和释放</h3><p>ASan对内存分配和释放函数（如<code>malloc</code>和<code>free</code>）进行重载，以维护内存区域的元数据。这些元数据包括：</p>\n<ul>\n<li><strong>红色区域（Redzones）</strong>：在每个分配的内存块周围添加红色区域，用于检测缓冲区溢出。红色区域被标记为非法访问区域。</li>\n<li><strong>元数据</strong>：记录每个内存块的大小、分配堆栈等信息，以便在检测到错误时提供详细报告。</li>\n</ul>\n<h3 id=\"4-运行时检查\"><a href=\"#4-运行时检查\" class=\"headerlink\" title=\"4. 运行时检查\"></a>4. 运行时检查</h3><p>在运行时，ASan插入的检查代码会在每次内存访问时执行，检查访问的地址是否在合法范围内。如果访问非法区域，则报告错误并终止程序。</p>\n<ul>\n<li><strong>内存访问检查</strong>：每次内存读取或写入时，检查影子内存中的值，以确定访问是否合法。</li>\n<li><strong>错误报告</strong>：在检测到非法访问时，ASan会生成详细的错误报告，包含访问地址、内存块信息、调用堆栈等。</li>\n</ul>\n<h3 id=\"5-错误类型检测\"><a href=\"#5-错误类型检测\" class=\"headerlink\" title=\"5. 错误类型检测\"></a>5. 错误类型检测</h3><p>ASan能够检测多种类型的内存错误，包括：</p>\n<ul>\n<li><strong>缓冲区溢出</strong>：访问数组或内存块的边界外的区域。</li>\n<li><strong>使用未初始化内存</strong>：访问未初始化的内存。</li>\n<li><strong>使用已释放内存</strong>：访问已经释放的内存。</li>\n<li><strong>双重释放</strong>：重复释放同一块内存。</li>\n<li><strong>堆栈溢出</strong>：访问栈帧之外的内存。</li>\n</ul>\n<h3 id=\"6-性能与开销\"><a href=\"#6-性能与开销\" class=\"headerlink\" title=\"6. 性能与开销\"></a>6. 性能与开销</h3><p>ASan在检测内存错误时会引入一定的性能开销和内存开销：</p>\n<ul>\n<li><strong>性能开销</strong>：由于插入了额外的检查代码，程序的执行速度会有所降低。通常，ASan引入的性能开销在2-3倍左右。</li>\n<li><strong>内存开销</strong>：影子内存和红色区域会增加内存使用量，通常内存开销在2倍左右。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>AddressSanitizer通过编译时插桩、使用影子内存和运行时检查等机制，能够有效地检测和报告内存相关的错误。尽管引入了一定的性能和内存开销，但它在提高程序安全性和稳定性方面具有重要意义，是开发和调试C/C++程序的强大工具。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>AddressSanitizer（简称ASan）是一种内存错误检测工具，用于捕捉诸如缓冲区溢出、使用已释放内存、堆栈溢出等内存错误。ASan在编译时和运行时对程序进行处理，以检测和报告内存相关的错误。以下是AddressSanitizer的实现原理的详细解释：</p>\n<h3 id=\"1-编译时插桩\"><a href=\"#1-编译时插桩\" class=\"headerlink\" title=\"1. 编译时插桩\"></a>1. 编译时插桩</h3><p>ASan在编译时对代码进行插桩，插入额外的检查代码。这些检查代码会在每次内存访问时执行，以验证访问是否合法。具体过程包括：</p>\n<ul>\n<li><strong>插入检查代码</strong>：在每次内存分配、释放和访问操作前后插入检查代码。</li>\n<li><strong>标记内存区域</strong>：在内存分配和释放时，更新内存区域的元数据，以记录该区域的状态（已分配、已释放等）。</li>\n</ul>\n<h3 id=\"2-Shadow-Memory\"><a href=\"#2-Shadow-Memory\" class=\"headerlink\" title=\"2. Shadow Memory\"></a>2. Shadow Memory</h3><p>ASan使用影子内存（Shadow Memory）来记录主内存的状态。影子内存是主内存的一个映射区域，每个字节的影子内存对应主内存的几个字节（通常是8字节）。影子内存的值用于指示主内存的哪些部分是合法访问的，哪些部分是非法的。</p>\n<ul>\n<li><strong>影子内存布局</strong>：影子内存占用主内存的1/8，因为每个影子字节代表8个主内存字节。</li>\n<li><strong>影子内存值</strong>：影子内存中的值表示主内存的状态。例如，0表示所有8个字节都是合法的，负值表示不合法的访问，正值表示部分合法访问。</li>\n</ul>\n<h3 id=\"3-内存分配和释放\"><a href=\"#3-内存分配和释放\" class=\"headerlink\" title=\"3. 内存分配和释放\"></a>3. 内存分配和释放</h3><p>ASan对内存分配和释放函数（如<code>malloc</code>和<code>free</code>）进行重载，以维护内存区域的元数据。这些元数据包括：</p>\n<ul>\n<li><strong>红色区域（Redzones）</strong>：在每个分配的内存块周围添加红色区域，用于检测缓冲区溢出。红色区域被标记为非法访问区域。</li>\n<li><strong>元数据</strong>：记录每个内存块的大小、分配堆栈等信息，以便在检测到错误时提供详细报告。</li>\n</ul>\n<h3 id=\"4-运行时检查\"><a href=\"#4-运行时检查\" class=\"headerlink\" title=\"4. 运行时检查\"></a>4. 运行时检查</h3><p>在运行时，ASan插入的检查代码会在每次内存访问时执行，检查访问的地址是否在合法范围内。如果访问非法区域，则报告错误并终止程序。</p>\n<ul>\n<li><strong>内存访问检查</strong>：每次内存读取或写入时，检查影子内存中的值，以确定访问是否合法。</li>\n<li><strong>错误报告</strong>：在检测到非法访问时，ASan会生成详细的错误报告，包含访问地址、内存块信息、调用堆栈等。</li>\n</ul>\n<h3 id=\"5-错误类型检测\"><a href=\"#5-错误类型检测\" class=\"headerlink\" title=\"5. 错误类型检测\"></a>5. 错误类型检测</h3><p>ASan能够检测多种类型的内存错误，包括：</p>\n<ul>\n<li><strong>缓冲区溢出</strong>：访问数组或内存块的边界外的区域。</li>\n<li><strong>使用未初始化内存</strong>：访问未初始化的内存。</li>\n<li><strong>使用已释放内存</strong>：访问已经释放的内存。</li>\n<li><strong>双重释放</strong>：重复释放同一块内存。</li>\n<li><strong>堆栈溢出</strong>：访问栈帧之外的内存。</li>\n</ul>\n<h3 id=\"6-性能与开销\"><a href=\"#6-性能与开销\" class=\"headerlink\" title=\"6. 性能与开销\"></a>6. 性能与开销</h3><p>ASan在检测内存错误时会引入一定的性能开销和内存开销：</p>\n<ul>\n<li><strong>性能开销</strong>：由于插入了额外的检查代码，程序的执行速度会有所降低。通常，ASan引入的性能开销在2-3倍左右。</li>\n<li><strong>内存开销</strong>：影子内存和红色区域会增加内存使用量，通常内存开销在2倍左右。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>AddressSanitizer通过编译时插桩、使用影子内存和运行时检查等机制，能够有效地检测和报告内存相关的错误。尽管引入了一定的性能和内存开销，但它在提高程序安全性和稳定性方面具有重要意义，是开发和调试C/C++程序的强大工具。</p>\n"},{"title":"c++ 11 智能指针","date":"2022-09-25T07:13:02.000Z","_content":"\n## 智能指针\n\n\n### share_ptr使用\n\n\n\n\n#### sharet_ptr<T>构造函数和std::make_share<T> 的区别\n1. 两个堆内存和一个堆内存，std::make_share效率更高\n2. \n\n\n\n### weak_ptr使用\n1. expired(),返回指向对堆对象是否释放\n2. use_count,share_ptr的强引用计数\n3. lock，返回share_ptr，如果释放，返回空\n4. \n\n\n\n### share_ptr线程安全话题\n1. share_ptr引用计数本身是线程安全的\n2. 一个share_ptr对象，在多个线程操作，不能保证线程安全\n3. share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全\n\n\n\n### stl容器多线程安全时的性能考虑\n\n\n### code使用\n```\nint main()\n{\n    shared_ptr<Person> person1;\n    \n    shared_ptr<Person> person2(nullptr);\n    \n    shared_ptr<Person> person3(new Person(10));\n\n    shared_ptr<Person> person4 = std::make_shared<Person>(5); //效率更高，内存分布在一起\n    \n    shared_ptr<Person> person5(std::move(person3)); // person3无法再使用\n    \n    shared_ptr<Person> arary(new Person[10], deletePersonArray);\n    \n    weak_ptr<Person> weak_Person = person5;\n    \n    cout << weak_Person.use_count() << endl;\n    \n    shared_ptr<Person> person6 = person5;\n    \n    cout << weak_Person.use_count() << endl;\n    \n    person5.reset();\n    \n    cout << weak_Person.use_count() << endl;\n    \n    person6.reset();\n    \n    if (weak_Person.expired()) {\n        cout << weak_Person.use_count() << endl;\n        \n        auto shareptr = weak_Person.lock();\n        \n        cout << shareptr << endl;\n    }\n    \n    return 0;\n    \n}\n\n```\n\n","source":"_posts/C++-智能指针.md","raw":"---\ntitle: c++ 11 智能指针\ndate: 2022-09-25 15:13:02\ntags: C++11\n---\n\n## 智能指针\n\n\n### share_ptr使用\n\n\n\n\n#### sharet_ptr<T>构造函数和std::make_share<T> 的区别\n1. 两个堆内存和一个堆内存，std::make_share效率更高\n2. \n\n\n\n### weak_ptr使用\n1. expired(),返回指向对堆对象是否释放\n2. use_count,share_ptr的强引用计数\n3. lock，返回share_ptr，如果释放，返回空\n4. \n\n\n\n### share_ptr线程安全话题\n1. share_ptr引用计数本身是线程安全的\n2. 一个share_ptr对象，在多个线程操作，不能保证线程安全\n3. share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全\n\n\n\n### stl容器多线程安全时的性能考虑\n\n\n### code使用\n```\nint main()\n{\n    shared_ptr<Person> person1;\n    \n    shared_ptr<Person> person2(nullptr);\n    \n    shared_ptr<Person> person3(new Person(10));\n\n    shared_ptr<Person> person4 = std::make_shared<Person>(5); //效率更高，内存分布在一起\n    \n    shared_ptr<Person> person5(std::move(person3)); // person3无法再使用\n    \n    shared_ptr<Person> arary(new Person[10], deletePersonArray);\n    \n    weak_ptr<Person> weak_Person = person5;\n    \n    cout << weak_Person.use_count() << endl;\n    \n    shared_ptr<Person> person6 = person5;\n    \n    cout << weak_Person.use_count() << endl;\n    \n    person5.reset();\n    \n    cout << weak_Person.use_count() << endl;\n    \n    person6.reset();\n    \n    if (weak_Person.expired()) {\n        cout << weak_Person.use_count() << endl;\n        \n        auto shareptr = weak_Person.lock();\n        \n        cout << shareptr << endl;\n    }\n    \n    return 0;\n    \n}\n\n```\n\n","slug":"C++-智能指针","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l99x0005gccoao9k67y8","content":"<h2 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h2><h3 id=\"share-ptr使用\"><a href=\"#share-ptr使用\" class=\"headerlink\" title=\"share_ptr使用\"></a>share_ptr使用</h3><h4 id=\"sharet-ptr构造函数和std-make-share-的区别\"><a href=\"#sharet-ptr构造函数和std-make-share-的区别\" class=\"headerlink\" title=\"sharet_ptr构造函数和std::make_share 的区别\"></a>sharet_ptr<T>构造函数和std::make_share<T> 的区别</h4><ol>\n<li>两个堆内存和一个堆内存，std::make_share效率更高</li>\n<li></li>\n</ol>\n<h3 id=\"weak-ptr使用\"><a href=\"#weak-ptr使用\" class=\"headerlink\" title=\"weak_ptr使用\"></a>weak_ptr使用</h3><ol>\n<li>expired(),返回指向对堆对象是否释放</li>\n<li>use_count,share_ptr的强引用计数</li>\n<li>lock，返回share_ptr，如果释放，返回空</li>\n<li></li>\n</ol>\n<h3 id=\"share-ptr线程安全话题\"><a href=\"#share-ptr线程安全话题\" class=\"headerlink\" title=\"share_ptr线程安全话题\"></a>share_ptr线程安全话题</h3><ol>\n<li>share_ptr引用计数本身是线程安全的</li>\n<li>一个share_ptr对象，在多个线程操作，不能保证线程安全</li>\n<li>share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全</li>\n</ol>\n<h3 id=\"stl容器多线程安全时的性能考虑\"><a href=\"#stl容器多线程安全时的性能考虑\" class=\"headerlink\" title=\"stl容器多线程安全时的性能考虑\"></a>stl容器多线程安全时的性能考虑</h3><h3 id=\"code使用\"><a href=\"#code使用\" class=\"headerlink\" title=\"code使用\"></a>code使用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person2(nullptr);</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person3(new Person(10));</span><br><span class=\"line\"></span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person4 = std::make_shared&lt;Person&gt;(5); //效率更高，内存分布在一起</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person5(std::move(person3)); // person3无法再使用</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; arary(new Person[10], deletePersonArray);</span><br><span class=\"line\">    </span><br><span class=\"line\">    weak_ptr&lt;Person&gt; weak_Person = person5;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person6 = person5;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    person5.reset();</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    person6.reset();</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (weak_Person.expired()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">        </span><br><span class=\"line\">        auto shareptr = weak_Person.lock();</span><br><span class=\"line\">        </span><br><span class=\"line\">        cout &lt;&lt; shareptr &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h2><h3 id=\"share-ptr使用\"><a href=\"#share-ptr使用\" class=\"headerlink\" title=\"share_ptr使用\"></a>share_ptr使用</h3><h4 id=\"sharet-ptr构造函数和std-make-share-的区别\"><a href=\"#sharet-ptr构造函数和std-make-share-的区别\" class=\"headerlink\" title=\"sharet_ptr构造函数和std::make_share 的区别\"></a>sharet_ptr<T>构造函数和std::make_share<T> 的区别</h4><ol>\n<li>两个堆内存和一个堆内存，std::make_share效率更高</li>\n<li></li>\n</ol>\n<h3 id=\"weak-ptr使用\"><a href=\"#weak-ptr使用\" class=\"headerlink\" title=\"weak_ptr使用\"></a>weak_ptr使用</h3><ol>\n<li>expired(),返回指向对堆对象是否释放</li>\n<li>use_count,share_ptr的强引用计数</li>\n<li>lock，返回share_ptr，如果释放，返回空</li>\n<li></li>\n</ol>\n<h3 id=\"share-ptr线程安全话题\"><a href=\"#share-ptr线程安全话题\" class=\"headerlink\" title=\"share_ptr线程安全话题\"></a>share_ptr线程安全话题</h3><ol>\n<li>share_ptr引用计数本身是线程安全的</li>\n<li>一个share_ptr对象，在多个线程操作，不能保证线程安全</li>\n<li>share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全</li>\n</ol>\n<h3 id=\"stl容器多线程安全时的性能考虑\"><a href=\"#stl容器多线程安全时的性能考虑\" class=\"headerlink\" title=\"stl容器多线程安全时的性能考虑\"></a>stl容器多线程安全时的性能考虑</h3><h3 id=\"code使用\"><a href=\"#code使用\" class=\"headerlink\" title=\"code使用\"></a>code使用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person2(nullptr);</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person3(new Person(10));</span><br><span class=\"line\"></span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person4 = std::make_shared&lt;Person&gt;(5); //效率更高，内存分布在一起</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person5(std::move(person3)); // person3无法再使用</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; arary(new Person[10], deletePersonArray);</span><br><span class=\"line\">    </span><br><span class=\"line\">    weak_ptr&lt;Person&gt; weak_Person = person5;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person6 = person5;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    person5.reset();</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    person6.reset();</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (weak_Person.expired()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">        </span><br><span class=\"line\">        auto shareptr = weak_Person.lock();</span><br><span class=\"line\">        </span><br><span class=\"line\">        cout &lt;&lt; shareptr &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"c++中operator的重载","date":"2022-09-18T07:10:20.000Z","_content":"\n## 两种函数允许编译器进行隐士类型转换\n1. 单一参数调用成功的constructors\n2. 隐士转换操作符\n\n```\nclass Ration {\npublic:\n    //1 隐士构造函数\n    Ration(int a) {\n        \n    }\n    //2 隐士类型转换函数\n    operator double() const {\n        return 5.0f;\n    }\n};\n\n\nint main()\n{\n    Ration ration(1);\n    cout << ration << endl;\n    return 0;\n}\n```\n\n### 如何阻止构造函数发生不期望的隐士类型转换\n```\nclass Ration {\npublic:\n    explicit Ration(int a) {\n        \n    }\n};\n\nint main()\n{\n    Ration ration(1);\n    \n    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错\n    if (ration == 2) {\n        \n    }\n    return 0;\n}\n```\n\n### 重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 && || 操作符， 原因是改变了短路运算的语义，变成函数调用。\n\n#### 这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\n\n\n###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数\n```\nclass Ration {\npublic:\n    explicit Ration(int a) {\n        \n    }\n    \n    int operator() (int a , int b, int c)\n    {\n        return 10;\n    }\n    \n    int operator() (int a , int b)\n    {\n        return 5;\n    }\n};\n\nint main()\n{\n    Ration ration(1);\n    ration(1, 2, 3);\n    ration(1, 3);\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/C++中operator的重载.md","raw":"---\ntitle: c++中operator的重载\ndate: 2022-09-18 15:10:20\ntags: C++11\n---\n\n## 两种函数允许编译器进行隐士类型转换\n1. 单一参数调用成功的constructors\n2. 隐士转换操作符\n\n```\nclass Ration {\npublic:\n    //1 隐士构造函数\n    Ration(int a) {\n        \n    }\n    //2 隐士类型转换函数\n    operator double() const {\n        return 5.0f;\n    }\n};\n\n\nint main()\n{\n    Ration ration(1);\n    cout << ration << endl;\n    return 0;\n}\n```\n\n### 如何阻止构造函数发生不期望的隐士类型转换\n```\nclass Ration {\npublic:\n    explicit Ration(int a) {\n        \n    }\n};\n\nint main()\n{\n    Ration ration(1);\n    \n    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错\n    if (ration == 2) {\n        \n    }\n    return 0;\n}\n```\n\n### 重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 && || 操作符， 原因是改变了短路运算的语义，变成函数调用。\n\n#### 这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\n\n\n###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数\n```\nclass Ration {\npublic:\n    explicit Ration(int a) {\n        \n    }\n    \n    int operator() (int a , int b, int c)\n    {\n        return 10;\n    }\n    \n    int operator() (int a , int b)\n    {\n        return 5;\n    }\n};\n\nint main()\n{\n    Ration ration(1);\n    ration(1, 2, 3);\n    ration(1, 3);\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"C++中operator的重载","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l99x0006gccodegh69uj","content":"<h2 id=\"两种函数允许编译器进行隐士类型转换\"><a href=\"#两种函数允许编译器进行隐士类型转换\" class=\"headerlink\" title=\"两种函数允许编译器进行隐士类型转换\"></a>两种函数允许编译器进行隐士类型转换</h2><ol>\n<li>单一参数调用成功的constructors</li>\n<li>隐士转换操作符</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //1 隐士构造函数</span><br><span class=\"line\">    Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //2 隐士类型转换函数</span><br><span class=\"line\">    operator double() const &#123;</span><br><span class=\"line\">        return 5.0f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    cout &lt;&lt; ration &lt;&lt; endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如何阻止构造函数发生不期望的隐士类型转换\"><a href=\"#如何阻止构造函数发生不期望的隐士类型转换\" class=\"headerlink\" title=\"如何阻止构造函数发生不期望的隐士类型转换\"></a>如何阻止构造函数发生不期望的隐士类型转换</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错</span><br><span class=\"line\">    if (ration == 2) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。\"><a href=\"#重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。\" class=\"headerlink\" title=\"重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。\"></a>重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。</h3><h4 id=\"这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\"><a href=\"#这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\" class=\"headerlink\" title=\"这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\"></a>这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。</h4><p>###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int operator() (int a , int b, int c)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int operator() (int a , int b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    ration(1, 2, 3);</span><br><span class=\"line\">    ration(1, 3);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"两种函数允许编译器进行隐士类型转换\"><a href=\"#两种函数允许编译器进行隐士类型转换\" class=\"headerlink\" title=\"两种函数允许编译器进行隐士类型转换\"></a>两种函数允许编译器进行隐士类型转换</h2><ol>\n<li>单一参数调用成功的constructors</li>\n<li>隐士转换操作符</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //1 隐士构造函数</span><br><span class=\"line\">    Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //2 隐士类型转换函数</span><br><span class=\"line\">    operator double() const &#123;</span><br><span class=\"line\">        return 5.0f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    cout &lt;&lt; ration &lt;&lt; endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如何阻止构造函数发生不期望的隐士类型转换\"><a href=\"#如何阻止构造函数发生不期望的隐士类型转换\" class=\"headerlink\" title=\"如何阻止构造函数发生不期望的隐士类型转换\"></a>如何阻止构造函数发生不期望的隐士类型转换</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错</span><br><span class=\"line\">    if (ration == 2) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。\"><a href=\"#重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。\" class=\"headerlink\" title=\"重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。\"></a>重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。</h3><h4 id=\"这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\"><a href=\"#这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\" class=\"headerlink\" title=\"这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\"></a>这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。</h4><p>###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int operator() (int a , int b, int c)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int operator() (int a , int b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    ration(1, 2, 3);</span><br><span class=\"line\">    ration(1, 3);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"c++ 右值引用","date":"2022-09-18T08:15:56.000Z","_content":"\n### 1. 什么是右值？\n有名称，可以取地址的值，是左值。\n没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。\nc++11中，所有的值，必属于左值，将亡值，和纯右值。\n\n\n\n### 2. 左值引用，右值引用\n\n```\nint main() {\n    \n    int a = 0; //ok\n    \n    int& b = a; //ok,左值引用\n    int& c = 0; // not ok,左值引用无法引用右值\n    \n    const int& d = 0; // ok，常左值引用，可以绑定右值\n    const int& e = a; // ok，常左值引用，可以绑定左值\n    \n    int&& f = 0;//ok 右值引用绑定右值\n    const int && g = 0; // ok,常右值引用可以绑定右值\n    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗\n    \n    int&& h = a;//not ok，右值引用无法绑定左值\n    \n    return 0;\n}\n```\n左值引用，只能绑定左值\n常左值引用，可以绑定常量左值，右值，非常量左值和右值\n右值引用，只能绑定非常量右值\n常右值引用，可以绑定常量右值，非常量右值\n\n\n### 3. 讨论右值引用，要注意排除返回值优化\n如果关闭返回值优化，可以参考\n<https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO>\n\n```\nPerson GetPerson(){\n    return Person();\n}\n\nint main()\n{\n    Person person = GetPerson();\n    person.print();\n    \n    /*\n     一共执行三次构造\n    1 Person()默认构造函数\n    2 GetPerson函数返回时，生成临时对象，调用移动构造函数\n    3 使用临时对象，构造person，调用移动构造函数\n     */\n    return 0;\n}\n```\n\n\n```\nPerson&& GetPerson(){\n    return Person();\n}\n\nint main()\n{\n    Person person = GetPerson();\n    person.print();\n    \n    /*\n     一共执行两次次构造，这种写法是错的，会有warnning\n     Returning reference to local temporary object\n    1 Person()默认构造函数\n    2 右值引用，引用了已经析构的临时对象\n    3 使用临时对象，构造person，调用移动构造函数\n     */\n    return 0;\n}\n```\n\n### 4. 函数返回值，如果没有写左值引用，就是临时变量属于右值\n\n```\nPerson GetPerson(){\n    return Person();\n}\n\nint main() {\n    \n    Person person1 = GetPerson(); //调用一次构造，两次次移动构造\n    \n    Person&& person2 = GetPerson(); //调用一次构造，一次移动构造\n    \n    return 0;\n}\n```\n理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象\nperson2是直接对临时变量的右值引用\n\n#### 注意\n```\nconst Person& GetPerson1(){\n    return Person();\n}\n\nPerson&& GetPerson2(){\n    return Person();\n}\n```\n上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告\n\n`Returning reference to local temporary object`\n\n\n\n\n\n","source":"_posts/C++右值引用.md","raw":"---\ntitle: c++ 右值引用\ndate: 2022-09-18 16:15:56\ntags:\n\t- C++11\n---\n\n### 1. 什么是右值？\n有名称，可以取地址的值，是左值。\n没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。\nc++11中，所有的值，必属于左值，将亡值，和纯右值。\n\n\n\n### 2. 左值引用，右值引用\n\n```\nint main() {\n    \n    int a = 0; //ok\n    \n    int& b = a; //ok,左值引用\n    int& c = 0; // not ok,左值引用无法引用右值\n    \n    const int& d = 0; // ok，常左值引用，可以绑定右值\n    const int& e = a; // ok，常左值引用，可以绑定左值\n    \n    int&& f = 0;//ok 右值引用绑定右值\n    const int && g = 0; // ok,常右值引用可以绑定右值\n    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗\n    \n    int&& h = a;//not ok，右值引用无法绑定左值\n    \n    return 0;\n}\n```\n左值引用，只能绑定左值\n常左值引用，可以绑定常量左值，右值，非常量左值和右值\n右值引用，只能绑定非常量右值\n常右值引用，可以绑定常量右值，非常量右值\n\n\n### 3. 讨论右值引用，要注意排除返回值优化\n如果关闭返回值优化，可以参考\n<https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO>\n\n```\nPerson GetPerson(){\n    return Person();\n}\n\nint main()\n{\n    Person person = GetPerson();\n    person.print();\n    \n    /*\n     一共执行三次构造\n    1 Person()默认构造函数\n    2 GetPerson函数返回时，生成临时对象，调用移动构造函数\n    3 使用临时对象，构造person，调用移动构造函数\n     */\n    return 0;\n}\n```\n\n\n```\nPerson&& GetPerson(){\n    return Person();\n}\n\nint main()\n{\n    Person person = GetPerson();\n    person.print();\n    \n    /*\n     一共执行两次次构造，这种写法是错的，会有warnning\n     Returning reference to local temporary object\n    1 Person()默认构造函数\n    2 右值引用，引用了已经析构的临时对象\n    3 使用临时对象，构造person，调用移动构造函数\n     */\n    return 0;\n}\n```\n\n### 4. 函数返回值，如果没有写左值引用，就是临时变量属于右值\n\n```\nPerson GetPerson(){\n    return Person();\n}\n\nint main() {\n    \n    Person person1 = GetPerson(); //调用一次构造，两次次移动构造\n    \n    Person&& person2 = GetPerson(); //调用一次构造，一次移动构造\n    \n    return 0;\n}\n```\n理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象\nperson2是直接对临时变量的右值引用\n\n#### 注意\n```\nconst Person& GetPerson1(){\n    return Person();\n}\n\nPerson&& GetPerson2(){\n    return Person();\n}\n```\n上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告\n\n`Returning reference to local temporary object`\n\n\n\n\n\n","slug":"C++右值引用","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l99y0008gcco76pv0qwm","content":"<h3 id=\"1-什么是右值？\"><a href=\"#1-什么是右值？\" class=\"headerlink\" title=\"1. 什么是右值？\"></a>1. 什么是右值？</h3><p>有名称，可以取地址的值，是左值。<br>没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。<br>c++11中，所有的值，必属于左值，将亡值，和纯右值。</p>\n<h3 id=\"2-左值引用，右值引用\"><a href=\"#2-左值引用，右值引用\" class=\"headerlink\" title=\"2. 左值引用，右值引用\"></a>2. 左值引用，右值引用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int a = 0; //ok</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp; b = a; //ok,左值引用</span><br><span class=\"line\">    int&amp; c = 0; // not ok,左值引用无法引用右值</span><br><span class=\"line\">    </span><br><span class=\"line\">    const int&amp; d = 0; // ok，常左值引用，可以绑定右值</span><br><span class=\"line\">    const int&amp; e = a; // ok，常左值引用，可以绑定左值</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp;&amp; f = 0;//ok 右值引用绑定右值</span><br><span class=\"line\">    const int &amp;&amp; g = 0; // ok,常右值引用可以绑定右值</span><br><span class=\"line\">    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp;&amp; h = a;//not ok，右值引用无法绑定左值</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>左值引用，只能绑定左值<br>常左值引用，可以绑定常量左值，右值，非常量左值和右值<br>右值引用，只能绑定非常量右值<br>常右值引用，可以绑定常量右值，非常量右值</p>\n<h3 id=\"3-讨论右值引用，要注意排除返回值优化\"><a href=\"#3-讨论右值引用，要注意排除返回值优化\" class=\"headerlink\" title=\"3. 讨论右值引用，要注意排除返回值优化\"></a>3. 讨论右值引用，要注意排除返回值优化</h3><p>如果关闭返回值优化，可以参考<br><a href=\"https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO\">https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person = GetPerson();</span><br><span class=\"line\">    person.print();</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     一共执行三次构造</span><br><span class=\"line\">    1 Person()默认构造函数</span><br><span class=\"line\">    2 GetPerson函数返回时，生成临时对象，调用移动构造函数</span><br><span class=\"line\">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person&amp;&amp; GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person = GetPerson();</span><br><span class=\"line\">    person.print();</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     一共执行两次次构造，这种写法是错的，会有warnning</span><br><span class=\"line\">     Returning reference to local temporary object</span><br><span class=\"line\">    1 Person()默认构造函数</span><br><span class=\"line\">    2 右值引用，引用了已经析构的临时对象</span><br><span class=\"line\">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-函数返回值，如果没有写左值引用，就是临时变量属于右值\"><a href=\"#4-函数返回值，如果没有写左值引用，就是临时变量属于右值\" class=\"headerlink\" title=\"4. 函数返回值，如果没有写左值引用，就是临时变量属于右值\"></a>4. 函数返回值，如果没有写左值引用，就是临时变量属于右值</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person person1 = GetPerson(); //调用一次构造，两次次移动构造</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person&amp;&amp; person2 = GetPerson(); //调用一次构造，一次移动构造</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象<br>person2是直接对临时变量的右值引用</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Person&amp; GetPerson1()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person&amp;&amp; GetPerson2()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告</p>\n<p><code>Returning reference to local temporary object</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-什么是右值？\"><a href=\"#1-什么是右值？\" class=\"headerlink\" title=\"1. 什么是右值？\"></a>1. 什么是右值？</h3><p>有名称，可以取地址的值，是左值。<br>没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。<br>c++11中，所有的值，必属于左值，将亡值，和纯右值。</p>\n<h3 id=\"2-左值引用，右值引用\"><a href=\"#2-左值引用，右值引用\" class=\"headerlink\" title=\"2. 左值引用，右值引用\"></a>2. 左值引用，右值引用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int a = 0; //ok</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp; b = a; //ok,左值引用</span><br><span class=\"line\">    int&amp; c = 0; // not ok,左值引用无法引用右值</span><br><span class=\"line\">    </span><br><span class=\"line\">    const int&amp; d = 0; // ok，常左值引用，可以绑定右值</span><br><span class=\"line\">    const int&amp; e = a; // ok，常左值引用，可以绑定左值</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp;&amp; f = 0;//ok 右值引用绑定右值</span><br><span class=\"line\">    const int &amp;&amp; g = 0; // ok,常右值引用可以绑定右值</span><br><span class=\"line\">    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp;&amp; h = a;//not ok，右值引用无法绑定左值</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>左值引用，只能绑定左值<br>常左值引用，可以绑定常量左值，右值，非常量左值和右值<br>右值引用，只能绑定非常量右值<br>常右值引用，可以绑定常量右值，非常量右值</p>\n<h3 id=\"3-讨论右值引用，要注意排除返回值优化\"><a href=\"#3-讨论右值引用，要注意排除返回值优化\" class=\"headerlink\" title=\"3. 讨论右值引用，要注意排除返回值优化\"></a>3. 讨论右值引用，要注意排除返回值优化</h3><p>如果关闭返回值优化，可以参考<br><a href=\"https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO\">https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person = GetPerson();</span><br><span class=\"line\">    person.print();</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     一共执行三次构造</span><br><span class=\"line\">    1 Person()默认构造函数</span><br><span class=\"line\">    2 GetPerson函数返回时，生成临时对象，调用移动构造函数</span><br><span class=\"line\">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person&amp;&amp; GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person = GetPerson();</span><br><span class=\"line\">    person.print();</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     一共执行两次次构造，这种写法是错的，会有warnning</span><br><span class=\"line\">     Returning reference to local temporary object</span><br><span class=\"line\">    1 Person()默认构造函数</span><br><span class=\"line\">    2 右值引用，引用了已经析构的临时对象</span><br><span class=\"line\">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-函数返回值，如果没有写左值引用，就是临时变量属于右值\"><a href=\"#4-函数返回值，如果没有写左值引用，就是临时变量属于右值\" class=\"headerlink\" title=\"4. 函数返回值，如果没有写左值引用，就是临时变量属于右值\"></a>4. 函数返回值，如果没有写左值引用，就是临时变量属于右值</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person person1 = GetPerson(); //调用一次构造，两次次移动构造</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person&amp;&amp; person2 = GetPerson(); //调用一次构造，一次移动构造</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象<br>person2是直接对临时变量的右值引用</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Person&amp; GetPerson1()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person&amp;&amp; GetPerson2()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告</p>\n<p><code>Returning reference to local temporary object</code></p>\n"},{"title":"实现完美转发","date":"2022-10-23T12:36:59.000Z","_content":"\n\n### 什么是完美转发？\n\n#### 在理解什么是完美转发之前，需要知道什么是万能引用?\n在模板推导过程中，使用T&& a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。\n\n```\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    cout << a << endl;\n    cout << b << endl;\n}\n\nint main() {\n    \n    Add(4, 5); // a，b的类型会被推导成int&&\n    int a = 0;\n    int b = 0;\n    Add(a, b); // a，b的类型会被推导成int&\n    \n    return 0;\n}\n```\n根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用\n\n\n#### 万能引用遇到的问题？\n上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.\n```\ntemplate <typename T>\nvoid AddImp(T&& a, T&& b) {\n    cout << a << endl;\n    cout << b << endl;\n}\n\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    AddImp(a, b);\n}\n\nint main() {\n    \n    Add(4, 5);\n    int a = 0;\n    int b = 0;\n    Add(a, b);\n    \n    return 0;\n}\n```\n\n#### 解决方案: std::forward<T>\n```\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    AddImp(std::forward<T>(a), std::forward<T>(b));\n}\n\n```\nstd::forward的具体实现\n```\ntemplate <class _Tp>\n_Tp&& forward(typename remove_reference<_Tp>::type& __t) \n{\n  return static_cast<_Tp&&>(__t);\n}\n```\n\n具体分析一下，也是通过引用折叠来实现\n1. 如果_Tp的类型是int&， 通过引用折叠 int& && 折叠后是左值引用int&\n2. 如果_Tp的类型是int&&， 通过引用折叠 int&& && 折叠后是int&&\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/C++实现完美转发.md","raw":"---\ntitle: 实现完美转发\ndate: 2022-10-23 20:36:59\ntags: C++11\n---\n\n\n### 什么是完美转发？\n\n#### 在理解什么是完美转发之前，需要知道什么是万能引用?\n在模板推导过程中，使用T&& a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。\n\n```\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    cout << a << endl;\n    cout << b << endl;\n}\n\nint main() {\n    \n    Add(4, 5); // a，b的类型会被推导成int&&\n    int a = 0;\n    int b = 0;\n    Add(a, b); // a，b的类型会被推导成int&\n    \n    return 0;\n}\n```\n根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用\n\n\n#### 万能引用遇到的问题？\n上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.\n```\ntemplate <typename T>\nvoid AddImp(T&& a, T&& b) {\n    cout << a << endl;\n    cout << b << endl;\n}\n\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    AddImp(a, b);\n}\n\nint main() {\n    \n    Add(4, 5);\n    int a = 0;\n    int b = 0;\n    Add(a, b);\n    \n    return 0;\n}\n```\n\n#### 解决方案: std::forward<T>\n```\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    AddImp(std::forward<T>(a), std::forward<T>(b));\n}\n\n```\nstd::forward的具体实现\n```\ntemplate <class _Tp>\n_Tp&& forward(typename remove_reference<_Tp>::type& __t) \n{\n  return static_cast<_Tp&&>(__t);\n}\n```\n\n具体分析一下，也是通过引用折叠来实现\n1. 如果_Tp的类型是int&， 通过引用折叠 int& && 折叠后是左值引用int&\n2. 如果_Tp的类型是int&&， 通过引用折叠 int&& && 折叠后是int&&\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"C++实现完美转发","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l99y0009gcco2xo585f2","content":"<h3 id=\"什么是完美转发？\"><a href=\"#什么是完美转发？\" class=\"headerlink\" title=\"什么是完美转发？\"></a>什么是完美转发？</h3><h4 id=\"在理解什么是完美转发之前，需要知道什么是万能引用\"><a href=\"#在理解什么是完美转发之前，需要知道什么是万能引用\" class=\"headerlink\" title=\"在理解什么是完美转发之前，需要知道什么是万能引用?\"></a>在理解什么是完美转发之前，需要知道什么是万能引用?</h4><p>在模板推导过程中，使用T&amp;&amp; a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Add(4, 5); // a，b的类型会被推导成int&amp;&amp;</span><br><span class=\"line\">    int a = 0;</span><br><span class=\"line\">    int b = 0;</span><br><span class=\"line\">    Add(a, b); // a，b的类型会被推导成int&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用</p>\n<h4 id=\"万能引用遇到的问题？\"><a href=\"#万能引用遇到的问题？\" class=\"headerlink\" title=\"万能引用遇到的问题？\"></a>万能引用遇到的问题？</h4><p>上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void AddImp(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    AddImp(a, b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Add(4, 5);</span><br><span class=\"line\">    int a = 0;</span><br><span class=\"line\">    int b = 0;</span><br><span class=\"line\">    Add(a, b);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"解决方案-std-forward\"><a href=\"#解决方案-std-forward\" class=\"headerlink\" title=\"解决方案: std::forward\"></a>解决方案: std::forward<T></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    AddImp(std::forward&lt;T&gt;(a), std::forward&lt;T&gt;(b));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>std::forward的具体实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class _Tp&gt;</span><br><span class=\"line\">_Tp&amp;&amp; forward(typename remove_reference&lt;_Tp&gt;::type&amp; __t) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体分析一下，也是通过引用折叠来实现</p>\n<ol>\n<li>如果_Tp的类型是int&amp;， 通过引用折叠 int&amp; &amp;&amp; 折叠后是左值引用int&amp;</li>\n<li>如果_Tp的类型是int&amp;&amp;， 通过引用折叠 int&amp;&amp; &amp;&amp; 折叠后是int&amp;&amp;</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是完美转发？\"><a href=\"#什么是完美转发？\" class=\"headerlink\" title=\"什么是完美转发？\"></a>什么是完美转发？</h3><h4 id=\"在理解什么是完美转发之前，需要知道什么是万能引用\"><a href=\"#在理解什么是完美转发之前，需要知道什么是万能引用\" class=\"headerlink\" title=\"在理解什么是完美转发之前，需要知道什么是万能引用?\"></a>在理解什么是完美转发之前，需要知道什么是万能引用?</h4><p>在模板推导过程中，使用T&amp;&amp; a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Add(4, 5); // a，b的类型会被推导成int&amp;&amp;</span><br><span class=\"line\">    int a = 0;</span><br><span class=\"line\">    int b = 0;</span><br><span class=\"line\">    Add(a, b); // a，b的类型会被推导成int&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用</p>\n<h4 id=\"万能引用遇到的问题？\"><a href=\"#万能引用遇到的问题？\" class=\"headerlink\" title=\"万能引用遇到的问题？\"></a>万能引用遇到的问题？</h4><p>上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void AddImp(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    AddImp(a, b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Add(4, 5);</span><br><span class=\"line\">    int a = 0;</span><br><span class=\"line\">    int b = 0;</span><br><span class=\"line\">    Add(a, b);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"解决方案-std-forward\"><a href=\"#解决方案-std-forward\" class=\"headerlink\" title=\"解决方案: std::forward\"></a>解决方案: std::forward<T></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    AddImp(std::forward&lt;T&gt;(a), std::forward&lt;T&gt;(b));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>std::forward的具体实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class _Tp&gt;</span><br><span class=\"line\">_Tp&amp;&amp; forward(typename remove_reference&lt;_Tp&gt;::type&amp; __t) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体分析一下，也是通过引用折叠来实现</p>\n<ol>\n<li>如果_Tp的类型是int&amp;， 通过引用折叠 int&amp; &amp;&amp; 折叠后是左值引用int&amp;</li>\n<li>如果_Tp的类型是int&amp;&amp;， 通过引用折叠 int&amp;&amp; &amp;&amp; 折叠后是int&amp;&amp;</li>\n</ol>\n"},{"title":"C++ 构造函数","date":"2022-09-18T02:54:51.000Z","_content":"\n## C++ 构造函数\n\n1. 默认构造\n2. copy构造\n3. 移动构造\n4. operator= 赋值函数\n\n\n### 说明\n\n1. 对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用\n\n```\nclass Person\n{\npublic:\n    Person() {\n        cout << \"Person()\" << endl;\n    };\n    ~Person() {\n        cout << \"~Person()\" << endl;\n    };\n\n    Person(const Person& Person) {\n        cout << \"Person(Person& Person)\" << endl;\n    }\n    \n    Person(Person&& Person) {\n        cout << \"Person(Person&& Person)\" << endl;\n    }\n    \n    Person& operator=(const Person&)\n    {\n        cout << \"operator=(const Person&)\" << endl;\n        return *this;\n    }\n};\n\n```\n\n2. 对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。\n\n```\nclass Person\n{\npublic:\n//    Person() {\n//        cout << \"Person()\" << endl;\n//    };\n    ~Person() {\n        cout << \"~Person()\" << endl;\n    };\n\n//    Person(const Person& Person) {\n//        cout << \"Person(Person& Person)\" << endl;\n//    }\n\n    Person(Person&& Person) {\n        cout << \"Person(Person&& Person)\" << endl;\n    }\n\n    Person& operator=(const Person&)\n    {\n        cout << \"operator=(const Person&)\" << endl;\n        return *this;\n    }\n};\n\nint main()\n{\n    Person person; //编译报错，找不到匹配的构造函数\n    return 0;\n\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/C++构造函数.md","raw":"---\ntitle: C++ 构造函数\ndate: 2022-09-18 10:54:51\ntags: C++11\n---\n\n## C++ 构造函数\n\n1. 默认构造\n2. copy构造\n3. 移动构造\n4. operator= 赋值函数\n\n\n### 说明\n\n1. 对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用\n\n```\nclass Person\n{\npublic:\n    Person() {\n        cout << \"Person()\" << endl;\n    };\n    ~Person() {\n        cout << \"~Person()\" << endl;\n    };\n\n    Person(const Person& Person) {\n        cout << \"Person(Person& Person)\" << endl;\n    }\n    \n    Person(Person&& Person) {\n        cout << \"Person(Person&& Person)\" << endl;\n    }\n    \n    Person& operator=(const Person&)\n    {\n        cout << \"operator=(const Person&)\" << endl;\n        return *this;\n    }\n};\n\n```\n\n2. 对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。\n\n```\nclass Person\n{\npublic:\n//    Person() {\n//        cout << \"Person()\" << endl;\n//    };\n    ~Person() {\n        cout << \"~Person()\" << endl;\n    };\n\n//    Person(const Person& Person) {\n//        cout << \"Person(Person& Person)\" << endl;\n//    }\n\n    Person(Person&& Person) {\n        cout << \"Person(Person&& Person)\" << endl;\n    }\n\n    Person& operator=(const Person&)\n    {\n        cout << \"operator=(const Person&)\" << endl;\n        return *this;\n    }\n};\n\nint main()\n{\n    Person person; //编译报错，找不到匹配的构造函数\n    return 0;\n\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"C++构造函数","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l99y000agcco31tuhw0n","content":"<h2 id=\"C-构造函数\"><a href=\"#C-构造函数\" class=\"headerlink\" title=\"C++ 构造函数\"></a>C++ 构造函数</h2><ol>\n<li>默认构造</li>\n<li>copy构造</li>\n<li>移动构造</li>\n<li>operator= 赋值函数</li>\n</ol>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><ol>\n<li>对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(const Person&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person(Person&amp;&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person&amp; operator=(const Person&amp;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">//    Person() &#123;</span><br><span class=\"line\">//        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">//    &#125;;</span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//    Person(const Person&amp; Person) &#123;</span><br><span class=\"line\">//        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">//    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(Person&amp;&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person&amp; operator=(const Person&amp;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person; //编译报错，找不到匹配的构造函数</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-构造函数\"><a href=\"#C-构造函数\" class=\"headerlink\" title=\"C++ 构造函数\"></a>C++ 构造函数</h2><ol>\n<li>默认构造</li>\n<li>copy构造</li>\n<li>移动构造</li>\n<li>operator= 赋值函数</li>\n</ol>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><ol>\n<li>对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(const Person&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person(Person&amp;&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person&amp; operator=(const Person&amp;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">//    Person() &#123;</span><br><span class=\"line\">//        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">//    &#125;;</span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//    Person(const Person&amp; Person) &#123;</span><br><span class=\"line\">//        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">//    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(Person&amp;&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person&amp; operator=(const Person&amp;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person; //编译报错，找不到匹配的构造函数</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"layout":"post","title":"CALayer opaque","date":"2016-12-30T02:51:46.000Z","_content":"\n### 颜色合成公式\n\n**R = S + D \\* ( 1 – Sa )**\n\n ![20130819170332968](/Users/baidu/Downloads/20130819170332968.png)\n\n其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。\n\n设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算\n\n注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期\n","source":"_posts/CALayer-opaque.md","raw":"---\nlayout: post\ntitle: CALayer opaque\ndate: 2016-12-30 10:51:46\ntags: iOS\n\n---\n\n### 颜色合成公式\n\n**R = S + D \\* ( 1 – Sa )**\n\n ![20130819170332968](/Users/baidu/Downloads/20130819170332968.png)\n\n其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。\n\n设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算\n\n注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期\n","slug":"CALayer-opaque","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l99z000dgcco5n3u3h3g","content":"<h3 id=\"颜色合成公式\"><a href=\"#颜色合成公式\" class=\"headerlink\" title=\"颜色合成公式\"></a>颜色合成公式</h3><p><strong>R = S + D * ( 1 – Sa )</strong></p>\n<p> <img src=\"/Users/baidu/Downloads/20130819170332968.png\" alt=\"20130819170332968\"></p>\n<p>其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。</p>\n<p>设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算</p>\n<p>注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"颜色合成公式\"><a href=\"#颜色合成公式\" class=\"headerlink\" title=\"颜色合成公式\"></a>颜色合成公式</h3><p><strong>R = S + D * ( 1 – Sa )</strong></p>\n<p> <img src=\"/Users/baidu/Downloads/20130819170332968.png\" alt=\"20130819170332968\"></p>\n<p>其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。</p>\n<p>设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算</p>\n<p>注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期</p>\n"},{"layout":"post","title":"怎么build apple watch app","date":"2016-10-26T06:24:18.000Z","_content":"\n### step1\n\n在IphoneCom 的Embedded Binaries中添加Watch.app\n\n### step2\n\nRun IphoneCom\n\n### Step3\n\nrun WachApp\n","source":"_posts/How to build Apple Watch App.md","raw":"---\nlayout: post\ntitle: 怎么build apple watch app\ndate: 2016-10-26 14:24:18\ntags: iOS\n---\n\n### step1\n\n在IphoneCom 的Embedded Binaries中添加Watch.app\n\n### step2\n\nRun IphoneCom\n\n### Step3\n\nrun WachApp\n","slug":"How to build Apple Watch App","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l99z000fgccoa3jg8ecu","content":"<h3 id=\"step1\"><a href=\"#step1\" class=\"headerlink\" title=\"step1\"></a>step1</h3><p>在IphoneCom 的Embedded Binaries中添加Watch.app</p>\n<h3 id=\"step2\"><a href=\"#step2\" class=\"headerlink\" title=\"step2\"></a>step2</h3><p>Run IphoneCom</p>\n<h3 id=\"Step3\"><a href=\"#Step3\" class=\"headerlink\" title=\"Step3\"></a>Step3</h3><p>run WachApp</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"step1\"><a href=\"#step1\" class=\"headerlink\" title=\"step1\"></a>step1</h3><p>在IphoneCom 的Embedded Binaries中添加Watch.app</p>\n<h3 id=\"step2\"><a href=\"#step2\" class=\"headerlink\" title=\"step2\"></a>step2</h3><p>Run IphoneCom</p>\n<h3 id=\"Step3\"><a href=\"#Step3\" class=\"headerlink\" title=\"Step3\"></a>Step3</h3><p>run WachApp</p>\n"},{"layout":"post","title":"Mac环境下安装Ruby","subtitle":"ruby2.2","date":"2017-09-18T16:00:00.000Z","author":"jack","catalog":true,"_content":"\n## 使用rvm来安装ruby\n\n### step1\n```\n\t$ curl -L get.rvm.io | bash -s stable  \n```\n### step2  \n```\n\t$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  \n\t$ source ~/.bash_profile  \n\t$ rvm -v  \n```\t\n### step3  \n```\t\n\t$ rvm list known  \n```\t\n### step4\n```    \n\t$ rvm install 2.2.0  \n```\n\n### 如果Step4失败，可以进行如下尝试\n```\n\tsudo chown -R $(whoami):admin /usr/local\n\tcd /usr/local\n\tgit remote set-url origin git://mirrors.ustc.edu.cn/brew.git\n\tbrew update\n\tsudo chown root:wheel /usr/local\n\trvm install 2.2.0\n```\n","source":"_posts/MacOS下ruby安装.md","raw":"---\nlayout:     post\ntitle:      Mac环境下安装Ruby\nsubtitle:   ruby2.2\ndate:       2017-09-19\nauthor:     jack\ncatalog: true\ntags:\n    - iOS\n    - ruby\n---\n\n## 使用rvm来安装ruby\n\n### step1\n```\n\t$ curl -L get.rvm.io | bash -s stable  \n```\n### step2  \n```\n\t$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  \n\t$ source ~/.bash_profile  \n\t$ rvm -v  \n```\t\n### step3  \n```\t\n\t$ rvm list known  \n```\t\n### step4\n```    \n\t$ rvm install 2.2.0  \n```\n\n### 如果Step4失败，可以进行如下尝试\n```\n\tsudo chown -R $(whoami):admin /usr/local\n\tcd /usr/local\n\tgit remote set-url origin git://mirrors.ustc.edu.cn/brew.git\n\tbrew update\n\tsudo chown root:wheel /usr/local\n\trvm install 2.2.0\n```\n","slug":"MacOS下ruby安装","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a0000igcco5mwjdhkk","content":"<h2 id=\"使用rvm来安装ruby\"><a href=\"#使用rvm来安装ruby\" class=\"headerlink\" title=\"使用rvm来安装ruby\"></a>使用rvm来安装ruby</h2><h3 id=\"step1\"><a href=\"#step1\" class=\"headerlink\" title=\"step1\"></a>step1</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -L get.rvm.io | bash -s stable  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step2\"><a href=\"#step2\" class=\"headerlink\" title=\"step2\"></a>step2</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  </span><br><span class=\"line\">$ source ~/.bash_profile  </span><br><span class=\"line\">$ rvm -v  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step3\"><a href=\"#step3\" class=\"headerlink\" title=\"step3\"></a>step3</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rvm list known  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step4\"><a href=\"#step4\" class=\"headerlink\" title=\"step4\"></a>step4</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rvm install 2.2.0  </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如果Step4失败，可以进行如下尝试\"><a href=\"#如果Step4失败，可以进行如下尝试\" class=\"headerlink\" title=\"如果Step4失败，可以进行如下尝试\"></a>如果Step4失败，可以进行如下尝试</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown -R $(whoami):admin /usr/local</span><br><span class=\"line\">cd /usr/local</span><br><span class=\"line\">git remote set-url origin git://mirrors.ustc.edu.cn/brew.git</span><br><span class=\"line\">brew update</span><br><span class=\"line\">sudo chown root:wheel /usr/local</span><br><span class=\"line\">rvm install 2.2.0</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"使用rvm来安装ruby\"><a href=\"#使用rvm来安装ruby\" class=\"headerlink\" title=\"使用rvm来安装ruby\"></a>使用rvm来安装ruby</h2><h3 id=\"step1\"><a href=\"#step1\" class=\"headerlink\" title=\"step1\"></a>step1</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -L get.rvm.io | bash -s stable  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step2\"><a href=\"#step2\" class=\"headerlink\" title=\"step2\"></a>step2</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  </span><br><span class=\"line\">$ source ~/.bash_profile  </span><br><span class=\"line\">$ rvm -v  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step3\"><a href=\"#step3\" class=\"headerlink\" title=\"step3\"></a>step3</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rvm list known  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step4\"><a href=\"#step4\" class=\"headerlink\" title=\"step4\"></a>step4</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rvm install 2.2.0  </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如果Step4失败，可以进行如下尝试\"><a href=\"#如果Step4失败，可以进行如下尝试\" class=\"headerlink\" title=\"如果Step4失败，可以进行如下尝试\"></a>如果Step4失败，可以进行如下尝试</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown -R $(whoami):admin /usr/local</span><br><span class=\"line\">cd /usr/local</span><br><span class=\"line\">git remote set-url origin git://mirrors.ustc.edu.cn/brew.git</span><br><span class=\"line\">brew update</span><br><span class=\"line\">sudo chown root:wheel /usr/local</span><br><span class=\"line\">rvm install 2.2.0</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"iOSCALayer的presentLayer那点事","subtitle":"关于PresentLayer","date":"2017-11-11T16:00:00.000Z","author":"jack","header-img":"img/post-bg-ios9-web.jpg","catalog":true,"_content":"\n\n> 最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决\n\n\n\n### 动画过程中，如何获取它的实时位置\n\n这个话题涉及对CALayer的理解和使用\n\nCALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer\n\n\n\n- modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据\n- presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试\n\n\n\n```\nUIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];\n\n    view.backgroundColor = [UIColor redColor];\n\n    [self.view addSubview:view];\n\n    NSLog(@\"model   Layeer = %@\", NSStringFromCGRect([view.layer modelLayer].frame));\n\n    NSLog(@\"present Layeer = %@\", NSStringFromCGRect([view.layer presentationLayer].frame));\n\n    [UIView animateWithDuration:10 animations:^{\n\n        view.frame = CGRectMake(200, 100, 100, 100);\n        \n    } completion:^(BOOL finished) {\n    }];\n\n    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n    \n        NSLog(@\"model   Layeer = %@\", NSStringFromCGRect([view.layer modelLayer].frame));\n        NSLog(@\"present Layeer = %@\", NSStringFromCGRect([view.layer presentationLayer].frame));\n    }];\n\n```\n\n\n\n通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置\n","source":"_posts/CALayer的presentLayer那点事.md","raw":"---\nlayout:     post\ntitle:      iOSCALayer的presentLayer那点事\nsubtitle:   关于PresentLayer\ndate:       2017-11-12\nauthor:     jack\nheader-img: img/post-bg-ios9-web.jpg\ncatalog: true\ntags:\n    - iOS\n---\n\n\n> 最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决\n\n\n\n### 动画过程中，如何获取它的实时位置\n\n这个话题涉及对CALayer的理解和使用\n\nCALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer\n\n\n\n- modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据\n- presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试\n\n\n\n```\nUIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];\n\n    view.backgroundColor = [UIColor redColor];\n\n    [self.view addSubview:view];\n\n    NSLog(@\"model   Layeer = %@\", NSStringFromCGRect([view.layer modelLayer].frame));\n\n    NSLog(@\"present Layeer = %@\", NSStringFromCGRect([view.layer presentationLayer].frame));\n\n    [UIView animateWithDuration:10 animations:^{\n\n        view.frame = CGRectMake(200, 100, 100, 100);\n        \n    } completion:^(BOOL finished) {\n    }];\n\n    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n    \n        NSLog(@\"model   Layeer = %@\", NSStringFromCGRect([view.layer modelLayer].frame));\n        NSLog(@\"present Layeer = %@\", NSStringFromCGRect([view.layer presentationLayer].frame));\n    }];\n\n```\n\n\n\n通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置\n","slug":"CALayer的presentLayer那点事","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a0000kgcco8aga4w1m","content":"<blockquote>\n<p>最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决</p>\n</blockquote>\n<h3 id=\"动画过程中，如何获取它的实时位置\"><a href=\"#动画过程中，如何获取它的实时位置\" class=\"headerlink\" title=\"动画过程中，如何获取它的实时位置\"></a>动画过程中，如何获取它的实时位置</h3><p>这个话题涉及对CALayer的理解和使用</p>\n<p>CALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer</p>\n<ul>\n<li>modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据</li>\n<li>presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class=\"line\"></span><br><span class=\"line\">    view.backgroundColor = [UIColor redColor];</span><br><span class=\"line\"></span><br><span class=\"line\">    [self.view addSubview:view];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class=\"line\"></span><br><span class=\"line\">    [UIView animateWithDuration:10 animations:^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        view.frame = CGRectMake(200, 100, 100, 100);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; completion:^(BOOL finished) &#123;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class=\"line\">        NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决</p>\n</blockquote>\n<h3 id=\"动画过程中，如何获取它的实时位置\"><a href=\"#动画过程中，如何获取它的实时位置\" class=\"headerlink\" title=\"动画过程中，如何获取它的实时位置\"></a>动画过程中，如何获取它的实时位置</h3><p>这个话题涉及对CALayer的理解和使用</p>\n<p>CALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer</p>\n<ul>\n<li>modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据</li>\n<li>presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class=\"line\"></span><br><span class=\"line\">    view.backgroundColor = [UIColor redColor];</span><br><span class=\"line\"></span><br><span class=\"line\">    [self.view addSubview:view];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class=\"line\"></span><br><span class=\"line\">    [UIView animateWithDuration:10 animations:^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        view.frame = CGRectMake(200, 100, 100, 100);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; completion:^(BOOL finished) &#123;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class=\"line\">        NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置</p>\n"},{"layout":"post","title":"VBO","date":"2017-01-02T05:19:23.000Z","_content":"\n### VBO的目的：\n\n主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间\n\n两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER\n\n分别对应顶点数据和索引\n\n使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量\n\n### VBO使用的大概流程：\n\n```\n    //获取一个操作句柄\n    glGenBuffers(1, &_vertexBuffer);\n    //设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引\n    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);\n    //分配内存空间\n    glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);\n    \n    在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别\n    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);\n    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);\n    glEnableVertexAttribArray(_positionSlot);\n    \n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);\n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);\n    \n    //可以在清理时，释放VBO\n    glDeleteBuffers(1, &_vertexBuffer);\n    _vertexBuffer = 0;\n    \n    glDeleteBuffers(1, &_triangleIndexBuffer);\n    _triangleIndexBuffer = 0;\n    \n```\n\n","source":"_posts/OpenGL-VBO.md","raw":"---\nlayout: post\ntitle: VBO\ndate: 2017-01-02 13:19:23\ntags: openGL\n---\n\n### VBO的目的：\n\n主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间\n\n两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER\n\n分别对应顶点数据和索引\n\n使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量\n\n### VBO使用的大概流程：\n\n```\n    //获取一个操作句柄\n    glGenBuffers(1, &_vertexBuffer);\n    //设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引\n    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);\n    //分配内存空间\n    glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);\n    \n    在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别\n    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);\n    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);\n    glEnableVertexAttribArray(_positionSlot);\n    \n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);\n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);\n    \n    //可以在清理时，释放VBO\n    glDeleteBuffers(1, &_vertexBuffer);\n    _vertexBuffer = 0;\n    \n    glDeleteBuffers(1, &_triangleIndexBuffer);\n    _triangleIndexBuffer = 0;\n    \n```\n\n","slug":"OpenGL-VBO","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a0000ngccoacq405k4","content":"<h3 id=\"VBO的目的：\"><a href=\"#VBO的目的：\" class=\"headerlink\" title=\"VBO的目的：\"></a>VBO的目的：</h3><p>主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间</p>\n<p>两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER</p>\n<p>分别对应顶点数据和索引</p>\n<p>使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量</p>\n<h3 id=\"VBO使用的大概流程：\"><a href=\"#VBO使用的大概流程：\" class=\"headerlink\" title=\"VBO使用的大概流程：\"></a>VBO使用的大概流程：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取一个操作句柄</span><br><span class=\"line\">glGenBuffers(1, &amp;_vertexBuffer);</span><br><span class=\"line\">//设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class=\"line\">//分配内存空间</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class=\"line\">glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);</span><br><span class=\"line\">glEnableVertexAttribArray(_positionSlot);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//可以在清理时，释放VBO</span><br><span class=\"line\">glDeleteBuffers(1, &amp;_vertexBuffer);</span><br><span class=\"line\">_vertexBuffer = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">glDeleteBuffers(1, &amp;_triangleIndexBuffer);</span><br><span class=\"line\">_triangleIndexBuffer = 0;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"VBO的目的：\"><a href=\"#VBO的目的：\" class=\"headerlink\" title=\"VBO的目的：\"></a>VBO的目的：</h3><p>主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间</p>\n<p>两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER</p>\n<p>分别对应顶点数据和索引</p>\n<p>使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量</p>\n<h3 id=\"VBO使用的大概流程：\"><a href=\"#VBO使用的大概流程：\" class=\"headerlink\" title=\"VBO使用的大概流程：\"></a>VBO使用的大概流程：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取一个操作句柄</span><br><span class=\"line\">glGenBuffers(1, &amp;_vertexBuffer);</span><br><span class=\"line\">//设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class=\"line\">//分配内存空间</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class=\"line\">glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);</span><br><span class=\"line\">glEnableVertexAttribArray(_positionSlot);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//可以在清理时，释放VBO</span><br><span class=\"line\">glDeleteBuffers(1, &amp;_vertexBuffer);</span><br><span class=\"line\">_vertexBuffer = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">glDeleteBuffers(1, &amp;_triangleIndexBuffer);</span><br><span class=\"line\">_triangleIndexBuffer = 0;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"layout":"post","title":"CALayer属性positon和anchor","date":"2016-10-26T06:24:18.000Z","_content":"\n\n\n### CALayer 的frame，bounds, position和anchor\n\nframe描述的是在父layer上的坐标和尺寸\n\nbounds是类似于View的bounds\n\nanchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）\n\nposition描述的是anchor的在父layer的坐标\n\n\n\n举例来说，一个View的Frame是（40，40，100，100）\n\n那么layer的frame是（40，40，100，100）\n\nbound是（0，0，100，100）\n\nposition是：（140，140）\n\nposition计算：\n\npos.x = origin.x + anchor.x*size.with\n\npos.y = origin.y + anchor.y*size.height\n\n\n如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化\n\n如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可\n\n    CGRect oldFrame = _redView.frame;\n    _redView.layer.anchorPoint = CGPointMake(0.5, 1);\n    _redView.frame = oldFrame;\n注意，position并不适用这一点","source":"_posts/CALayer属性positon和anchor.md","raw":"---\nlayout: post\ntitle: CALayer属性positon和anchor\ndate: 2016-10-26 14:24:18\ntags: iOS\n---\n\n\n\n### CALayer 的frame，bounds, position和anchor\n\nframe描述的是在父layer上的坐标和尺寸\n\nbounds是类似于View的bounds\n\nanchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）\n\nposition描述的是anchor的在父layer的坐标\n\n\n\n举例来说，一个View的Frame是（40，40，100，100）\n\n那么layer的frame是（40，40，100，100）\n\nbound是（0，0，100，100）\n\nposition是：（140，140）\n\nposition计算：\n\npos.x = origin.x + anchor.x*size.with\n\npos.y = origin.y + anchor.y*size.height\n\n\n如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化\n\n如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可\n\n    CGRect oldFrame = _redView.frame;\n    _redView.layer.anchorPoint = CGPointMake(0.5, 1);\n    _redView.frame = oldFrame;\n注意，position并不适用这一点","slug":"CALayer属性positon和anchor","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a0000ogcco38by0lyh","content":"<h3 id=\"CALayer-的frame，bounds-position和anchor\"><a href=\"#CALayer-的frame，bounds-position和anchor\" class=\"headerlink\" title=\"CALayer 的frame，bounds, position和anchor\"></a>CALayer 的frame，bounds, position和anchor</h3><p>frame描述的是在父layer上的坐标和尺寸</p>\n<p>bounds是类似于View的bounds</p>\n<p>anchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）</p>\n<p>position描述的是anchor的在父layer的坐标</p>\n<p>举例来说，一个View的Frame是（40，40，100，100）</p>\n<p>那么layer的frame是（40，40，100，100）</p>\n<p>bound是（0，0，100，100）</p>\n<p>position是：（140，140）</p>\n<p>position计算：</p>\n<p>pos.x = origin.x + anchor.x*size.with</p>\n<p>pos.y = origin.y + anchor.y*size.height</p>\n<p>如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化</p>\n<p>如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可</p>\n<pre><code>CGRect oldFrame = _redView.frame;\n_redView.layer.anchorPoint = CGPointMake(0.5, 1);\n_redView.frame = oldFrame;\n</code></pre>\n<p>注意，position并不适用这一点</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"CALayer-的frame，bounds-position和anchor\"><a href=\"#CALayer-的frame，bounds-position和anchor\" class=\"headerlink\" title=\"CALayer 的frame，bounds, position和anchor\"></a>CALayer 的frame，bounds, position和anchor</h3><p>frame描述的是在父layer上的坐标和尺寸</p>\n<p>bounds是类似于View的bounds</p>\n<p>anchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）</p>\n<p>position描述的是anchor的在父layer的坐标</p>\n<p>举例来说，一个View的Frame是（40，40，100，100）</p>\n<p>那么layer的frame是（40，40，100，100）</p>\n<p>bound是（0，0，100，100）</p>\n<p>position是：（140，140）</p>\n<p>position计算：</p>\n<p>pos.x = origin.x + anchor.x*size.with</p>\n<p>pos.y = origin.y + anchor.y*size.height</p>\n<p>如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化</p>\n<p>如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可</p>\n<pre><code>CGRect oldFrame = _redView.frame;\n_redView.layer.anchorPoint = CGPointMake(0.5, 1);\n_redView.frame = oldFrame;\n</code></pre>\n<p>注意，position并不适用这一点</p>\n"},{"layout":"post","title":"uniform和attribute区别","date":"2016-12-30T08:17:50.000Z","_content":"\n#### 简单对比一下\n\nattribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用\n\nuniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用\n\n\n\n使用上的区别：\n\n1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法\n\n2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制\n\n3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements\n\n","source":"_posts/OpenGL-uniform和attribute.md","raw":"---\nlayout: post\ntitle: uniform和attribute区别\ndate: 2016-12-30 16:17:50\ntags: openGL\n---\n\n#### 简单对比一下\n\nattribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用\n\nuniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用\n\n\n\n使用上的区别：\n\n1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法\n\n2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制\n\n3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements\n\n","slug":"OpenGL-uniform和attribute","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a1000qgcco4vtb6d58","content":"<h4 id=\"简单对比一下\"><a href=\"#简单对比一下\" class=\"headerlink\" title=\"简单对比一下\"></a>简单对比一下</h4><p>attribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用</p>\n<p>uniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用</p>\n<p>使用上的区别：</p>\n<p>1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法</p>\n<p>2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制</p>\n<p>3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简单对比一下\"><a href=\"#简单对比一下\" class=\"headerlink\" title=\"简单对比一下\"></a>简单对比一下</h4><p>attribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用</p>\n<p>uniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用</p>\n<p>使用上的区别：</p>\n<p>1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法</p>\n<p>2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制</p>\n<p>3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements</p>\n"},{"layout":"post","title":"光照学习","date":"2017-01-02T05:43:54.000Z","_content":"\n### 基本概念\n\n1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性\n\n2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）\n\n3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射\n\n4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节\n\n\n\n### 光的计算：\n\n1 发射光计算：发射颜色=物体的发射材质颜色\n\n2 环境光计算\n\n环境颜色 = 光源的环境光颜色*物体的环境材质颜色\n\n3 漫反射计算：\n\n漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor\n\n其中DiffuseFactor = max（0，dot（N，L））\n\ndot表示两个向量夹角的cos\n\n4 镜面反射：\n\n镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor\n\nSpecularFactor = power（max（0， dot（N，H）），shininess）\n\nH = normalise（L+E）\n\n","source":"_posts/OpenGL-光照学习.md","raw":"---\nlayout: post\ntitle: 光照学习\ndate: 2017-01-02 13:43:54\ntags: openGL\n---\n\n### 基本概念\n\n1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性\n\n2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）\n\n3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射\n\n4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节\n\n\n\n### 光的计算：\n\n1 发射光计算：发射颜色=物体的发射材质颜色\n\n2 环境光计算\n\n环境颜色 = 光源的环境光颜色*物体的环境材质颜色\n\n3 漫反射计算：\n\n漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor\n\n其中DiffuseFactor = max（0，dot（N，L））\n\ndot表示两个向量夹角的cos\n\n4 镜面反射：\n\n镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor\n\nSpecularFactor = power（max（0， dot（N，H）），shininess）\n\nH = normalise（L+E）\n\n","slug":"OpenGL-光照学习","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a1000sgccocz2y68aj","content":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性</p>\n<p>2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）</p>\n<p>3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射</p>\n<p>4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节</p>\n<h3 id=\"光的计算：\"><a href=\"#光的计算：\" class=\"headerlink\" title=\"光的计算：\"></a>光的计算：</h3><p>1 发射光计算：发射颜色=物体的发射材质颜色</p>\n<p>2 环境光计算</p>\n<p>环境颜色 = 光源的环境光颜色*物体的环境材质颜色</p>\n<p>3 漫反射计算：</p>\n<p>漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor</p>\n<p>其中DiffuseFactor = max（0，dot（N，L））</p>\n<p>dot表示两个向量夹角的cos</p>\n<p>4 镜面反射：</p>\n<p>镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor</p>\n<p>SpecularFactor = power（max（0， dot（N，H）），shininess）</p>\n<p>H = normalise（L+E）</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性</p>\n<p>2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）</p>\n<p>3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射</p>\n<p>4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节</p>\n<h3 id=\"光的计算：\"><a href=\"#光的计算：\" class=\"headerlink\" title=\"光的计算：\"></a>光的计算：</h3><p>1 发射光计算：发射颜色=物体的发射材质颜色</p>\n<p>2 环境光计算</p>\n<p>环境颜色 = 光源的环境光颜色*物体的环境材质颜色</p>\n<p>3 漫反射计算：</p>\n<p>漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor</p>\n<p>其中DiffuseFactor = max（0，dot（N，L））</p>\n<p>dot表示两个向量夹角的cos</p>\n<p>4 镜面反射：</p>\n<p>镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor</p>\n<p>SpecularFactor = power（max（0， dot（N，H）），shininess）</p>\n<p>H = normalise（L+E）</p>\n"},{"layout":"post","title":"opengl iOS创建OpenGL环境绘制一个简单三角形","date":"2016-12-30T07:42:35.000Z","_content":"\n### EAGLView创建要点\n\n1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性\n\n```\n- (void)setupLayer{\n\n    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;\n    \n    layer.opaque = YES;\n    \n    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,\n                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];\n}\n```\n\n2  创建EAGLContext\n\n```\n_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];\n```\n\n3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：\n\na获取着色器源文件，创建shader，编译\n\nb创建program，attachShader，link，useProgram\n\nc从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)\n\n这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext\n\n4 每一帧绘制流程\n\n在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是\n\n```\n- (void)drawFrame{\n\n    [_eaglView setFramebuffer];\n    \n    [_eaglView draw];\n    \n    [_eaglView presentFramebuffer];\n}\n```\n\n5 关于frameBuffetObject的创建和释放\n\n前提：context确保设置\n\n流程大致是\n\n```\n- (void)createBuffer{\n    \n    [self checkContext];\n    \n    glGenRenderbuffers(1, &_colorRenderBuffer);\n    \n    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);\n    \n    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];\n    \n    glGenFramebuffers(1, &_frameBuffer);\n    \n    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);\n    \n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,\n    \t\t\t\t\t\tGL_RENDERBUFFER, _colorRenderBuffer);\n}\n\n- (void)deleteBuffer{\n\n    [self checkContext];\n    \n    glDeleteRenderbuffers(1, &_colorRenderBuffer);\n    \n    _colorRenderBuffer = 0;\n    \n    glDeleteFramebuffers(1, &_frameBuffer);\n    \n    _frameBuffer = 0;\n}\n\n- (void)setFramebuffer\n{\n    if ([self checkContext])\n    {\n        if (!_frameBuffer){\n            [self createBuffer];\n        }\n        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);\n    }\n}\n\n- (BOOL)presentFramebuffer\n{\n    BOOL success = FALSE;\n    \n    if ([self checkContext])\n    {\n        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);\n        \n        success = [_context presentRenderbuffer:GL_RENDERBUFFER];\n    }\n    return success;\n}\n```\n\n6 关于绘制三角形\n\n```\n- (void)draw{\n    //设置背景颜色为绿色\n    glClearColor(0, 1.0, 0,1.0);\n    glClear(GL_COLOR_BUFFER_BIT);\n    //设置管区域大小\n    glViewport(0, 0, self.frame.size.width, self.frame.size.height);\n    \n    GLfloat vertices[] = {\n        0.0f,  0.5f, 0.0f,\n        -0.5f, -0.5f, 0.0f,\n        0.5f,  -0.5f, 0.0f };\n    //设置着色器中的vPositon\n    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);\n    //使上一步的设置生效\n    glEnableVertexAttribArray(_positionSlot);\n    //绘制三角形\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n}\n```\n","source":"_posts/OpenGL-基本框架搭建和绘制一个简单图形.md","raw":"---\nlayout: post\ntitle: opengl iOS创建OpenGL环境绘制一个简单三角形\ndate: 2016-12-30 15:42:35\ntags: \n    - openGL \n    - iOS\n---\n\n### EAGLView创建要点\n\n1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性\n\n```\n- (void)setupLayer{\n\n    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;\n    \n    layer.opaque = YES;\n    \n    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,\n                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];\n}\n```\n\n2  创建EAGLContext\n\n```\n_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];\n```\n\n3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：\n\na获取着色器源文件，创建shader，编译\n\nb创建program，attachShader，link，useProgram\n\nc从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)\n\n这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext\n\n4 每一帧绘制流程\n\n在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是\n\n```\n- (void)drawFrame{\n\n    [_eaglView setFramebuffer];\n    \n    [_eaglView draw];\n    \n    [_eaglView presentFramebuffer];\n}\n```\n\n5 关于frameBuffetObject的创建和释放\n\n前提：context确保设置\n\n流程大致是\n\n```\n- (void)createBuffer{\n    \n    [self checkContext];\n    \n    glGenRenderbuffers(1, &_colorRenderBuffer);\n    \n    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);\n    \n    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];\n    \n    glGenFramebuffers(1, &_frameBuffer);\n    \n    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);\n    \n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,\n    \t\t\t\t\t\tGL_RENDERBUFFER, _colorRenderBuffer);\n}\n\n- (void)deleteBuffer{\n\n    [self checkContext];\n    \n    glDeleteRenderbuffers(1, &_colorRenderBuffer);\n    \n    _colorRenderBuffer = 0;\n    \n    glDeleteFramebuffers(1, &_frameBuffer);\n    \n    _frameBuffer = 0;\n}\n\n- (void)setFramebuffer\n{\n    if ([self checkContext])\n    {\n        if (!_frameBuffer){\n            [self createBuffer];\n        }\n        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);\n    }\n}\n\n- (BOOL)presentFramebuffer\n{\n    BOOL success = FALSE;\n    \n    if ([self checkContext])\n    {\n        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);\n        \n        success = [_context presentRenderbuffer:GL_RENDERBUFFER];\n    }\n    return success;\n}\n```\n\n6 关于绘制三角形\n\n```\n- (void)draw{\n    //设置背景颜色为绿色\n    glClearColor(0, 1.0, 0,1.0);\n    glClear(GL_COLOR_BUFFER_BIT);\n    //设置管区域大小\n    glViewport(0, 0, self.frame.size.width, self.frame.size.height);\n    \n    GLfloat vertices[] = {\n        0.0f,  0.5f, 0.0f,\n        -0.5f, -0.5f, 0.0f,\n        0.5f,  -0.5f, 0.0f };\n    //设置着色器中的vPositon\n    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);\n    //使上一步的设置生效\n    glEnableVertexAttribArray(_positionSlot);\n    //绘制三角形\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n}\n```\n","slug":"OpenGL-基本框架搭建和绘制一个简单图形","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a1000vgcco4gta1fs2","content":"<h3 id=\"EAGLView创建要点\"><a href=\"#EAGLView创建要点\" class=\"headerlink\" title=\"EAGLView创建要点\"></a>EAGLView创建要点</h3><p>1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setupLayer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    layer.opaque = YES;</span><br><span class=\"line\">    </span><br><span class=\"line\">    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,</span><br><span class=\"line\">                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2  创建EAGLContext</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br></pre></td></tr></table></figure>\n\n<p>3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：</p>\n<p>a获取着色器源文件，创建shader，编译</p>\n<p>b创建program，attachShader，link，useProgram</p>\n<p>c从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)</p>\n<p>这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext</p>\n<p>4 每一帧绘制流程</p>\n<p>在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)drawFrame&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [_eaglView setFramebuffer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_eaglView draw];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_eaglView presentFramebuffer];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5 关于frameBuffetObject的创建和释放</p>\n<p>前提：context确保设置</p>\n<p>流程大致是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)createBuffer&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self checkContext];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenFramebuffers(1, &amp;_frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class=\"line\">    \t\t\t\t\t\tGL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)deleteBuffer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [self checkContext];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDeleteRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    _colorRenderBuffer = 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDeleteFramebuffers(1, &amp;_frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    _frameBuffer = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setFramebuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if ([self checkContext])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (!_frameBuffer)&#123;</span><br><span class=\"line\">            [self createBuffer];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)presentFramebuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BOOL success = FALSE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if ([self checkContext])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">        </span><br><span class=\"line\">        success = [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return success;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6 关于绘制三角形</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)draw&#123;</span><br><span class=\"line\">    //设置背景颜色为绿色</span><br><span class=\"line\">    glClearColor(0, 1.0, 0,1.0);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    //设置管区域大小</span><br><span class=\"line\">    glViewport(0, 0, self.frame.size.width, self.frame.size.height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        0.0f,  0.5f, 0.0f,</span><br><span class=\"line\">        -0.5f, -0.5f, 0.0f,</span><br><span class=\"line\">        0.5f,  -0.5f, 0.0f &#125;;</span><br><span class=\"line\">    //设置着色器中的vPositon</span><br><span class=\"line\">    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);</span><br><span class=\"line\">    //使上一步的设置生效</span><br><span class=\"line\">    glEnableVertexAttribArray(_positionSlot);</span><br><span class=\"line\">    //绘制三角形</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"EAGLView创建要点\"><a href=\"#EAGLView创建要点\" class=\"headerlink\" title=\"EAGLView创建要点\"></a>EAGLView创建要点</h3><p>1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setupLayer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    layer.opaque = YES;</span><br><span class=\"line\">    </span><br><span class=\"line\">    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,</span><br><span class=\"line\">                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2  创建EAGLContext</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br></pre></td></tr></table></figure>\n\n<p>3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：</p>\n<p>a获取着色器源文件，创建shader，编译</p>\n<p>b创建program，attachShader，link，useProgram</p>\n<p>c从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)</p>\n<p>这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext</p>\n<p>4 每一帧绘制流程</p>\n<p>在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)drawFrame&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [_eaglView setFramebuffer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_eaglView draw];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_eaglView presentFramebuffer];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5 关于frameBuffetObject的创建和释放</p>\n<p>前提：context确保设置</p>\n<p>流程大致是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)createBuffer&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self checkContext];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenFramebuffers(1, &amp;_frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class=\"line\">    \t\t\t\t\t\tGL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)deleteBuffer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [self checkContext];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDeleteRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    _colorRenderBuffer = 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDeleteFramebuffers(1, &amp;_frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    _frameBuffer = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setFramebuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if ([self checkContext])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (!_frameBuffer)&#123;</span><br><span class=\"line\">            [self createBuffer];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)presentFramebuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BOOL success = FALSE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if ([self checkContext])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">        </span><br><span class=\"line\">        success = [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return success;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6 关于绘制三角形</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)draw&#123;</span><br><span class=\"line\">    //设置背景颜色为绿色</span><br><span class=\"line\">    glClearColor(0, 1.0, 0,1.0);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    //设置管区域大小</span><br><span class=\"line\">    glViewport(0, 0, self.frame.size.width, self.frame.size.height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        0.0f,  0.5f, 0.0f,</span><br><span class=\"line\">        -0.5f, -0.5f, 0.0f,</span><br><span class=\"line\">        0.5f,  -0.5f, 0.0f &#125;;</span><br><span class=\"line\">    //设置着色器中的vPositon</span><br><span class=\"line\">    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);</span><br><span class=\"line\">    //使上一步的设置生效</span><br><span class=\"line\">    glEnableVertexAttribArray(_positionSlot);</span><br><span class=\"line\">    //绘制三角形</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"纹理贴图","date":"2017-01-03T03:11:26.000Z","_content":"\n1 VertexShader\n\n```\nattribute vec2 TexCoordIn; // New\nvarying vec2 TexCoordOut; // New\n\nvoid main(void) { \n    DestinationColor = SourceColor; \n    gl_Position = Projection * Modelview * Position;\n    TexCoordOut = TexCoordIn; // New\n}\n```\n\n2 FragmentShader\n\n```\nvarying lowp vec4 DestinationColor;\nvarying lowp vec2 TexCoordOut; // New\nuniform sampler2D Texture; // New\n\nvoid main(void) {\n    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New\n}\n```\n\n3 将图片资源转换成位图数据，绑定到对应纹理ID中\n\n```\n+ (GLuint)createTextureWithImage:(UIImage *)image{\n    \n    //转换为CGImage，获取图片基本参数\n    CGImageRef cgImageRef = [image CGImage];\n    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);\n    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);\n    CGRect rect = CGRectMake(0, 0, width, height);\n    \n    //绘制图片\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    void *imageData = malloc(width * height * 4);\n    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);\n    CGContextTranslateCTM(context, 0, height);\n    CGContextScaleCTM(context, 1.0f, -1.0f);\n    CGColorSpaceRelease(colorSpace);\n    CGContextClearRect(context, rect);\n    CGContextDrawImage(context, rect, cgImageRef);\n    \n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_2D, textureID);\n    \n    //纹理一些设置，可有可无\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    \n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);\n    \n    glBindTexture(GL_TEXTURE_2D, 0);\n    \n    //释放内存\n    CGContextRelease(context);\n    free(imageData);\n    \n    return textureID;\n}\n```\n\n4 绘制时使用纹理\n\n```\n    glActiveTexture(GL_TEXTURE0);\n    //载入纹理\n    glBindTexture(GL_TEXTURE_2D, _textTureId);\n\n    glUniform1i(_textureSlot, 0);\n    \n    const GLfloat texCoords[] = {\n        0, 0,//左下\n        1, 0,//右下\n        0, 1,//左上\n        1, 1,//右上\n    };\n    glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);\n    glEnableVertexAttribArray(_textureCoordsSlot);\n```\n\n5 关于纹理坐标\n","source":"_posts/OpenGL-纹理贴图.md","raw":"---\nlayout: post\ntitle: 纹理贴图\ndate: 2017-01-03 11:11:26\ntags: openGL\n---\n\n1 VertexShader\n\n```\nattribute vec2 TexCoordIn; // New\nvarying vec2 TexCoordOut; // New\n\nvoid main(void) { \n    DestinationColor = SourceColor; \n    gl_Position = Projection * Modelview * Position;\n    TexCoordOut = TexCoordIn; // New\n}\n```\n\n2 FragmentShader\n\n```\nvarying lowp vec4 DestinationColor;\nvarying lowp vec2 TexCoordOut; // New\nuniform sampler2D Texture; // New\n\nvoid main(void) {\n    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New\n}\n```\n\n3 将图片资源转换成位图数据，绑定到对应纹理ID中\n\n```\n+ (GLuint)createTextureWithImage:(UIImage *)image{\n    \n    //转换为CGImage，获取图片基本参数\n    CGImageRef cgImageRef = [image CGImage];\n    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);\n    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);\n    CGRect rect = CGRectMake(0, 0, width, height);\n    \n    //绘制图片\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    void *imageData = malloc(width * height * 4);\n    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);\n    CGContextTranslateCTM(context, 0, height);\n    CGContextScaleCTM(context, 1.0f, -1.0f);\n    CGColorSpaceRelease(colorSpace);\n    CGContextClearRect(context, rect);\n    CGContextDrawImage(context, rect, cgImageRef);\n    \n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_2D, textureID);\n    \n    //纹理一些设置，可有可无\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    \n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);\n    \n    glBindTexture(GL_TEXTURE_2D, 0);\n    \n    //释放内存\n    CGContextRelease(context);\n    free(imageData);\n    \n    return textureID;\n}\n```\n\n4 绘制时使用纹理\n\n```\n    glActiveTexture(GL_TEXTURE0);\n    //载入纹理\n    glBindTexture(GL_TEXTURE_2D, _textTureId);\n\n    glUniform1i(_textureSlot, 0);\n    \n    const GLfloat texCoords[] = {\n        0, 0,//左下\n        1, 0,//右下\n        0, 1,//左上\n        1, 1,//右上\n    };\n    glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);\n    glEnableVertexAttribArray(_textureCoordsSlot);\n```\n\n5 关于纹理坐标\n","slug":"OpenGL-纹理贴图","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a1000xgcco7l7d22dw","content":"<p>1 VertexShader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attribute vec2 TexCoordIn; // New</span><br><span class=\"line\">varying vec2 TexCoordOut; // New</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123; </span><br><span class=\"line\">    DestinationColor = SourceColor; </span><br><span class=\"line\">    gl_Position = Projection * Modelview * Position;</span><br><span class=\"line\">    TexCoordOut = TexCoordIn; // New</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2 FragmentShader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying lowp vec4 DestinationColor;</span><br><span class=\"line\">varying lowp vec2 TexCoordOut; // New</span><br><span class=\"line\">uniform sampler2D Texture; // New</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123;</span><br><span class=\"line\">    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3 将图片资源转换成位图数据，绑定到对应纹理ID中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (GLuint)createTextureWithImage:(UIImage *)image&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //转换为CGImage，获取图片基本参数</span><br><span class=\"line\">    CGImageRef cgImageRef = [image CGImage];</span><br><span class=\"line\">    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);</span><br><span class=\"line\">    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);</span><br><span class=\"line\">    CGRect rect = CGRectMake(0, 0, width, height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //绘制图片</span><br><span class=\"line\">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class=\"line\">    void *imageData = malloc(width * height * 4);</span><br><span class=\"line\">    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class=\"line\">    CGContextTranslateCTM(context, 0, height);</span><br><span class=\"line\">    CGContextScaleCTM(context, 1.0f, -1.0f);</span><br><span class=\"line\">    CGColorSpaceRelease(colorSpace);</span><br><span class=\"line\">    CGContextClearRect(context, rect);</span><br><span class=\"line\">    CGContextDrawImage(context, rect, cgImageRef);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLuint textureID;</span><br><span class=\"line\">    glGenTextures(1, &amp;textureID);</span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, textureID);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //纹理一些设置，可有可无</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, 0);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //释放内存</span><br><span class=\"line\">    CGContextRelease(context);</span><br><span class=\"line\">    free(imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return textureID;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4 绘制时使用纹理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">//载入纹理</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, _textTureId);</span><br><span class=\"line\"></span><br><span class=\"line\">glUniform1i(_textureSlot, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">const GLfloat texCoords[] = &#123;</span><br><span class=\"line\">    0, 0,//左下</span><br><span class=\"line\">    1, 0,//右下</span><br><span class=\"line\">    0, 1,//左上</span><br><span class=\"line\">    1, 1,//右上</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);</span><br><span class=\"line\">glEnableVertexAttribArray(_textureCoordsSlot);</span><br></pre></td></tr></table></figure>\n\n<p>5 关于纹理坐标</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1 VertexShader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attribute vec2 TexCoordIn; // New</span><br><span class=\"line\">varying vec2 TexCoordOut; // New</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123; </span><br><span class=\"line\">    DestinationColor = SourceColor; </span><br><span class=\"line\">    gl_Position = Projection * Modelview * Position;</span><br><span class=\"line\">    TexCoordOut = TexCoordIn; // New</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2 FragmentShader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying lowp vec4 DestinationColor;</span><br><span class=\"line\">varying lowp vec2 TexCoordOut; // New</span><br><span class=\"line\">uniform sampler2D Texture; // New</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123;</span><br><span class=\"line\">    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3 将图片资源转换成位图数据，绑定到对应纹理ID中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (GLuint)createTextureWithImage:(UIImage *)image&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //转换为CGImage，获取图片基本参数</span><br><span class=\"line\">    CGImageRef cgImageRef = [image CGImage];</span><br><span class=\"line\">    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);</span><br><span class=\"line\">    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);</span><br><span class=\"line\">    CGRect rect = CGRectMake(0, 0, width, height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //绘制图片</span><br><span class=\"line\">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class=\"line\">    void *imageData = malloc(width * height * 4);</span><br><span class=\"line\">    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class=\"line\">    CGContextTranslateCTM(context, 0, height);</span><br><span class=\"line\">    CGContextScaleCTM(context, 1.0f, -1.0f);</span><br><span class=\"line\">    CGColorSpaceRelease(colorSpace);</span><br><span class=\"line\">    CGContextClearRect(context, rect);</span><br><span class=\"line\">    CGContextDrawImage(context, rect, cgImageRef);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLuint textureID;</span><br><span class=\"line\">    glGenTextures(1, &amp;textureID);</span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, textureID);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //纹理一些设置，可有可无</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, 0);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //释放内存</span><br><span class=\"line\">    CGContextRelease(context);</span><br><span class=\"line\">    free(imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return textureID;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4 绘制时使用纹理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">//载入纹理</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, _textTureId);</span><br><span class=\"line\"></span><br><span class=\"line\">glUniform1i(_textureSlot, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">const GLfloat texCoords[] = &#123;</span><br><span class=\"line\">    0, 0,//左下</span><br><span class=\"line\">    1, 0,//右下</span><br><span class=\"line\">    0, 1,//左上</span><br><span class=\"line\">    1, 1,//右上</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);</span><br><span class=\"line\">glEnableVertexAttribArray(_textureCoordsSlot);</span><br></pre></td></tr></table></figure>\n\n<p>5 关于纹理坐标</p>\n"},{"title":"OpenGLE_VAO局部影响vs全局影响","date":"2024-07-28T08:57:48.000Z","_content":"\n\n### 全局顶点属性数组使能状态\n\n`glEnableVertexAttribArray` 和 `glDisableVertexAttribArray` 确实是全局状态。这意味着在不使用 VAO 的情况下，启用或禁用特定的顶点属性数组会影响所有后续的绘制调用，直到该状态被改变。例如：\n\n```c\n// 启用顶点属性数组索引 0\nglEnableVertexAttribArray(0);\n\n// 进行绘制调用，使用索引 0 的顶点属性数组\nglDrawArrays(GL_TRIANGLES, 0, 3);\n\n// 禁用顶点属性数组索引 0\nglDisableVertexAttribArray(0);\n\n// 再次进行绘制调用，此时索引 0 的顶点属性数组将不会被使用\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n### 顶点数组对象（VAO）\n\n当使用 VAO 时，`glEnableVertexAttribArray` 和 `glVertexAttribPointer` 等顶点属性相关的状态是存储在 VAO 中的。这意味着当你绑定一个 VAO 时，它会恢复之前存储的所有顶点属性状态，包括哪些属性数组是启用的。这样，每个 VAO 可以拥有自己独立的顶点属性配置。例如：\n\n```c\n// 创建并绑定第一个 VAO\nGLuint vao1;\nglGenVertexArrays(1, &vao1);\nglBindVertexArray(vao1);\n\n// 设置顶点属性指针和启用顶点属性数组\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (void*)0);\nglEnableVertexAttribArray(0);\n\n// 解绑 VAO\nglBindVertexArray(0);\n\n// 创建并绑定第二个 VAO\nGLuint vao2;\nglGenVertexArrays(1, &vao2);\nglBindVertexArray(vao2);\n\n// 设置不同的顶点属性指针和启用顶点属性数组\nglVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), (void*)0);\nglEnableVertexAttribArray(1);\n\n// 解绑 VAO\nglBindVertexArray(0);\n\n// 使用第一个 VAO 进行绘制\nglBindVertexArray(vao1);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n\n// 使用第二个 VAO 进行绘制\nglBindVertexArray(vao2);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n在这个例子中：\n\n- `vao1` 存储了顶点属性索引 0 的配置和使能状态。\n- `vao2` 存储了顶点属性索引 1 的配置和使能状态。\n\n绑定 `vao1` 会恢复其配置和状态，绑定 `vao2` 则会恢复其自身的配置和状态。\n\n### 总结\n\n- **全局顶点属性数组使能状态**：在不使用 VAO 时，`glEnableVertexAttribArray` 和 `glDisableVertexAttribArray` 对所有后续绘制调用生效，直到状态被改变。\n  \n- **顶点数组对象（VAO）**：存储了顶点属性相关的所有状态，包括使能状态。当绑定 VAO 时，会恢复之前存储的顶点属性配置和使能状态，使得每个 VAO 拥有独立的顶点属性配置。\n\n使用 VAO 是管理复杂场景和多个对象的最佳实践，因为它简化了状态管理，并且可以提高渲染性能。\n","source":"_posts/OpenGLE-VAO局部影响vs全局影响.md","raw":"---\ntitle: OpenGLE_VAO局部影响vs全局影响\ndate: 2024-07-28 16:57:48\ntags:\n---\n\n\n### 全局顶点属性数组使能状态\n\n`glEnableVertexAttribArray` 和 `glDisableVertexAttribArray` 确实是全局状态。这意味着在不使用 VAO 的情况下，启用或禁用特定的顶点属性数组会影响所有后续的绘制调用，直到该状态被改变。例如：\n\n```c\n// 启用顶点属性数组索引 0\nglEnableVertexAttribArray(0);\n\n// 进行绘制调用，使用索引 0 的顶点属性数组\nglDrawArrays(GL_TRIANGLES, 0, 3);\n\n// 禁用顶点属性数组索引 0\nglDisableVertexAttribArray(0);\n\n// 再次进行绘制调用，此时索引 0 的顶点属性数组将不会被使用\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n### 顶点数组对象（VAO）\n\n当使用 VAO 时，`glEnableVertexAttribArray` 和 `glVertexAttribPointer` 等顶点属性相关的状态是存储在 VAO 中的。这意味着当你绑定一个 VAO 时，它会恢复之前存储的所有顶点属性状态，包括哪些属性数组是启用的。这样，每个 VAO 可以拥有自己独立的顶点属性配置。例如：\n\n```c\n// 创建并绑定第一个 VAO\nGLuint vao1;\nglGenVertexArrays(1, &vao1);\nglBindVertexArray(vao1);\n\n// 设置顶点属性指针和启用顶点属性数组\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (void*)0);\nglEnableVertexAttribArray(0);\n\n// 解绑 VAO\nglBindVertexArray(0);\n\n// 创建并绑定第二个 VAO\nGLuint vao2;\nglGenVertexArrays(1, &vao2);\nglBindVertexArray(vao2);\n\n// 设置不同的顶点属性指针和启用顶点属性数组\nglVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), (void*)0);\nglEnableVertexAttribArray(1);\n\n// 解绑 VAO\nglBindVertexArray(0);\n\n// 使用第一个 VAO 进行绘制\nglBindVertexArray(vao1);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n\n// 使用第二个 VAO 进行绘制\nglBindVertexArray(vao2);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n在这个例子中：\n\n- `vao1` 存储了顶点属性索引 0 的配置和使能状态。\n- `vao2` 存储了顶点属性索引 1 的配置和使能状态。\n\n绑定 `vao1` 会恢复其配置和状态，绑定 `vao2` 则会恢复其自身的配置和状态。\n\n### 总结\n\n- **全局顶点属性数组使能状态**：在不使用 VAO 时，`glEnableVertexAttribArray` 和 `glDisableVertexAttribArray` 对所有后续绘制调用生效，直到状态被改变。\n  \n- **顶点数组对象（VAO）**：存储了顶点属性相关的所有状态，包括使能状态。当绑定 VAO 时，会恢复之前存储的顶点属性配置和使能状态，使得每个 VAO 拥有独立的顶点属性配置。\n\n使用 VAO 是管理复杂场景和多个对象的最佳实践，因为它简化了状态管理，并且可以提高渲染性能。\n","slug":"OpenGLE-VAO局部影响vs全局影响","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a1000zgccoh42m589u","content":"<h3 id=\"全局顶点属性数组使能状态\"><a href=\"#全局顶点属性数组使能状态\" class=\"headerlink\" title=\"全局顶点属性数组使能状态\"></a>全局顶点属性数组使能状态</h3><p><code>glEnableVertexAttribArray</code> 和 <code>glDisableVertexAttribArray</code> 确实是全局状态。这意味着在不使用 VAO 的情况下，启用或禁用特定的顶点属性数组会影响所有后续的绘制调用，直到该状态被改变。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 启用顶点属性数组索引 0</span></span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行绘制调用，使用索引 0 的顶点属性数组</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 禁用顶点属性数组索引 0</span></span><br><span class=\"line\">glDisableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再次进行绘制调用，此时索引 0 的顶点属性数组将不会被使用</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"顶点数组对象（VAO）\"><a href=\"#顶点数组对象（VAO）\" class=\"headerlink\" title=\"顶点数组对象（VAO）\"></a>顶点数组对象（VAO）</h3><p>当使用 VAO 时，<code>glEnableVertexAttribArray</code> 和 <code>glVertexAttribPointer</code> 等顶点属性相关的状态是存储在 VAO 中的。这意味着当你绑定一个 VAO 时，它会恢复之前存储的所有顶点属性状态，包括哪些属性数组是启用的。这样，每个 VAO 可以拥有自己独立的顶点属性配置。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建并绑定第一个 VAO</span></span><br><span class=\"line\">GLuint vao1;</span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;vao1);</span><br><span class=\"line\">glBindVertexArray(vao1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置顶点属性指针和启用顶点属性数组</span></span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解绑 VAO</span></span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并绑定第二个 VAO</span></span><br><span class=\"line\">GLuint vao2;</span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;vao2);</span><br><span class=\"line\">glBindVertexArray(vao2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置不同的顶点属性指针和启用顶点属性数组</span></span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">2</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">2</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解绑 VAO</span></span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用第一个 VAO 进行绘制</span></span><br><span class=\"line\">glBindVertexArray(vao1);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用第二个 VAO 进行绘制</span></span><br><span class=\"line\">glBindVertexArray(vao2);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中：</p>\n<ul>\n<li><code>vao1</code> 存储了顶点属性索引 0 的配置和使能状态。</li>\n<li><code>vao2</code> 存储了顶点属性索引 1 的配置和使能状态。</li>\n</ul>\n<p>绑定 <code>vao1</code> 会恢复其配置和状态，绑定 <code>vao2</code> 则会恢复其自身的配置和状态。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>全局顶点属性数组使能状态</strong>：在不使用 VAO 时，<code>glEnableVertexAttribArray</code> 和 <code>glDisableVertexAttribArray</code> 对所有后续绘制调用生效，直到状态被改变。</li>\n<li><strong>顶点数组对象（VAO）</strong>：存储了顶点属性相关的所有状态，包括使能状态。当绑定 VAO 时，会恢复之前存储的顶点属性配置和使能状态，使得每个 VAO 拥有独立的顶点属性配置。</li>\n</ul>\n<p>使用 VAO 是管理复杂场景和多个对象的最佳实践，因为它简化了状态管理，并且可以提高渲染性能。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"全局顶点属性数组使能状态\"><a href=\"#全局顶点属性数组使能状态\" class=\"headerlink\" title=\"全局顶点属性数组使能状态\"></a>全局顶点属性数组使能状态</h3><p><code>glEnableVertexAttribArray</code> 和 <code>glDisableVertexAttribArray</code> 确实是全局状态。这意味着在不使用 VAO 的情况下，启用或禁用特定的顶点属性数组会影响所有后续的绘制调用，直到该状态被改变。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 启用顶点属性数组索引 0</span></span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行绘制调用，使用索引 0 的顶点属性数组</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 禁用顶点属性数组索引 0</span></span><br><span class=\"line\">glDisableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再次进行绘制调用，此时索引 0 的顶点属性数组将不会被使用</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"顶点数组对象（VAO）\"><a href=\"#顶点数组对象（VAO）\" class=\"headerlink\" title=\"顶点数组对象（VAO）\"></a>顶点数组对象（VAO）</h3><p>当使用 VAO 时，<code>glEnableVertexAttribArray</code> 和 <code>glVertexAttribPointer</code> 等顶点属性相关的状态是存储在 VAO 中的。这意味着当你绑定一个 VAO 时，它会恢复之前存储的所有顶点属性状态，包括哪些属性数组是启用的。这样，每个 VAO 可以拥有自己独立的顶点属性配置。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建并绑定第一个 VAO</span></span><br><span class=\"line\">GLuint vao1;</span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;vao1);</span><br><span class=\"line\">glBindVertexArray(vao1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置顶点属性指针和启用顶点属性数组</span></span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解绑 VAO</span></span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并绑定第二个 VAO</span></span><br><span class=\"line\">GLuint vao2;</span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;vao2);</span><br><span class=\"line\">glBindVertexArray(vao2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置不同的顶点属性指针和启用顶点属性数组</span></span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">2</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">2</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解绑 VAO</span></span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用第一个 VAO 进行绘制</span></span><br><span class=\"line\">glBindVertexArray(vao1);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用第二个 VAO 进行绘制</span></span><br><span class=\"line\">glBindVertexArray(vao2);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中：</p>\n<ul>\n<li><code>vao1</code> 存储了顶点属性索引 0 的配置和使能状态。</li>\n<li><code>vao2</code> 存储了顶点属性索引 1 的配置和使能状态。</li>\n</ul>\n<p>绑定 <code>vao1</code> 会恢复其配置和状态，绑定 <code>vao2</code> 则会恢复其自身的配置和状态。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>全局顶点属性数组使能状态</strong>：在不使用 VAO 时，<code>glEnableVertexAttribArray</code> 和 <code>glDisableVertexAttribArray</code> 对所有后续绘制调用生效，直到状态被改变。</li>\n<li><strong>顶点数组对象（VAO）</strong>：存储了顶点属性相关的所有状态，包括使能状态。当绑定 VAO 时，会恢复之前存储的顶点属性配置和使能状态，使得每个 VAO 拥有独立的顶点属性配置。</li>\n</ul>\n<p>使用 VAO 是管理复杂场景和多个对象的最佳实践，因为它简化了状态管理，并且可以提高渲染性能。</p>\n"},{"title":"OpenGL模板测试流程","date":"2022-11-08T03:51:27.000Z","_content":"\n\n### 模板测试流程\n\n不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试\n\n#### 模板测试一般使用流程：\n\t1. 启用模板缓冲写入\n\t2. 渲染物体，更新模板缓冲\n\t3. 禁用模板缓冲写入\n\t4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段\n\n\n##### 使用模板测试绘制物体轮廓的例子\n\n\t```\n\tglStencilMask();\n\tglStencilFunc(GLenum func, GLint ref, GLuint mask);\n\tglStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);\n\t```\n\n\t1. 开启模板测试和深度测试\n\t2. 第一次render pass，主要是绘制，并写入模板\n\t\t1. 开启模板测试和深度测试\n\t\t2. glStencilMask(0xFF);\n\t\t3. glStencilOp(keep, keep, replace);\n\t\t4. glStencilFunc(always, 1, 0xFF);\n\t\t5. 绘制物体\n\t3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素\n\t\t1. 将物体缩放变大\n\t\t2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系\n\t\t3. 关闭模板写入glStencilMask(0x00);\n\t\t4. glStencilFunc(not_equal, 1, 0xFF);\n\t\t5. 绘制物体\n\n\n### 关于OpenGL里面的Mask\n\t1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&运算后写入\n\t2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入\n\t3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入\n","source":"_posts/OpenGL模板测试流程.md","raw":"---\ntitle: OpenGL模板测试流程\ndate: 2022-11-08 11:51:27\ntags: openGL\n---\n\n\n### 模板测试流程\n\n不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试\n\n#### 模板测试一般使用流程：\n\t1. 启用模板缓冲写入\n\t2. 渲染物体，更新模板缓冲\n\t3. 禁用模板缓冲写入\n\t4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段\n\n\n##### 使用模板测试绘制物体轮廓的例子\n\n\t```\n\tglStencilMask();\n\tglStencilFunc(GLenum func, GLint ref, GLuint mask);\n\tglStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);\n\t```\n\n\t1. 开启模板测试和深度测试\n\t2. 第一次render pass，主要是绘制，并写入模板\n\t\t1. 开启模板测试和深度测试\n\t\t2. glStencilMask(0xFF);\n\t\t3. glStencilOp(keep, keep, replace);\n\t\t4. glStencilFunc(always, 1, 0xFF);\n\t\t5. 绘制物体\n\t3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素\n\t\t1. 将物体缩放变大\n\t\t2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系\n\t\t3. 关闭模板写入glStencilMask(0x00);\n\t\t4. glStencilFunc(not_equal, 1, 0xFF);\n\t\t5. 绘制物体\n\n\n### 关于OpenGL里面的Mask\n\t1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&运算后写入\n\t2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入\n\t3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入\n","slug":"OpenGL模板测试流程","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a20010gcco8bilemdt","content":"<h3 id=\"模板测试流程\"><a href=\"#模板测试流程\" class=\"headerlink\" title=\"模板测试流程\"></a>模板测试流程</h3><p>不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试</p>\n<h4 id=\"模板测试一般使用流程：\"><a href=\"#模板测试一般使用流程：\" class=\"headerlink\" title=\"模板测试一般使用流程：\"></a>模板测试一般使用流程：</h4><pre><code>1. 启用模板缓冲写入\n2. 渲染物体，更新模板缓冲\n3. 禁用模板缓冲写入\n4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段\n</code></pre>\n<h5 id=\"使用模板测试绘制物体轮廓的例子\"><a href=\"#使用模板测试绘制物体轮廓的例子\" class=\"headerlink\" title=\"使用模板测试绘制物体轮廓的例子\"></a>使用模板测试绘制物体轮廓的例子</h5><pre><code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glStencilMask();</span><br><span class=\"line\">glStencilFunc(GLenum func, GLint ref, GLuint mask);</span><br><span class=\"line\">glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);</span><br></pre></td></tr></table></figure>\n\n1. 开启模板测试和深度测试\n2. 第一次render pass，主要是绘制，并写入模板\n    1. 开启模板测试和深度测试\n    2. glStencilMask(0xFF);\n    3. glStencilOp(keep, keep, replace);\n    4. glStencilFunc(always, 1, 0xFF);\n    5. 绘制物体\n3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素\n    1. 将物体缩放变大\n    2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系\n    3. 关闭模板写入glStencilMask(0x00);\n    4. glStencilFunc(not_equal, 1, 0xFF);\n    5. 绘制物体\n</code></pre>\n<h3 id=\"关于OpenGL里面的Mask\"><a href=\"#关于OpenGL里面的Mask\" class=\"headerlink\" title=\"关于OpenGL里面的Mask\"></a>关于OpenGL里面的Mask</h3><pre><code>1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&amp;运算后写入\n2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入\n3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"模板测试流程\"><a href=\"#模板测试流程\" class=\"headerlink\" title=\"模板测试流程\"></a>模板测试流程</h3><p>不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试</p>\n<h4 id=\"模板测试一般使用流程：\"><a href=\"#模板测试一般使用流程：\" class=\"headerlink\" title=\"模板测试一般使用流程：\"></a>模板测试一般使用流程：</h4><pre><code>1. 启用模板缓冲写入\n2. 渲染物体，更新模板缓冲\n3. 禁用模板缓冲写入\n4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段\n</code></pre>\n<h5 id=\"使用模板测试绘制物体轮廓的例子\"><a href=\"#使用模板测试绘制物体轮廓的例子\" class=\"headerlink\" title=\"使用模板测试绘制物体轮廓的例子\"></a>使用模板测试绘制物体轮廓的例子</h5><pre><code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glStencilMask();</span><br><span class=\"line\">glStencilFunc(GLenum func, GLint ref, GLuint mask);</span><br><span class=\"line\">glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);</span><br></pre></td></tr></table></figure>\n\n1. 开启模板测试和深度测试\n2. 第一次render pass，主要是绘制，并写入模板\n    1. 开启模板测试和深度测试\n    2. glStencilMask(0xFF);\n    3. glStencilOp(keep, keep, replace);\n    4. glStencilFunc(always, 1, 0xFF);\n    5. 绘制物体\n3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素\n    1. 将物体缩放变大\n    2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系\n    3. 关闭模板写入glStencilMask(0x00);\n    4. glStencilFunc(not_equal, 1, 0xFF);\n    5. 绘制物体\n</code></pre>\n<h3 id=\"关于OpenGL里面的Mask\"><a href=\"#关于OpenGL里面的Mask\" class=\"headerlink\" title=\"关于OpenGL里面的Mask\"></a>关于OpenGL里面的Mask</h3><pre><code>1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&amp;运算后写入\n2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入\n3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入\n</code></pre>\n"},{"title":"OpenGLES设置顶点属性的默认值","date":"2024-07-28T08:53:57.000Z","_content":"\n在 OpenGL ES 中，设置顶点属性的默认值和通过顶点缓冲对象（VBO）上传顶点属性是两种不同的处理顶点属性的方法。以下是详细的解释：\n\n### 设置顶点属性默认值\n\n在 OpenGL ES 中，可以使用 `glVertexAttrib4f`（或其他类似的函数）来设置顶点属性的默认值。这些函数允许您为指定的顶点属性索引设置一个常量值，而不必为每个顶点提供一个值。例如：\n\n```c\n// 设置索引为 0 的顶点属性的默认值为 (1.0, 0.0, 0.0, 1.0)\nglVertexAttrib4f(0, 1.0f, 0.0f, 0.0f, 1.0f);\n```\n\n请注意，这种方法直接在顶点着色器中使用常量值，因此适用于需要相同属性值的所有顶点的情况。\n\n### 通过 VBO 上传顶点属性\n\nVBO 是一种在图形硬件上存储顶点数据的高效方式。使用 VBO 可以提高渲染性能，因为数据存储在 GPU 内存中，而不是通过每次绘制调用从 CPU 内存传输数据。以下是使用 VBO 上传顶点属性的步骤：\n\n1. **生成和绑定 VBO**：\n   ```c\n   GLuint vbo;\n   glGenBuffers(1, &vbo);\n   glBindBuffer(GL_ARRAY_BUFFER, vbo);\n   ```\n\n2. **上传顶点数据**：\n   ```c\n   GLfloat vertices[] = {\n       // 顶点数据，假设每个顶点包含 3 个浮点数 (x, y, z)\n       0.0f, 0.0f, 0.0f,\n       1.0f, 0.0f, 0.0f,\n       0.0f, 1.0f, 0.0f,\n   };\n   glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n   ```\n\n3. **设置顶点属性指针**：\n   ```c\n   glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (void*)0);\n   glEnableVertexAttribArray(0);\n   ```\n\n4. **绘制**：\n   ```c\n   glDrawArrays(GL_TRIANGLES, 0, 3);\n   ```\n\n### 性能差别\n\n- **设置顶点属性默认值**：这种方法适用于所有顶点共享相同属性值的情况。其优点是简单直接，不需要额外的内存传输。然而，它缺乏灵活性，只能应用于特定的简单场景。\n\n- **通过 VBO 上传顶点属性**：这种方法更为灵活，可以为每个顶点设置不同的属性值。因为数据存储在 GPU 内存中，所以渲染性能通常更高，特别是在处理大量顶点数据时。这种方法适用于大多数复杂的渲染任务。\n\n总结来说，如果您的应用场景中所有顶点都共享相同的属性值，可以使用设置默认值的方法。如果不同顶点有不同的属性值，并且您希望获得更好的性能，应使用 VBO。\n","source":"_posts/OpenGLES设置顶点属性的默认值.md","raw":"---\ntitle: OpenGLES设置顶点属性的默认值\ndate: 2024-07-28 16:53:57\ntags:\n---\n\n在 OpenGL ES 中，设置顶点属性的默认值和通过顶点缓冲对象（VBO）上传顶点属性是两种不同的处理顶点属性的方法。以下是详细的解释：\n\n### 设置顶点属性默认值\n\n在 OpenGL ES 中，可以使用 `glVertexAttrib4f`（或其他类似的函数）来设置顶点属性的默认值。这些函数允许您为指定的顶点属性索引设置一个常量值，而不必为每个顶点提供一个值。例如：\n\n```c\n// 设置索引为 0 的顶点属性的默认值为 (1.0, 0.0, 0.0, 1.0)\nglVertexAttrib4f(0, 1.0f, 0.0f, 0.0f, 1.0f);\n```\n\n请注意，这种方法直接在顶点着色器中使用常量值，因此适用于需要相同属性值的所有顶点的情况。\n\n### 通过 VBO 上传顶点属性\n\nVBO 是一种在图形硬件上存储顶点数据的高效方式。使用 VBO 可以提高渲染性能，因为数据存储在 GPU 内存中，而不是通过每次绘制调用从 CPU 内存传输数据。以下是使用 VBO 上传顶点属性的步骤：\n\n1. **生成和绑定 VBO**：\n   ```c\n   GLuint vbo;\n   glGenBuffers(1, &vbo);\n   glBindBuffer(GL_ARRAY_BUFFER, vbo);\n   ```\n\n2. **上传顶点数据**：\n   ```c\n   GLfloat vertices[] = {\n       // 顶点数据，假设每个顶点包含 3 个浮点数 (x, y, z)\n       0.0f, 0.0f, 0.0f,\n       1.0f, 0.0f, 0.0f,\n       0.0f, 1.0f, 0.0f,\n   };\n   glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n   ```\n\n3. **设置顶点属性指针**：\n   ```c\n   glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (void*)0);\n   glEnableVertexAttribArray(0);\n   ```\n\n4. **绘制**：\n   ```c\n   glDrawArrays(GL_TRIANGLES, 0, 3);\n   ```\n\n### 性能差别\n\n- **设置顶点属性默认值**：这种方法适用于所有顶点共享相同属性值的情况。其优点是简单直接，不需要额外的内存传输。然而，它缺乏灵活性，只能应用于特定的简单场景。\n\n- **通过 VBO 上传顶点属性**：这种方法更为灵活，可以为每个顶点设置不同的属性值。因为数据存储在 GPU 内存中，所以渲染性能通常更高，特别是在处理大量顶点数据时。这种方法适用于大多数复杂的渲染任务。\n\n总结来说，如果您的应用场景中所有顶点都共享相同的属性值，可以使用设置默认值的方法。如果不同顶点有不同的属性值，并且您希望获得更好的性能，应使用 VBO。\n","slug":"OpenGLES设置顶点属性的默认值","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a20012gcco4i1m097s","content":"<p>在 OpenGL ES 中，设置顶点属性的默认值和通过顶点缓冲对象（VBO）上传顶点属性是两种不同的处理顶点属性的方法。以下是详细的解释：</p>\n<h3 id=\"设置顶点属性默认值\"><a href=\"#设置顶点属性默认值\" class=\"headerlink\" title=\"设置顶点属性默认值\"></a>设置顶点属性默认值</h3><p>在 OpenGL ES 中，可以使用 <code>glVertexAttrib4f</code>（或其他类似的函数）来设置顶点属性的默认值。这些函数允许您为指定的顶点属性索引设置一个常量值，而不必为每个顶点提供一个值。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置索引为 0 的顶点属性的默认值为 (1.0, 0.0, 0.0, 1.0)</span></span><br><span class=\"line\">glVertexAttrib4f(<span class=\"number\">0</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>);</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这种方法直接在顶点着色器中使用常量值，因此适用于需要相同属性值的所有顶点的情况。</p>\n<h3 id=\"通过-VBO-上传顶点属性\"><a href=\"#通过-VBO-上传顶点属性\" class=\"headerlink\" title=\"通过 VBO 上传顶点属性\"></a>通过 VBO 上传顶点属性</h3><p>VBO 是一种在图形硬件上存储顶点数据的高效方式。使用 VBO 可以提高渲染性能，因为数据存储在 GPU 内存中，而不是通过每次绘制调用从 CPU 内存传输数据。以下是使用 VBO 上传顶点属性的步骤：</p>\n<ol>\n<li><p><strong>生成和绑定 VBO</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint vbo;</span><br><span class=\"line\">glGenBuffers(<span class=\"number\">1</span>, &amp;vbo);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbo);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>上传顶点数据</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 顶点数据，假设每个顶点包含 3 个浮点数 (x, y, z)</span></span><br><span class=\"line\">    <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,</span><br><span class=\"line\">    <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,</span><br><span class=\"line\">    <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>设置顶点属性指针</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>绘制</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"性能差别\"><a href=\"#性能差别\" class=\"headerlink\" title=\"性能差别\"></a>性能差别</h3><ul>\n<li><p><strong>设置顶点属性默认值</strong>：这种方法适用于所有顶点共享相同属性值的情况。其优点是简单直接，不需要额外的内存传输。然而，它缺乏灵活性，只能应用于特定的简单场景。</p>\n</li>\n<li><p><strong>通过 VBO 上传顶点属性</strong>：这种方法更为灵活，可以为每个顶点设置不同的属性值。因为数据存储在 GPU 内存中，所以渲染性能通常更高，特别是在处理大量顶点数据时。这种方法适用于大多数复杂的渲染任务。</p>\n</li>\n</ul>\n<p>总结来说，如果您的应用场景中所有顶点都共享相同的属性值，可以使用设置默认值的方法。如果不同顶点有不同的属性值，并且您希望获得更好的性能，应使用 VBO。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 OpenGL ES 中，设置顶点属性的默认值和通过顶点缓冲对象（VBO）上传顶点属性是两种不同的处理顶点属性的方法。以下是详细的解释：</p>\n<h3 id=\"设置顶点属性默认值\"><a href=\"#设置顶点属性默认值\" class=\"headerlink\" title=\"设置顶点属性默认值\"></a>设置顶点属性默认值</h3><p>在 OpenGL ES 中，可以使用 <code>glVertexAttrib4f</code>（或其他类似的函数）来设置顶点属性的默认值。这些函数允许您为指定的顶点属性索引设置一个常量值，而不必为每个顶点提供一个值。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置索引为 0 的顶点属性的默认值为 (1.0, 0.0, 0.0, 1.0)</span></span><br><span class=\"line\">glVertexAttrib4f(<span class=\"number\">0</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>);</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这种方法直接在顶点着色器中使用常量值，因此适用于需要相同属性值的所有顶点的情况。</p>\n<h3 id=\"通过-VBO-上传顶点属性\"><a href=\"#通过-VBO-上传顶点属性\" class=\"headerlink\" title=\"通过 VBO 上传顶点属性\"></a>通过 VBO 上传顶点属性</h3><p>VBO 是一种在图形硬件上存储顶点数据的高效方式。使用 VBO 可以提高渲染性能，因为数据存储在 GPU 内存中，而不是通过每次绘制调用从 CPU 内存传输数据。以下是使用 VBO 上传顶点属性的步骤：</p>\n<ol>\n<li><p><strong>生成和绑定 VBO</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint vbo;</span><br><span class=\"line\">glGenBuffers(<span class=\"number\">1</span>, &amp;vbo);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbo);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>上传顶点数据</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 顶点数据，假设每个顶点包含 3 个浮点数 (x, y, z)</span></span><br><span class=\"line\">    <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,</span><br><span class=\"line\">    <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,</span><br><span class=\"line\">    <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>设置顶点属性指针</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>绘制</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"性能差别\"><a href=\"#性能差别\" class=\"headerlink\" title=\"性能差别\"></a>性能差别</h3><ul>\n<li><p><strong>设置顶点属性默认值</strong>：这种方法适用于所有顶点共享相同属性值的情况。其优点是简单直接，不需要额外的内存传输。然而，它缺乏灵活性，只能应用于特定的简单场景。</p>\n</li>\n<li><p><strong>通过 VBO 上传顶点属性</strong>：这种方法更为灵活，可以为每个顶点设置不同的属性值。因为数据存储在 GPU 内存中，所以渲染性能通常更高，特别是在处理大量顶点数据时。这种方法适用于大多数复杂的渲染任务。</p>\n</li>\n</ul>\n<p>总结来说，如果您的应用场景中所有顶点都共享相同的属性值，可以使用设置默认值的方法。如果不同顶点有不同的属性值，并且您希望获得更好的性能，应使用 VBO。</p>\n"},{"title":"SDF实现CornerRadius","date":"2023-12-28T10:45:16.000Z","_content":"","source":"_posts/SDF实现CornerRadius.md","raw":"---\ntitle: SDF实现CornerRadius\ndate: 2023-12-28 18:45:16\ntags:\n---\n","slug":"SDF实现CornerRadius","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a20014gccodml6h68f","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"UTF编码内存角度比较.md","date":"2024-07-11T07:36:56.000Z","_content":"\nUTF-8、UTF-16 和 UTF-32 是三种不同的 Unicode 编码方式，它们在表示字符时占用的字节数各不相同。具体如下：\n\n1. **UTF-8**：\n   - UTF-8 是一种可变长度的编码方式，每个字符占用 1 到 4 个字节。\n   - 具体字节数取决于字符的 Unicode 码点：\n     - U+0000 至 U+007F（基本拉丁字母）占 1 个字节。\n     - U+0080 至 U+07FF 占 2 个字节。\n     - U+0800 至 U+FFFF 占 3 个字节。\n     - U+10000 至 U+10FFFF 占 4 个字节。\n\n2. **UTF-16**：\n   - UTF-16 也是一种可变长度的编码方式，每个字符占用 2 或 4 个字节。\n   - 具体字节数取决于字符的 Unicode 码点：\n     - U+0000 至 U+FFFF（基本多语言平面，BMP）占 2 个字节。\n     - U+10000 至 U+10FFFF（辅助平面）占 4 个字节（使用一对代理项，即高位代理项和低位代理项，每个占 2 个字节）。\n\n3. **UTF-32**：\n   - UTF-32 是一种固定长度的编码方式，每个字符占用 4 个字节。\n   - 无论字符的 Unicode 码点是多少，每个字符始终占用 4 个字节。\n\n总结：\n\n- **UTF-8**：1 到 4 个字节，具体取决于字符。\n- **UTF-16**：2 或 4 个字节，具体取决于字符。\n- **UTF-32**：固定 4 个字节。\n\n这三种编码方式各有优缺点。UTF-8 是最常用的编码方式，因其对 ASCII 字符的高效编码（仅占 1 个字节），节省空间且向后兼容 ASCII。UTF-16 在处理基本多语言平面字符时相对高效，但对于包括大量辅助平面字符的文本，可能会占用更多空间。UTF-32 最简单，但由于每个字符固定占用 4 个字节，通常会占用更多的存储空间。\n","source":"_posts/UTF编码内存角度比较-md.md","raw":"---\ntitle: UTF编码内存角度比较.md\ndate: 2024-07-11 15:36:56\ntags:\n---\n\nUTF-8、UTF-16 和 UTF-32 是三种不同的 Unicode 编码方式，它们在表示字符时占用的字节数各不相同。具体如下：\n\n1. **UTF-8**：\n   - UTF-8 是一种可变长度的编码方式，每个字符占用 1 到 4 个字节。\n   - 具体字节数取决于字符的 Unicode 码点：\n     - U+0000 至 U+007F（基本拉丁字母）占 1 个字节。\n     - U+0080 至 U+07FF 占 2 个字节。\n     - U+0800 至 U+FFFF 占 3 个字节。\n     - U+10000 至 U+10FFFF 占 4 个字节。\n\n2. **UTF-16**：\n   - UTF-16 也是一种可变长度的编码方式，每个字符占用 2 或 4 个字节。\n   - 具体字节数取决于字符的 Unicode 码点：\n     - U+0000 至 U+FFFF（基本多语言平面，BMP）占 2 个字节。\n     - U+10000 至 U+10FFFF（辅助平面）占 4 个字节（使用一对代理项，即高位代理项和低位代理项，每个占 2 个字节）。\n\n3. **UTF-32**：\n   - UTF-32 是一种固定长度的编码方式，每个字符占用 4 个字节。\n   - 无论字符的 Unicode 码点是多少，每个字符始终占用 4 个字节。\n\n总结：\n\n- **UTF-8**：1 到 4 个字节，具体取决于字符。\n- **UTF-16**：2 或 4 个字节，具体取决于字符。\n- **UTF-32**：固定 4 个字节。\n\n这三种编码方式各有优缺点。UTF-8 是最常用的编码方式，因其对 ASCII 字符的高效编码（仅占 1 个字节），节省空间且向后兼容 ASCII。UTF-16 在处理基本多语言平面字符时相对高效，但对于包括大量辅助平面字符的文本，可能会占用更多空间。UTF-32 最简单，但由于每个字符固定占用 4 个字节，通常会占用更多的存储空间。\n","slug":"UTF编码内存角度比较-md","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a20017gccodyf6fejo","content":"<p>UTF-8、UTF-16 和 UTF-32 是三种不同的 Unicode 编码方式，它们在表示字符时占用的字节数各不相同。具体如下：</p>\n<ol>\n<li><p><strong>UTF-8</strong>：</p>\n<ul>\n<li>UTF-8 是一种可变长度的编码方式，每个字符占用 1 到 4 个字节。</li>\n<li>具体字节数取决于字符的 Unicode 码点：<ul>\n<li>U+0000 至 U+007F（基本拉丁字母）占 1 个字节。</li>\n<li>U+0080 至 U+07FF 占 2 个字节。</li>\n<li>U+0800 至 U+FFFF 占 3 个字节。</li>\n<li>U+10000 至 U+10FFFF 占 4 个字节。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>UTF-16</strong>：</p>\n<ul>\n<li>UTF-16 也是一种可变长度的编码方式，每个字符占用 2 或 4 个字节。</li>\n<li>具体字节数取决于字符的 Unicode 码点：<ul>\n<li>U+0000 至 U+FFFF（基本多语言平面，BMP）占 2 个字节。</li>\n<li>U+10000 至 U+10FFFF（辅助平面）占 4 个字节（使用一对代理项，即高位代理项和低位代理项，每个占 2 个字节）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>UTF-32</strong>：</p>\n<ul>\n<li>UTF-32 是一种固定长度的编码方式，每个字符占用 4 个字节。</li>\n<li>无论字符的 Unicode 码点是多少，每个字符始终占用 4 个字节。</li>\n</ul>\n</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li><strong>UTF-8</strong>：1 到 4 个字节，具体取决于字符。</li>\n<li><strong>UTF-16</strong>：2 或 4 个字节，具体取决于字符。</li>\n<li><strong>UTF-32</strong>：固定 4 个字节。</li>\n</ul>\n<p>这三种编码方式各有优缺点。UTF-8 是最常用的编码方式，因其对 ASCII 字符的高效编码（仅占 1 个字节），节省空间且向后兼容 ASCII。UTF-16 在处理基本多语言平面字符时相对高效，但对于包括大量辅助平面字符的文本，可能会占用更多空间。UTF-32 最简单，但由于每个字符固定占用 4 个字节，通常会占用更多的存储空间。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>UTF-8、UTF-16 和 UTF-32 是三种不同的 Unicode 编码方式，它们在表示字符时占用的字节数各不相同。具体如下：</p>\n<ol>\n<li><p><strong>UTF-8</strong>：</p>\n<ul>\n<li>UTF-8 是一种可变长度的编码方式，每个字符占用 1 到 4 个字节。</li>\n<li>具体字节数取决于字符的 Unicode 码点：<ul>\n<li>U+0000 至 U+007F（基本拉丁字母）占 1 个字节。</li>\n<li>U+0080 至 U+07FF 占 2 个字节。</li>\n<li>U+0800 至 U+FFFF 占 3 个字节。</li>\n<li>U+10000 至 U+10FFFF 占 4 个字节。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>UTF-16</strong>：</p>\n<ul>\n<li>UTF-16 也是一种可变长度的编码方式，每个字符占用 2 或 4 个字节。</li>\n<li>具体字节数取决于字符的 Unicode 码点：<ul>\n<li>U+0000 至 U+FFFF（基本多语言平面，BMP）占 2 个字节。</li>\n<li>U+10000 至 U+10FFFF（辅助平面）占 4 个字节（使用一对代理项，即高位代理项和低位代理项，每个占 2 个字节）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>UTF-32</strong>：</p>\n<ul>\n<li>UTF-32 是一种固定长度的编码方式，每个字符占用 4 个字节。</li>\n<li>无论字符的 Unicode 码点是多少，每个字符始终占用 4 个字节。</li>\n</ul>\n</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li><strong>UTF-8</strong>：1 到 4 个字节，具体取决于字符。</li>\n<li><strong>UTF-16</strong>：2 或 4 个字节，具体取决于字符。</li>\n<li><strong>UTF-32</strong>：固定 4 个字节。</li>\n</ul>\n<p>这三种编码方式各有优缺点。UTF-8 是最常用的编码方式，因其对 ASCII 字符的高效编码（仅占 1 个字节），节省空间且向后兼容 ASCII。UTF-16 在处理基本多语言平面字符时相对高效，但对于包括大量辅助平面字符的文本，可能会占用更多空间。UTF-32 最简单，但由于每个字符固定占用 4 个字节，通常会占用更多的存储空间。</p>\n"},{"title":"add Image","date":"2022-09-25T12:26:19.000Z","_content":"\n\n###测试插入一张图片\n\n\n![](../add-Image/sharedptr1.png)\n\n\ntest end\n\n\n\n","source":"_posts/add-Image.md","raw":"---\ntitle: add Image\ndate: 2022-09-25 20:26:19\ntags: test\n---\n\n\n###测试插入一张图片\n\n\n![](../add-Image/sharedptr1.png)\n\n\ntest end\n\n\n\n","slug":"add-Image","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a20019gcco0almano7","content":"<p>###测试插入一张图片</p>\n<p><img src=\"/2022/09/25/add-Image/sharedptr1.png\"></p>\n<p>test end</p>\n","site":{"data":{}},"excerpt":"","more":"<p>###测试插入一张图片</p>\n<p><img src=\"/2022/09/25/add-Image/sharedptr1.png\"></p>\n<p>test end</p>\n"},{"title":"c++ 可变参数模板","date":"2022-12-11T06:50:04.000Z","_content":"\n\n\n### 可变模版参数(variadic templates)\n可以对参数进行高度泛化，标识0到任意个数参数\n\n#### 两种展开形式\n1. 使用特化的终止函数结合递归\n\n```\n#include <iostream>\nusing namespace std;\n\n//终止函数\nint multiply()\n{\n    return 1;\n}\n\n//递归展开\ntemplate <typename T, typename ...Args>\nint multiply(T&& t, Args&& ...arg)\n{\n    return t * multiply(arg...);\n}\n\nint main(int argc, const char * argv[]) {\n    \n    cout << multiply(3, 4, 5) << endl;\n    \n    cout << multiply() << endl;\n    \n    return 0;\n}\n```\n\n2. 使用逗号表达式\n初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)...}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc... )，最终会创建一个元素值都为0的数组int arr[sizeof...(Args)]\n\n\n```\ntemplate<class F, class... Args>void expand(const F& f, Args&&...args)\n{\n  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》\n  initializer_list<int>{(f(std::forward< Args>(args)),0)...};\n}\n\nint main(int argc, const char * argv[]) {\n    \n    expand([](int i) {\n        cout<<i<<endl;\n    }, 1,2,3);\n    return 0;\n}\n\n```\n\n### initializer_list\n为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板\n\n```\nstruct myclass {\n    myclass(int,int)\n    {\n        cout << \"myclass constructor\" << endl;\n    }\n    myclass(initializer_list<int>)\n    {\n        cout << \"myclass initializer_list constructor\" << endl;\n    }\n};\n\n\nint main(int argc, const char * argv[]) {\n    \n    auto il = {10, 20, 30};\n    \n    myclass foo {10,20};  // calls initializer_list constructor\n    myclass bar (10,20);  // calls first constructo\n    \n    return 0;\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/c-可变参数模板.md","raw":"---\ntitle: c++ 可变参数模板\ndate: 2022-12-11 14:50:04\ntags: c++11\n---\n\n\n\n### 可变模版参数(variadic templates)\n可以对参数进行高度泛化，标识0到任意个数参数\n\n#### 两种展开形式\n1. 使用特化的终止函数结合递归\n\n```\n#include <iostream>\nusing namespace std;\n\n//终止函数\nint multiply()\n{\n    return 1;\n}\n\n//递归展开\ntemplate <typename T, typename ...Args>\nint multiply(T&& t, Args&& ...arg)\n{\n    return t * multiply(arg...);\n}\n\nint main(int argc, const char * argv[]) {\n    \n    cout << multiply(3, 4, 5) << endl;\n    \n    cout << multiply() << endl;\n    \n    return 0;\n}\n```\n\n2. 使用逗号表达式\n初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)...}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc... )，最终会创建一个元素值都为0的数组int arr[sizeof...(Args)]\n\n\n```\ntemplate<class F, class... Args>void expand(const F& f, Args&&...args)\n{\n  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》\n  initializer_list<int>{(f(std::forward< Args>(args)),0)...};\n}\n\nint main(int argc, const char * argv[]) {\n    \n    expand([](int i) {\n        cout<<i<<endl;\n    }, 1,2,3);\n    return 0;\n}\n\n```\n\n### initializer_list\n为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板\n\n```\nstruct myclass {\n    myclass(int,int)\n    {\n        cout << \"myclass constructor\" << endl;\n    }\n    myclass(initializer_list<int>)\n    {\n        cout << \"myclass initializer_list constructor\" << endl;\n    }\n};\n\n\nint main(int argc, const char * argv[]) {\n    \n    auto il = {10, 20, 30};\n    \n    myclass foo {10,20};  // calls initializer_list constructor\n    myclass bar (10,20);  // calls first constructo\n    \n    return 0;\n}\n```\n\n\n\n\n\n\n\n","slug":"c-可变参数模板","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a2001bgcco7xms5h43","content":"<h3 id=\"可变模版参数-variadic-templates\"><a href=\"#可变模版参数-variadic-templates\" class=\"headerlink\" title=\"可变模版参数(variadic templates)\"></a>可变模版参数(variadic templates)</h3><p>可以对参数进行高度泛化，标识0到任意个数参数</p>\n<h4 id=\"两种展开形式\"><a href=\"#两种展开形式\" class=\"headerlink\" title=\"两种展开形式\"></a>两种展开形式</h4><ol>\n<li>使用特化的终止函数结合递归</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">//终止函数</span><br><span class=\"line\">int multiply()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//递归展开</span><br><span class=\"line\">template &lt;typename T, typename ...Args&gt;</span><br><span class=\"line\">int multiply(T&amp;&amp; t, Args&amp;&amp; ...arg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return t * multiply(arg...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; multiply(3, 4, 5) &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; multiply() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用逗号表达式<br>初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc… )，最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class F, class... Args&gt;void expand(const F&amp; f, Args&amp;&amp;...args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》</span><br><span class=\"line\">  initializer_list&lt;int&gt;&#123;(f(std::forward&lt; Args&gt;(args)),0)...&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    expand([](int i) &#123;</span><br><span class=\"line\">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class=\"line\">    &#125;, 1,2,3);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"initializer-list\"><a href=\"#initializer-list\" class=\"headerlink\" title=\"initializer_list\"></a>initializer_list</h3><p>为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct myclass &#123;</span><br><span class=\"line\">    myclass(int,int)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;myclass constructor&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    myclass(initializer_list&lt;int&gt;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;myclass initializer_list constructor&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    auto il = &#123;10, 20, 30&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    myclass foo &#123;10,20&#125;;  // calls initializer_list constructor</span><br><span class=\"line\">    myclass bar (10,20);  // calls first constructo</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"可变模版参数-variadic-templates\"><a href=\"#可变模版参数-variadic-templates\" class=\"headerlink\" title=\"可变模版参数(variadic templates)\"></a>可变模版参数(variadic templates)</h3><p>可以对参数进行高度泛化，标识0到任意个数参数</p>\n<h4 id=\"两种展开形式\"><a href=\"#两种展开形式\" class=\"headerlink\" title=\"两种展开形式\"></a>两种展开形式</h4><ol>\n<li>使用特化的终止函数结合递归</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">//终止函数</span><br><span class=\"line\">int multiply()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//递归展开</span><br><span class=\"line\">template &lt;typename T, typename ...Args&gt;</span><br><span class=\"line\">int multiply(T&amp;&amp; t, Args&amp;&amp; ...arg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return t * multiply(arg...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; multiply(3, 4, 5) &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; multiply() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用逗号表达式<br>初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc… )，最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class F, class... Args&gt;void expand(const F&amp; f, Args&amp;&amp;...args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》</span><br><span class=\"line\">  initializer_list&lt;int&gt;&#123;(f(std::forward&lt; Args&gt;(args)),0)...&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    expand([](int i) &#123;</span><br><span class=\"line\">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class=\"line\">    &#125;, 1,2,3);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"initializer-list\"><a href=\"#initializer-list\" class=\"headerlink\" title=\"initializer_list\"></a>initializer_list</h3><p>为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct myclass &#123;</span><br><span class=\"line\">    myclass(int,int)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;myclass constructor&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    myclass(initializer_list&lt;int&gt;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;myclass initializer_list constructor&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    auto il = &#123;10, 20, 30&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    myclass foo &#123;10,20&#125;;  // calls initializer_list constructor</span><br><span class=\"line\">    myclass bar (10,20);  // calls first constructo</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n"},{"title":"c++模版函数delete防止隐士类型转换.md","date":"2024-09-26T06:29:27.000Z","_content":"```c++\nstruct Person {\n    int a = 0;\n    operator int&() { return a; }\n    operator const int&() const { return a; }\n};\n\ntemplate <typename T>\nvoid testFunc(T arg) = delete;\n\nvoid testFunc(int arg)\n{\n    printf(\"called testFunc int\\n\");\n}\n\nint main() {\n    \n    Person a;\n    testFunc(a); //报错\n    return 0;\n}\n```\n","source":"_posts/c-模版函数delete防止隐士类型转换-md.md","raw":"---\ntitle: c++模版函数delete防止隐士类型转换.md\ndate: 2024-09-26 14:29:27\ntags:\n---\n```c++\nstruct Person {\n    int a = 0;\n    operator int&() { return a; }\n    operator const int&() const { return a; }\n};\n\ntemplate <typename T>\nvoid testFunc(T arg) = delete;\n\nvoid testFunc(int arg)\n{\n    printf(\"called testFunc int\\n\");\n}\n\nint main() {\n    \n    Person a;\n    testFunc(a); //报错\n    return 0;\n}\n```\n","slug":"c-模版函数delete防止隐士类型转换-md","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a3001dgccoeg0v7hlm","content":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"type\">int</span>&amp;() &#123; <span class=\"keyword\">return</span> a; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"type\">const</span> <span class=\"type\">int</span>&amp;() <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> a; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">testFunc</span><span class=\"params\">(T arg)</span> </span>= <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">testFunc</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;called testFunc int\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person a;</span><br><span class=\"line\">    <span class=\"built_in\">testFunc</span>(a); <span class=\"comment\">//报错</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"type\">int</span>&amp;() &#123; <span class=\"keyword\">return</span> a; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"type\">const</span> <span class=\"type\">int</span>&amp;() <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> a; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">testFunc</span><span class=\"params\">(T arg)</span> </span>= <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">testFunc</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;called testFunc int\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person a;</span><br><span class=\"line\">    <span class=\"built_in\">testFunc</span>(a); <span class=\"comment\">//报错</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"c++继承权限","date":"2022-12-04T14:52:54.000Z","_content":"\n1. 继承有三种权限，public，proteced，private，默认不写是private\n\n2. 权限的最低是public，其次是protected，最高private\n\n3. 继承方式代表是父类属性在当前类中的最低呈现\n\n4. 父类中的privated属性在子类中不可访问\n\n","source":"_posts/c-继承权限.md","raw":"---\ntitle: c++继承权限\ndate: 2022-12-04 22:52:54\ntags:\n---\n\n1. 继承有三种权限，public，proteced，private，默认不写是private\n\n2. 权限的最低是public，其次是protected，最高private\n\n3. 继承方式代表是父类属性在当前类中的最低呈现\n\n4. 父类中的privated属性在子类中不可访问\n\n","slug":"c-继承权限","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a3001fgccof1f1f5pf","content":"<ol>\n<li><p>继承有三种权限，public，proteced，private，默认不写是private</p>\n</li>\n<li><p>权限的最低是public，其次是protected，最高private</p>\n</li>\n<li><p>继承方式代表是父类属性在当前类中的最低呈现</p>\n</li>\n<li><p>父类中的privated属性在子类中不可访问</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>继承有三种权限，public，proteced，private，默认不写是private</p>\n</li>\n<li><p>权限的最低是public，其次是protected，最高private</p>\n</li>\n<li><p>继承方式代表是父类属性在当前类中的最低呈现</p>\n</li>\n<li><p>父类中的privated属性在子类中不可访问</p>\n</li>\n</ol>\n"},{"layout":"post","title":"iOS运行时消息转发","subtitle":"iOS Runtime","date":"2017-12-13T16:00:00.000Z","_content":"\n\n> 最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解\n\n\n\n### iOS 方法调用探讨\n\n这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, ...)方法这种方式\n\n在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding\n\n如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：\n\n![image.png](https://oh144b0ji.qnssl.com/OC%20runTime.jpg)\n\n\n\n主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程\n\n1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法\n\n```\n+ (BOOL)resolveInstanceMethod:(SEL)aSEL{\n  \n    if (aSEL == @selector(notFoundFunctiion)) {\n        \n        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, \"v@:\");\n        return YES;\n    }\n    \n    return [super resolveInstanceMethod:aSEL];\n}\n```\n\n​\t需要注意的是，不仅[self notFoundFunctiion]会触发这里，在\n\n```\n[self respondsToSelector:@selector(notFoundFunctiion)]\n```\n\n​\t这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。\n\n\n\n2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程\n\n可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO\n\n\n\n#### 参考文章：\n\n[Objective-C Runtime Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html)\n\n\n\n\n","source":"_posts/iOS-MessageForwarding.md","raw":"---\nlayout:     post\ntitle:      iOS运行时消息转发\nsubtitle:   iOS Runtime\ndate:       2017-12-14\ntags:\n    - iOS\n---\n\n\n> 最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解\n\n\n\n### iOS 方法调用探讨\n\n这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, ...)方法这种方式\n\n在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding\n\n如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：\n\n![image.png](https://oh144b0ji.qnssl.com/OC%20runTime.jpg)\n\n\n\n主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程\n\n1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法\n\n```\n+ (BOOL)resolveInstanceMethod:(SEL)aSEL{\n  \n    if (aSEL == @selector(notFoundFunctiion)) {\n        \n        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, \"v@:\");\n        return YES;\n    }\n    \n    return [super resolveInstanceMethod:aSEL];\n}\n```\n\n​\t需要注意的是，不仅[self notFoundFunctiion]会触发这里，在\n\n```\n[self respondsToSelector:@selector(notFoundFunctiion)]\n```\n\n​\t这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。\n\n\n\n2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程\n\n可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO\n\n\n\n#### 参考文章：\n\n[Objective-C Runtime Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html)\n\n\n\n\n","slug":"iOS-MessageForwarding","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a3001hgccodamgc2ha","content":"<blockquote>\n<p>最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解</p>\n</blockquote>\n<h3 id=\"iOS-方法调用探讨\"><a href=\"#iOS-方法调用探讨\" class=\"headerlink\" title=\"iOS 方法调用探讨\"></a>iOS 方法调用探讨</h3><p>这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, …)方法这种方式</p>\n<p>在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding</p>\n<p>如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：</p>\n<p><img src=\"https://oh144b0ji.qnssl.com/OC%20runTime.jpg\" alt=\"image.png\"></p>\n<p>主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程</p>\n<p>1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    if (aSEL == @selector(notFoundFunctiion)) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return [super resolveInstanceMethod:aSEL];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    需要注意的是，不仅[self notFoundFunctiion]会触发这里，在</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self respondsToSelector:@selector(notFoundFunctiion)]</span><br></pre></td></tr></table></figure>\n\n<p>​    这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。</p>\n<p>2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程</p>\n<p>可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO</p>\n<h4 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h4><p><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html\">Objective-C Runtime Programming Guide</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解</p>\n</blockquote>\n<h3 id=\"iOS-方法调用探讨\"><a href=\"#iOS-方法调用探讨\" class=\"headerlink\" title=\"iOS 方法调用探讨\"></a>iOS 方法调用探讨</h3><p>这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, …)方法这种方式</p>\n<p>在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding</p>\n<p>如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：</p>\n<p><img src=\"https://oh144b0ji.qnssl.com/OC%20runTime.jpg\" alt=\"image.png\"></p>\n<p>主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程</p>\n<p>1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    if (aSEL == @selector(notFoundFunctiion)) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return [super resolveInstanceMethod:aSEL];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    需要注意的是，不仅[self notFoundFunctiion]会触发这里，在</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self respondsToSelector:@selector(notFoundFunctiion)]</span><br></pre></td></tr></table></figure>\n\n<p>​    这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。</p>\n<p>2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程</p>\n<p>可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO</p>\n<h4 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h4><p><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html\">Objective-C Runtime Programming Guide</a></p>\n"},{"layout":"post","title":"iOS11模拟器运行OpenGL相关程序卡顿","subtitle":"Xcode9.0 problem","date":"2017-09-18T16:00:00.000Z","author":"jack","header-img":"img/post-bg-ios9-web.jpg","catalog":true,"_content":"\n\n> 最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug\n\n\n\n### 具体的解决方案是\n替换此路径下的文件用附件文件，替换此路径下文件即可\n\n*/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib*  \n\n[libCoreVMClient.dylib下载链接](http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib)\n\n\n\n### 参考文献\n\n[苹果开发者论坛](https://forums.developer.apple.com/thread/83570)","source":"_posts/iOS11 Simulator OpenGL Slowly.md","raw":"---\nlayout:     post\ntitle:      iOS11模拟器运行OpenGL相关程序卡顿\nsubtitle:   Xcode9.0 problem\ndate:       2017-09-19\nauthor:     jack\nheader-img: img/post-bg-ios9-web.jpg\ncatalog: true\ntags:\n    - iOS\n---\n\n\n> 最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug\n\n\n\n### 具体的解决方案是\n替换此路径下的文件用附件文件，替换此路径下文件即可\n\n*/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib*  \n\n[libCoreVMClient.dylib下载链接](http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib)\n\n\n\n### 参考文献\n\n[苹果开发者论坛](https://forums.developer.apple.com/thread/83570)","slug":"iOS11 Simulator OpenGL Slowly","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a3001jgcco6306azsf","content":"<blockquote>\n<p>最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug</p>\n</blockquote>\n<h3 id=\"具体的解决方案是\"><a href=\"#具体的解决方案是\" class=\"headerlink\" title=\"具体的解决方案是\"></a>具体的解决方案是</h3><p>替换此路径下的文件用附件文件，替换此路径下文件即可</p>\n<p><em>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib</em>  </p>\n<p><a href=\"http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib\">libCoreVMClient.dylib下载链接</a></p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://forums.developer.apple.com/thread/83570\">苹果开发者论坛</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug</p>\n</blockquote>\n<h3 id=\"具体的解决方案是\"><a href=\"#具体的解决方案是\" class=\"headerlink\" title=\"具体的解决方案是\"></a>具体的解决方案是</h3><p>替换此路径下的文件用附件文件，替换此路径下文件即可</p>\n<p><em>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib</em>  </p>\n<p><a href=\"http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib\">libCoreVMClient.dylib下载链接</a></p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://forums.developer.apple.com/thread/83570\">苹果开发者论坛</a></p>\n"},{"layout":"post","title":"iOS不受用户手动修改时间的影响的计时技术","subtitle":"一种不受系统时钟影响的实现","date":"2017-09-16T16:00:00.000Z","author":"jack","header-img":"img/post-bg-ios9-web.jpg","catalog":true,"_content":"\n### iOS不受用户手动修改时间的影响的计时技术\n\n### 前言\n\n这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案\n\n\n\n### 解决问题\n\n直接说最终方案\n\n`[[NSProcessInfo processInfo] systemUptime];`\n\n这个函数返回的是开机到当前的时间，秒数为单位，并且**不受系统时钟的影响**，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.\n\n\n\n### 参考文献\n\n[苹果接口文档](https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc)","source":"_posts/iOS准确计时.md","raw":"---\nlayout:     post\ntitle:      iOS不受用户手动修改时间的影响的计时技术\nsubtitle:   一种不受系统时钟影响的实现\ndate:       2017-09-17\nauthor:     jack\nheader-img: img/post-bg-ios9-web.jpg\ncatalog: true\ntags:\n    - iOS\n---\n\n### iOS不受用户手动修改时间的影响的计时技术\n\n### 前言\n\n这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案\n\n\n\n### 解决问题\n\n直接说最终方案\n\n`[[NSProcessInfo processInfo] systemUptime];`\n\n这个函数返回的是开机到当前的时间，秒数为单位，并且**不受系统时钟的影响**，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.\n\n\n\n### 参考文献\n\n[苹果接口文档](https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc)","slug":"iOS准确计时","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a3001lgcco5g9bdi77","content":"<h3 id=\"iOS不受用户手动修改时间的影响的计时技术\"><a href=\"#iOS不受用户手动修改时间的影响的计时技术\" class=\"headerlink\" title=\"iOS不受用户手动修改时间的影响的计时技术\"></a>iOS不受用户手动修改时间的影响的计时技术</h3><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案</p>\n<h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>直接说最终方案</p>\n<p><code>[[NSProcessInfo processInfo] systemUptime];</code></p>\n<p>这个函数返回的是开机到当前的时间，秒数为单位，并且<strong>不受系统时钟的影响</strong>，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc\">苹果接口文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"iOS不受用户手动修改时间的影响的计时技术\"><a href=\"#iOS不受用户手动修改时间的影响的计时技术\" class=\"headerlink\" title=\"iOS不受用户手动修改时间的影响的计时技术\"></a>iOS不受用户手动修改时间的影响的计时技术</h3><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案</p>\n<h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>直接说最终方案</p>\n<p><code>[[NSProcessInfo processInfo] systemUptime];</code></p>\n<p>这个函数返回的是开机到当前的时间，秒数为单位，并且<strong>不受系统时钟的影响</strong>，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc\">苹果接口文档</a></p>\n"},{"title":"lamda 初始化捕获用法","date":"2023-12-27T06:16:08.000Z","_content":"","source":"_posts/lamda-初始化捕获用法.md","raw":"---\ntitle: lamda 初始化捕获用法\ndate: 2023-12-27 14:16:08\ntags:\n---\n","slug":"lamda-初始化捕获用法","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a3001ogcco0vf1dm9z","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"pthread_create设置栈size","date":"2024-07-28T02:44:09.000Z","_content":"\n```cpp\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid* threadFunction(void* arg) {\n    // 线程的执行代码\n    printf(\"Thread is running\\n\");\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    pthread_attr_t attr;\n    size_t stackSize = 2 * 1024 * 1024; // 设置栈大小为2 MiB\n\n    // 初始化线程属性\n    if (pthread_attr_init(&attr) != 0) {\n        perror(\"pthread_attr_init\");\n        return EXIT_FAILURE;\n    }\n\n    // 设置线程栈大小\n    if (pthread_attr_setstacksize(&attr, stackSize) != 0) {\n        perror(\"pthread_attr_setstacksize\");\n        return EXIT_FAILURE;\n    }\n\n    // 创建线程\n    if (pthread_create(&thread, &attr, threadFunction, NULL) != 0) {\n        perror(\"pthread_create\");\n        return EXIT_FAILURE;\n    }\n\n    // 等待线程结束\n    if (pthread_join(thread, NULL) != 0) {\n        perror(\"pthread_join\");\n        return EXIT_FAILURE;\n    }\n\n    // 销毁线程属性\n    if (pthread_attr_destroy(&attr) != 0) {\n        perror(\"pthread_attr_destroy\");\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n```","source":"_posts/pthread-create设置栈size.md","raw":"---\ntitle: pthread_create设置栈size\ndate: 2024-07-28 10:44:09\ntags:\n---\n\n```cpp\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid* threadFunction(void* arg) {\n    // 线程的执行代码\n    printf(\"Thread is running\\n\");\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    pthread_attr_t attr;\n    size_t stackSize = 2 * 1024 * 1024; // 设置栈大小为2 MiB\n\n    // 初始化线程属性\n    if (pthread_attr_init(&attr) != 0) {\n        perror(\"pthread_attr_init\");\n        return EXIT_FAILURE;\n    }\n\n    // 设置线程栈大小\n    if (pthread_attr_setstacksize(&attr, stackSize) != 0) {\n        perror(\"pthread_attr_setstacksize\");\n        return EXIT_FAILURE;\n    }\n\n    // 创建线程\n    if (pthread_create(&thread, &attr, threadFunction, NULL) != 0) {\n        perror(\"pthread_create\");\n        return EXIT_FAILURE;\n    }\n\n    // 等待线程结束\n    if (pthread_join(thread, NULL) != 0) {\n        perror(\"pthread_join\");\n        return EXIT_FAILURE;\n    }\n\n    // 销毁线程属性\n    if (pthread_attr_destroy(&attr) != 0) {\n        perror(\"pthread_attr_destroy\");\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n```","slug":"pthread-create设置栈size","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a4001qgcco5s52gswr","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span>* <span class=\"title\">threadFunction</span><span class=\"params\">(<span class=\"type\">void</span>* arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 线程的执行代码</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Thread is running\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> thread;</span><br><span class=\"line\">    <span class=\"type\">pthread_attr_t</span> attr;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> stackSize = <span class=\"number\">2</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>; <span class=\"comment\">// 设置栈大小为2 MiB</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化线程属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_attr_init</span>(&amp;attr) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_attr_init&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置线程栈大小</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_attr_setstacksize</span>(&amp;attr, stackSize) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_attr_setstacksize&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_create</span>(&amp;thread, &amp;attr, threadFunction, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_create&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待线程结束</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_join</span>(thread, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_join&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 销毁线程属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_attr_destroy</span>(&amp;attr) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_attr_destroy&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span>* <span class=\"title\">threadFunction</span><span class=\"params\">(<span class=\"type\">void</span>* arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 线程的执行代码</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Thread is running\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> thread;</span><br><span class=\"line\">    <span class=\"type\">pthread_attr_t</span> attr;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> stackSize = <span class=\"number\">2</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>; <span class=\"comment\">// 设置栈大小为2 MiB</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化线程属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_attr_init</span>(&amp;attr) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_attr_init&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置线程栈大小</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_attr_setstacksize</span>(&amp;attr, stackSize) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_attr_setstacksize&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_create</span>(&amp;thread, &amp;attr, threadFunction, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_create&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待线程结束</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_join</span>(thread, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_join&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 销毁线程属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_attr_destroy</span>(&amp;attr) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_attr_destroy&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"shell和子shell环境变量","date":"2024-09-29T06:12:02.000Z","_content":"\n在 Shell 脚本中，命令替换（command substitution）是指将命令的输出作为字符串插入到另一个命令中。命令替换通常使用反引号（`` `command` ``）或 `$()` 语法来实现。命令替换会在一个子 Shell 中执行指定的命令，这意味着在子 Shell 中定义的变量不会影响父 Shell 中的变量。\n\n### 1. 子 Shell 的概念\n\n- **子 Shell**: 当你在 Shell 中执行一个命令替换时，Shell 会创建一个新的子 Shell 来执行该命令。子 Shell 是父 Shell 的一个独立实例，具有自己的环境和变量。\n\n### 2. 变量作用域\n\n- 在子 Shell 中定义的变量不会影响父 Shell 中的变量。相反，父 Shell 中的变量也无法在子 Shell 中被访问。\n\n### 3. 示例\n\n以下是一个示例，展示了命令替换如何在子 Shell 中运行命令，并且如何影响变量的作用域。\n\n```bash\n#!/bin/bash\n\n# 定义一个变量\nvar=\"Hello from parent shell\"\n\n# 使用命令替换\nresult=$(echo $var)\n\n# 输出结果\necho \"Result from command substitution: $result\"\n\n# 在子 Shell 中修改变量\nresult=$(echo \"Hello from child shell\"; var=\"Hello from child shell\")\n\n# 输出结果\necho \"Result after child shell: $result\"\necho \"Variable in parent shell: $var\"\n```\n\n### 4. 运行结果\n\n如果你运行上述脚本，输出将是：\n\n```\nResult from command substitution: Hello from parent shell\nResult after child shell: Hello from child shell\nVariable in parent shell: Hello from parent shell\n```\n\n### 5. 解释\n\n- **第一部分**: \n  - `var=\"Hello from parent shell\"` 定义了一个变量 `var` 在父 Shell 中。\n  - `result=$(echo $var)` 使用命令替换，将 `var` 的值传递给 `result`。此时，`result` 的值为 `Hello from parent shell`。\n\n- **第二部分**:\n  - `result=$(echo \"Hello from child shell\"; var=\"Hello from child shell\")` 在子 Shell 中执行。虽然在子 Shell 中修改了 `var` 的值，但这个修改不会影响父 Shell 中的 `var` 变量。\n  - `result` 的值被设置为 `Hello from child shell`，但父 Shell 中的 `var` 仍然保持为 `Hello from parent shell`。\n\n### 6. 总结\n\n命令替换会在子 Shell 中执行命令，因此在子 Shell 中定义的变量不会影响父 Shell 中的变量。这种行为是 Shell 的一个重要特性，理解这一点对于编写有效的 Shell 脚本非常重要。","source":"_posts/shell和子shell环境变量.md","raw":"---\ntitle: shell和子shell环境变量\ndate: 2024-09-29 14:12:02\ntags:\n---\n\n在 Shell 脚本中，命令替换（command substitution）是指将命令的输出作为字符串插入到另一个命令中。命令替换通常使用反引号（`` `command` ``）或 `$()` 语法来实现。命令替换会在一个子 Shell 中执行指定的命令，这意味着在子 Shell 中定义的变量不会影响父 Shell 中的变量。\n\n### 1. 子 Shell 的概念\n\n- **子 Shell**: 当你在 Shell 中执行一个命令替换时，Shell 会创建一个新的子 Shell 来执行该命令。子 Shell 是父 Shell 的一个独立实例，具有自己的环境和变量。\n\n### 2. 变量作用域\n\n- 在子 Shell 中定义的变量不会影响父 Shell 中的变量。相反，父 Shell 中的变量也无法在子 Shell 中被访问。\n\n### 3. 示例\n\n以下是一个示例，展示了命令替换如何在子 Shell 中运行命令，并且如何影响变量的作用域。\n\n```bash\n#!/bin/bash\n\n# 定义一个变量\nvar=\"Hello from parent shell\"\n\n# 使用命令替换\nresult=$(echo $var)\n\n# 输出结果\necho \"Result from command substitution: $result\"\n\n# 在子 Shell 中修改变量\nresult=$(echo \"Hello from child shell\"; var=\"Hello from child shell\")\n\n# 输出结果\necho \"Result after child shell: $result\"\necho \"Variable in parent shell: $var\"\n```\n\n### 4. 运行结果\n\n如果你运行上述脚本，输出将是：\n\n```\nResult from command substitution: Hello from parent shell\nResult after child shell: Hello from child shell\nVariable in parent shell: Hello from parent shell\n```\n\n### 5. 解释\n\n- **第一部分**: \n  - `var=\"Hello from parent shell\"` 定义了一个变量 `var` 在父 Shell 中。\n  - `result=$(echo $var)` 使用命令替换，将 `var` 的值传递给 `result`。此时，`result` 的值为 `Hello from parent shell`。\n\n- **第二部分**:\n  - `result=$(echo \"Hello from child shell\"; var=\"Hello from child shell\")` 在子 Shell 中执行。虽然在子 Shell 中修改了 `var` 的值，但这个修改不会影响父 Shell 中的 `var` 变量。\n  - `result` 的值被设置为 `Hello from child shell`，但父 Shell 中的 `var` 仍然保持为 `Hello from parent shell`。\n\n### 6. 总结\n\n命令替换会在子 Shell 中执行命令，因此在子 Shell 中定义的变量不会影响父 Shell 中的变量。这种行为是 Shell 的一个重要特性，理解这一点对于编写有效的 Shell 脚本非常重要。","slug":"shell和子shell环境变量","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a4001tgcco56ln1pjt","content":"<p>在 Shell 脚本中，命令替换（command substitution）是指将命令的输出作为字符串插入到另一个命令中。命令替换通常使用反引号（<code>`command`</code>）或 <code>$()</code> 语法来实现。命令替换会在一个子 Shell 中执行指定的命令，这意味着在子 Shell 中定义的变量不会影响父 Shell 中的变量。</p>\n<h3 id=\"1-子-Shell-的概念\"><a href=\"#1-子-Shell-的概念\" class=\"headerlink\" title=\"1. 子 Shell 的概念\"></a>1. 子 Shell 的概念</h3><ul>\n<li><strong>子 Shell</strong>: 当你在 Shell 中执行一个命令替换时，Shell 会创建一个新的子 Shell 来执行该命令。子 Shell 是父 Shell 的一个独立实例，具有自己的环境和变量。</li>\n</ul>\n<h3 id=\"2-变量作用域\"><a href=\"#2-变量作用域\" class=\"headerlink\" title=\"2. 变量作用域\"></a>2. 变量作用域</h3><ul>\n<li>在子 Shell 中定义的变量不会影响父 Shell 中的变量。相反，父 Shell 中的变量也无法在子 Shell 中被访问。</li>\n</ul>\n<h3 id=\"3-示例\"><a href=\"#3-示例\" class=\"headerlink\" title=\"3. 示例\"></a>3. 示例</h3><p>以下是一个示例，展示了命令替换如何在子 Shell 中运行命令，并且如何影响变量的作用域。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义一个变量</span></span><br><span class=\"line\">var=<span class=\"string\">&quot;Hello from parent shell&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用命令替换</span></span><br><span class=\"line\">result=$(<span class=\"built_in\">echo</span> <span class=\"variable\">$var</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Result from command substitution: <span class=\"variable\">$result</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在子 Shell 中修改变量</span></span><br><span class=\"line\">result=$(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello from child shell&quot;</span>; var=<span class=\"string\">&quot;Hello from child shell&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Result after child shell: <span class=\"variable\">$result</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Variable in parent shell: <span class=\"variable\">$var</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-运行结果\"><a href=\"#4-运行结果\" class=\"headerlink\" title=\"4. 运行结果\"></a>4. 运行结果</h3><p>如果你运行上述脚本，输出将是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result from command substitution: Hello from parent shell</span><br><span class=\"line\">Result after child shell: Hello from child shell</span><br><span class=\"line\">Variable in parent shell: Hello from parent shell</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-解释\"><a href=\"#5-解释\" class=\"headerlink\" title=\"5. 解释\"></a>5. 解释</h3><ul>\n<li><p><strong>第一部分</strong>: </p>\n<ul>\n<li><code>var=&quot;Hello from parent shell&quot;</code> 定义了一个变量 <code>var</code> 在父 Shell 中。</li>\n<li><code>result=$(echo $var)</code> 使用命令替换，将 <code>var</code> 的值传递给 <code>result</code>。此时，<code>result</code> 的值为 <code>Hello from parent shell</code>。</li>\n</ul>\n</li>\n<li><p><strong>第二部分</strong>:</p>\n<ul>\n<li><code>result=$(echo &quot;Hello from child shell&quot;; var=&quot;Hello from child shell&quot;)</code> 在子 Shell 中执行。虽然在子 Shell 中修改了 <code>var</code> 的值，但这个修改不会影响父 Shell 中的 <code>var</code> 变量。</li>\n<li><code>result</code> 的值被设置为 <code>Hello from child shell</code>，但父 Shell 中的 <code>var</code> 仍然保持为 <code>Hello from parent shell</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><p>命令替换会在子 Shell 中执行命令，因此在子 Shell 中定义的变量不会影响父 Shell 中的变量。这种行为是 Shell 的一个重要特性，理解这一点对于编写有效的 Shell 脚本非常重要。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 Shell 脚本中，命令替换（command substitution）是指将命令的输出作为字符串插入到另一个命令中。命令替换通常使用反引号（<code>`command`</code>）或 <code>$()</code> 语法来实现。命令替换会在一个子 Shell 中执行指定的命令，这意味着在子 Shell 中定义的变量不会影响父 Shell 中的变量。</p>\n<h3 id=\"1-子-Shell-的概念\"><a href=\"#1-子-Shell-的概念\" class=\"headerlink\" title=\"1. 子 Shell 的概念\"></a>1. 子 Shell 的概念</h3><ul>\n<li><strong>子 Shell</strong>: 当你在 Shell 中执行一个命令替换时，Shell 会创建一个新的子 Shell 来执行该命令。子 Shell 是父 Shell 的一个独立实例，具有自己的环境和变量。</li>\n</ul>\n<h3 id=\"2-变量作用域\"><a href=\"#2-变量作用域\" class=\"headerlink\" title=\"2. 变量作用域\"></a>2. 变量作用域</h3><ul>\n<li>在子 Shell 中定义的变量不会影响父 Shell 中的变量。相反，父 Shell 中的变量也无法在子 Shell 中被访问。</li>\n</ul>\n<h3 id=\"3-示例\"><a href=\"#3-示例\" class=\"headerlink\" title=\"3. 示例\"></a>3. 示例</h3><p>以下是一个示例，展示了命令替换如何在子 Shell 中运行命令，并且如何影响变量的作用域。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义一个变量</span></span><br><span class=\"line\">var=<span class=\"string\">&quot;Hello from parent shell&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用命令替换</span></span><br><span class=\"line\">result=$(<span class=\"built_in\">echo</span> <span class=\"variable\">$var</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Result from command substitution: <span class=\"variable\">$result</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在子 Shell 中修改变量</span></span><br><span class=\"line\">result=$(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello from child shell&quot;</span>; var=<span class=\"string\">&quot;Hello from child shell&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Result after child shell: <span class=\"variable\">$result</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Variable in parent shell: <span class=\"variable\">$var</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-运行结果\"><a href=\"#4-运行结果\" class=\"headerlink\" title=\"4. 运行结果\"></a>4. 运行结果</h3><p>如果你运行上述脚本，输出将是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result from command substitution: Hello from parent shell</span><br><span class=\"line\">Result after child shell: Hello from child shell</span><br><span class=\"line\">Variable in parent shell: Hello from parent shell</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-解释\"><a href=\"#5-解释\" class=\"headerlink\" title=\"5. 解释\"></a>5. 解释</h3><ul>\n<li><p><strong>第一部分</strong>: </p>\n<ul>\n<li><code>var=&quot;Hello from parent shell&quot;</code> 定义了一个变量 <code>var</code> 在父 Shell 中。</li>\n<li><code>result=$(echo $var)</code> 使用命令替换，将 <code>var</code> 的值传递给 <code>result</code>。此时，<code>result</code> 的值为 <code>Hello from parent shell</code>。</li>\n</ul>\n</li>\n<li><p><strong>第二部分</strong>:</p>\n<ul>\n<li><code>result=$(echo &quot;Hello from child shell&quot;; var=&quot;Hello from child shell&quot;)</code> 在子 Shell 中执行。虽然在子 Shell 中修改了 <code>var</code> 的值，但这个修改不会影响父 Shell 中的 <code>var</code> 变量。</li>\n<li><code>result</code> 的值被设置为 <code>Hello from child shell</code>，但父 Shell 中的 <code>var</code> 仍然保持为 <code>Hello from parent shell</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><p>命令替换会在子 Shell 中执行命令，因此在子 Shell 中定义的变量不会影响父 Shell 中的变量。这种行为是 Shell 的一个重要特性，理解这一点对于编写有效的 Shell 脚本非常重要。</p>\n"},{"layout":"post","title":"iOS手势事件分发原理","subtitle":"iOSHitTest和PointInSide实现探究","date":"2017-06-30T16:00:00.000Z","author":"jack","header-img":"img/post-bg-ios9-web.jpg","catalog":true,"_content":"\nHitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理\n\n```\n- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event{\n    \n    //apple文档描述，不接受事件的情况\n    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha < 0.01) {\n        return nil;\n    }\n    \n    //如果当前View包含此Point\n    if ([self pointInside:point withEvent:event]) {\n        \n        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的\n        for (NSInteger i=self.subviews.count-1; i>=0; i--) {\n            \n            UIView* subView = [self.subviews objectAtIndex:i];\n            \n            //将父View的Point转换成子View坐标系的Point\n            CGPoint pointInSubView = [subView convertPoint:point fromView:self];\n            \n            //递归子View调用HitTest:\n            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];\n            \n            //找到了子View可以响应\n            if (resultView) {\n                return resultView;\n            }\n            \n        }\n        \n        //没有找到可以响应的子View，返回自己\n        return self;\n    }\n    \n    //返回nil，告诉上一级自己无法响应此事件\n    return nil;\n}\n```\n\n流程图总结\n\n![image.png](http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","source":"_posts/iOS手势事件分发原理.md","raw":"---\nlayout:     post\ntitle:      iOS手势事件分发原理\nsubtitle:   iOSHitTest和PointInSide实现探究\ndate:       2017-07-01\nauthor:     jack\nheader-img: img/post-bg-ios9-web.jpg\ncatalog: true\ntags:\n    - iOS\n---\n\nHitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理\n\n```\n- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event{\n    \n    //apple文档描述，不接受事件的情况\n    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha < 0.01) {\n        return nil;\n    }\n    \n    //如果当前View包含此Point\n    if ([self pointInside:point withEvent:event]) {\n        \n        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的\n        for (NSInteger i=self.subviews.count-1; i>=0; i--) {\n            \n            UIView* subView = [self.subviews objectAtIndex:i];\n            \n            //将父View的Point转换成子View坐标系的Point\n            CGPoint pointInSubView = [subView convertPoint:point fromView:self];\n            \n            //递归子View调用HitTest:\n            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];\n            \n            //找到了子View可以响应\n            if (resultView) {\n                return resultView;\n            }\n            \n        }\n        \n        //没有找到可以响应的子View，返回自己\n        return self;\n    }\n    \n    //返回nil，告诉上一级自己无法响应此事件\n    return nil;\n}\n```\n\n流程图总结\n\n![image.png](http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","slug":"iOS手势事件分发原理","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a4001vgccohqo4clcd","content":"<p>HitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //apple文档描述，不接受事件的情况</span><br><span class=\"line\">    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha &lt; 0.01) &#123;</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //如果当前View包含此Point</span><br><span class=\"line\">    if ([self pointInside:point withEvent:event]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的</span><br><span class=\"line\">        for (NSInteger i=self.subviews.count-1; i&gt;=0; i--) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            UIView* subView = [self.subviews objectAtIndex:i];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //将父View的Point转换成子View坐标系的Point</span><br><span class=\"line\">            CGPoint pointInSubView = [subView convertPoint:point fromView:self];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //递归子View调用HitTest:</span><br><span class=\"line\">            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //找到了子View可以响应</span><br><span class=\"line\">            if (resultView) &#123;</span><br><span class=\"line\">                return resultView;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //没有找到可以响应的子View，返回自己</span><br><span class=\"line\">        return self;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //返回nil，告诉上一级自己无法响应此事件</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>流程图总结</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>HitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //apple文档描述，不接受事件的情况</span><br><span class=\"line\">    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha &lt; 0.01) &#123;</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //如果当前View包含此Point</span><br><span class=\"line\">    if ([self pointInside:point withEvent:event]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的</span><br><span class=\"line\">        for (NSInteger i=self.subviews.count-1; i&gt;=0; i--) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            UIView* subView = [self.subviews objectAtIndex:i];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //将父View的Point转换成子View坐标系的Point</span><br><span class=\"line\">            CGPoint pointInSubView = [subView convertPoint:point fromView:self];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //递归子View调用HitTest:</span><br><span class=\"line\">            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //找到了子View可以响应</span><br><span class=\"line\">            if (resultView) &#123;</span><br><span class=\"line\">                return resultView;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //没有找到可以响应的子View，返回自己</span><br><span class=\"line\">        return self;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //返回nil，告诉上一级自己无法响应此事件</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>流程图总结</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n"},{"title":"std::nth_element实现","date":"2024-10-08T09:37:18.000Z","_content":"\n`std::nth_element` 是 C++ 标准库中的一个算法，用于在一个范围内重新排列元素，使得第 `n` 个元素位于其最终位置，并且该元素左侧的所有元素都小于或等于它，右侧的所有元素都大于或等于它。这个算法的时间复杂度为 O(n) 平均情况下，最坏情况下为 O(n^2)。\n\n### 实现原理\n\n`std::nth_element` 的实现通常基于快速选择算法（Quickselect），这是一个选择算法，类似于快速排序。其基本思路如下：\n\n1. **选择一个基准元素**: 从数组中选择一个基准元素（pivot）。\n2. **分区**: 将数组分为两部分：小于基准元素的部分和大于基准元素的部分。\n3. **递归选择**: 根据基准元素的位置与 `n` 的关系，决定在左侧还是右侧继续查找。\n\n### 代码实现\n\n以下是一个简单的 `std::nth_element` 的实现示例：\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib> // for std::rand\n\n// Partition function for Quickselect\ntemplate <typename RandomIt>\nRandomIt partition(RandomIt first, RandomIt last, RandomIt pivot) {\n    std::iter_swap(pivot, last - 1); // Move pivot to end\n    RandomIt storeIndex = first;\n\n    for (RandomIt it = first; it < last - 1; ++it) {\n        if (*it < *(last - 1)) {\n            std::iter_swap(it, storeIndex);\n            ++storeIndex;\n        }\n    }\n    std::iter_swap(storeIndex, last - 1); // Move pivot to its final place\n    return storeIndex;\n}\n\n// Quickselect function\ntemplate <typename RandomIt>\nvoid quickselect(RandomIt first, RandomIt last, size_t n) {\n    if (first < last) {\n        RandomIt pivot = first + std::rand() % (last - first); // Random pivot\n        pivot = partition(first, last, pivot);\n\n        if (pivot - first == n) {\n            return; // Found the nth element\n        } else if (pivot - first > n) {\n            quickselect(first, pivot, n); // Search in the left part\n        } else {\n            quickselect(pivot + 1, last, n - (pivot - first + 1)); // Search in the right part\n        }\n    }\n}\n\n// nth_element implementation\ntemplate <typename RandomIt>\nvoid my_nth_element(RandomIt first, RandomIt nth, RandomIt last) {\n    size_t n = nth - first;\n    quickselect(first, last, n);\n}\n\nint main() {\n    std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};\n    size_t n = 5; // We want the 5th element (0-based index)\n\n    my_nth_element(vec.begin(), vec.begin() + n, vec.end());\n\n    std::cout << \"The \" << n << \"th element is: \" << vec[n] << std::endl;\n\n    return 0;\n}\n```\n\n### 代码解释\n\n1. **Partition Function**: \n   - `partition` 函数将数组分为两部分，返回基准元素的最终位置。\n   - 它将基准元素移动到数组的末尾，然后遍历数组，将小于基准的元素移动到左侧。\n\n2. **Quickselect Function**:\n   - `quickselect` 函数递归地选择基准元素并进行分区，直到找到第 `n` 个元素。\n\n3. **My Nth Element Function**:\n   - `my_nth_element` 是用户定义的函数，调用 `quickselect` 来找到第 `n` 个元素。\n\n4. **Main Function**:\n   - 在 `main` 函数中，创建一个整数向量，调用 `my_nth_element`，并输出第 `n` 个元素。\n\n### 总结\n\n`std::nth_element` 的实现基于快速选择算法，能够高效地找到数组中第 `n` 个元素。上述代码展示了如何实现这一算法，并提供了一个简单的示例来演示其用法。","source":"_posts/std-nth-element实现.md","raw":"---\ntitle: 'std::nth_element实现'\ndate: 2024-10-08 17:37:18\ntags:\n---\n\n`std::nth_element` 是 C++ 标准库中的一个算法，用于在一个范围内重新排列元素，使得第 `n` 个元素位于其最终位置，并且该元素左侧的所有元素都小于或等于它，右侧的所有元素都大于或等于它。这个算法的时间复杂度为 O(n) 平均情况下，最坏情况下为 O(n^2)。\n\n### 实现原理\n\n`std::nth_element` 的实现通常基于快速选择算法（Quickselect），这是一个选择算法，类似于快速排序。其基本思路如下：\n\n1. **选择一个基准元素**: 从数组中选择一个基准元素（pivot）。\n2. **分区**: 将数组分为两部分：小于基准元素的部分和大于基准元素的部分。\n3. **递归选择**: 根据基准元素的位置与 `n` 的关系，决定在左侧还是右侧继续查找。\n\n### 代码实现\n\n以下是一个简单的 `std::nth_element` 的实现示例：\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib> // for std::rand\n\n// Partition function for Quickselect\ntemplate <typename RandomIt>\nRandomIt partition(RandomIt first, RandomIt last, RandomIt pivot) {\n    std::iter_swap(pivot, last - 1); // Move pivot to end\n    RandomIt storeIndex = first;\n\n    for (RandomIt it = first; it < last - 1; ++it) {\n        if (*it < *(last - 1)) {\n            std::iter_swap(it, storeIndex);\n            ++storeIndex;\n        }\n    }\n    std::iter_swap(storeIndex, last - 1); // Move pivot to its final place\n    return storeIndex;\n}\n\n// Quickselect function\ntemplate <typename RandomIt>\nvoid quickselect(RandomIt first, RandomIt last, size_t n) {\n    if (first < last) {\n        RandomIt pivot = first + std::rand() % (last - first); // Random pivot\n        pivot = partition(first, last, pivot);\n\n        if (pivot - first == n) {\n            return; // Found the nth element\n        } else if (pivot - first > n) {\n            quickselect(first, pivot, n); // Search in the left part\n        } else {\n            quickselect(pivot + 1, last, n - (pivot - first + 1)); // Search in the right part\n        }\n    }\n}\n\n// nth_element implementation\ntemplate <typename RandomIt>\nvoid my_nth_element(RandomIt first, RandomIt nth, RandomIt last) {\n    size_t n = nth - first;\n    quickselect(first, last, n);\n}\n\nint main() {\n    std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};\n    size_t n = 5; // We want the 5th element (0-based index)\n\n    my_nth_element(vec.begin(), vec.begin() + n, vec.end());\n\n    std::cout << \"The \" << n << \"th element is: \" << vec[n] << std::endl;\n\n    return 0;\n}\n```\n\n### 代码解释\n\n1. **Partition Function**: \n   - `partition` 函数将数组分为两部分，返回基准元素的最终位置。\n   - 它将基准元素移动到数组的末尾，然后遍历数组，将小于基准的元素移动到左侧。\n\n2. **Quickselect Function**:\n   - `quickselect` 函数递归地选择基准元素并进行分区，直到找到第 `n` 个元素。\n\n3. **My Nth Element Function**:\n   - `my_nth_element` 是用户定义的函数，调用 `quickselect` 来找到第 `n` 个元素。\n\n4. **Main Function**:\n   - 在 `main` 函数中，创建一个整数向量，调用 `my_nth_element`，并输出第 `n` 个元素。\n\n### 总结\n\n`std::nth_element` 的实现基于快速选择算法，能够高效地找到数组中第 `n` 个元素。上述代码展示了如何实现这一算法，并提供了一个简单的示例来演示其用法。","slug":"std-nth-element实现","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a4001ygcco1xcdbzxt","content":"<p><code>std::nth_element</code> 是 C++ 标准库中的一个算法，用于在一个范围内重新排列元素，使得第 <code>n</code> 个元素位于其最终位置，并且该元素左侧的所有元素都小于或等于它，右侧的所有元素都大于或等于它。这个算法的时间复杂度为 O(n) 平均情况下，最坏情况下为 O(n^2)。</p>\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p><code>std::nth_element</code> 的实现通常基于快速选择算法（Quickselect），这是一个选择算法，类似于快速排序。其基本思路如下：</p>\n<ol>\n<li><strong>选择一个基准元素</strong>: 从数组中选择一个基准元素（pivot）。</li>\n<li><strong>分区</strong>: 将数组分为两部分：小于基准元素的部分和大于基准元素的部分。</li>\n<li><strong>递归选择</strong>: 根据基准元素的位置与 <code>n</code> 的关系，决定在左侧还是右侧继续查找。</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>以下是一个简单的 <code>std::nth_element</code> 的实现示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span> <span class=\"comment\">// for std::rand</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Partition function for Quickselect</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> RandomIt&gt;</span><br><span class=\"line\"><span class=\"function\">RandomIt <span class=\"title\">partition</span><span class=\"params\">(RandomIt first, RandomIt last, RandomIt pivot)</span> </span>&#123;</span><br><span class=\"line\">    std::<span class=\"built_in\">iter_swap</span>(pivot, last - <span class=\"number\">1</span>); <span class=\"comment\">// Move pivot to end</span></span><br><span class=\"line\">    RandomIt storeIndex = first;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RandomIt it = first; it &lt; last - <span class=\"number\">1</span>; ++it) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*it &lt; *(last - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            std::<span class=\"built_in\">iter_swap</span>(it, storeIndex);</span><br><span class=\"line\">            ++storeIndex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::<span class=\"built_in\">iter_swap</span>(storeIndex, last - <span class=\"number\">1</span>); <span class=\"comment\">// Move pivot to its final place</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> storeIndex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Quickselect function</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> RandomIt&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickselect</span><span class=\"params\">(RandomIt first, RandomIt last, <span class=\"type\">size_t</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first &lt; last) &#123;</span><br><span class=\"line\">        RandomIt pivot = first + std::<span class=\"built_in\">rand</span>() % (last - first); <span class=\"comment\">// Random pivot</span></span><br><span class=\"line\">        pivot = <span class=\"built_in\">partition</span>(first, last, pivot);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pivot - first == n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// Found the nth element</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pivot - first &gt; n) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">quickselect</span>(first, pivot, n); <span class=\"comment\">// Search in the left part</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">quickselect</span>(pivot + <span class=\"number\">1</span>, last, n - (pivot - first + <span class=\"number\">1</span>)); <span class=\"comment\">// Search in the right part</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// nth_element implementation</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> RandomIt&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">my_nth_element</span><span class=\"params\">(RandomIt first, RandomIt nth, RandomIt last)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = nth - first;</span><br><span class=\"line\">    <span class=\"built_in\">quickselect</span>(first, last, n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; vec = &#123;<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = <span class=\"number\">5</span>; <span class=\"comment\">// We want the 5th element (0-based index)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">my_nth_element</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">begin</span>() + n, vec.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;The &quot;</span> &lt;&lt; n &lt;&lt; <span class=\"string\">&quot;th element is: &quot;</span> &lt;&lt; vec[n] &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码解释\"><a href=\"#代码解释\" class=\"headerlink\" title=\"代码解释\"></a>代码解释</h3><ol>\n<li><p><strong>Partition Function</strong>: </p>\n<ul>\n<li><code>partition</code> 函数将数组分为两部分，返回基准元素的最终位置。</li>\n<li>它将基准元素移动到数组的末尾，然后遍历数组，将小于基准的元素移动到左侧。</li>\n</ul>\n</li>\n<li><p><strong>Quickselect Function</strong>:</p>\n<ul>\n<li><code>quickselect</code> 函数递归地选择基准元素并进行分区，直到找到第 <code>n</code> 个元素。</li>\n</ul>\n</li>\n<li><p><strong>My Nth Element Function</strong>:</p>\n<ul>\n<li><code>my_nth_element</code> 是用户定义的函数，调用 <code>quickselect</code> 来找到第 <code>n</code> 个元素。</li>\n</ul>\n</li>\n<li><p><strong>Main Function</strong>:</p>\n<ul>\n<li>在 <code>main</code> 函数中，创建一个整数向量，调用 <code>my_nth_element</code>，并输出第 <code>n</code> 个元素。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>std::nth_element</code> 的实现基于快速选择算法，能够高效地找到数组中第 <code>n</code> 个元素。上述代码展示了如何实现这一算法，并提供了一个简单的示例来演示其用法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>std::nth_element</code> 是 C++ 标准库中的一个算法，用于在一个范围内重新排列元素，使得第 <code>n</code> 个元素位于其最终位置，并且该元素左侧的所有元素都小于或等于它，右侧的所有元素都大于或等于它。这个算法的时间复杂度为 O(n) 平均情况下，最坏情况下为 O(n^2)。</p>\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p><code>std::nth_element</code> 的实现通常基于快速选择算法（Quickselect），这是一个选择算法，类似于快速排序。其基本思路如下：</p>\n<ol>\n<li><strong>选择一个基准元素</strong>: 从数组中选择一个基准元素（pivot）。</li>\n<li><strong>分区</strong>: 将数组分为两部分：小于基准元素的部分和大于基准元素的部分。</li>\n<li><strong>递归选择</strong>: 根据基准元素的位置与 <code>n</code> 的关系，决定在左侧还是右侧继续查找。</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>以下是一个简单的 <code>std::nth_element</code> 的实现示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span> <span class=\"comment\">// for std::rand</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Partition function for Quickselect</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> RandomIt&gt;</span><br><span class=\"line\"><span class=\"function\">RandomIt <span class=\"title\">partition</span><span class=\"params\">(RandomIt first, RandomIt last, RandomIt pivot)</span> </span>&#123;</span><br><span class=\"line\">    std::<span class=\"built_in\">iter_swap</span>(pivot, last - <span class=\"number\">1</span>); <span class=\"comment\">// Move pivot to end</span></span><br><span class=\"line\">    RandomIt storeIndex = first;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RandomIt it = first; it &lt; last - <span class=\"number\">1</span>; ++it) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*it &lt; *(last - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            std::<span class=\"built_in\">iter_swap</span>(it, storeIndex);</span><br><span class=\"line\">            ++storeIndex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::<span class=\"built_in\">iter_swap</span>(storeIndex, last - <span class=\"number\">1</span>); <span class=\"comment\">// Move pivot to its final place</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> storeIndex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Quickselect function</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> RandomIt&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickselect</span><span class=\"params\">(RandomIt first, RandomIt last, <span class=\"type\">size_t</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first &lt; last) &#123;</span><br><span class=\"line\">        RandomIt pivot = first + std::<span class=\"built_in\">rand</span>() % (last - first); <span class=\"comment\">// Random pivot</span></span><br><span class=\"line\">        pivot = <span class=\"built_in\">partition</span>(first, last, pivot);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pivot - first == n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// Found the nth element</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pivot - first &gt; n) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">quickselect</span>(first, pivot, n); <span class=\"comment\">// Search in the left part</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">quickselect</span>(pivot + <span class=\"number\">1</span>, last, n - (pivot - first + <span class=\"number\">1</span>)); <span class=\"comment\">// Search in the right part</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// nth_element implementation</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> RandomIt&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">my_nth_element</span><span class=\"params\">(RandomIt first, RandomIt nth, RandomIt last)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = nth - first;</span><br><span class=\"line\">    <span class=\"built_in\">quickselect</span>(first, last, n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; vec = &#123;<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = <span class=\"number\">5</span>; <span class=\"comment\">// We want the 5th element (0-based index)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">my_nth_element</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">begin</span>() + n, vec.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;The &quot;</span> &lt;&lt; n &lt;&lt; <span class=\"string\">&quot;th element is: &quot;</span> &lt;&lt; vec[n] &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码解释\"><a href=\"#代码解释\" class=\"headerlink\" title=\"代码解释\"></a>代码解释</h3><ol>\n<li><p><strong>Partition Function</strong>: </p>\n<ul>\n<li><code>partition</code> 函数将数组分为两部分，返回基准元素的最终位置。</li>\n<li>它将基准元素移动到数组的末尾，然后遍历数组，将小于基准的元素移动到左侧。</li>\n</ul>\n</li>\n<li><p><strong>Quickselect Function</strong>:</p>\n<ul>\n<li><code>quickselect</code> 函数递归地选择基准元素并进行分区，直到找到第 <code>n</code> 个元素。</li>\n</ul>\n</li>\n<li><p><strong>My Nth Element Function</strong>:</p>\n<ul>\n<li><code>my_nth_element</code> 是用户定义的函数，调用 <code>quickselect</code> 来找到第 <code>n</code> 个元素。</li>\n</ul>\n</li>\n<li><p><strong>Main Function</strong>:</p>\n<ul>\n<li>在 <code>main</code> 函数中，创建一个整数向量，调用 <code>my_nth_element</code>，并输出第 <code>n</code> 个元素。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>std::nth_element</code> 的实现基于快速选择算法，能够高效地找到数组中第 <code>n</code> 个元素。上述代码展示了如何实现这一算法，并提供了一个简单的示例来演示其用法。</p>\n"},{"title":"smoothStep实现","date":"2023-12-22T11:51:30.000Z","_content":"","source":"_posts/smoothStep实现.md","raw":"---\ntitle: smoothStep实现\ndate: 2023-12-22 19:51:30\ntags:\n---\n","slug":"smoothStep实现","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a50020gccob8sh40ua","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tag dispatch","date":"2023-12-24T06:44:19.000Z","_content":"\n#### 对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\n\n```cpp\nnamespace TagDispatch {\n\ntemplate <typename T>\nvoid fun(T&& params) {\n    std::vector<std::string> temp;\n    temp.emplace_back(std::forward<T>(params));\n    std::cout << \"called fun(T&& params)\" << std::endl;\n}\n\nvoid fun(int a) {\n    std::cout << \"called fun(int a)\" << std::endl;\n}\n\ntemplate <typename T>\nvoid fwd(T&& params) {\n    fun(std::forward<T>(params));\n}\n\nvoid test()\n{\n    fwd(\"abc\"); //suc\n    int a = 0;\n    fwd(a);     //suc\n    \n    short b = 10;\n    //fwd(b);     //failed, 匹配到了通用引用函数\n    \n}\n\nint main(int argc, const char * argv[]) {    \n    TagDispatch::test();\n\n    return 0;\n}\n\n}\n```\n\n\n#### 使用TagDispath，来解决匹配的问题\n\n```cpp\nnamespace TagDispatch {\n\ntemplate <typename T>\nvoid fun2(T&& params, std::false_type) {\n    std::vector<std::string> temp;\n    temp.emplace_back(std::forward<T>(params));\n    std::cout << \"called fun(T&& params)\" << std::endl;\n}\n\nvoid fun2(int a, std::true_type) {\n    std::cout << \"called fun(int a)\" << std::endl;\n}\n\ntemplate <typename T>\nvoid fwd(T&& params) {\n    fun2(std::forward<T>(params), std::is_integral<typename std::remove_reference<T>::type>());\n}\n\nvoid test()\n{\n    fwd(\"abc\"); //suc\n    int a = 0;\n    fwd(a);     //suc\n    \n    short b = 10;\n    fwd(b);     //succeed, 匹配到了通用引用函数\n}\n\n}\n\n```\n\n#### 针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配\n\n```cpp\nclass Person\n{\npublic:\n    template <\n        typename T,\n        typename = std::enable_if_t<\n            !std::is_base_of<Person, std::decay_t<T>>::value    // 防止调用拷贝和移动构造函数，并且考虑了子类\n            &&                                                  // decay,移除指针引用和cv修饰符\n            !std::is_integral<std::remove_reference_t<T>>::value\n        >\n    >\n    explicit Person(T&& params) {\n        std::vector<std::string> temp;\n        temp.emplace_back(std::forward<T>(params));\n        std::cout << \"Person(T&& params)\" << std::endl;\n    }\n    \n    explicit Person(int a) {\n        std::cout << \"Person(int a)\" << std::endl;\n    }\n};\n\nvoid testCtrOverload() {\n\n    short b = 10;\n    Person person(b);\n    \n}\n\n}\n```","source":"_posts/tag-dispatch.md","raw":"---\ntitle: tag dispatch\ndate: 2023-12-24 14:44:19\ntags:\n---\n\n#### 对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\n\n```cpp\nnamespace TagDispatch {\n\ntemplate <typename T>\nvoid fun(T&& params) {\n    std::vector<std::string> temp;\n    temp.emplace_back(std::forward<T>(params));\n    std::cout << \"called fun(T&& params)\" << std::endl;\n}\n\nvoid fun(int a) {\n    std::cout << \"called fun(int a)\" << std::endl;\n}\n\ntemplate <typename T>\nvoid fwd(T&& params) {\n    fun(std::forward<T>(params));\n}\n\nvoid test()\n{\n    fwd(\"abc\"); //suc\n    int a = 0;\n    fwd(a);     //suc\n    \n    short b = 10;\n    //fwd(b);     //failed, 匹配到了通用引用函数\n    \n}\n\nint main(int argc, const char * argv[]) {    \n    TagDispatch::test();\n\n    return 0;\n}\n\n}\n```\n\n\n#### 使用TagDispath，来解决匹配的问题\n\n```cpp\nnamespace TagDispatch {\n\ntemplate <typename T>\nvoid fun2(T&& params, std::false_type) {\n    std::vector<std::string> temp;\n    temp.emplace_back(std::forward<T>(params));\n    std::cout << \"called fun(T&& params)\" << std::endl;\n}\n\nvoid fun2(int a, std::true_type) {\n    std::cout << \"called fun(int a)\" << std::endl;\n}\n\ntemplate <typename T>\nvoid fwd(T&& params) {\n    fun2(std::forward<T>(params), std::is_integral<typename std::remove_reference<T>::type>());\n}\n\nvoid test()\n{\n    fwd(\"abc\"); //suc\n    int a = 0;\n    fwd(a);     //suc\n    \n    short b = 10;\n    fwd(b);     //succeed, 匹配到了通用引用函数\n}\n\n}\n\n```\n\n#### 针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配\n\n```cpp\nclass Person\n{\npublic:\n    template <\n        typename T,\n        typename = std::enable_if_t<\n            !std::is_base_of<Person, std::decay_t<T>>::value    // 防止调用拷贝和移动构造函数，并且考虑了子类\n            &&                                                  // decay,移除指针引用和cv修饰符\n            !std::is_integral<std::remove_reference_t<T>>::value\n        >\n    >\n    explicit Person(T&& params) {\n        std::vector<std::string> temp;\n        temp.emplace_back(std::forward<T>(params));\n        std::cout << \"Person(T&& params)\" << std::endl;\n    }\n    \n    explicit Person(int a) {\n        std::cout << \"Person(int a)\" << std::endl;\n    }\n};\n\nvoid testCtrOverload() {\n\n    short b = 10;\n    Person person(b);\n    \n}\n\n}\n```","slug":"tag-dispatch","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a60022gcco8gfkalel","content":"<h4 id=\"对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\"><a href=\"#对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\" class=\"headerlink\" title=\"对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\"></a>对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> TagDispatch &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; temp;</span><br><span class=\"line\">    temp.<span class=\"built_in\">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fwd</span><span class=\"params\">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fun</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(<span class=\"string\">&quot;abc&quot;</span>); <span class=\"comment\">//suc</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(a);     <span class=\"comment\">//suc</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">short</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">//fwd(b);     //failed, 匹配到了通用引用函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> * argv[])</span> </span>&#123;    </span><br><span class=\"line\">    TagDispatch::<span class=\"built_in\">test</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"使用TagDispath，来解决匹配的问题\"><a href=\"#使用TagDispath，来解决匹配的问题\" class=\"headerlink\" title=\"使用TagDispath，来解决匹配的问题\"></a>使用TagDispath，来解决匹配的问题</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> TagDispatch &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun2</span><span class=\"params\">(T&amp;&amp; params, std::false_type)</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; temp;</span><br><span class=\"line\">    temp.<span class=\"built_in\">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun2</span><span class=\"params\">(<span class=\"type\">int</span> a, std::true_type)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fwd</span><span class=\"params\">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fun2</span>(std::forward&lt;T&gt;(params), std::is_integral&lt;<span class=\"keyword\">typename</span> std::remove_reference&lt;T&gt;::type&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(<span class=\"string\">&quot;abc&quot;</span>); <span class=\"comment\">//suc</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(a);     <span class=\"comment\">//suc</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">short</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(b);     <span class=\"comment\">//succeed, 匹配到了通用引用函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable-if来限制模板的匹配\"><a href=\"#针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable-if来限制模板的匹配\" class=\"headerlink\" title=\"针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配\"></a>针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;</span><br><span class=\"line\">        <span class=\"keyword\">typename</span> T,</span><br><span class=\"line\">        <span class=\"keyword\">typename</span> = std::<span class=\"type\">enable_if_t</span>&lt;</span><br><span class=\"line\">            !std::is_base_of&lt;Person, std::<span class=\"type\">decay_t</span>&lt;T&gt;&gt;::value    <span class=\"comment\">// 防止调用拷贝和移动构造函数，并且考虑了子类</span></span><br><span class=\"line\">            &amp;&amp;                                                  <span class=\"comment\">// decay,移除指针引用和cv修饰符</span></span><br><span class=\"line\">            !std::is_integral&lt;std::<span class=\"type\">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">    <span class=\"keyword\">explicit</span> <span class=\"built_in\">Person</span>(T&amp;&amp; params) &#123;</span><br><span class=\"line\">        std::vector&lt;std::string&gt; temp;</span><br><span class=\"line\">        temp.<span class=\"built_in\">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Person(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Person</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Person(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">testCtrOverload</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">short</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">person</span><span class=\"params\">(b)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\"><a href=\"#对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\" class=\"headerlink\" title=\"对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\"></a>对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> TagDispatch &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; temp;</span><br><span class=\"line\">    temp.<span class=\"built_in\">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fwd</span><span class=\"params\">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fun</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(<span class=\"string\">&quot;abc&quot;</span>); <span class=\"comment\">//suc</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(a);     <span class=\"comment\">//suc</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">short</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">//fwd(b);     //failed, 匹配到了通用引用函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> * argv[])</span> </span>&#123;    </span><br><span class=\"line\">    TagDispatch::<span class=\"built_in\">test</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"使用TagDispath，来解决匹配的问题\"><a href=\"#使用TagDispath，来解决匹配的问题\" class=\"headerlink\" title=\"使用TagDispath，来解决匹配的问题\"></a>使用TagDispath，来解决匹配的问题</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> TagDispatch &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun2</span><span class=\"params\">(T&amp;&amp; params, std::false_type)</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; temp;</span><br><span class=\"line\">    temp.<span class=\"built_in\">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun2</span><span class=\"params\">(<span class=\"type\">int</span> a, std::true_type)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fwd</span><span class=\"params\">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fun2</span>(std::forward&lt;T&gt;(params), std::is_integral&lt;<span class=\"keyword\">typename</span> std::remove_reference&lt;T&gt;::type&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(<span class=\"string\">&quot;abc&quot;</span>); <span class=\"comment\">//suc</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(a);     <span class=\"comment\">//suc</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">short</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(b);     <span class=\"comment\">//succeed, 匹配到了通用引用函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable-if来限制模板的匹配\"><a href=\"#针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable-if来限制模板的匹配\" class=\"headerlink\" title=\"针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配\"></a>针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;</span><br><span class=\"line\">        <span class=\"keyword\">typename</span> T,</span><br><span class=\"line\">        <span class=\"keyword\">typename</span> = std::<span class=\"type\">enable_if_t</span>&lt;</span><br><span class=\"line\">            !std::is_base_of&lt;Person, std::<span class=\"type\">decay_t</span>&lt;T&gt;&gt;::value    <span class=\"comment\">// 防止调用拷贝和移动构造函数，并且考虑了子类</span></span><br><span class=\"line\">            &amp;&amp;                                                  <span class=\"comment\">// decay,移除指针引用和cv修饰符</span></span><br><span class=\"line\">            !std::is_integral&lt;std::<span class=\"type\">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">    <span class=\"keyword\">explicit</span> <span class=\"built_in\">Person</span>(T&amp;&amp; params) &#123;</span><br><span class=\"line\">        std::vector&lt;std::string&gt; temp;</span><br><span class=\"line\">        temp.<span class=\"built_in\">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Person(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Person</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Person(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">testCtrOverload</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">short</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">person</span><span class=\"params\">(b)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"texelFetch","date":"2024-10-06T10:16:59.000Z","_content":"\n`texelFetch` 是一个在着色器编程中用于从纹理中获取特定纹素（texel）的函数。与常规的纹理采样不同，`texelFetch` 使用整数纹理坐标来直接访问纹理数据，不进行过滤或插值。\n\n在 OpenGL 的 GLSL（OpenGL Shading Language）中，`texelFetch` 的用法如下：\n\n```glsl\nvec4 texelFetch(sampler2D sampler, ivec2 coord, int lod);\n```\n\n- `sampler`：纹理采样器。\n- `coord`：整数形式的纹理坐标。\n- `lod`：细节层次（level of detail），通常为 0。\n\n`texelFetch` 适用于需要精确访问纹理像素的场合，比如在一些计算或图像处理效果中。","source":"_posts/texelFetch.md","raw":"---\ntitle: texelFetch\ndate: 2024-10-06 18:16:59\ntags:\n---\n\n`texelFetch` 是一个在着色器编程中用于从纹理中获取特定纹素（texel）的函数。与常规的纹理采样不同，`texelFetch` 使用整数纹理坐标来直接访问纹理数据，不进行过滤或插值。\n\n在 OpenGL 的 GLSL（OpenGL Shading Language）中，`texelFetch` 的用法如下：\n\n```glsl\nvec4 texelFetch(sampler2D sampler, ivec2 coord, int lod);\n```\n\n- `sampler`：纹理采样器。\n- `coord`：整数形式的纹理坐标。\n- `lod`：细节层次（level of detail），通常为 0。\n\n`texelFetch` 适用于需要精确访问纹理像素的场合，比如在一些计算或图像处理效果中。","slug":"texelFetch","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a60025gcco4see7p02","content":"<p><code>texelFetch</code> 是一个在着色器编程中用于从纹理中获取特定纹素（texel）的函数。与常规的纹理采样不同，<code>texelFetch</code> 使用整数纹理坐标来直接访问纹理数据，不进行过滤或插值。</p>\n<p>在 OpenGL 的 GLSL（OpenGL Shading Language）中，<code>texelFetch</code> 的用法如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec4</span> <span class=\"built_in\">texelFetch</span>(<span class=\"type\">sampler2D</span> sampler, <span class=\"type\">ivec2</span> coord, <span class=\"type\">int</span> lod);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>sampler</code>：纹理采样器。</li>\n<li><code>coord</code>：整数形式的纹理坐标。</li>\n<li><code>lod</code>：细节层次（level of detail），通常为 0。</li>\n</ul>\n<p><code>texelFetch</code> 适用于需要精确访问纹理像素的场合，比如在一些计算或图像处理效果中。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>texelFetch</code> 是一个在着色器编程中用于从纹理中获取特定纹素（texel）的函数。与常规的纹理采样不同，<code>texelFetch</code> 使用整数纹理坐标来直接访问纹理数据，不进行过滤或插值。</p>\n<p>在 OpenGL 的 GLSL（OpenGL Shading Language）中，<code>texelFetch</code> 的用法如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec4</span> <span class=\"built_in\">texelFetch</span>(<span class=\"type\">sampler2D</span> sampler, <span class=\"type\">ivec2</span> coord, <span class=\"type\">int</span> lod);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>sampler</code>：纹理采样器。</li>\n<li><code>coord</code>：整数形式的纹理坐标。</li>\n<li><code>lod</code>：细节层次（level of detail），通常为 0。</li>\n</ul>\n<p><code>texelFetch</code> 适用于需要精确访问纹理像素的场合，比如在一些计算或图像处理效果中。</p>\n"},{"title":"traits设计和用法","date":"2024-09-29T09:25:47.000Z","_content":"\n在 C++ 中，**Traits**（特性）是一种设计模式，通常用于提供类型信息或行为的模板类。Traits 允许在编译时获取类型的特性，从而实现更灵活和可扩展的代码。Traits 模式广泛应用于标准库和现代 C++ 编程中，尤其是在模板编程和泛型编程中。\n\n### 1. Traits 的设计\n\nTraits 通常是一个模板类，专门用于提供与类型相关的信息。它们可以用于：\n\n- **类型特性**: 提供类型的属性（如是否是指针、是否是类等）。\n- **类型转换**: 提供类型的转换信息（如获取类型的基类、去除引用等）。\n- **类型操作**: 提供与类型相关的操作（如获取类型的大小、默认构造函数等）。\n\n### 2. Traits 的基本用法\n\n以下是一些常见的 Traits 用法示例：\n\n#### a. 类型特性\n\n使用 `std::is_integral` 来检查一个类型是否是整数类型：\n\n```cpp\n#include <iostream>\n#include <type_traits>\n\ntemplate<typename T>\nvoid checkType() {\n    if (std::is_integral<T>::value) {\n        std::cout << \"T is an integral type.\" << std::endl;\n    } else {\n        std::cout << \"T is not an integral type.\" << std::endl;\n    }\n}\n\nint main() {\n    checkType<int>();    // 输出: T is an integral type.\n    checkType<double>(); // 输出: T is not an integral type.\n    return 0;\n}\n```\n\n#### b. 自定义 Traits\n\n你可以定义自己的 Traits 类来提供特定类型的信息。例如，定义一个 Traits 类来获取类型的大小：\n\n```cpp\n#include <iostream>\n\ntemplate<typename T>\nstruct TypeTraits {\n    static const size_t size = sizeof(T);\n};\n\nint main() {\n    std::cout << \"Size of int: \" << TypeTraits<int>::size << std::endl; // 输出: Size of int: 4\n    std::cout << \"Size of double: \" << TypeTraits<double>::size << std::endl; // 输出: Size of double: 8\n    return 0;\n}\n```\n\n#### c. 结合 SFINAE\n\nTraits 可以与 SFINAE（Substitution Failure Is Not An Error）结合使用，以实现更复杂的模板特化。例如，选择性地启用某些函数：\n\n```cpp\n#include <iostream>\n#include <type_traits>\n\ntemplate<typename T>\ntypename std::enable_if<std::is_integral<T>::value>::type\nprocess(T value) {\n    std::cout << \"Processing integral type: \" << value << std::endl;\n}\n\ntemplate<typename T>\ntypename std::enable_if<!std::is_integral<T>::value>::type\nprocess(T value) {\n    std::cout << \"Processing non-integral type: \" << value << std::endl;\n}\n\nint main() {\n    process(42);        // 输出: Processing integral type: 42\n    process(3.14);     // 输出: Processing non-integral type: 3.14\n    return 0;\n}\n```\n\n### 3. Traits 的应用\n\nTraits 在 C++ 标准库中有广泛的应用，以下是一些常见的例子：\n\n- **`std::iterator_traits`**: 提供迭代器的类型信息，如值类型、指针类型等。\n- **`std::numeric_limits`**: 提供数值类型的特性，如最小值、最大值等。\n- **`std::enable_if`**: 用于条件性地启用模板特化。\n\n### 4. 总结\n\n- **Traits** 是一种强大的设计模式，允许在编译时获取类型信息和行为。\n- 它们可以用于类型特性、类型转换和类型操作，提供灵活性和可扩展性。\n- Traits 在 C++ 标准库中有广泛的应用，尤其是在模板编程和泛型编程中。\n\n通过使用 Traits，开发者可以编写更通用和可重用的代码，同时提高类型安全性和性能。","source":"_posts/traits设计和用法.md","raw":"---\ntitle: traits设计和用法\ndate: 2024-09-29 17:25:47\ntags:\n---\n\n在 C++ 中，**Traits**（特性）是一种设计模式，通常用于提供类型信息或行为的模板类。Traits 允许在编译时获取类型的特性，从而实现更灵活和可扩展的代码。Traits 模式广泛应用于标准库和现代 C++ 编程中，尤其是在模板编程和泛型编程中。\n\n### 1. Traits 的设计\n\nTraits 通常是一个模板类，专门用于提供与类型相关的信息。它们可以用于：\n\n- **类型特性**: 提供类型的属性（如是否是指针、是否是类等）。\n- **类型转换**: 提供类型的转换信息（如获取类型的基类、去除引用等）。\n- **类型操作**: 提供与类型相关的操作（如获取类型的大小、默认构造函数等）。\n\n### 2. Traits 的基本用法\n\n以下是一些常见的 Traits 用法示例：\n\n#### a. 类型特性\n\n使用 `std::is_integral` 来检查一个类型是否是整数类型：\n\n```cpp\n#include <iostream>\n#include <type_traits>\n\ntemplate<typename T>\nvoid checkType() {\n    if (std::is_integral<T>::value) {\n        std::cout << \"T is an integral type.\" << std::endl;\n    } else {\n        std::cout << \"T is not an integral type.\" << std::endl;\n    }\n}\n\nint main() {\n    checkType<int>();    // 输出: T is an integral type.\n    checkType<double>(); // 输出: T is not an integral type.\n    return 0;\n}\n```\n\n#### b. 自定义 Traits\n\n你可以定义自己的 Traits 类来提供特定类型的信息。例如，定义一个 Traits 类来获取类型的大小：\n\n```cpp\n#include <iostream>\n\ntemplate<typename T>\nstruct TypeTraits {\n    static const size_t size = sizeof(T);\n};\n\nint main() {\n    std::cout << \"Size of int: \" << TypeTraits<int>::size << std::endl; // 输出: Size of int: 4\n    std::cout << \"Size of double: \" << TypeTraits<double>::size << std::endl; // 输出: Size of double: 8\n    return 0;\n}\n```\n\n#### c. 结合 SFINAE\n\nTraits 可以与 SFINAE（Substitution Failure Is Not An Error）结合使用，以实现更复杂的模板特化。例如，选择性地启用某些函数：\n\n```cpp\n#include <iostream>\n#include <type_traits>\n\ntemplate<typename T>\ntypename std::enable_if<std::is_integral<T>::value>::type\nprocess(T value) {\n    std::cout << \"Processing integral type: \" << value << std::endl;\n}\n\ntemplate<typename T>\ntypename std::enable_if<!std::is_integral<T>::value>::type\nprocess(T value) {\n    std::cout << \"Processing non-integral type: \" << value << std::endl;\n}\n\nint main() {\n    process(42);        // 输出: Processing integral type: 42\n    process(3.14);     // 输出: Processing non-integral type: 3.14\n    return 0;\n}\n```\n\n### 3. Traits 的应用\n\nTraits 在 C++ 标准库中有广泛的应用，以下是一些常见的例子：\n\n- **`std::iterator_traits`**: 提供迭代器的类型信息，如值类型、指针类型等。\n- **`std::numeric_limits`**: 提供数值类型的特性，如最小值、最大值等。\n- **`std::enable_if`**: 用于条件性地启用模板特化。\n\n### 4. 总结\n\n- **Traits** 是一种强大的设计模式，允许在编译时获取类型信息和行为。\n- 它们可以用于类型特性、类型转换和类型操作，提供灵活性和可扩展性。\n- Traits 在 C++ 标准库中有广泛的应用，尤其是在模板编程和泛型编程中。\n\n通过使用 Traits，开发者可以编写更通用和可重用的代码，同时提高类型安全性和性能。","slug":"traits设计和用法","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a60027gcco8ghb9ul2","content":"<p>在 C++ 中，<strong>Traits</strong>（特性）是一种设计模式，通常用于提供类型信息或行为的模板类。Traits 允许在编译时获取类型的特性，从而实现更灵活和可扩展的代码。Traits 模式广泛应用于标准库和现代 C++ 编程中，尤其是在模板编程和泛型编程中。</p>\n<h3 id=\"1-Traits-的设计\"><a href=\"#1-Traits-的设计\" class=\"headerlink\" title=\"1. Traits 的设计\"></a>1. Traits 的设计</h3><p>Traits 通常是一个模板类，专门用于提供与类型相关的信息。它们可以用于：</p>\n<ul>\n<li><strong>类型特性</strong>: 提供类型的属性（如是否是指针、是否是类等）。</li>\n<li><strong>类型转换</strong>: 提供类型的转换信息（如获取类型的基类、去除引用等）。</li>\n<li><strong>类型操作</strong>: 提供与类型相关的操作（如获取类型的大小、默认构造函数等）。</li>\n</ul>\n<h3 id=\"2-Traits-的基本用法\"><a href=\"#2-Traits-的基本用法\" class=\"headerlink\" title=\"2. Traits 的基本用法\"></a>2. Traits 的基本用法</h3><p>以下是一些常见的 Traits 用法示例：</p>\n<h4 id=\"a-类型特性\"><a href=\"#a-类型特性\" class=\"headerlink\" title=\"a. 类型特性\"></a>a. 类型特性</h4><p>使用 <code>std::is_integral</code> 来检查一个类型是否是整数类型：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checkType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::is_integral&lt;T&gt;::value) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;T is an integral type.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;T is not an integral type.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkType</span>&lt;<span class=\"type\">int</span>&gt;();    <span class=\"comment\">// 输出: T is an integral type.</span></span><br><span class=\"line\">    <span class=\"built_in\">checkType</span>&lt;<span class=\"type\">double</span>&gt;(); <span class=\"comment\">// 输出: T is not an integral type.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"b-自定义-Traits\"><a href=\"#b-自定义-Traits\" class=\"headerlink\" title=\"b. 自定义 Traits\"></a>b. 自定义 Traits</h4><p>你可以定义自己的 Traits 类来提供特定类型的信息。例如，定义一个 Traits 类来获取类型的大小：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TypeTraits</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> size = <span class=\"built_in\">sizeof</span>(T);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Size of int: &quot;</span> &lt;&lt; TypeTraits&lt;<span class=\"type\">int</span>&gt;::size &lt;&lt; std::endl; <span class=\"comment\">// 输出: Size of int: 4</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Size of double: &quot;</span> &lt;&lt; TypeTraits&lt;<span class=\"type\">double</span>&gt;::size &lt;&lt; std::endl; <span class=\"comment\">// 输出: Size of double: 8</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"c-结合-SFINAE\"><a href=\"#c-结合-SFINAE\" class=\"headerlink\" title=\"c. 结合 SFINAE\"></a>c. 结合 SFINAE</h4><p>Traits 可以与 SFINAE（Substitution Failure Is Not An Error）结合使用，以实现更复杂的模板特化。例如，选择性地启用某些函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::<span class=\"function\">type</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">process</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Processing integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">typename</span> std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::<span class=\"function\">type</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">process</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Processing non-integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">process</span>(<span class=\"number\">42</span>);        <span class=\"comment\">// 输出: Processing integral type: 42</span></span><br><span class=\"line\">    <span class=\"built_in\">process</span>(<span class=\"number\">3.14</span>);     <span class=\"comment\">// 输出: Processing non-integral type: 3.14</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-Traits-的应用\"><a href=\"#3-Traits-的应用\" class=\"headerlink\" title=\"3. Traits 的应用\"></a>3. Traits 的应用</h3><p>Traits 在 C++ 标准库中有广泛的应用，以下是一些常见的例子：</p>\n<ul>\n<li><strong><code>std::iterator_traits</code></strong>: 提供迭代器的类型信息，如值类型、指针类型等。</li>\n<li><strong><code>std::numeric_limits</code></strong>: 提供数值类型的特性，如最小值、最大值等。</li>\n<li><strong><code>std::enable_if</code></strong>: 用于条件性地启用模板特化。</li>\n</ul>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><ul>\n<li><strong>Traits</strong> 是一种强大的设计模式，允许在编译时获取类型信息和行为。</li>\n<li>它们可以用于类型特性、类型转换和类型操作，提供灵活性和可扩展性。</li>\n<li>Traits 在 C++ 标准库中有广泛的应用，尤其是在模板编程和泛型编程中。</li>\n</ul>\n<p>通过使用 Traits，开发者可以编写更通用和可重用的代码，同时提高类型安全性和性能。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 C++ 中，<strong>Traits</strong>（特性）是一种设计模式，通常用于提供类型信息或行为的模板类。Traits 允许在编译时获取类型的特性，从而实现更灵活和可扩展的代码。Traits 模式广泛应用于标准库和现代 C++ 编程中，尤其是在模板编程和泛型编程中。</p>\n<h3 id=\"1-Traits-的设计\"><a href=\"#1-Traits-的设计\" class=\"headerlink\" title=\"1. Traits 的设计\"></a>1. Traits 的设计</h3><p>Traits 通常是一个模板类，专门用于提供与类型相关的信息。它们可以用于：</p>\n<ul>\n<li><strong>类型特性</strong>: 提供类型的属性（如是否是指针、是否是类等）。</li>\n<li><strong>类型转换</strong>: 提供类型的转换信息（如获取类型的基类、去除引用等）。</li>\n<li><strong>类型操作</strong>: 提供与类型相关的操作（如获取类型的大小、默认构造函数等）。</li>\n</ul>\n<h3 id=\"2-Traits-的基本用法\"><a href=\"#2-Traits-的基本用法\" class=\"headerlink\" title=\"2. Traits 的基本用法\"></a>2. Traits 的基本用法</h3><p>以下是一些常见的 Traits 用法示例：</p>\n<h4 id=\"a-类型特性\"><a href=\"#a-类型特性\" class=\"headerlink\" title=\"a. 类型特性\"></a>a. 类型特性</h4><p>使用 <code>std::is_integral</code> 来检查一个类型是否是整数类型：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checkType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::is_integral&lt;T&gt;::value) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;T is an integral type.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;T is not an integral type.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkType</span>&lt;<span class=\"type\">int</span>&gt;();    <span class=\"comment\">// 输出: T is an integral type.</span></span><br><span class=\"line\">    <span class=\"built_in\">checkType</span>&lt;<span class=\"type\">double</span>&gt;(); <span class=\"comment\">// 输出: T is not an integral type.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"b-自定义-Traits\"><a href=\"#b-自定义-Traits\" class=\"headerlink\" title=\"b. 自定义 Traits\"></a>b. 自定义 Traits</h4><p>你可以定义自己的 Traits 类来提供特定类型的信息。例如，定义一个 Traits 类来获取类型的大小：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TypeTraits</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> size = <span class=\"built_in\">sizeof</span>(T);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Size of int: &quot;</span> &lt;&lt; TypeTraits&lt;<span class=\"type\">int</span>&gt;::size &lt;&lt; std::endl; <span class=\"comment\">// 输出: Size of int: 4</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Size of double: &quot;</span> &lt;&lt; TypeTraits&lt;<span class=\"type\">double</span>&gt;::size &lt;&lt; std::endl; <span class=\"comment\">// 输出: Size of double: 8</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"c-结合-SFINAE\"><a href=\"#c-结合-SFINAE\" class=\"headerlink\" title=\"c. 结合 SFINAE\"></a>c. 结合 SFINAE</h4><p>Traits 可以与 SFINAE（Substitution Failure Is Not An Error）结合使用，以实现更复杂的模板特化。例如，选择性地启用某些函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::<span class=\"function\">type</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">process</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Processing integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">typename</span> std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::<span class=\"function\">type</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">process</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Processing non-integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">process</span>(<span class=\"number\">42</span>);        <span class=\"comment\">// 输出: Processing integral type: 42</span></span><br><span class=\"line\">    <span class=\"built_in\">process</span>(<span class=\"number\">3.14</span>);     <span class=\"comment\">// 输出: Processing non-integral type: 3.14</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-Traits-的应用\"><a href=\"#3-Traits-的应用\" class=\"headerlink\" title=\"3. Traits 的应用\"></a>3. Traits 的应用</h3><p>Traits 在 C++ 标准库中有广泛的应用，以下是一些常见的例子：</p>\n<ul>\n<li><strong><code>std::iterator_traits</code></strong>: 提供迭代器的类型信息，如值类型、指针类型等。</li>\n<li><strong><code>std::numeric_limits</code></strong>: 提供数值类型的特性，如最小值、最大值等。</li>\n<li><strong><code>std::enable_if</code></strong>: 用于条件性地启用模板特化。</li>\n</ul>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><ul>\n<li><strong>Traits</strong> 是一种强大的设计模式，允许在编译时获取类型信息和行为。</li>\n<li>它们可以用于类型特性、类型转换和类型操作，提供灵活性和可扩展性。</li>\n<li>Traits 在 C++ 标准库中有广泛的应用，尤其是在模板编程和泛型编程中。</li>\n</ul>\n<p>通过使用 Traits，开发者可以编写更通用和可重用的代码，同时提高类型安全性和性能。</p>\n"},{"title":"trivially copyable(拷贝不变)","date":"2022-10-25T08:55:46.000Z","_content":"","source":"_posts/trivially-copyable-拷贝不变.md","raw":"---\ntitle: trivially copyable(拷贝不变)\ndate: 2022-10-25 16:55:46\ntags:\n---\n","slug":"trivially-copyable-拷贝不变","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a60028gcco60idgjf6","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"tweak心得","date":"2017-03-07T01:20:39.000Z","_content":"\n### 1 关于ssh\n\n一般形式 ssh root@192.168.2.17或者ssh mobile@192.168.2.17\n\nroot和mobile分别为iOS上默认用户，alpine是默认密码\n\n可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码\n\n### 2 scp source dest\n\n一般为\n\nscp ~/123.txt mobile@192.168.2.17:/usr/bin\n\n### 3 Makefile\n\n可以配置手机的IP，framework，arch等参数\n\nTHEOS_DEVICE_IP = 192.168.31.202\nARCHS = armv7 arm64\nTARGET = iphone:latest:8.0\n\niOSREGreetings_FRAMEWORKS = UIKit \n\n### 4 关于bundleID\n\n.plist中的bundle就是你想hook的程序的bundleID\n","source":"_posts/tweak使用说明.md","raw":"---\nlayout: post\ntitle: tweak心得\ndate: 2017-03-07 09:20:39\ntags: iOS\n---\n\n### 1 关于ssh\n\n一般形式 ssh root@192.168.2.17或者ssh mobile@192.168.2.17\n\nroot和mobile分别为iOS上默认用户，alpine是默认密码\n\n可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码\n\n### 2 scp source dest\n\n一般为\n\nscp ~/123.txt mobile@192.168.2.17:/usr/bin\n\n### 3 Makefile\n\n可以配置手机的IP，framework，arch等参数\n\nTHEOS_DEVICE_IP = 192.168.31.202\nARCHS = armv7 arm64\nTARGET = iphone:latest:8.0\n\niOSREGreetings_FRAMEWORKS = UIKit \n\n### 4 关于bundleID\n\n.plist中的bundle就是你想hook的程序的bundleID\n","slug":"tweak使用说明","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a6002agccob4wtg6la","content":"<h3 id=\"1-关于ssh\"><a href=\"#1-关于ssh\" class=\"headerlink\" title=\"1 关于ssh\"></a>1 关于ssh</h3><p>一般形式 ssh <a href=\"mailto:&#114;&#x6f;&#x6f;&#116;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#54;&#56;&#46;&#50;&#x2e;&#x31;&#x37;\">&#114;&#x6f;&#x6f;&#116;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#54;&#56;&#46;&#50;&#x2e;&#x31;&#x37;</a>或者ssh <a href=\"mailto:&#109;&#111;&#98;&#105;&#x6c;&#x65;&#64;&#x31;&#57;&#50;&#46;&#x31;&#54;&#56;&#x2e;&#x32;&#x2e;&#x31;&#55;\">&#109;&#111;&#98;&#105;&#x6c;&#x65;&#64;&#x31;&#57;&#50;&#46;&#x31;&#54;&#56;&#x2e;&#x32;&#x2e;&#x31;&#55;</a></p>\n<p>root和mobile分别为iOS上默认用户，alpine是默认密码</p>\n<p>可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码</p>\n<h3 id=\"2-scp-source-dest\"><a href=\"#2-scp-source-dest\" class=\"headerlink\" title=\"2 scp source dest\"></a>2 scp source dest</h3><p>一般为</p>\n<p>scp ~/123.txt <a href=\"mailto:&#109;&#x6f;&#98;&#x69;&#x6c;&#x65;&#x40;&#49;&#x39;&#x32;&#46;&#49;&#54;&#x38;&#x2e;&#x32;&#x2e;&#x31;&#x37;\">&#109;&#x6f;&#98;&#x69;&#x6c;&#x65;&#x40;&#49;&#x39;&#x32;&#46;&#49;&#54;&#x38;&#x2e;&#x32;&#x2e;&#x31;&#x37;</a>:/usr/bin</p>\n<h3 id=\"3-Makefile\"><a href=\"#3-Makefile\" class=\"headerlink\" title=\"3 Makefile\"></a>3 Makefile</h3><p>可以配置手机的IP，framework，arch等参数</p>\n<p>THEOS_DEVICE_IP = 192.168.31.202<br>ARCHS = armv7 arm64<br>TARGET = iphone:latest:8.0</p>\n<p>iOSREGreetings_FRAMEWORKS = UIKit </p>\n<h3 id=\"4-关于bundleID\"><a href=\"#4-关于bundleID\" class=\"headerlink\" title=\"4 关于bundleID\"></a>4 关于bundleID</h3><p>.plist中的bundle就是你想hook的程序的bundleID</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-关于ssh\"><a href=\"#1-关于ssh\" class=\"headerlink\" title=\"1 关于ssh\"></a>1 关于ssh</h3><p>一般形式 ssh <a href=\"mailto:&#114;&#x6f;&#x6f;&#116;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#54;&#56;&#46;&#50;&#x2e;&#x31;&#x37;\">&#114;&#x6f;&#x6f;&#116;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#54;&#56;&#46;&#50;&#x2e;&#x31;&#x37;</a>或者ssh <a href=\"mailto:&#109;&#111;&#98;&#105;&#x6c;&#x65;&#64;&#x31;&#57;&#50;&#46;&#x31;&#54;&#56;&#x2e;&#x32;&#x2e;&#x31;&#55;\">&#109;&#111;&#98;&#105;&#x6c;&#x65;&#64;&#x31;&#57;&#50;&#46;&#x31;&#54;&#56;&#x2e;&#x32;&#x2e;&#x31;&#55;</a></p>\n<p>root和mobile分别为iOS上默认用户，alpine是默认密码</p>\n<p>可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码</p>\n<h3 id=\"2-scp-source-dest\"><a href=\"#2-scp-source-dest\" class=\"headerlink\" title=\"2 scp source dest\"></a>2 scp source dest</h3><p>一般为</p>\n<p>scp ~/123.txt <a href=\"mailto:&#109;&#x6f;&#98;&#x69;&#x6c;&#x65;&#x40;&#49;&#x39;&#x32;&#46;&#49;&#54;&#x38;&#x2e;&#x32;&#x2e;&#x31;&#x37;\">&#109;&#x6f;&#98;&#x69;&#x6c;&#x65;&#x40;&#49;&#x39;&#x32;&#46;&#49;&#54;&#x38;&#x2e;&#x32;&#x2e;&#x31;&#x37;</a>:/usr/bin</p>\n<h3 id=\"3-Makefile\"><a href=\"#3-Makefile\" class=\"headerlink\" title=\"3 Makefile\"></a>3 Makefile</h3><p>可以配置手机的IP，framework，arch等参数</p>\n<p>THEOS_DEVICE_IP = 192.168.31.202<br>ARCHS = armv7 arm64<br>TARGET = iphone:latest:8.0</p>\n<p>iOSREGreetings_FRAMEWORKS = UIKit </p>\n<h3 id=\"4-关于bundleID\"><a href=\"#4-关于bundleID\" class=\"headerlink\" title=\"4 关于bundleID\"></a>4 关于bundleID</h3><p>.plist中的bundle就是你想hook的程序的bundleID</p>\n"},{"layout":"post","title":"tweak环境搭建","date":"2017-03-07T00:43:58.000Z","_content":"\n### 0 设置环境变量 export THEOS=/opt/theos\n\n可以设置~/.zshrc中添加，修改后用source命令重新加载\n\n### 1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下\n\n### 2 下载ldid，放到/opt/theos/bin下\n\nsudo chmod 777 /opt/theos/bin/ldid\n\n### 3 配置CydiaSubstrate\n\n在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib\n\n并将头文件substrate.h也scp 到/opt/theos/include下\n\nsudo /opt/theos/bin/bootstrap.sh substrate\n\n### 4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/\n\nsuodo chmod 777 /opt/bin/dpkg-deb\n\n基本就搭建完成，可以练习创建工程\n\n/opt/theos/bin/nic.pl\n\n然后进行make package \n\nmake package install\n\n","source":"_posts/tweak环境搭建.md","raw":"---\nlayout: post\ntitle: tweak环境搭建\ndate: 2017-03-07 08:43:58\ntags: iOS\n---\n\n### 0 设置环境变量 export THEOS=/opt/theos\n\n可以设置~/.zshrc中添加，修改后用source命令重新加载\n\n### 1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下\n\n### 2 下载ldid，放到/opt/theos/bin下\n\nsudo chmod 777 /opt/theos/bin/ldid\n\n### 3 配置CydiaSubstrate\n\n在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib\n\n并将头文件substrate.h也scp 到/opt/theos/include下\n\nsudo /opt/theos/bin/bootstrap.sh substrate\n\n### 4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/\n\nsuodo chmod 777 /opt/bin/dpkg-deb\n\n基本就搭建完成，可以练习创建工程\n\n/opt/theos/bin/nic.pl\n\n然后进行make package \n\nmake package install\n\n","slug":"tweak环境搭建","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbm0l9a6002bgcco6eakc2to","content":"<h3 id=\"0-设置环境变量-export-THEOS-opt-theos\"><a href=\"#0-设置环境变量-export-THEOS-opt-theos\" class=\"headerlink\" title=\"0 设置环境变量 export THEOS=/opt/theos\"></a>0 设置环境变量 export THEOS=/opt/theos</h3><p>可以设置~/.zshrc中添加，修改后用source命令重新加载</p>\n<h3 id=\"1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下\"><a href=\"#1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下\" class=\"headerlink\" title=\"1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下\"></a>1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下</h3><h3 id=\"2-下载ldid，放到-opt-theos-bin下\"><a href=\"#2-下载ldid，放到-opt-theos-bin下\" class=\"headerlink\" title=\"2 下载ldid，放到/opt/theos/bin下\"></a>2 下载ldid，放到/opt/theos/bin下</h3><p>sudo chmod 777 /opt/theos/bin/ldid</p>\n<h3 id=\"3-配置CydiaSubstrate\"><a href=\"#3-配置CydiaSubstrate\" class=\"headerlink\" title=\"3 配置CydiaSubstrate\"></a>3 配置CydiaSubstrate</h3><p>在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib</p>\n<p>并将头文件substrate.h也scp 到/opt/theos/include下</p>\n<p>sudo /opt/theos/bin/bootstrap.sh substrate</p>\n<h3 id=\"4-将dm-pl重命名为dpkg-deb，cp到-opt-bin\"><a href=\"#4-将dm-pl重命名为dpkg-deb，cp到-opt-bin\" class=\"headerlink\" title=\"4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/\"></a>4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/</h3><p>suodo chmod 777 /opt/bin/dpkg-deb</p>\n<p>基本就搭建完成，可以练习创建工程</p>\n<p>/opt/theos/bin/nic.pl</p>\n<p>然后进行make package </p>\n<p>make package install</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"0-设置环境变量-export-THEOS-opt-theos\"><a href=\"#0-设置环境变量-export-THEOS-opt-theos\" class=\"headerlink\" title=\"0 设置环境变量 export THEOS=/opt/theos\"></a>0 设置环境变量 export THEOS=/opt/theos</h3><p>可以设置~/.zshrc中添加，修改后用source命令重新加载</p>\n<h3 id=\"1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下\"><a href=\"#1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下\" class=\"headerlink\" title=\"1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下\"></a>1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下</h3><h3 id=\"2-下载ldid，放到-opt-theos-bin下\"><a href=\"#2-下载ldid，放到-opt-theos-bin下\" class=\"headerlink\" title=\"2 下载ldid，放到/opt/theos/bin下\"></a>2 下载ldid，放到/opt/theos/bin下</h3><p>sudo chmod 777 /opt/theos/bin/ldid</p>\n<h3 id=\"3-配置CydiaSubstrate\"><a href=\"#3-配置CydiaSubstrate\" class=\"headerlink\" title=\"3 配置CydiaSubstrate\"></a>3 配置CydiaSubstrate</h3><p>在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib</p>\n<p>并将头文件substrate.h也scp 到/opt/theos/include下</p>\n<p>sudo /opt/theos/bin/bootstrap.sh substrate</p>\n<h3 id=\"4-将dm-pl重命名为dpkg-deb，cp到-opt-bin\"><a href=\"#4-将dm-pl重命名为dpkg-deb，cp到-opt-bin\" class=\"headerlink\" title=\"4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/\"></a>4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/</h3><p>suodo chmod 777 /opt/bin/dpkg-deb</p>\n<p>基本就搭建完成，可以练习创建工程</p>\n<p>/opt/theos/bin/nic.pl</p>\n<p>然后进行make package </p>\n<p>make package install</p>\n"},{"title":"type script","date":"2025-03-15T15:23:39.000Z","_content":"TypeScript 是一种由 **Microsoft** 开发的开源编程语言，它是 **JavaScript 的超集**，为 JavaScript 添加了可选的静态类型系统和现代语言特性。TypeScript 的目标是提高 JavaScript 代码的可维护性、可读性和开发效率，同时保持与 JavaScript 的完全兼容。\n\n---\n\n### **1. TypeScript 的核心特性**\n#### **(1) 静态类型检查**\n- **类型注解**：  \n  允许开发者为变量、函数参数和返回值等添加类型注解，例如：\n  ```typescript\n  let count: number = 10;\n  function add(a: number, b: number): number {\n      return a + b;\n  }\n  ```\n- **类型推断**：  \n  即使没有显式注解，TypeScript 也能根据上下文推断类型。\n\n#### **(2) 面向对象编程**\n- **类与接口**：  \n  支持类、继承、接口等面向对象特性：\n  ```typescript\n  interface Animal {\n      name: string;\n      makeSound(): void;\n  }\n\n  class Dog implements Animal {\n      name: string;\n      constructor(name: string) {\n          this.name = name;\n      }\n      makeSound() {\n          console.log(\"Woof!\");\n      }\n  }\n  ```\n\n#### **(3) 现代 JavaScript 特性**\n- **ES6+ 支持**：  \n  TypeScript 支持最新的 JavaScript 特性（如箭头函数、解构赋值、模块化等），并将其编译为兼容性更好的 ES5 或更低版本。\n- **装饰器**：  \n  支持实验性装饰器语法，常用于 Angular 等框架。\n\n#### **(4) 工具支持**\n- **强大的 IDE 支持**：  \n  TypeScript 提供了丰富的工具支持，如代码补全、类型检查、重构等，主流 IDE（如 VS Code）对 TypeScript 有原生支持。\n- **编译时错误检查**：  \n  在编译阶段捕获类型错误，减少运行时错误。\n\n---\n\n### **2. TypeScript 的优势**\n#### **(1) 提高代码质量**\n- **类型安全**：  \n  静态类型检查可以在编译阶段发现潜在的错误，减少运行时错误。\n- **代码可读性**：  \n  类型注解使代码更易于理解和维护。\n\n#### **(2) 提高开发效率**\n- **智能提示**：  \n  IDE 可以根据类型信息提供更准确的代码补全和提示。\n- **重构支持**：  \n  类型信息使得重构代码更加安全和高效。\n\n#### **(3) 兼容性**\n- **与 JavaScript 兼容**：  \n  TypeScript 是 JavaScript 的超集，任何合法的 JavaScript 代码都是合法的 TypeScript 代码。\n- **渐进式采用**：  \n  可以在现有 JavaScript 项目中逐步引入 TypeScript。\n\n---\n\n### **3. TypeScript 的基本语法**\n#### **(1) 类型注解**\n```typescript\nlet isDone: boolean = false;\nlet count: number = 42;\nlet name: string = \"TypeScript\";\n```\n\n#### **(2) 接口**\n```typescript\ninterface User {\n    id: number;\n    name: string;\n    email?: string;  // 可选属性\n}\n\nlet user: User = {\n    id: 1,\n    name: \"Alice\"\n};\n```\n\n#### **(3) 类**\n```typescript\nclass Person {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    greet() {\n        console.log(`Hello, ${this.name}`);\n    }\n}\n\nlet person = new Person(\"Bob\");\nperson.greet();\n```\n\n#### **(4) 泛型**\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet output = identity<string>(\"Hello\");\n```\n\n#### **(5) 模块化**\n```typescript\n// math.ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\n// main.ts\nimport { add } from './math';\nconsole.log(add(1, 2));\n```\n\n---\n\n### **4. TypeScript 的工作流程**\n1. **编写 TypeScript 代码**：  \n   使用 `.ts` 或 `.tsx` 文件编写代码。\n2. **编译 TypeScript**：  \n   使用 TypeScript 编译器（`tsc`）将代码编译为 JavaScript：\n   ```bash\n   tsc main.ts\n   ```\n3. **运行 JavaScript**：  \n   执行生成的 `.js` 文件。\n\n---\n\n### **5. TypeScript 的适用场景**\n- **大型项目**：  \n  类型系统有助于管理复杂的代码库。\n- **团队协作**：  \n  类型注解和接口定义可以提高团队协作效率。\n- **框架开发**：  \n  许多现代前端框架（如 Angular、Vue 3、React）都支持 TypeScript。\n- **渐进式迁移**：  \n  可以在现有 JavaScript 项目中逐步引入 TypeScript。\n\n---\n\n### **6. TypeScript 与 JavaScript 的区别**\n| 特性                | TypeScript                     | JavaScript                 |\n|---------------------|--------------------------------|----------------------------|\n| **类型系统**         | 静态类型                       | 动态类型                   |\n| **编译**             | 需要编译为 JavaScript          | 直接运行                   |\n| **工具支持**         | 强大的 IDE 支持                | 有限的工具支持             |\n| **学习曲线**         | 较高（需要学习类型系统）       | 较低                       |\n| **适用场景**         | 大型项目、团队协作             | 小型项目、快速原型开发     |\n\n---\n\n### **7. 如何开始学习 TypeScript**\n1. **安装 TypeScript**：\n   ```bash\n   npm install -g typescript\n   ```\n2. **编写第一个 TypeScript 程序**：\n   ```typescript\n   // hello.ts\n   function greet(name: string): string {\n       return `Hello, ${name}!`;\n   }\n   console.log(greet(\"TypeScript\"));\n   ```\n3. **编译并运行**：\n   ```bash\n   tsc hello.ts\n   node hello.js\n   ```\n\n---\n\n### **总结**\nTypeScript 是一种强大的编程语言，通过静态类型检查和现代语言特性，显著提升了 JavaScript 的开发效率和代码质量。它特别适合大型项目、团队协作以及对代码质量要求较高的场景。如果你已经熟悉 JavaScript，学习 TypeScript 将是一个自然且有益的进阶选择。\n","source":"_posts/type-script.md","raw":"---\ntitle: type script\ndate: 2025-03-15 23:23:39\ntags:\n---\nTypeScript 是一种由 **Microsoft** 开发的开源编程语言，它是 **JavaScript 的超集**，为 JavaScript 添加了可选的静态类型系统和现代语言特性。TypeScript 的目标是提高 JavaScript 代码的可维护性、可读性和开发效率，同时保持与 JavaScript 的完全兼容。\n\n---\n\n### **1. TypeScript 的核心特性**\n#### **(1) 静态类型检查**\n- **类型注解**：  \n  允许开发者为变量、函数参数和返回值等添加类型注解，例如：\n  ```typescript\n  let count: number = 10;\n  function add(a: number, b: number): number {\n      return a + b;\n  }\n  ```\n- **类型推断**：  \n  即使没有显式注解，TypeScript 也能根据上下文推断类型。\n\n#### **(2) 面向对象编程**\n- **类与接口**：  \n  支持类、继承、接口等面向对象特性：\n  ```typescript\n  interface Animal {\n      name: string;\n      makeSound(): void;\n  }\n\n  class Dog implements Animal {\n      name: string;\n      constructor(name: string) {\n          this.name = name;\n      }\n      makeSound() {\n          console.log(\"Woof!\");\n      }\n  }\n  ```\n\n#### **(3) 现代 JavaScript 特性**\n- **ES6+ 支持**：  \n  TypeScript 支持最新的 JavaScript 特性（如箭头函数、解构赋值、模块化等），并将其编译为兼容性更好的 ES5 或更低版本。\n- **装饰器**：  \n  支持实验性装饰器语法，常用于 Angular 等框架。\n\n#### **(4) 工具支持**\n- **强大的 IDE 支持**：  \n  TypeScript 提供了丰富的工具支持，如代码补全、类型检查、重构等，主流 IDE（如 VS Code）对 TypeScript 有原生支持。\n- **编译时错误检查**：  \n  在编译阶段捕获类型错误，减少运行时错误。\n\n---\n\n### **2. TypeScript 的优势**\n#### **(1) 提高代码质量**\n- **类型安全**：  \n  静态类型检查可以在编译阶段发现潜在的错误，减少运行时错误。\n- **代码可读性**：  \n  类型注解使代码更易于理解和维护。\n\n#### **(2) 提高开发效率**\n- **智能提示**：  \n  IDE 可以根据类型信息提供更准确的代码补全和提示。\n- **重构支持**：  \n  类型信息使得重构代码更加安全和高效。\n\n#### **(3) 兼容性**\n- **与 JavaScript 兼容**：  \n  TypeScript 是 JavaScript 的超集，任何合法的 JavaScript 代码都是合法的 TypeScript 代码。\n- **渐进式采用**：  \n  可以在现有 JavaScript 项目中逐步引入 TypeScript。\n\n---\n\n### **3. TypeScript 的基本语法**\n#### **(1) 类型注解**\n```typescript\nlet isDone: boolean = false;\nlet count: number = 42;\nlet name: string = \"TypeScript\";\n```\n\n#### **(2) 接口**\n```typescript\ninterface User {\n    id: number;\n    name: string;\n    email?: string;  // 可选属性\n}\n\nlet user: User = {\n    id: 1,\n    name: \"Alice\"\n};\n```\n\n#### **(3) 类**\n```typescript\nclass Person {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    greet() {\n        console.log(`Hello, ${this.name}`);\n    }\n}\n\nlet person = new Person(\"Bob\");\nperson.greet();\n```\n\n#### **(4) 泛型**\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet output = identity<string>(\"Hello\");\n```\n\n#### **(5) 模块化**\n```typescript\n// math.ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\n// main.ts\nimport { add } from './math';\nconsole.log(add(1, 2));\n```\n\n---\n\n### **4. TypeScript 的工作流程**\n1. **编写 TypeScript 代码**：  \n   使用 `.ts` 或 `.tsx` 文件编写代码。\n2. **编译 TypeScript**：  \n   使用 TypeScript 编译器（`tsc`）将代码编译为 JavaScript：\n   ```bash\n   tsc main.ts\n   ```\n3. **运行 JavaScript**：  \n   执行生成的 `.js` 文件。\n\n---\n\n### **5. TypeScript 的适用场景**\n- **大型项目**：  \n  类型系统有助于管理复杂的代码库。\n- **团队协作**：  \n  类型注解和接口定义可以提高团队协作效率。\n- **框架开发**：  \n  许多现代前端框架（如 Angular、Vue 3、React）都支持 TypeScript。\n- **渐进式迁移**：  \n  可以在现有 JavaScript 项目中逐步引入 TypeScript。\n\n---\n\n### **6. TypeScript 与 JavaScript 的区别**\n| 特性                | TypeScript                     | JavaScript                 |\n|---------------------|--------------------------------|----------------------------|\n| **类型系统**         | 静态类型                       | 动态类型                   |\n| **编译**             | 需要编译为 JavaScript          | 直接运行                   |\n| **工具支持**         | 强大的 IDE 支持                | 有限的工具支持             |\n| **学习曲线**         | 较高（需要学习类型系统）       | 较低                       |\n| **适用场景**         | 大型项目、团队协作             | 小型项目、快速原型开发     |\n\n---\n\n### **7. 如何开始学习 TypeScript**\n1. **安装 TypeScript**：\n   ```bash\n   npm install -g typescript\n   ```\n2. **编写第一个 TypeScript 程序**：\n   ```typescript\n   // hello.ts\n   function greet(name: string): string {\n       return `Hello, ${name}!`;\n   }\n   console.log(greet(\"TypeScript\"));\n   ```\n3. **编译并运行**：\n   ```bash\n   tsc hello.ts\n   node hello.js\n   ```\n\n---\n\n### **总结**\nTypeScript 是一种强大的编程语言，通过静态类型检查和现代语言特性，显著提升了 JavaScript 的开发效率和代码质量。它特别适合大型项目、团队协作以及对代码质量要求较高的场景。如果你已经熟悉 JavaScript，学习 TypeScript 将是一个自然且有益的进阶选择。\n","slug":"type-script","published":1,"updated":"2025-03-15T15:26:08.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a6002dgccoaihj41rp","content":"<p>TypeScript 是一种由 <strong>Microsoft</strong> 开发的开源编程语言，它是 <strong>JavaScript 的超集</strong>，为 JavaScript 添加了可选的静态类型系统和现代语言特性。TypeScript 的目标是提高 JavaScript 代码的可维护性、可读性和开发效率，同时保持与 JavaScript 的完全兼容。</p>\n<hr>\n<h3 id=\"1-TypeScript-的核心特性\"><a href=\"#1-TypeScript-的核心特性\" class=\"headerlink\" title=\"1. TypeScript 的核心特性\"></a><strong>1. TypeScript 的核心特性</strong></h3><h4 id=\"1-静态类型检查\"><a href=\"#1-静态类型检查\" class=\"headerlink\" title=\"(1) 静态类型检查\"></a><strong>(1) 静态类型检查</strong></h4><ul>\n<li><strong>类型注解</strong>：<br>允许开发者为变量、函数参数和返回值等添加类型注解，例如：<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">count</span>: <span class=\"built_in\">number</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a: <span class=\"built_in\">number</span>, b: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>类型推断</strong>：<br>即使没有显式注解，TypeScript 也能根据上下文推断类型。</li>\n</ul>\n<h4 id=\"2-面向对象编程\"><a href=\"#2-面向对象编程\" class=\"headerlink\" title=\"(2) 面向对象编程\"></a><strong>(2) 面向对象编程</strong></h4><ul>\n<li><strong>类与接口</strong>：<br>支持类、继承、接口等面向对象特性：<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"title function_\">makeSound</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">makeSound</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Woof!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"3-现代-JavaScript-特性\"><a href=\"#3-现代-JavaScript-特性\" class=\"headerlink\" title=\"(3) 现代 JavaScript 特性\"></a><strong>(3) 现代 JavaScript 特性</strong></h4><ul>\n<li><strong>ES6+ 支持</strong>：<br>TypeScript 支持最新的 JavaScript 特性（如箭头函数、解构赋值、模块化等），并将其编译为兼容性更好的 ES5 或更低版本。</li>\n<li><strong>装饰器</strong>：<br>支持实验性装饰器语法，常用于 Angular 等框架。</li>\n</ul>\n<h4 id=\"4-工具支持\"><a href=\"#4-工具支持\" class=\"headerlink\" title=\"(4) 工具支持\"></a><strong>(4) 工具支持</strong></h4><ul>\n<li><strong>强大的 IDE 支持</strong>：<br>TypeScript 提供了丰富的工具支持，如代码补全、类型检查、重构等，主流 IDE（如 VS Code）对 TypeScript 有原生支持。</li>\n<li><strong>编译时错误检查</strong>：<br>在编译阶段捕获类型错误，减少运行时错误。</li>\n</ul>\n<hr>\n<h3 id=\"2-TypeScript-的优势\"><a href=\"#2-TypeScript-的优势\" class=\"headerlink\" title=\"2. TypeScript 的优势\"></a><strong>2. TypeScript 的优势</strong></h3><h4 id=\"1-提高代码质量\"><a href=\"#1-提高代码质量\" class=\"headerlink\" title=\"(1) 提高代码质量\"></a><strong>(1) 提高代码质量</strong></h4><ul>\n<li><strong>类型安全</strong>：<br>静态类型检查可以在编译阶段发现潜在的错误，减少运行时错误。</li>\n<li><strong>代码可读性</strong>：<br>类型注解使代码更易于理解和维护。</li>\n</ul>\n<h4 id=\"2-提高开发效率\"><a href=\"#2-提高开发效率\" class=\"headerlink\" title=\"(2) 提高开发效率\"></a><strong>(2) 提高开发效率</strong></h4><ul>\n<li><strong>智能提示</strong>：<br>IDE 可以根据类型信息提供更准确的代码补全和提示。</li>\n<li><strong>重构支持</strong>：<br>类型信息使得重构代码更加安全和高效。</li>\n</ul>\n<h4 id=\"3-兼容性\"><a href=\"#3-兼容性\" class=\"headerlink\" title=\"(3) 兼容性\"></a><strong>(3) 兼容性</strong></h4><ul>\n<li><strong>与 JavaScript 兼容</strong>：<br>TypeScript 是 JavaScript 的超集，任何合法的 JavaScript 代码都是合法的 TypeScript 代码。</li>\n<li><strong>渐进式采用</strong>：<br>可以在现有 JavaScript 项目中逐步引入 TypeScript。</li>\n</ul>\n<hr>\n<h3 id=\"3-TypeScript-的基本语法\"><a href=\"#3-TypeScript-的基本语法\" class=\"headerlink\" title=\"3. TypeScript 的基本语法\"></a><strong>3. TypeScript 的基本语法</strong></h3><h4 id=\"1-类型注解\"><a href=\"#1-类型注解\" class=\"headerlink\" title=\"(1) 类型注解\"></a><strong>(1) 类型注解</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">isDone</span>: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">count</span>: <span class=\"built_in\">number</span> = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;TypeScript&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-接口\"><a href=\"#2-接口\" class=\"headerlink\" title=\"(2) 接口\"></a><strong>(2) 接口</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    email?: <span class=\"built_in\">string</span>;  <span class=\"comment\">// 可选属性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">user</span>: <span class=\"title class_\">User</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-类\"><a href=\"#3-类\" class=\"headerlink\" title=\"(3) 类\"></a><strong>(3) 类</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">person.<span class=\"title function_\">greet</span>();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-泛型\"><a href=\"#4-泛型\" class=\"headerlink\" title=\"(4) 泛型\"></a><strong>(4) 泛型</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;T&gt;(<span class=\"attr\">arg</span>: T): T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> output = identity&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-模块化\"><a href=\"#5-模块化\" class=\"headerlink\" title=\"(5) 模块化\"></a><strong>(5) 模块化</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// math.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a: <span class=\"built_in\">number</span>, b: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; add &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./math&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">add</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"4-TypeScript-的工作流程\"><a href=\"#4-TypeScript-的工作流程\" class=\"headerlink\" title=\"4. TypeScript 的工作流程\"></a><strong>4. TypeScript 的工作流程</strong></h3><ol>\n<li><strong>编写 TypeScript 代码</strong>：<br>使用 <code>.ts</code> 或 <code>.tsx</code> 文件编写代码。</li>\n<li><strong>编译 TypeScript</strong>：<br>使用 TypeScript 编译器（<code>tsc</code>）将代码编译为 JavaScript：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc main.ts</span><br></pre></td></tr></table></figure></li>\n<li><strong>运行 JavaScript</strong>：<br>执行生成的 <code>.js</code> 文件。</li>\n</ol>\n<hr>\n<h3 id=\"5-TypeScript-的适用场景\"><a href=\"#5-TypeScript-的适用场景\" class=\"headerlink\" title=\"5. TypeScript 的适用场景\"></a><strong>5. TypeScript 的适用场景</strong></h3><ul>\n<li><strong>大型项目</strong>：<br>类型系统有助于管理复杂的代码库。</li>\n<li><strong>团队协作</strong>：<br>类型注解和接口定义可以提高团队协作效率。</li>\n<li><strong>框架开发</strong>：<br>许多现代前端框架（如 Angular、Vue 3、React）都支持 TypeScript。</li>\n<li><strong>渐进式迁移</strong>：<br>可以在现有 JavaScript 项目中逐步引入 TypeScript。</li>\n</ul>\n<hr>\n<h3 id=\"6-TypeScript-与-JavaScript-的区别\"><a href=\"#6-TypeScript-与-JavaScript-的区别\" class=\"headerlink\" title=\"6. TypeScript 与 JavaScript 的区别\"></a><strong>6. TypeScript 与 JavaScript 的区别</strong></h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>TypeScript</th>\n<th>JavaScript</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>类型系统</strong></td>\n<td>静态类型</td>\n<td>动态类型</td>\n</tr>\n<tr>\n<td><strong>编译</strong></td>\n<td>需要编译为 JavaScript</td>\n<td>直接运行</td>\n</tr>\n<tr>\n<td><strong>工具支持</strong></td>\n<td>强大的 IDE 支持</td>\n<td>有限的工具支持</td>\n</tr>\n<tr>\n<td><strong>学习曲线</strong></td>\n<td>较高（需要学习类型系统）</td>\n<td>较低</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>大型项目、团队协作</td>\n<td>小型项目、快速原型开发</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"7-如何开始学习-TypeScript\"><a href=\"#7-如何开始学习-TypeScript\" class=\"headerlink\" title=\"7. 如何开始学习 TypeScript\"></a><strong>7. 如何开始学习 TypeScript</strong></h3><ol>\n<li><strong>安装 TypeScript</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure></li>\n<li><strong>编写第一个 TypeScript 程序</strong>：<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hello.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, <span class=\"subst\">$&#123;name&#125;</span>!`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">greet</span>(<span class=\"string\">&quot;TypeScript&quot;</span>));</span><br></pre></td></tr></table></figure></li>\n<li><strong>编译并运行</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc hello.ts</span><br><span class=\"line\">node hello.js</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>TypeScript 是一种强大的编程语言，通过静态类型检查和现代语言特性，显著提升了 JavaScript 的开发效率和代码质量。它特别适合大型项目、团队协作以及对代码质量要求较高的场景。如果你已经熟悉 JavaScript，学习 TypeScript 将是一个自然且有益的进阶选择。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>TypeScript 是一种由 <strong>Microsoft</strong> 开发的开源编程语言，它是 <strong>JavaScript 的超集</strong>，为 JavaScript 添加了可选的静态类型系统和现代语言特性。TypeScript 的目标是提高 JavaScript 代码的可维护性、可读性和开发效率，同时保持与 JavaScript 的完全兼容。</p>\n<hr>\n<h3 id=\"1-TypeScript-的核心特性\"><a href=\"#1-TypeScript-的核心特性\" class=\"headerlink\" title=\"1. TypeScript 的核心特性\"></a><strong>1. TypeScript 的核心特性</strong></h3><h4 id=\"1-静态类型检查\"><a href=\"#1-静态类型检查\" class=\"headerlink\" title=\"(1) 静态类型检查\"></a><strong>(1) 静态类型检查</strong></h4><ul>\n<li><strong>类型注解</strong>：<br>允许开发者为变量、函数参数和返回值等添加类型注解，例如：<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">count</span>: <span class=\"built_in\">number</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a: <span class=\"built_in\">number</span>, b: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>类型推断</strong>：<br>即使没有显式注解，TypeScript 也能根据上下文推断类型。</li>\n</ul>\n<h4 id=\"2-面向对象编程\"><a href=\"#2-面向对象编程\" class=\"headerlink\" title=\"(2) 面向对象编程\"></a><strong>(2) 面向对象编程</strong></h4><ul>\n<li><strong>类与接口</strong>：<br>支持类、继承、接口等面向对象特性：<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"title function_\">makeSound</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">makeSound</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Woof!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"3-现代-JavaScript-特性\"><a href=\"#3-现代-JavaScript-特性\" class=\"headerlink\" title=\"(3) 现代 JavaScript 特性\"></a><strong>(3) 现代 JavaScript 特性</strong></h4><ul>\n<li><strong>ES6+ 支持</strong>：<br>TypeScript 支持最新的 JavaScript 特性（如箭头函数、解构赋值、模块化等），并将其编译为兼容性更好的 ES5 或更低版本。</li>\n<li><strong>装饰器</strong>：<br>支持实验性装饰器语法，常用于 Angular 等框架。</li>\n</ul>\n<h4 id=\"4-工具支持\"><a href=\"#4-工具支持\" class=\"headerlink\" title=\"(4) 工具支持\"></a><strong>(4) 工具支持</strong></h4><ul>\n<li><strong>强大的 IDE 支持</strong>：<br>TypeScript 提供了丰富的工具支持，如代码补全、类型检查、重构等，主流 IDE（如 VS Code）对 TypeScript 有原生支持。</li>\n<li><strong>编译时错误检查</strong>：<br>在编译阶段捕获类型错误，减少运行时错误。</li>\n</ul>\n<hr>\n<h3 id=\"2-TypeScript-的优势\"><a href=\"#2-TypeScript-的优势\" class=\"headerlink\" title=\"2. TypeScript 的优势\"></a><strong>2. TypeScript 的优势</strong></h3><h4 id=\"1-提高代码质量\"><a href=\"#1-提高代码质量\" class=\"headerlink\" title=\"(1) 提高代码质量\"></a><strong>(1) 提高代码质量</strong></h4><ul>\n<li><strong>类型安全</strong>：<br>静态类型检查可以在编译阶段发现潜在的错误，减少运行时错误。</li>\n<li><strong>代码可读性</strong>：<br>类型注解使代码更易于理解和维护。</li>\n</ul>\n<h4 id=\"2-提高开发效率\"><a href=\"#2-提高开发效率\" class=\"headerlink\" title=\"(2) 提高开发效率\"></a><strong>(2) 提高开发效率</strong></h4><ul>\n<li><strong>智能提示</strong>：<br>IDE 可以根据类型信息提供更准确的代码补全和提示。</li>\n<li><strong>重构支持</strong>：<br>类型信息使得重构代码更加安全和高效。</li>\n</ul>\n<h4 id=\"3-兼容性\"><a href=\"#3-兼容性\" class=\"headerlink\" title=\"(3) 兼容性\"></a><strong>(3) 兼容性</strong></h4><ul>\n<li><strong>与 JavaScript 兼容</strong>：<br>TypeScript 是 JavaScript 的超集，任何合法的 JavaScript 代码都是合法的 TypeScript 代码。</li>\n<li><strong>渐进式采用</strong>：<br>可以在现有 JavaScript 项目中逐步引入 TypeScript。</li>\n</ul>\n<hr>\n<h3 id=\"3-TypeScript-的基本语法\"><a href=\"#3-TypeScript-的基本语法\" class=\"headerlink\" title=\"3. TypeScript 的基本语法\"></a><strong>3. TypeScript 的基本语法</strong></h3><h4 id=\"1-类型注解\"><a href=\"#1-类型注解\" class=\"headerlink\" title=\"(1) 类型注解\"></a><strong>(1) 类型注解</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">isDone</span>: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">count</span>: <span class=\"built_in\">number</span> = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;TypeScript&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-接口\"><a href=\"#2-接口\" class=\"headerlink\" title=\"(2) 接口\"></a><strong>(2) 接口</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    email?: <span class=\"built_in\">string</span>;  <span class=\"comment\">// 可选属性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">user</span>: <span class=\"title class_\">User</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-类\"><a href=\"#3-类\" class=\"headerlink\" title=\"(3) 类\"></a><strong>(3) 类</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">person.<span class=\"title function_\">greet</span>();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-泛型\"><a href=\"#4-泛型\" class=\"headerlink\" title=\"(4) 泛型\"></a><strong>(4) 泛型</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;T&gt;(<span class=\"attr\">arg</span>: T): T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> output = identity&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-模块化\"><a href=\"#5-模块化\" class=\"headerlink\" title=\"(5) 模块化\"></a><strong>(5) 模块化</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// math.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a: <span class=\"built_in\">number</span>, b: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; add &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./math&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">add</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"4-TypeScript-的工作流程\"><a href=\"#4-TypeScript-的工作流程\" class=\"headerlink\" title=\"4. TypeScript 的工作流程\"></a><strong>4. TypeScript 的工作流程</strong></h3><ol>\n<li><strong>编写 TypeScript 代码</strong>：<br>使用 <code>.ts</code> 或 <code>.tsx</code> 文件编写代码。</li>\n<li><strong>编译 TypeScript</strong>：<br>使用 TypeScript 编译器（<code>tsc</code>）将代码编译为 JavaScript：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc main.ts</span><br></pre></td></tr></table></figure></li>\n<li><strong>运行 JavaScript</strong>：<br>执行生成的 <code>.js</code> 文件。</li>\n</ol>\n<hr>\n<h3 id=\"5-TypeScript-的适用场景\"><a href=\"#5-TypeScript-的适用场景\" class=\"headerlink\" title=\"5. TypeScript 的适用场景\"></a><strong>5. TypeScript 的适用场景</strong></h3><ul>\n<li><strong>大型项目</strong>：<br>类型系统有助于管理复杂的代码库。</li>\n<li><strong>团队协作</strong>：<br>类型注解和接口定义可以提高团队协作效率。</li>\n<li><strong>框架开发</strong>：<br>许多现代前端框架（如 Angular、Vue 3、React）都支持 TypeScript。</li>\n<li><strong>渐进式迁移</strong>：<br>可以在现有 JavaScript 项目中逐步引入 TypeScript。</li>\n</ul>\n<hr>\n<h3 id=\"6-TypeScript-与-JavaScript-的区别\"><a href=\"#6-TypeScript-与-JavaScript-的区别\" class=\"headerlink\" title=\"6. TypeScript 与 JavaScript 的区别\"></a><strong>6. TypeScript 与 JavaScript 的区别</strong></h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>TypeScript</th>\n<th>JavaScript</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>类型系统</strong></td>\n<td>静态类型</td>\n<td>动态类型</td>\n</tr>\n<tr>\n<td><strong>编译</strong></td>\n<td>需要编译为 JavaScript</td>\n<td>直接运行</td>\n</tr>\n<tr>\n<td><strong>工具支持</strong></td>\n<td>强大的 IDE 支持</td>\n<td>有限的工具支持</td>\n</tr>\n<tr>\n<td><strong>学习曲线</strong></td>\n<td>较高（需要学习类型系统）</td>\n<td>较低</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>大型项目、团队协作</td>\n<td>小型项目、快速原型开发</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"7-如何开始学习-TypeScript\"><a href=\"#7-如何开始学习-TypeScript\" class=\"headerlink\" title=\"7. 如何开始学习 TypeScript\"></a><strong>7. 如何开始学习 TypeScript</strong></h3><ol>\n<li><strong>安装 TypeScript</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure></li>\n<li><strong>编写第一个 TypeScript 程序</strong>：<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hello.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, <span class=\"subst\">$&#123;name&#125;</span>!`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">greet</span>(<span class=\"string\">&quot;TypeScript&quot;</span>));</span><br></pre></td></tr></table></figure></li>\n<li><strong>编译并运行</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc hello.ts</span><br><span class=\"line\">node hello.js</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>TypeScript 是一种强大的编程语言，通过静态类型检查和现代语言特性，显著提升了 JavaScript 的开发效率和代码质量。它特别适合大型项目、团队协作以及对代码质量要求较高的场景。如果你已经熟悉 JavaScript，学习 TypeScript 将是一个自然且有益的进阶选择。</p>\n"},{"title":"what is mpx","date":"2025-03-15T15:04:48.000Z","_content":"MPX 是一个 **面向小程序开发的前端框架**，由滴滴出行团队开源，专为提升小程序开发效率和性能而设计。它基于 Vue.js 的语法和特性，同时针对小程序的特点进行了深度优化和扩展。以下是 MPX 的核心特性和详细介绍：\n\n---\n\n### **1. MPX 的核心特性**\n#### **(1) 基于 Vue.js 语法**\n- **语法兼容**：  \n  MPX 支持 Vue.js 的模板语法、计算属性、侦听器、生命周期钩子等，开发者可以快速上手。\n- **响应式数据**：  \n  支持 Vue 风格的响应式数据绑定，简化状态管理。\n\n#### **(2) 多平台支持**\n- **跨平台开发**：  \n  MPX 支持将同一套代码编译到微信小程序、支付宝小程序、百度小程序、字节跳动小程序等多个平台。\n- **平台差异化处理**：  \n  提供平台特定的 API 和配置，方便处理不同平台的兼容性问题。\n\n#### **(3) 性能优化**\n- **运行时优化**：  \n  通过减少不必要的 setData 调用和优化数据更新机制，提升小程序的运行性能。\n- **体积优化**：  \n  支持按需加载和代码分割，减小小程序包体积。\n\n#### **(4) 增强的开发体验**\n- **单文件组件**：  \n  支持 `.mpx` 单文件组件，将模板、脚本、样式封装在一个文件中，提升开发效率。\n- **TypeScript 支持**：  \n  提供完整的 TypeScript 支持，增强代码的可维护性和类型安全。\n- **插件系统**：  \n  支持丰富的插件生态，方便扩展功能（如状态管理、请求封装等）。\n\n#### **(5) 状态管理**\n- **Vuex 支持**：  \n  内置 Vuex 支持，方便管理全局状态。\n- **轻量级状态管理**：  \n  提供更轻量的状态管理方案，适合小型项目。\n\n---\n\n### **2. MPX 的核心架构**\n#### **(1) 编译时**\n- **模板编译**：  \n  将 `.mpx` 文件中的模板编译为小程序支持的 WXML。\n- **样式编译**：  \n  支持 Sass、Less 等预处理器，并将样式编译为小程序的 WXSS。\n- **脚本编译**：  \n  将 Vue.js 语法转换为小程序支持的 JS 代码。\n\n#### **(2) 运行时**\n- **响应式系统**：  \n  基于 Vue.js 的响应式系统，实现数据与视图的绑定。\n- **生命周期适配**：  \n  将 Vue.js 的生命周期钩子映射到小程序的生命周期中。\n\n#### **(3) 多平台适配**\n- **平台差异抹平**：  \n  通过统一的 API 和配置，抹平不同小程序平台的差异。\n- **条件编译**：  \n  支持条件编译，针对不同平台编写特定的代码逻辑。\n\n---\n\n### **3. MPX 的使用场景**\n- **多平台小程序开发**：  \n  适合需要同时发布到多个小程序平台的项目。\n- **复杂业务逻辑**：  \n  适合需要复杂状态管理和组件化开发的场景。\n- **性能敏感项目**：  \n  适合对性能要求较高的小程序项目。\n\n---\n\n### **4. MPX 的优缺点**\n#### **优点**\n- **开发效率高**：  \n  基于 Vue.js 语法，学习成本低，开发效率高。\n- **跨平台支持**：  \n  一套代码多端运行，减少重复开发。\n- **性能优化**：  \n  针对小程序性能做了深度优化。\n- **生态丰富**：  \n  支持 TypeScript、Vuex 等现代前端工具。\n\n#### **缺点**\n- **社区规模较小**：  \n  相比 Taro 和 uni-app，MPX 的社区和生态相对较小。\n- **平台兼容性**：  \n  虽然支持多平台，但在某些特定平台的兼容性上可能需要额外处理。\n\n---\n\n### **5. MPX 与其他小程序框架对比**\n| 特性                | MPX                     | Taro                   | uni-app                |\n|---------------------|-------------------------|------------------------|------------------------|\n| **语法基础**         | Vue.js                  | React                  | Vue.js                 |\n| **跨平台支持**       | 微信、支付宝、百度等     | 微信、支付宝、H5 等     | 微信、支付宝、H5、App 等 |\n| **性能优化**         | 深度优化                | 一般优化                | 一般优化                |\n| **生态丰富度**       | 中等                    | 丰富                    | 丰富                    |\n| **学习成本**         | 低（Vue.js 开发者）      | 中（React 开发者）      | 低（Vue.js 开发者）     |\n\n---\n\n### **6. 快速上手 MPX**\n#### **(1) 安装**\n```bash\nnpm install @mpxjs/cli -g\n```\n\n#### **(2) 创建项目**\n```bash\nmpx init my-project\n```\n\n#### **(3) 开发与构建**\n- 开发模式：\n  ```bash\n  npm run watch\n  ```\n- 生产构建：\n  ```bash\n  npm run build\n  ```\n\n#### **(4) 示例代码**\n```html\n<template>\n  <view class=\"container\">\n    <text>{{ message }}</text>\n    <button @tap=\"changeMessage\">点击我</button>\n  </view>\n</template>\n\n<script>\nimport { createComponent } from '@mpxjs/core'\n\ncreateComponent({\n  data: {\n    message: 'Hello MPX!'\n  },\n  methods: {\n    changeMessage() {\n      this.message = '你好，MPX！'\n    }\n  }\n})\n</script>\n\n<style lang=\"stylus\">\n.container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n}\n</style>\n```\n\n---\n\n### **总结**\nMPX 是一个专注于小程序开发的 Vue.js 风格框架，具有跨平台支持、性能优化和开发效率高等特点。它适合需要多平台发布、复杂业务逻辑和性能敏感的小程序项目。如果你已经是 Vue.js 开发者，MPX 将是一个快速上手且高效的选择。\n","source":"_posts/what-is-mpx.md","raw":"---\ntitle: what is mpx\ndate: 2025-03-15 23:04:48\ntags:\n---\nMPX 是一个 **面向小程序开发的前端框架**，由滴滴出行团队开源，专为提升小程序开发效率和性能而设计。它基于 Vue.js 的语法和特性，同时针对小程序的特点进行了深度优化和扩展。以下是 MPX 的核心特性和详细介绍：\n\n---\n\n### **1. MPX 的核心特性**\n#### **(1) 基于 Vue.js 语法**\n- **语法兼容**：  \n  MPX 支持 Vue.js 的模板语法、计算属性、侦听器、生命周期钩子等，开发者可以快速上手。\n- **响应式数据**：  \n  支持 Vue 风格的响应式数据绑定，简化状态管理。\n\n#### **(2) 多平台支持**\n- **跨平台开发**：  \n  MPX 支持将同一套代码编译到微信小程序、支付宝小程序、百度小程序、字节跳动小程序等多个平台。\n- **平台差异化处理**：  \n  提供平台特定的 API 和配置，方便处理不同平台的兼容性问题。\n\n#### **(3) 性能优化**\n- **运行时优化**：  \n  通过减少不必要的 setData 调用和优化数据更新机制，提升小程序的运行性能。\n- **体积优化**：  \n  支持按需加载和代码分割，减小小程序包体积。\n\n#### **(4) 增强的开发体验**\n- **单文件组件**：  \n  支持 `.mpx` 单文件组件，将模板、脚本、样式封装在一个文件中，提升开发效率。\n- **TypeScript 支持**：  \n  提供完整的 TypeScript 支持，增强代码的可维护性和类型安全。\n- **插件系统**：  \n  支持丰富的插件生态，方便扩展功能（如状态管理、请求封装等）。\n\n#### **(5) 状态管理**\n- **Vuex 支持**：  \n  内置 Vuex 支持，方便管理全局状态。\n- **轻量级状态管理**：  \n  提供更轻量的状态管理方案，适合小型项目。\n\n---\n\n### **2. MPX 的核心架构**\n#### **(1) 编译时**\n- **模板编译**：  \n  将 `.mpx` 文件中的模板编译为小程序支持的 WXML。\n- **样式编译**：  \n  支持 Sass、Less 等预处理器，并将样式编译为小程序的 WXSS。\n- **脚本编译**：  \n  将 Vue.js 语法转换为小程序支持的 JS 代码。\n\n#### **(2) 运行时**\n- **响应式系统**：  \n  基于 Vue.js 的响应式系统，实现数据与视图的绑定。\n- **生命周期适配**：  \n  将 Vue.js 的生命周期钩子映射到小程序的生命周期中。\n\n#### **(3) 多平台适配**\n- **平台差异抹平**：  \n  通过统一的 API 和配置，抹平不同小程序平台的差异。\n- **条件编译**：  \n  支持条件编译，针对不同平台编写特定的代码逻辑。\n\n---\n\n### **3. MPX 的使用场景**\n- **多平台小程序开发**：  \n  适合需要同时发布到多个小程序平台的项目。\n- **复杂业务逻辑**：  \n  适合需要复杂状态管理和组件化开发的场景。\n- **性能敏感项目**：  \n  适合对性能要求较高的小程序项目。\n\n---\n\n### **4. MPX 的优缺点**\n#### **优点**\n- **开发效率高**：  \n  基于 Vue.js 语法，学习成本低，开发效率高。\n- **跨平台支持**：  \n  一套代码多端运行，减少重复开发。\n- **性能优化**：  \n  针对小程序性能做了深度优化。\n- **生态丰富**：  \n  支持 TypeScript、Vuex 等现代前端工具。\n\n#### **缺点**\n- **社区规模较小**：  \n  相比 Taro 和 uni-app，MPX 的社区和生态相对较小。\n- **平台兼容性**：  \n  虽然支持多平台，但在某些特定平台的兼容性上可能需要额外处理。\n\n---\n\n### **5. MPX 与其他小程序框架对比**\n| 特性                | MPX                     | Taro                   | uni-app                |\n|---------------------|-------------------------|------------------------|------------------------|\n| **语法基础**         | Vue.js                  | React                  | Vue.js                 |\n| **跨平台支持**       | 微信、支付宝、百度等     | 微信、支付宝、H5 等     | 微信、支付宝、H5、App 等 |\n| **性能优化**         | 深度优化                | 一般优化                | 一般优化                |\n| **生态丰富度**       | 中等                    | 丰富                    | 丰富                    |\n| **学习成本**         | 低（Vue.js 开发者）      | 中（React 开发者）      | 低（Vue.js 开发者）     |\n\n---\n\n### **6. 快速上手 MPX**\n#### **(1) 安装**\n```bash\nnpm install @mpxjs/cli -g\n```\n\n#### **(2) 创建项目**\n```bash\nmpx init my-project\n```\n\n#### **(3) 开发与构建**\n- 开发模式：\n  ```bash\n  npm run watch\n  ```\n- 生产构建：\n  ```bash\n  npm run build\n  ```\n\n#### **(4) 示例代码**\n```html\n<template>\n  <view class=\"container\">\n    <text>{{ message }}</text>\n    <button @tap=\"changeMessage\">点击我</button>\n  </view>\n</template>\n\n<script>\nimport { createComponent } from '@mpxjs/core'\n\ncreateComponent({\n  data: {\n    message: 'Hello MPX!'\n  },\n  methods: {\n    changeMessage() {\n      this.message = '你好，MPX！'\n    }\n  }\n})\n</script>\n\n<style lang=\"stylus\">\n.container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n}\n</style>\n```\n\n---\n\n### **总结**\nMPX 是一个专注于小程序开发的 Vue.js 风格框架，具有跨平台支持、性能优化和开发效率高等特点。它适合需要多平台发布、复杂业务逻辑和性能敏感的小程序项目。如果你已经是 Vue.js 开发者，MPX 将是一个快速上手且高效的选择。\n","slug":"what-is-mpx","published":1,"updated":"2025-03-15T15:09:28.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a6002fgccod6bh58i0","content":"<p>MPX 是一个 <strong>面向小程序开发的前端框架</strong>，由滴滴出行团队开源，专为提升小程序开发效率和性能而设计。它基于 Vue.js 的语法和特性，同时针对小程序的特点进行了深度优化和扩展。以下是 MPX 的核心特性和详细介绍：</p>\n<hr>\n<h3 id=\"1-MPX-的核心特性\"><a href=\"#1-MPX-的核心特性\" class=\"headerlink\" title=\"1. MPX 的核心特性\"></a><strong>1. MPX 的核心特性</strong></h3><h4 id=\"1-基于-Vue-js-语法\"><a href=\"#1-基于-Vue-js-语法\" class=\"headerlink\" title=\"(1) 基于 Vue.js 语法\"></a><strong>(1) 基于 Vue.js 语法</strong></h4><ul>\n<li><strong>语法兼容</strong>：<br>MPX 支持 Vue.js 的模板语法、计算属性、侦听器、生命周期钩子等，开发者可以快速上手。</li>\n<li><strong>响应式数据</strong>：<br>支持 Vue 风格的响应式数据绑定，简化状态管理。</li>\n</ul>\n<h4 id=\"2-多平台支持\"><a href=\"#2-多平台支持\" class=\"headerlink\" title=\"(2) 多平台支持\"></a><strong>(2) 多平台支持</strong></h4><ul>\n<li><strong>跨平台开发</strong>：<br>MPX 支持将同一套代码编译到微信小程序、支付宝小程序、百度小程序、字节跳动小程序等多个平台。</li>\n<li><strong>平台差异化处理</strong>：<br>提供平台特定的 API 和配置，方便处理不同平台的兼容性问题。</li>\n</ul>\n<h4 id=\"3-性能优化\"><a href=\"#3-性能优化\" class=\"headerlink\" title=\"(3) 性能优化\"></a><strong>(3) 性能优化</strong></h4><ul>\n<li><strong>运行时优化</strong>：<br>通过减少不必要的 setData 调用和优化数据更新机制，提升小程序的运行性能。</li>\n<li><strong>体积优化</strong>：<br>支持按需加载和代码分割，减小小程序包体积。</li>\n</ul>\n<h4 id=\"4-增强的开发体验\"><a href=\"#4-增强的开发体验\" class=\"headerlink\" title=\"(4) 增强的开发体验\"></a><strong>(4) 增强的开发体验</strong></h4><ul>\n<li><strong>单文件组件</strong>：<br>支持 <code>.mpx</code> 单文件组件，将模板、脚本、样式封装在一个文件中，提升开发效率。</li>\n<li><strong>TypeScript 支持</strong>：<br>提供完整的 TypeScript 支持，增强代码的可维护性和类型安全。</li>\n<li><strong>插件系统</strong>：<br>支持丰富的插件生态，方便扩展功能（如状态管理、请求封装等）。</li>\n</ul>\n<h4 id=\"5-状态管理\"><a href=\"#5-状态管理\" class=\"headerlink\" title=\"(5) 状态管理\"></a><strong>(5) 状态管理</strong></h4><ul>\n<li><strong>Vuex 支持</strong>：<br>内置 Vuex 支持，方便管理全局状态。</li>\n<li><strong>轻量级状态管理</strong>：<br>提供更轻量的状态管理方案，适合小型项目。</li>\n</ul>\n<hr>\n<h3 id=\"2-MPX-的核心架构\"><a href=\"#2-MPX-的核心架构\" class=\"headerlink\" title=\"2. MPX 的核心架构\"></a><strong>2. MPX 的核心架构</strong></h3><h4 id=\"1-编译时\"><a href=\"#1-编译时\" class=\"headerlink\" title=\"(1) 编译时\"></a><strong>(1) 编译时</strong></h4><ul>\n<li><strong>模板编译</strong>：<br>将 <code>.mpx</code> 文件中的模板编译为小程序支持的 WXML。</li>\n<li><strong>样式编译</strong>：<br>支持 Sass、Less 等预处理器，并将样式编译为小程序的 WXSS。</li>\n<li><strong>脚本编译</strong>：<br>将 Vue.js 语法转换为小程序支持的 JS 代码。</li>\n</ul>\n<h4 id=\"2-运行时\"><a href=\"#2-运行时\" class=\"headerlink\" title=\"(2) 运行时\"></a><strong>(2) 运行时</strong></h4><ul>\n<li><strong>响应式系统</strong>：<br>基于 Vue.js 的响应式系统，实现数据与视图的绑定。</li>\n<li><strong>生命周期适配</strong>：<br>将 Vue.js 的生命周期钩子映射到小程序的生命周期中。</li>\n</ul>\n<h4 id=\"3-多平台适配\"><a href=\"#3-多平台适配\" class=\"headerlink\" title=\"(3) 多平台适配\"></a><strong>(3) 多平台适配</strong></h4><ul>\n<li><strong>平台差异抹平</strong>：<br>通过统一的 API 和配置，抹平不同小程序平台的差异。</li>\n<li><strong>条件编译</strong>：<br>支持条件编译，针对不同平台编写特定的代码逻辑。</li>\n</ul>\n<hr>\n<h3 id=\"3-MPX-的使用场景\"><a href=\"#3-MPX-的使用场景\" class=\"headerlink\" title=\"3. MPX 的使用场景\"></a><strong>3. MPX 的使用场景</strong></h3><ul>\n<li><strong>多平台小程序开发</strong>：<br>适合需要同时发布到多个小程序平台的项目。</li>\n<li><strong>复杂业务逻辑</strong>：<br>适合需要复杂状态管理和组件化开发的场景。</li>\n<li><strong>性能敏感项目</strong>：<br>适合对性能要求较高的小程序项目。</li>\n</ul>\n<hr>\n<h3 id=\"4-MPX-的优缺点\"><a href=\"#4-MPX-的优缺点\" class=\"headerlink\" title=\"4. MPX 的优缺点\"></a><strong>4. MPX 的优缺点</strong></h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a><strong>优点</strong></h4><ul>\n<li><strong>开发效率高</strong>：<br>基于 Vue.js 语法，学习成本低，开发效率高。</li>\n<li><strong>跨平台支持</strong>：<br>一套代码多端运行，减少重复开发。</li>\n<li><strong>性能优化</strong>：<br>针对小程序性能做了深度优化。</li>\n<li><strong>生态丰富</strong>：<br>支持 TypeScript、Vuex 等现代前端工具。</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a><strong>缺点</strong></h4><ul>\n<li><strong>社区规模较小</strong>：<br>相比 Taro 和 uni-app，MPX 的社区和生态相对较小。</li>\n<li><strong>平台兼容性</strong>：<br>虽然支持多平台，但在某些特定平台的兼容性上可能需要额外处理。</li>\n</ul>\n<hr>\n<h3 id=\"5-MPX-与其他小程序框架对比\"><a href=\"#5-MPX-与其他小程序框架对比\" class=\"headerlink\" title=\"5. MPX 与其他小程序框架对比\"></a><strong>5. MPX 与其他小程序框架对比</strong></h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>MPX</th>\n<th>Taro</th>\n<th>uni-app</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>语法基础</strong></td>\n<td>Vue.js</td>\n<td>React</td>\n<td>Vue.js</td>\n</tr>\n<tr>\n<td><strong>跨平台支持</strong></td>\n<td>微信、支付宝、百度等</td>\n<td>微信、支付宝、H5 等</td>\n<td>微信、支付宝、H5、App 等</td>\n</tr>\n<tr>\n<td><strong>性能优化</strong></td>\n<td>深度优化</td>\n<td>一般优化</td>\n<td>一般优化</td>\n</tr>\n<tr>\n<td><strong>生态丰富度</strong></td>\n<td>中等</td>\n<td>丰富</td>\n<td>丰富</td>\n</tr>\n<tr>\n<td><strong>学习成本</strong></td>\n<td>低（Vue.js 开发者）</td>\n<td>中（React 开发者）</td>\n<td>低（Vue.js 开发者）</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"6-快速上手-MPX\"><a href=\"#6-快速上手-MPX\" class=\"headerlink\" title=\"6. 快速上手 MPX\"></a><strong>6. 快速上手 MPX</strong></h3><h4 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"(1) 安装\"></a><strong>(1) 安装</strong></h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @mpxjs/cli -g</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-创建项目\"><a href=\"#2-创建项目\" class=\"headerlink\" title=\"(2) 创建项目\"></a><strong>(2) 创建项目</strong></h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mpx init my-project</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-开发与构建\"><a href=\"#3-开发与构建\" class=\"headerlink\" title=\"(3) 开发与构建\"></a><strong>(3) 开发与构建</strong></h4><ul>\n<li>开发模式：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run watch</span><br></pre></td></tr></table></figure></li>\n<li>生产构建：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"4-示例代码\"><a href=\"#4-示例代码\" class=\"headerlink\" title=\"(4) 示例代码\"></a><strong>(4) 示例代码</strong></h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">tap</span>=<span class=\"string\">&quot;changeMessage&quot;</span>&gt;</span>点击我<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; createComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@mpxjs/core&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"title function_\">createComponent</span>(&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">data</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello MPX!&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">methods</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">changeMessage</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"variable language_\">this</span>.<span class=\"property\">message</span> = <span class=\"string\">&#x27;你好，MPX！&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;)</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;stylus&quot;</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-class\">.container</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">display</span>: flex;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">justify-content</span>: center;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">align-items</span>: center;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">&#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>MPX 是一个专注于小程序开发的 Vue.js 风格框架，具有跨平台支持、性能优化和开发效率高等特点。它适合需要多平台发布、复杂业务逻辑和性能敏感的小程序项目。如果你已经是 Vue.js 开发者，MPX 将是一个快速上手且高效的选择。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>MPX 是一个 <strong>面向小程序开发的前端框架</strong>，由滴滴出行团队开源，专为提升小程序开发效率和性能而设计。它基于 Vue.js 的语法和特性，同时针对小程序的特点进行了深度优化和扩展。以下是 MPX 的核心特性和详细介绍：</p>\n<hr>\n<h3 id=\"1-MPX-的核心特性\"><a href=\"#1-MPX-的核心特性\" class=\"headerlink\" title=\"1. MPX 的核心特性\"></a><strong>1. MPX 的核心特性</strong></h3><h4 id=\"1-基于-Vue-js-语法\"><a href=\"#1-基于-Vue-js-语法\" class=\"headerlink\" title=\"(1) 基于 Vue.js 语法\"></a><strong>(1) 基于 Vue.js 语法</strong></h4><ul>\n<li><strong>语法兼容</strong>：<br>MPX 支持 Vue.js 的模板语法、计算属性、侦听器、生命周期钩子等，开发者可以快速上手。</li>\n<li><strong>响应式数据</strong>：<br>支持 Vue 风格的响应式数据绑定，简化状态管理。</li>\n</ul>\n<h4 id=\"2-多平台支持\"><a href=\"#2-多平台支持\" class=\"headerlink\" title=\"(2) 多平台支持\"></a><strong>(2) 多平台支持</strong></h4><ul>\n<li><strong>跨平台开发</strong>：<br>MPX 支持将同一套代码编译到微信小程序、支付宝小程序、百度小程序、字节跳动小程序等多个平台。</li>\n<li><strong>平台差异化处理</strong>：<br>提供平台特定的 API 和配置，方便处理不同平台的兼容性问题。</li>\n</ul>\n<h4 id=\"3-性能优化\"><a href=\"#3-性能优化\" class=\"headerlink\" title=\"(3) 性能优化\"></a><strong>(3) 性能优化</strong></h4><ul>\n<li><strong>运行时优化</strong>：<br>通过减少不必要的 setData 调用和优化数据更新机制，提升小程序的运行性能。</li>\n<li><strong>体积优化</strong>：<br>支持按需加载和代码分割，减小小程序包体积。</li>\n</ul>\n<h4 id=\"4-增强的开发体验\"><a href=\"#4-增强的开发体验\" class=\"headerlink\" title=\"(4) 增强的开发体验\"></a><strong>(4) 增强的开发体验</strong></h4><ul>\n<li><strong>单文件组件</strong>：<br>支持 <code>.mpx</code> 单文件组件，将模板、脚本、样式封装在一个文件中，提升开发效率。</li>\n<li><strong>TypeScript 支持</strong>：<br>提供完整的 TypeScript 支持，增强代码的可维护性和类型安全。</li>\n<li><strong>插件系统</strong>：<br>支持丰富的插件生态，方便扩展功能（如状态管理、请求封装等）。</li>\n</ul>\n<h4 id=\"5-状态管理\"><a href=\"#5-状态管理\" class=\"headerlink\" title=\"(5) 状态管理\"></a><strong>(5) 状态管理</strong></h4><ul>\n<li><strong>Vuex 支持</strong>：<br>内置 Vuex 支持，方便管理全局状态。</li>\n<li><strong>轻量级状态管理</strong>：<br>提供更轻量的状态管理方案，适合小型项目。</li>\n</ul>\n<hr>\n<h3 id=\"2-MPX-的核心架构\"><a href=\"#2-MPX-的核心架构\" class=\"headerlink\" title=\"2. MPX 的核心架构\"></a><strong>2. MPX 的核心架构</strong></h3><h4 id=\"1-编译时\"><a href=\"#1-编译时\" class=\"headerlink\" title=\"(1) 编译时\"></a><strong>(1) 编译时</strong></h4><ul>\n<li><strong>模板编译</strong>：<br>将 <code>.mpx</code> 文件中的模板编译为小程序支持的 WXML。</li>\n<li><strong>样式编译</strong>：<br>支持 Sass、Less 等预处理器，并将样式编译为小程序的 WXSS。</li>\n<li><strong>脚本编译</strong>：<br>将 Vue.js 语法转换为小程序支持的 JS 代码。</li>\n</ul>\n<h4 id=\"2-运行时\"><a href=\"#2-运行时\" class=\"headerlink\" title=\"(2) 运行时\"></a><strong>(2) 运行时</strong></h4><ul>\n<li><strong>响应式系统</strong>：<br>基于 Vue.js 的响应式系统，实现数据与视图的绑定。</li>\n<li><strong>生命周期适配</strong>：<br>将 Vue.js 的生命周期钩子映射到小程序的生命周期中。</li>\n</ul>\n<h4 id=\"3-多平台适配\"><a href=\"#3-多平台适配\" class=\"headerlink\" title=\"(3) 多平台适配\"></a><strong>(3) 多平台适配</strong></h4><ul>\n<li><strong>平台差异抹平</strong>：<br>通过统一的 API 和配置，抹平不同小程序平台的差异。</li>\n<li><strong>条件编译</strong>：<br>支持条件编译，针对不同平台编写特定的代码逻辑。</li>\n</ul>\n<hr>\n<h3 id=\"3-MPX-的使用场景\"><a href=\"#3-MPX-的使用场景\" class=\"headerlink\" title=\"3. MPX 的使用场景\"></a><strong>3. MPX 的使用场景</strong></h3><ul>\n<li><strong>多平台小程序开发</strong>：<br>适合需要同时发布到多个小程序平台的项目。</li>\n<li><strong>复杂业务逻辑</strong>：<br>适合需要复杂状态管理和组件化开发的场景。</li>\n<li><strong>性能敏感项目</strong>：<br>适合对性能要求较高的小程序项目。</li>\n</ul>\n<hr>\n<h3 id=\"4-MPX-的优缺点\"><a href=\"#4-MPX-的优缺点\" class=\"headerlink\" title=\"4. MPX 的优缺点\"></a><strong>4. MPX 的优缺点</strong></h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a><strong>优点</strong></h4><ul>\n<li><strong>开发效率高</strong>：<br>基于 Vue.js 语法，学习成本低，开发效率高。</li>\n<li><strong>跨平台支持</strong>：<br>一套代码多端运行，减少重复开发。</li>\n<li><strong>性能优化</strong>：<br>针对小程序性能做了深度优化。</li>\n<li><strong>生态丰富</strong>：<br>支持 TypeScript、Vuex 等现代前端工具。</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a><strong>缺点</strong></h4><ul>\n<li><strong>社区规模较小</strong>：<br>相比 Taro 和 uni-app，MPX 的社区和生态相对较小。</li>\n<li><strong>平台兼容性</strong>：<br>虽然支持多平台，但在某些特定平台的兼容性上可能需要额外处理。</li>\n</ul>\n<hr>\n<h3 id=\"5-MPX-与其他小程序框架对比\"><a href=\"#5-MPX-与其他小程序框架对比\" class=\"headerlink\" title=\"5. MPX 与其他小程序框架对比\"></a><strong>5. MPX 与其他小程序框架对比</strong></h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>MPX</th>\n<th>Taro</th>\n<th>uni-app</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>语法基础</strong></td>\n<td>Vue.js</td>\n<td>React</td>\n<td>Vue.js</td>\n</tr>\n<tr>\n<td><strong>跨平台支持</strong></td>\n<td>微信、支付宝、百度等</td>\n<td>微信、支付宝、H5 等</td>\n<td>微信、支付宝、H5、App 等</td>\n</tr>\n<tr>\n<td><strong>性能优化</strong></td>\n<td>深度优化</td>\n<td>一般优化</td>\n<td>一般优化</td>\n</tr>\n<tr>\n<td><strong>生态丰富度</strong></td>\n<td>中等</td>\n<td>丰富</td>\n<td>丰富</td>\n</tr>\n<tr>\n<td><strong>学习成本</strong></td>\n<td>低（Vue.js 开发者）</td>\n<td>中（React 开发者）</td>\n<td>低（Vue.js 开发者）</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"6-快速上手-MPX\"><a href=\"#6-快速上手-MPX\" class=\"headerlink\" title=\"6. 快速上手 MPX\"></a><strong>6. 快速上手 MPX</strong></h3><h4 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"(1) 安装\"></a><strong>(1) 安装</strong></h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @mpxjs/cli -g</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-创建项目\"><a href=\"#2-创建项目\" class=\"headerlink\" title=\"(2) 创建项目\"></a><strong>(2) 创建项目</strong></h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mpx init my-project</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-开发与构建\"><a href=\"#3-开发与构建\" class=\"headerlink\" title=\"(3) 开发与构建\"></a><strong>(3) 开发与构建</strong></h4><ul>\n<li>开发模式：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run watch</span><br></pre></td></tr></table></figure></li>\n<li>生产构建：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"4-示例代码\"><a href=\"#4-示例代码\" class=\"headerlink\" title=\"(4) 示例代码\"></a><strong>(4) 示例代码</strong></h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">tap</span>=<span class=\"string\">&quot;changeMessage&quot;</span>&gt;</span>点击我<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; createComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@mpxjs/core&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"title function_\">createComponent</span>(&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">data</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello MPX!&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">methods</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">changeMessage</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"variable language_\">this</span>.<span class=\"property\">message</span> = <span class=\"string\">&#x27;你好，MPX！&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;)</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;stylus&quot;</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-class\">.container</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">display</span>: flex;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">justify-content</span>: center;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">align-items</span>: center;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">&#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>MPX 是一个专注于小程序开发的 Vue.js 风格框架，具有跨平台支持、性能优化和开发效率高等特点。它适合需要多平台发布、复杂业务逻辑和性能敏感的小程序项目。如果你已经是 Vue.js 开发者，MPX 将是一个快速上手且高效的选择。</p>\n"},{"title":"使用__asan_unpoison_memory_region屏蔽某处内存检查","date":"2024-07-22T00:45:16.000Z","_content":"\n`__asan_unpoison_memory_region` 是 AddressSanitizer (ASan) 库中的一个函数。ASan 是一个用于检测内存错误的工具，主要用于 C 和 C++ 程序开发者。`__asan_unpoison_memory_region` 的作用是标记一段内存区域为“未污染”状态，这意味着这段内存可以被访问且不会触发 ASan 的错误报告。\n\n具体来说，这个函数通常用于以下场景：\n1. 在内存被分配后但未初始化之前，标记该区域为未污染，以便在初始化期间可以安全访问。\n2. 当程序知道某段内存区域将被合法访问时，预先标记该区域为未污染，以避免误报。\n\n函数原型通常如下：\n```c\nvoid __asan_unpoison_memory_region(void *addr, size_t size);\n```\n\n参数解释：\n- `addr`：内存区域的起始地址。\n- `size`：内存区域的大小（以字节为单位）。\n\n通过调用这个函数，开发者可以更精细地控制 ASan 的内存监控行为，减少误报，提高调试效率。","source":"_posts/使用-asan-unpoison-memory-region屏蔽某处内存检查.md","raw":"---\ntitle: 使用__asan_unpoison_memory_region屏蔽某处内存检查\ndate: 2024-07-22 08:45:16\ntags:\n---\n\n`__asan_unpoison_memory_region` 是 AddressSanitizer (ASan) 库中的一个函数。ASan 是一个用于检测内存错误的工具，主要用于 C 和 C++ 程序开发者。`__asan_unpoison_memory_region` 的作用是标记一段内存区域为“未污染”状态，这意味着这段内存可以被访问且不会触发 ASan 的错误报告。\n\n具体来说，这个函数通常用于以下场景：\n1. 在内存被分配后但未初始化之前，标记该区域为未污染，以便在初始化期间可以安全访问。\n2. 当程序知道某段内存区域将被合法访问时，预先标记该区域为未污染，以避免误报。\n\n函数原型通常如下：\n```c\nvoid __asan_unpoison_memory_region(void *addr, size_t size);\n```\n\n参数解释：\n- `addr`：内存区域的起始地址。\n- `size`：内存区域的大小（以字节为单位）。\n\n通过调用这个函数，开发者可以更精细地控制 ASan 的内存监控行为，减少误报，提高调试效率。","slug":"使用-asan-unpoison-memory-region屏蔽某处内存检查","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a6002ggccodkj7a2wp","content":"<p><code>__asan_unpoison_memory_region</code> 是 AddressSanitizer (ASan) 库中的一个函数。ASan 是一个用于检测内存错误的工具，主要用于 C 和 C++ 程序开发者。<code>__asan_unpoison_memory_region</code> 的作用是标记一段内存区域为“未污染”状态，这意味着这段内存可以被访问且不会触发 ASan 的错误报告。</p>\n<p>具体来说，这个函数通常用于以下场景：</p>\n<ol>\n<li>在内存被分配后但未初始化之前，标记该区域为未污染，以便在初始化期间可以安全访问。</li>\n<li>当程序知道某段内存区域将被合法访问时，预先标记该区域为未污染，以避免误报。</li>\n</ol>\n<p>函数原型通常如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __asan_unpoison_memory_region(<span class=\"type\">void</span> *addr, <span class=\"type\">size_t</span> size);</span><br></pre></td></tr></table></figure>\n\n<p>参数解释：</p>\n<ul>\n<li><code>addr</code>：内存区域的起始地址。</li>\n<li><code>size</code>：内存区域的大小（以字节为单位）。</li>\n</ul>\n<p>通过调用这个函数，开发者可以更精细地控制 ASan 的内存监控行为，减少误报，提高调试效率。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>__asan_unpoison_memory_region</code> 是 AddressSanitizer (ASan) 库中的一个函数。ASan 是一个用于检测内存错误的工具，主要用于 C 和 C++ 程序开发者。<code>__asan_unpoison_memory_region</code> 的作用是标记一段内存区域为“未污染”状态，这意味着这段内存可以被访问且不会触发 ASan 的错误报告。</p>\n<p>具体来说，这个函数通常用于以下场景：</p>\n<ol>\n<li>在内存被分配后但未初始化之前，标记该区域为未污染，以便在初始化期间可以安全访问。</li>\n<li>当程序知道某段内存区域将被合法访问时，预先标记该区域为未污染，以避免误报。</li>\n</ol>\n<p>函数原型通常如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __asan_unpoison_memory_region(<span class=\"type\">void</span> *addr, <span class=\"type\">size_t</span> size);</span><br></pre></td></tr></table></figure>\n\n<p>参数解释：</p>\n<ul>\n<li><code>addr</code>：内存区域的起始地址。</li>\n<li><code>size</code>：内存区域的大小（以字节为单位）。</li>\n</ul>\n<p>通过调用这个函数，开发者可以更精细地控制 ASan 的内存监控行为，减少误报，提高调试效率。</p>\n"},{"title":"命令行通配符","date":"2024-11-04T09:14:07.000Z","_content":"\n### 这是因为 shell 中的通配符（`*`）展开行为不同：\n\n1. `unzip *.zip`：\n- shell 会先展开 `*.zip`，如果当前目录有多个 zip 文件\n- 命令会变成 `unzip file1.zip file2.zip file3.zip`\n- 这可能导致 unzip 命令收到多个参数而报错\n\n2. `unzip \"*.zip\"`：\n- 引号阻止了 shell 展开通配符\n- 通配符会直接传递给 unzip 命令\n- unzip 命令自己处理通配符匹配\n\n### 正确的写法有几种：\n\n```bash\n# 方法1：使用引号\nunzip \"*.zip\"\n\n# 方法2：使用转义\nunzip \\*.zip\n\n# 方法3：使用循环处理多个文件\nfor zip in *.zip; do\n    unzip \"$zip\"\ndone\n\n# 方法4：使用find命令\nfind . -name \"*.zip\" -exec unzip {} \\;\n```\n\n如果需要更健壮的处理：\n\n```bash\n#!/bin/bash\n\n# 解压所有zip文件\nunzip_all() {\n    local zip_files=( *.zip )\n    \n    # 检查是否存在zip文件\n    if [ ! -e \"${zip_files[0]}\" ]; then\n        echo \"没有找到zip文件\"\n        return 1\n    }\n    \n    # 逐个解压\n    for zip in \"${zip_files[@]}\"; do\n        echo \"解压: $zip\"\n        if ! unzip \"$zip\"; then\n            echo \"解压失败: $zip\"\n            return 1\n        fi\n    done\n}\n```","source":"_posts/命令行通配符.md","raw":"---\ntitle: 命令行通配符\ndate: 2024-11-04 17:14:07\ntags:\n---\n\n### 这是因为 shell 中的通配符（`*`）展开行为不同：\n\n1. `unzip *.zip`：\n- shell 会先展开 `*.zip`，如果当前目录有多个 zip 文件\n- 命令会变成 `unzip file1.zip file2.zip file3.zip`\n- 这可能导致 unzip 命令收到多个参数而报错\n\n2. `unzip \"*.zip\"`：\n- 引号阻止了 shell 展开通配符\n- 通配符会直接传递给 unzip 命令\n- unzip 命令自己处理通配符匹配\n\n### 正确的写法有几种：\n\n```bash\n# 方法1：使用引号\nunzip \"*.zip\"\n\n# 方法2：使用转义\nunzip \\*.zip\n\n# 方法3：使用循环处理多个文件\nfor zip in *.zip; do\n    unzip \"$zip\"\ndone\n\n# 方法4：使用find命令\nfind . -name \"*.zip\" -exec unzip {} \\;\n```\n\n如果需要更健壮的处理：\n\n```bash\n#!/bin/bash\n\n# 解压所有zip文件\nunzip_all() {\n    local zip_files=( *.zip )\n    \n    # 检查是否存在zip文件\n    if [ ! -e \"${zip_files[0]}\" ]; then\n        echo \"没有找到zip文件\"\n        return 1\n    }\n    \n    # 逐个解压\n    for zip in \"${zip_files[@]}\"; do\n        echo \"解压: $zip\"\n        if ! unzip \"$zip\"; then\n            echo \"解压失败: $zip\"\n            return 1\n        fi\n    done\n}\n```","slug":"命令行通配符","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a7002hgcco9wz90cec","content":"<h3 id=\"这是因为-shell-中的通配符（-）展开行为不同：\"><a href=\"#这是因为-shell-中的通配符（-）展开行为不同：\" class=\"headerlink\" title=\"这是因为 shell 中的通配符（*）展开行为不同：\"></a>这是因为 shell 中的通配符（<code>*</code>）展开行为不同：</h3><ol>\n<li><code>unzip *.zip</code>：</li>\n</ol>\n<ul>\n<li>shell 会先展开 <code>*.zip</code>，如果当前目录有多个 zip 文件</li>\n<li>命令会变成 <code>unzip file1.zip file2.zip file3.zip</code></li>\n<li>这可能导致 unzip 命令收到多个参数而报错</li>\n</ul>\n<ol start=\"2\">\n<li><code>unzip &quot;*.zip&quot;</code>：</li>\n</ol>\n<ul>\n<li>引号阻止了 shell 展开通配符</li>\n<li>通配符会直接传递给 unzip 命令</li>\n<li>unzip 命令自己处理通配符匹配</li>\n</ul>\n<h3 id=\"正确的写法有几种：\"><a href=\"#正确的写法有几种：\" class=\"headerlink\" title=\"正确的写法有几种：\"></a>正确的写法有几种：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方法1：使用引号</span></span><br><span class=\"line\">unzip <span class=\"string\">&quot;*.zip&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法2：使用转义</span></span><br><span class=\"line\">unzip \\*.zip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法3：使用循环处理多个文件</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> zip <span class=\"keyword\">in</span> *.zip; <span class=\"keyword\">do</span></span><br><span class=\"line\">    unzip <span class=\"string\">&quot;<span class=\"variable\">$zip</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法4：使用find命令</span></span><br><span class=\"line\">find . -name <span class=\"string\">&quot;*.zip&quot;</span> -<span class=\"built_in\">exec</span> unzip &#123;&#125; \\;</span><br></pre></td></tr></table></figure>\n\n<p>如果需要更健壮的处理：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压所有zip文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip_all</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">local</span> zip_files=( *.zip )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 检查是否存在zip文件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ ! -e <span class=\"string\">&quot;<span class=\"variable\">$&#123;zip_files[0]&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;没有找到zip文件&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">return</span> 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 逐个解压</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> zip <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;zip_files[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;解压: <span class=\"variable\">$zip</span>&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ! unzip <span class=\"string\">&quot;<span class=\"variable\">$zip</span>&quot;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;解压失败: <span class=\"variable\">$zip</span>&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> 1</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"这是因为-shell-中的通配符（-）展开行为不同：\"><a href=\"#这是因为-shell-中的通配符（-）展开行为不同：\" class=\"headerlink\" title=\"这是因为 shell 中的通配符（*）展开行为不同：\"></a>这是因为 shell 中的通配符（<code>*</code>）展开行为不同：</h3><ol>\n<li><code>unzip *.zip</code>：</li>\n</ol>\n<ul>\n<li>shell 会先展开 <code>*.zip</code>，如果当前目录有多个 zip 文件</li>\n<li>命令会变成 <code>unzip file1.zip file2.zip file3.zip</code></li>\n<li>这可能导致 unzip 命令收到多个参数而报错</li>\n</ul>\n<ol start=\"2\">\n<li><code>unzip &quot;*.zip&quot;</code>：</li>\n</ol>\n<ul>\n<li>引号阻止了 shell 展开通配符</li>\n<li>通配符会直接传递给 unzip 命令</li>\n<li>unzip 命令自己处理通配符匹配</li>\n</ul>\n<h3 id=\"正确的写法有几种：\"><a href=\"#正确的写法有几种：\" class=\"headerlink\" title=\"正确的写法有几种：\"></a>正确的写法有几种：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方法1：使用引号</span></span><br><span class=\"line\">unzip <span class=\"string\">&quot;*.zip&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法2：使用转义</span></span><br><span class=\"line\">unzip \\*.zip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法3：使用循环处理多个文件</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> zip <span class=\"keyword\">in</span> *.zip; <span class=\"keyword\">do</span></span><br><span class=\"line\">    unzip <span class=\"string\">&quot;<span class=\"variable\">$zip</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法4：使用find命令</span></span><br><span class=\"line\">find . -name <span class=\"string\">&quot;*.zip&quot;</span> -<span class=\"built_in\">exec</span> unzip &#123;&#125; \\;</span><br></pre></td></tr></table></figure>\n\n<p>如果需要更健壮的处理：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压所有zip文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip_all</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">local</span> zip_files=( *.zip )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 检查是否存在zip文件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ ! -e <span class=\"string\">&quot;<span class=\"variable\">$&#123;zip_files[0]&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;没有找到zip文件&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">return</span> 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 逐个解压</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> zip <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;zip_files[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;解压: <span class=\"variable\">$zip</span>&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ! unzip <span class=\"string\">&quot;<span class=\"variable\">$zip</span>&quot;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;解压失败: <span class=\"variable\">$zip</span>&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> 1</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵","date":"2024-07-30T04:26:12.000Z","_content":"\n要从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵，您需要对原矩阵进行一些操作。原矩阵通常是一个3x3或4x4的矩阵。\n\n### 对于3x3矩阵：\n原3x3矩阵的形式如下：\n```\n| a  b  tx |\n| c  d  ty |\n| 0  0  1  |\n```\n\n步骤：\n1. 提取旋转部分（左上2x2子矩阵）：\n```\n| a  b |\n| c  d |\n```\n\n2. 计算缩放因子（可以使用行向量的范数或列向量的范数）：\n```\ns = sqrt(a^2 + c^2) = sqrt(b^2 + d^2)\n```\n\n3. 将旋转部分归一化：\n```\n| a/s  b/s |\n| c/s  d/s |\n```\n\n4. 构建新的3x3矩阵，包含平移分量：\n```\n| a/s  b/s  tx |\n| c/s  d/s  ty |\n|  0    0    1 |\n```\n\n### 对于4x4矩阵：\n原4x4矩阵的形式如下：\n```\n| a  b  c  tx |\n| d  e  f  ty |\n| g  h  i  tz |\n| 0  0  0   1 |\n```\n\n步骤：\n1. 提取旋转部分（左上3x3子矩阵）：\n```\n| a  b  c |\n| d  e  f |\n| g  h  i |\n```\n\n2. 计算缩放因子（可以使用行向量的范数或列向量的范数）：\n```\nsx = sqrt(a^2 + d^2 + g^2)\nsy = sqrt(b^2 + e^2 + h^2)\nsz = sqrt(c^2 + f^2 + i^2)\n```\n\n3. 将旋转部分归一化：\n```\n| a/sx  b/sy  c/sz |\n| d/sx  e/sy  f/sz |\n| g/sx  h/sy  i/sz |\n```\n\n4. 构建新的4x4矩阵，包含平移分量：\n```\n| a/sx  b/sy  c/sz  tx |\n| d/sx  e/sy  f/sz  ty |\n| g/sx  h/sy  i/sz  tz |\n|  0     0     0    1  |\n```\n\n这些步骤可以帮助您从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵。\n","source":"_posts/从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵.md","raw":"---\ntitle: 从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵\ndate: 2024-07-30 12:26:12\ntags:\n---\n\n要从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵，您需要对原矩阵进行一些操作。原矩阵通常是一个3x3或4x4的矩阵。\n\n### 对于3x3矩阵：\n原3x3矩阵的形式如下：\n```\n| a  b  tx |\n| c  d  ty |\n| 0  0  1  |\n```\n\n步骤：\n1. 提取旋转部分（左上2x2子矩阵）：\n```\n| a  b |\n| c  d |\n```\n\n2. 计算缩放因子（可以使用行向量的范数或列向量的范数）：\n```\ns = sqrt(a^2 + c^2) = sqrt(b^2 + d^2)\n```\n\n3. 将旋转部分归一化：\n```\n| a/s  b/s |\n| c/s  d/s |\n```\n\n4. 构建新的3x3矩阵，包含平移分量：\n```\n| a/s  b/s  tx |\n| c/s  d/s  ty |\n|  0    0    1 |\n```\n\n### 对于4x4矩阵：\n原4x4矩阵的形式如下：\n```\n| a  b  c  tx |\n| d  e  f  ty |\n| g  h  i  tz |\n| 0  0  0   1 |\n```\n\n步骤：\n1. 提取旋转部分（左上3x3子矩阵）：\n```\n| a  b  c |\n| d  e  f |\n| g  h  i |\n```\n\n2. 计算缩放因子（可以使用行向量的范数或列向量的范数）：\n```\nsx = sqrt(a^2 + d^2 + g^2)\nsy = sqrt(b^2 + e^2 + h^2)\nsz = sqrt(c^2 + f^2 + i^2)\n```\n\n3. 将旋转部分归一化：\n```\n| a/sx  b/sy  c/sz |\n| d/sx  e/sy  f/sz |\n| g/sx  h/sy  i/sz |\n```\n\n4. 构建新的4x4矩阵，包含平移分量：\n```\n| a/sx  b/sy  c/sz  tx |\n| d/sx  e/sy  f/sz  ty |\n| g/sx  h/sy  i/sz  tz |\n|  0     0     0    1  |\n```\n\n这些步骤可以帮助您从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵。\n","slug":"从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a7002igcco4c5zaovg","content":"<p>要从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵，您需要对原矩阵进行一些操作。原矩阵通常是一个3x3或4x4的矩阵。</p>\n<h3 id=\"对于3x3矩阵：\"><a href=\"#对于3x3矩阵：\" class=\"headerlink\" title=\"对于3x3矩阵：\"></a>对于3x3矩阵：</h3><p>原3x3矩阵的形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b  tx |</span><br><span class=\"line\">| c  d  ty |</span><br><span class=\"line\">| 0  0  1  |</span><br></pre></td></tr></table></figure>\n\n<p>步骤：</p>\n<ol>\n<li><p>提取旋转部分（左上2x2子矩阵）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b |</span><br><span class=\"line\">| c  d |</span><br></pre></td></tr></table></figure></li>\n<li><p>计算缩放因子（可以使用行向量的范数或列向量的范数）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = sqrt(a^2 + c^2) = sqrt(b^2 + d^2)</span><br></pre></td></tr></table></figure></li>\n<li><p>将旋转部分归一化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/s  b/s |</span><br><span class=\"line\">| c/s  d/s |</span><br></pre></td></tr></table></figure></li>\n<li><p>构建新的3x3矩阵，包含平移分量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/s  b/s  tx |</span><br><span class=\"line\">| c/s  d/s  ty |</span><br><span class=\"line\">|  0    0    1 |</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"对于4x4矩阵：\"><a href=\"#对于4x4矩阵：\" class=\"headerlink\" title=\"对于4x4矩阵：\"></a>对于4x4矩阵：</h3><p>原4x4矩阵的形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b  c  tx |</span><br><span class=\"line\">| d  e  f  ty |</span><br><span class=\"line\">| g  h  i  tz |</span><br><span class=\"line\">| 0  0  0   1 |</span><br></pre></td></tr></table></figure>\n\n<p>步骤：</p>\n<ol>\n<li><p>提取旋转部分（左上3x3子矩阵）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b  c |</span><br><span class=\"line\">| d  e  f |</span><br><span class=\"line\">| g  h  i |</span><br></pre></td></tr></table></figure></li>\n<li><p>计算缩放因子（可以使用行向量的范数或列向量的范数）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sx = sqrt(a^2 + d^2 + g^2)</span><br><span class=\"line\">sy = sqrt(b^2 + e^2 + h^2)</span><br><span class=\"line\">sz = sqrt(c^2 + f^2 + i^2)</span><br></pre></td></tr></table></figure></li>\n<li><p>将旋转部分归一化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/sx  b/sy  c/sz |</span><br><span class=\"line\">| d/sx  e/sy  f/sz |</span><br><span class=\"line\">| g/sx  h/sy  i/sz |</span><br></pre></td></tr></table></figure></li>\n<li><p>构建新的4x4矩阵，包含平移分量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/sx  b/sy  c/sz  tx |</span><br><span class=\"line\">| d/sx  e/sy  f/sz  ty |</span><br><span class=\"line\">| g/sx  h/sy  i/sz  tz |</span><br><span class=\"line\">|  0     0     0    1  |</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>这些步骤可以帮助您从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>要从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵，您需要对原矩阵进行一些操作。原矩阵通常是一个3x3或4x4的矩阵。</p>\n<h3 id=\"对于3x3矩阵：\"><a href=\"#对于3x3矩阵：\" class=\"headerlink\" title=\"对于3x3矩阵：\"></a>对于3x3矩阵：</h3><p>原3x3矩阵的形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b  tx |</span><br><span class=\"line\">| c  d  ty |</span><br><span class=\"line\">| 0  0  1  |</span><br></pre></td></tr></table></figure>\n\n<p>步骤：</p>\n<ol>\n<li><p>提取旋转部分（左上2x2子矩阵）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b |</span><br><span class=\"line\">| c  d |</span><br></pre></td></tr></table></figure></li>\n<li><p>计算缩放因子（可以使用行向量的范数或列向量的范数）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = sqrt(a^2 + c^2) = sqrt(b^2 + d^2)</span><br></pre></td></tr></table></figure></li>\n<li><p>将旋转部分归一化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/s  b/s |</span><br><span class=\"line\">| c/s  d/s |</span><br></pre></td></tr></table></figure></li>\n<li><p>构建新的3x3矩阵，包含平移分量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/s  b/s  tx |</span><br><span class=\"line\">| c/s  d/s  ty |</span><br><span class=\"line\">|  0    0    1 |</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"对于4x4矩阵：\"><a href=\"#对于4x4矩阵：\" class=\"headerlink\" title=\"对于4x4矩阵：\"></a>对于4x4矩阵：</h3><p>原4x4矩阵的形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b  c  tx |</span><br><span class=\"line\">| d  e  f  ty |</span><br><span class=\"line\">| g  h  i  tz |</span><br><span class=\"line\">| 0  0  0   1 |</span><br></pre></td></tr></table></figure>\n\n<p>步骤：</p>\n<ol>\n<li><p>提取旋转部分（左上3x3子矩阵）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b  c |</span><br><span class=\"line\">| d  e  f |</span><br><span class=\"line\">| g  h  i |</span><br></pre></td></tr></table></figure></li>\n<li><p>计算缩放因子（可以使用行向量的范数或列向量的范数）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sx = sqrt(a^2 + d^2 + g^2)</span><br><span class=\"line\">sy = sqrt(b^2 + e^2 + h^2)</span><br><span class=\"line\">sz = sqrt(c^2 + f^2 + i^2)</span><br></pre></td></tr></table></figure></li>\n<li><p>将旋转部分归一化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/sx  b/sy  c/sz |</span><br><span class=\"line\">| d/sx  e/sy  f/sz |</span><br><span class=\"line\">| g/sx  h/sy  i/sz |</span><br></pre></td></tr></table></figure></li>\n<li><p>构建新的4x4矩阵，包含平移分量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/sx  b/sy  c/sz  tx |</span><br><span class=\"line\">| d/sx  e/sy  f/sz  ty |</span><br><span class=\"line\">| g/sx  h/sy  i/sz  tz |</span><br><span class=\"line\">|  0     0     0    1  |</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>这些步骤可以帮助您从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵。</p>\n"},{"title":"分支预测","date":"2024-09-27T01:25:37.000Z","_content":"\n1. 宏定义解释\n```cpp\n#define likely(x) __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n```\n\n* likely(x):\n这个宏用于表示某个条件 x 是“可能为真”的。它的作用是告诉编译器，x 很可能为真（即返回值为 1）。\n__builtin_expect(!!(x), 1) 的作用是将 x 的值转换为布尔值（0 或 1），并告诉编译器这个值很可能是 1。\n* unlikely(x):\n这个宏用于表示某个条件 x 是“可能为假”的。它的作用是告诉编译器，x 很可能为假（即返回值为 0）。\n__builtin_expect(!!(x), 0) 的作用是将 x 的值转换为布尔值，并告诉编译器这个值很可能是 0。\n\n2. 使用场景\n这些宏通常用于条件语句中，以优化分支预测。例如：\n\n```cpp\nif (likely(condition)) {\n    // 处理条件为真的情况\n} else {\n    // 处理条件为假的情况\n}\n```\n\n在这个例子中，使用 likely 可以帮助编译器优化代码生成，使得在条件为真的情况下，相关的代码路径更快。\n\n3. 优化原理\n分支预测：现代 CPU 通常具有分支预测机制，能够根据历史执行路径预测条件语句的结果。通过使用 likely 和 unlikely，开发者可以显式地告诉编译器和 CPU 哪个分支更可能被执行，从而提高预测的准确性。\n性能提升：在性能敏感的代码中，减少错误的分支预测可以显著提高执行效率，尤其是在循环和频繁调用的函数中。\n\n4. 注意事项\n可读性：虽然使用这些宏可以提高性能，但过度使用可能会影响代码的可读性。应在性能关键的部分使用，而不是在所有条件判断中使用。\n编译器支持：__builtin_expect 是 GCC 和 Clang 的扩展，其他编译器可能不支持此功能。在使用时需要确保代码的可移植性。\n总结\nlikely 和 unlikely 宏通过利用 __builtin_expect 提供了对条件分支的预测信息，帮助编译器生成更高效的代码。它们在性能敏感的应用中非常有用，尤其是在需要优化分支预测的场景中","source":"_posts/分支预测.md","raw":"---\ntitle: 分支预测\ndate: 2024-09-27 09:25:37\ntags:\n---\n\n1. 宏定义解释\n```cpp\n#define likely(x) __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n```\n\n* likely(x):\n这个宏用于表示某个条件 x 是“可能为真”的。它的作用是告诉编译器，x 很可能为真（即返回值为 1）。\n__builtin_expect(!!(x), 1) 的作用是将 x 的值转换为布尔值（0 或 1），并告诉编译器这个值很可能是 1。\n* unlikely(x):\n这个宏用于表示某个条件 x 是“可能为假”的。它的作用是告诉编译器，x 很可能为假（即返回值为 0）。\n__builtin_expect(!!(x), 0) 的作用是将 x 的值转换为布尔值，并告诉编译器这个值很可能是 0。\n\n2. 使用场景\n这些宏通常用于条件语句中，以优化分支预测。例如：\n\n```cpp\nif (likely(condition)) {\n    // 处理条件为真的情况\n} else {\n    // 处理条件为假的情况\n}\n```\n\n在这个例子中，使用 likely 可以帮助编译器优化代码生成，使得在条件为真的情况下，相关的代码路径更快。\n\n3. 优化原理\n分支预测：现代 CPU 通常具有分支预测机制，能够根据历史执行路径预测条件语句的结果。通过使用 likely 和 unlikely，开发者可以显式地告诉编译器和 CPU 哪个分支更可能被执行，从而提高预测的准确性。\n性能提升：在性能敏感的代码中，减少错误的分支预测可以显著提高执行效率，尤其是在循环和频繁调用的函数中。\n\n4. 注意事项\n可读性：虽然使用这些宏可以提高性能，但过度使用可能会影响代码的可读性。应在性能关键的部分使用，而不是在所有条件判断中使用。\n编译器支持：__builtin_expect 是 GCC 和 Clang 的扩展，其他编译器可能不支持此功能。在使用时需要确保代码的可移植性。\n总结\nlikely 和 unlikely 宏通过利用 __builtin_expect 提供了对条件分支的预测信息，帮助编译器生成更高效的代码。它们在性能敏感的应用中非常有用，尤其是在需要优化分支预测的场景中","slug":"分支预测","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a7002jgccoel6x3sjz","content":"<ol>\n<li>宏定义解释<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>likely(x):<br>这个宏用于表示某个条件 x 是“可能为真”的。它的作用是告诉编译器，x 很可能为真（即返回值为 1）。<br>__builtin_expect(!!(x), 1) 的作用是将 x 的值转换为布尔值（0 或 1），并告诉编译器这个值很可能是 1。</li>\n<li>unlikely(x):<br>这个宏用于表示某个条件 x 是“可能为假”的。它的作用是告诉编译器，x 很可能为假（即返回值为 0）。<br>__builtin_expect(!!(x), 0) 的作用是将 x 的值转换为布尔值，并告诉编译器这个值很可能是 0。</li>\n</ul>\n<ol start=\"2\">\n<li>使用场景<br>这些宏通常用于条件语句中，以优化分支预测。例如：</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">likely</span>(condition)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理条件为真的情况</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理条件为假的情况</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，使用 likely 可以帮助编译器优化代码生成，使得在条件为真的情况下，相关的代码路径更快。</p>\n<ol start=\"3\">\n<li><p>优化原理<br>分支预测：现代 CPU 通常具有分支预测机制，能够根据历史执行路径预测条件语句的结果。通过使用 likely 和 unlikely，开发者可以显式地告诉编译器和 CPU 哪个分支更可能被执行，从而提高预测的准确性。<br>性能提升：在性能敏感的代码中，减少错误的分支预测可以显著提高执行效率，尤其是在循环和频繁调用的函数中。</p>\n</li>\n<li><p>注意事项<br>可读性：虽然使用这些宏可以提高性能，但过度使用可能会影响代码的可读性。应在性能关键的部分使用，而不是在所有条件判断中使用。<br>编译器支持：__builtin_expect 是 GCC 和 Clang 的扩展，其他编译器可能不支持此功能。在使用时需要确保代码的可移植性。<br>总结<br>likely 和 unlikely 宏通过利用 __builtin_expect 提供了对条件分支的预测信息，帮助编译器生成更高效的代码。它们在性能敏感的应用中非常有用，尤其是在需要优化分支预测的场景中</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>宏定义解释<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>likely(x):<br>这个宏用于表示某个条件 x 是“可能为真”的。它的作用是告诉编译器，x 很可能为真（即返回值为 1）。<br>__builtin_expect(!!(x), 1) 的作用是将 x 的值转换为布尔值（0 或 1），并告诉编译器这个值很可能是 1。</li>\n<li>unlikely(x):<br>这个宏用于表示某个条件 x 是“可能为假”的。它的作用是告诉编译器，x 很可能为假（即返回值为 0）。<br>__builtin_expect(!!(x), 0) 的作用是将 x 的值转换为布尔值，并告诉编译器这个值很可能是 0。</li>\n</ul>\n<ol start=\"2\">\n<li>使用场景<br>这些宏通常用于条件语句中，以优化分支预测。例如：</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">likely</span>(condition)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理条件为真的情况</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理条件为假的情况</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，使用 likely 可以帮助编译器优化代码生成，使得在条件为真的情况下，相关的代码路径更快。</p>\n<ol start=\"3\">\n<li><p>优化原理<br>分支预测：现代 CPU 通常具有分支预测机制，能够根据历史执行路径预测条件语句的结果。通过使用 likely 和 unlikely，开发者可以显式地告诉编译器和 CPU 哪个分支更可能被执行，从而提高预测的准确性。<br>性能提升：在性能敏感的代码中，减少错误的分支预测可以显著提高执行效率，尤其是在循环和频繁调用的函数中。</p>\n</li>\n<li><p>注意事项<br>可读性：虽然使用这些宏可以提高性能，但过度使用可能会影响代码的可读性。应在性能关键的部分使用，而不是在所有条件判断中使用。<br>编译器支持：__builtin_expect 是 GCC 和 Clang 的扩展，其他编译器可能不支持此功能。在使用时需要确保代码的可移植性。<br>总结<br>likely 和 unlikely 宏通过利用 __builtin_expect 提供了对条件分支的预测信息，帮助编译器生成更高效的代码。它们在性能敏感的应用中非常有用，尤其是在需要优化分支预测的场景中</p>\n</li>\n</ol>\n"},{"title":"模板规则推导","date":"2023-12-21T05:56:09.000Z","_content":"\n### 模板推导规则\n\n```\ntemplate<typename T>\nvoid passByRefFun(T& val) { }\n\ntemplate<typename T>\nvoid passByUniRefFun(T&& val) { }\n\ntemplate<typename T>\nvoid passByValueFun(T val) { }\n\nvoid fun3(int& a) { }\nvoid fun3(int&& a) { }\n\nvoid test()\n{\n    int a = 0;          //a int\n    const int b = a;    //b const int\n    const int& c = a;   //c const int&\n    \n    passByRefFun(a);    // int&\n    passByRefFun(b);    // const int&\n    passByRefFun(c);    // const int&\n    //passByRefFun(27);   // 报错\n    \n    passByUniRefFun(a); // int&\n    passByUniRefFun(b); // const int&\n    passByUniRefFun(c); // const int&\n    passByUniRefFun(27); // int&&\n    \n    passByValueFun(a);  // int\n    passByValueFun(b);  // int\n    passByValueFun(c);  // int\n    passByValueFun(27); // int\n    \n    {\n        int&& a = 10;\n        fun3(a);            // called void fun3(int& a)\n        fun3(std::move(a)); // called void fun3(int&& a)\n        \n    }\n}\n```\n\n\n### SFINAE\nSFINAE（Substitution Failure Is Not An Error）是 C++ 中的一个重要概念，主要用于模板编程。它的意思是，当模板参数替换导致错误时，编译器不会将其视为错误，而是会继续查找其他可能的匹配。这使得我们可以在模板中进行条件编译，选择合适的重载或特化\n\nSFINAE 的优势\n条件编译：可以根据类型特征选择不同的实现，增强代码的灵活性和可重用性。\n避免编译错误：当模板参数替换导致错误时，编译器不会将其视为错误，而是继续查找其他匹配的模板。\n类型安全：通过类型特征，可以确保只有符合条件的类型才能使用特定的模板实现。\n\n\nSFINAE 是 C++ 模板编程中的一个强大工具，允许开发者根据类型特征选择合适的模板特化或重载。通过结合 std::enable_if 和类型特征，开发者可以编写更灵活和安全的代码。","source":"_posts/模板规则推导.md","raw":"---\ntitle: 模板规则推导\ndate: 2023-12-21 13:56:09\ntags:\n---\n\n### 模板推导规则\n\n```\ntemplate<typename T>\nvoid passByRefFun(T& val) { }\n\ntemplate<typename T>\nvoid passByUniRefFun(T&& val) { }\n\ntemplate<typename T>\nvoid passByValueFun(T val) { }\n\nvoid fun3(int& a) { }\nvoid fun3(int&& a) { }\n\nvoid test()\n{\n    int a = 0;          //a int\n    const int b = a;    //b const int\n    const int& c = a;   //c const int&\n    \n    passByRefFun(a);    // int&\n    passByRefFun(b);    // const int&\n    passByRefFun(c);    // const int&\n    //passByRefFun(27);   // 报错\n    \n    passByUniRefFun(a); // int&\n    passByUniRefFun(b); // const int&\n    passByUniRefFun(c); // const int&\n    passByUniRefFun(27); // int&&\n    \n    passByValueFun(a);  // int\n    passByValueFun(b);  // int\n    passByValueFun(c);  // int\n    passByValueFun(27); // int\n    \n    {\n        int&& a = 10;\n        fun3(a);            // called void fun3(int& a)\n        fun3(std::move(a)); // called void fun3(int&& a)\n        \n    }\n}\n```\n\n\n### SFINAE\nSFINAE（Substitution Failure Is Not An Error）是 C++ 中的一个重要概念，主要用于模板编程。它的意思是，当模板参数替换导致错误时，编译器不会将其视为错误，而是会继续查找其他可能的匹配。这使得我们可以在模板中进行条件编译，选择合适的重载或特化\n\nSFINAE 的优势\n条件编译：可以根据类型特征选择不同的实现，增强代码的灵活性和可重用性。\n避免编译错误：当模板参数替换导致错误时，编译器不会将其视为错误，而是继续查找其他匹配的模板。\n类型安全：通过类型特征，可以确保只有符合条件的类型才能使用特定的模板实现。\n\n\nSFINAE 是 C++ 模板编程中的一个强大工具，允许开发者根据类型特征选择合适的模板特化或重载。通过结合 std::enable_if 和类型特征，开发者可以编写更灵活和安全的代码。","slug":"模板规则推导","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a7002kgccocp7225j1","content":"<h3 id=\"模板推导规则\"><a href=\"#模板推导规则\" class=\"headerlink\" title=\"模板推导规则\"></a>模板推导规则</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void passByRefFun(T&amp; val) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void passByUniRefFun(T&amp;&amp; val) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void passByValueFun(T val) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void fun3(int&amp; a) &#123; &#125;</span><br><span class=\"line\">void fun3(int&amp;&amp; a) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void test()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a = 0;          //a int</span><br><span class=\"line\">    const int b = a;    //b const int</span><br><span class=\"line\">    const int&amp; c = a;   //c const int&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    passByRefFun(a);    // int&amp;</span><br><span class=\"line\">    passByRefFun(b);    // const int&amp;</span><br><span class=\"line\">    passByRefFun(c);    // const int&amp;</span><br><span class=\"line\">    //passByRefFun(27);   // 报错</span><br><span class=\"line\">    </span><br><span class=\"line\">    passByUniRefFun(a); // int&amp;</span><br><span class=\"line\">    passByUniRefFun(b); // const int&amp;</span><br><span class=\"line\">    passByUniRefFun(c); // const int&amp;</span><br><span class=\"line\">    passByUniRefFun(27); // int&amp;&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    passByValueFun(a);  // int</span><br><span class=\"line\">    passByValueFun(b);  // int</span><br><span class=\"line\">    passByValueFun(c);  // int</span><br><span class=\"line\">    passByValueFun(27); // int</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int&amp;&amp; a = 10;</span><br><span class=\"line\">        fun3(a);            // called void fun3(int&amp; a)</span><br><span class=\"line\">        fun3(std::move(a)); // called void fun3(int&amp;&amp; a)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"SFINAE\"><a href=\"#SFINAE\" class=\"headerlink\" title=\"SFINAE\"></a>SFINAE</h3><p>SFINAE（Substitution Failure Is Not An Error）是 C++ 中的一个重要概念，主要用于模板编程。它的意思是，当模板参数替换导致错误时，编译器不会将其视为错误，而是会继续查找其他可能的匹配。这使得我们可以在模板中进行条件编译，选择合适的重载或特化</p>\n<p>SFINAE 的优势<br>条件编译：可以根据类型特征选择不同的实现，增强代码的灵活性和可重用性。<br>避免编译错误：当模板参数替换导致错误时，编译器不会将其视为错误，而是继续查找其他匹配的模板。<br>类型安全：通过类型特征，可以确保只有符合条件的类型才能使用特定的模板实现。</p>\n<p>SFINAE 是 C++ 模板编程中的一个强大工具，允许开发者根据类型特征选择合适的模板特化或重载。通过结合 std::enable_if 和类型特征，开发者可以编写更灵活和安全的代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"模板推导规则\"><a href=\"#模板推导规则\" class=\"headerlink\" title=\"模板推导规则\"></a>模板推导规则</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void passByRefFun(T&amp; val) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void passByUniRefFun(T&amp;&amp; val) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void passByValueFun(T val) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void fun3(int&amp; a) &#123; &#125;</span><br><span class=\"line\">void fun3(int&amp;&amp; a) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void test()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a = 0;          //a int</span><br><span class=\"line\">    const int b = a;    //b const int</span><br><span class=\"line\">    const int&amp; c = a;   //c const int&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    passByRefFun(a);    // int&amp;</span><br><span class=\"line\">    passByRefFun(b);    // const int&amp;</span><br><span class=\"line\">    passByRefFun(c);    // const int&amp;</span><br><span class=\"line\">    //passByRefFun(27);   // 报错</span><br><span class=\"line\">    </span><br><span class=\"line\">    passByUniRefFun(a); // int&amp;</span><br><span class=\"line\">    passByUniRefFun(b); // const int&amp;</span><br><span class=\"line\">    passByUniRefFun(c); // const int&amp;</span><br><span class=\"line\">    passByUniRefFun(27); // int&amp;&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    passByValueFun(a);  // int</span><br><span class=\"line\">    passByValueFun(b);  // int</span><br><span class=\"line\">    passByValueFun(c);  // int</span><br><span class=\"line\">    passByValueFun(27); // int</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int&amp;&amp; a = 10;</span><br><span class=\"line\">        fun3(a);            // called void fun3(int&amp; a)</span><br><span class=\"line\">        fun3(std::move(a)); // called void fun3(int&amp;&amp; a)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"SFINAE\"><a href=\"#SFINAE\" class=\"headerlink\" title=\"SFINAE\"></a>SFINAE</h3><p>SFINAE（Substitution Failure Is Not An Error）是 C++ 中的一个重要概念，主要用于模板编程。它的意思是，当模板参数替换导致错误时，编译器不会将其视为错误，而是会继续查找其他可能的匹配。这使得我们可以在模板中进行条件编译，选择合适的重载或特化</p>\n<p>SFINAE 的优势<br>条件编译：可以根据类型特征选择不同的实现，增强代码的灵活性和可重用性。<br>避免编译错误：当模板参数替换导致错误时，编译器不会将其视为错误，而是继续查找其他匹配的模板。<br>类型安全：通过类型特征，可以确保只有符合条件的类型才能使用特定的模板实现。</p>\n<p>SFINAE 是 C++ 模板编程中的一个强大工具，允许开发者根据类型特征选择合适的模板特化或重载。通过结合 std::enable_if 和类型特征，开发者可以编写更灵活和安全的代码。</p>\n"},{"title":"电子书目录","date":"2022-12-25T15:36:30.000Z","_content":"\n## 渲染整理\n\n\n#### 开放世界的场景管理\n\t1. 切成tile\n\t2. 数据分级LOD\n\t3. 根据天顶角，调整远平面，裁剪数据\n\n#### 游戏引擎分层架构\n\t1. EditorLayer\n\t2. FuntionLayer\n\t\t1. Rendering\n\t\t2. Animation\n\t\t3. Camera\n\t\t4. Physics\n\t\t5. Script\n\t3. ResourceLayer\n\t4. CoreLayer\n\t\t1. threadPoolManagement\n\t\t2. memoryPool\n\t\t3. mathLibrary\n\t5. PlatformLayer\n\t\t1. RHI\n\n#### Renderable\n\t1. shader\n\t\t1. vs,fs\n\t\t2. macro\n\t2. RenderState\n\t3. MVP \n\t4. Texture\n\t5. DrawImp\n\n#### 渲染效果\n\t1. 前向渲染\n  \t\t1. PBR\n  \t\t2. 布林冯模型\n\t2. 阴影shadowMap：\n\t\t1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性\n\t\t2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度\n\t3. 楼的倒影\n\t\t1. 矩阵楼块插入地面\n\t\t2. 模板测试，只有地面和水才绘制\n\t4. AO\n\t5. 聚光灯效果\n\t6. UV动画\n\n#### 技术点提炼\n\t1. 楼块\n\t\t1. 切成小块\n\t\t2. 柔化圆角\n\t\t3. 贴UV\n\t2. 3d瓦片绘制\n\t\t1. 瓦片的加载，与cache\n\t\t2. 非实施例渲染，按材质进行分类渲染\n\t\t3. 实例化渲染，动态计算lod进行渲染\n\t3. 模型渲染\n\t\t1. PBR渲染\n\t\t2. 非PBR渲染","source":"_posts/电子书目录.md","raw":"---\ntitle: 电子书目录\ndate: 2022-12-25 23:36:30\ntags:\n---\n\n## 渲染整理\n\n\n#### 开放世界的场景管理\n\t1. 切成tile\n\t2. 数据分级LOD\n\t3. 根据天顶角，调整远平面，裁剪数据\n\n#### 游戏引擎分层架构\n\t1. EditorLayer\n\t2. FuntionLayer\n\t\t1. Rendering\n\t\t2. Animation\n\t\t3. Camera\n\t\t4. Physics\n\t\t5. Script\n\t3. ResourceLayer\n\t4. CoreLayer\n\t\t1. threadPoolManagement\n\t\t2. memoryPool\n\t\t3. mathLibrary\n\t5. PlatformLayer\n\t\t1. RHI\n\n#### Renderable\n\t1. shader\n\t\t1. vs,fs\n\t\t2. macro\n\t2. RenderState\n\t3. MVP \n\t4. Texture\n\t5. DrawImp\n\n#### 渲染效果\n\t1. 前向渲染\n  \t\t1. PBR\n  \t\t2. 布林冯模型\n\t2. 阴影shadowMap：\n\t\t1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性\n\t\t2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度\n\t3. 楼的倒影\n\t\t1. 矩阵楼块插入地面\n\t\t2. 模板测试，只有地面和水才绘制\n\t4. AO\n\t5. 聚光灯效果\n\t6. UV动画\n\n#### 技术点提炼\n\t1. 楼块\n\t\t1. 切成小块\n\t\t2. 柔化圆角\n\t\t3. 贴UV\n\t2. 3d瓦片绘制\n\t\t1. 瓦片的加载，与cache\n\t\t2. 非实施例渲染，按材质进行分类渲染\n\t\t3. 实例化渲染，动态计算lod进行渲染\n\t3. 模型渲染\n\t\t1. PBR渲染\n\t\t2. 非PBR渲染","slug":"电子书目录","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a7002lgcco2j7nc53o","content":"<h2 id=\"渲染整理\"><a href=\"#渲染整理\" class=\"headerlink\" title=\"渲染整理\"></a>渲染整理</h2><h4 id=\"开放世界的场景管理\"><a href=\"#开放世界的场景管理\" class=\"headerlink\" title=\"开放世界的场景管理\"></a>开放世界的场景管理</h4><pre><code>1. 切成tile\n2. 数据分级LOD\n3. 根据天顶角，调整远平面，裁剪数据\n</code></pre>\n<h4 id=\"游戏引擎分层架构\"><a href=\"#游戏引擎分层架构\" class=\"headerlink\" title=\"游戏引擎分层架构\"></a>游戏引擎分层架构</h4><pre><code>1. EditorLayer\n2. FuntionLayer\n    1. Rendering\n    2. Animation\n    3. Camera\n    4. Physics\n    5. Script\n3. ResourceLayer\n4. CoreLayer\n    1. threadPoolManagement\n    2. memoryPool\n    3. mathLibrary\n5. PlatformLayer\n    1. RHI\n</code></pre>\n<h4 id=\"Renderable\"><a href=\"#Renderable\" class=\"headerlink\" title=\"Renderable\"></a>Renderable</h4><pre><code>1. shader\n    1. vs,fs\n    2. macro\n2. RenderState\n3. MVP \n4. Texture\n5. DrawImp\n</code></pre>\n<h4 id=\"渲染效果\"><a href=\"#渲染效果\" class=\"headerlink\" title=\"渲染效果\"></a>渲染效果</h4><pre><code>1. 前向渲染\n      1. PBR\n      2. 布林冯模型\n2. 阴影shadowMap：\n    1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性\n    2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度\n3. 楼的倒影\n    1. 矩阵楼块插入地面\n    2. 模板测试，只有地面和水才绘制\n4. AO\n5. 聚光灯效果\n6. UV动画\n</code></pre>\n<h4 id=\"技术点提炼\"><a href=\"#技术点提炼\" class=\"headerlink\" title=\"技术点提炼\"></a>技术点提炼</h4><pre><code>1. 楼块\n    1. 切成小块\n    2. 柔化圆角\n    3. 贴UV\n2. 3d瓦片绘制\n    1. 瓦片的加载，与cache\n    2. 非实施例渲染，按材质进行分类渲染\n    3. 实例化渲染，动态计算lod进行渲染\n3. 模型渲染\n    1. PBR渲染\n    2. 非PBR渲染\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"渲染整理\"><a href=\"#渲染整理\" class=\"headerlink\" title=\"渲染整理\"></a>渲染整理</h2><h4 id=\"开放世界的场景管理\"><a href=\"#开放世界的场景管理\" class=\"headerlink\" title=\"开放世界的场景管理\"></a>开放世界的场景管理</h4><pre><code>1. 切成tile\n2. 数据分级LOD\n3. 根据天顶角，调整远平面，裁剪数据\n</code></pre>\n<h4 id=\"游戏引擎分层架构\"><a href=\"#游戏引擎分层架构\" class=\"headerlink\" title=\"游戏引擎分层架构\"></a>游戏引擎分层架构</h4><pre><code>1. EditorLayer\n2. FuntionLayer\n    1. Rendering\n    2. Animation\n    3. Camera\n    4. Physics\n    5. Script\n3. ResourceLayer\n4. CoreLayer\n    1. threadPoolManagement\n    2. memoryPool\n    3. mathLibrary\n5. PlatformLayer\n    1. RHI\n</code></pre>\n<h4 id=\"Renderable\"><a href=\"#Renderable\" class=\"headerlink\" title=\"Renderable\"></a>Renderable</h4><pre><code>1. shader\n    1. vs,fs\n    2. macro\n2. RenderState\n3. MVP \n4. Texture\n5. DrawImp\n</code></pre>\n<h4 id=\"渲染效果\"><a href=\"#渲染效果\" class=\"headerlink\" title=\"渲染效果\"></a>渲染效果</h4><pre><code>1. 前向渲染\n      1. PBR\n      2. 布林冯模型\n2. 阴影shadowMap：\n    1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性\n    2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度\n3. 楼的倒影\n    1. 矩阵楼块插入地面\n    2. 模板测试，只有地面和水才绘制\n4. AO\n5. 聚光灯效果\n6. UV动画\n</code></pre>\n<h4 id=\"技术点提炼\"><a href=\"#技术点提炼\" class=\"headerlink\" title=\"技术点提炼\"></a>技术点提炼</h4><pre><code>1. 楼块\n    1. 切成小块\n    2. 柔化圆角\n    3. 贴UV\n2. 3d瓦片绘制\n    1. 瓦片的加载，与cache\n    2. 非实施例渲染，按材质进行分类渲染\n    3. 实例化渲染，动态计算lod进行渲染\n3. 模型渲染\n    1. PBR渲染\n    2. 非PBR渲染\n</code></pre>\n"},{"title":"正则与通配符区别","date":"2024-10-11T11:11:45.000Z","_content":"\n正则表达式（Regular Expressions）和通配符（Wildcards）都是用于模式匹配的工具，但它们在功能、语法和应用场景上有显著的区别。以下是它们之间的主要区别：\n\n### 1. 定义\n\n- **正则表达式**:\n  - 正则表达式是一种用于描述字符串模式的强大工具，允许复杂的匹配规则。它可以用于查找、替换和验证字符串。\n  \n- **通配符**:\n  - 通配符是一种简单的模式匹配符号，通常用于文件名匹配或简单的字符串匹配。它们的功能相对较简单。\n\n### 2. 语法\n\n- **正则表达式**:\n  - 正则表达式使用特定的语法来定义模式，包括字符类、量词、边界匹配、分组等。例如：\n    - `^abc`：匹配以 \"abc\" 开头的字符串。\n    - `\\d`：匹配任何数字字符。\n    - `.*`：匹配任意字符（包括空字符）零次或多次。\n\n- **通配符**:\n  - 通配符通常使用简单的符号来表示匹配模式：\n    - `*`：匹配零个或多个字符。\n    - `?`：匹配一个字符。\n    - `[]`：匹配括号内的任意一个字符（例如，`[abc]` 匹配 \"a\"、\"b\" 或 \"c\"）。\n\n### 3. 功能\n\n- **正则表达式**:\n  - 正则表达式功能强大，支持复杂的匹配规则、分组、反向引用、替换等操作。可以用于文本处理、数据验证、搜索引擎等多种场景。\n\n- **通配符**:\n  - 通配符功能相对简单，主要用于文件系统中的文件名匹配（如在命令行中使用）或简单的字符串匹配。它们不支持复杂的匹配规则。\n\n### 4. 应用场景\n\n- **正则表达式**:\n  - 常用于编程语言（如 Python、Java、JavaScript、C++ 等）中的字符串处理、数据验证（如电子邮件、电话号码格式）、文本搜索和替换等。\n\n- **通配符**:\n  - 常用于文件系统操作（如在命令行中查找文件）、数据库查询（如 SQL 中的 LIKE 操作）等。\n\n### 5. 示例\n\n- **正则表达式示例**:\n  ```regex\n  ^[A-Za-z0-9]+@[A-Za-z]+\\.[A-Za-z]{2,}$\n  ```\n  - 这个正则表达式用于匹配电子邮件地址。\n\n- **通配符示例**:\n  - `*.txt`：匹配所有以 `.txt` 结尾的文件。\n  - `file?.jpg`：匹配 `file1.jpg`、`file2.jpg` 等文件，但不匹配 `file10.jpg`。\n\n### 总结\n\n- **正则表达式** 是一种功能强大的模式匹配工具，适用于复杂的字符串处理和验证。\n- **通配符** 是一种简单的模式匹配符号，主要用于文件名匹配和简单的字符串匹配。\n\n根据具体的需求选择合适的工具，可以更有效地完成字符串匹配和处理任务。","source":"_posts/正则与通配符区别.md","raw":"---\ntitle: 正则与通配符区别\ndate: 2024-10-11 19:11:45\ntags:\n---\n\n正则表达式（Regular Expressions）和通配符（Wildcards）都是用于模式匹配的工具，但它们在功能、语法和应用场景上有显著的区别。以下是它们之间的主要区别：\n\n### 1. 定义\n\n- **正则表达式**:\n  - 正则表达式是一种用于描述字符串模式的强大工具，允许复杂的匹配规则。它可以用于查找、替换和验证字符串。\n  \n- **通配符**:\n  - 通配符是一种简单的模式匹配符号，通常用于文件名匹配或简单的字符串匹配。它们的功能相对较简单。\n\n### 2. 语法\n\n- **正则表达式**:\n  - 正则表达式使用特定的语法来定义模式，包括字符类、量词、边界匹配、分组等。例如：\n    - `^abc`：匹配以 \"abc\" 开头的字符串。\n    - `\\d`：匹配任何数字字符。\n    - `.*`：匹配任意字符（包括空字符）零次或多次。\n\n- **通配符**:\n  - 通配符通常使用简单的符号来表示匹配模式：\n    - `*`：匹配零个或多个字符。\n    - `?`：匹配一个字符。\n    - `[]`：匹配括号内的任意一个字符（例如，`[abc]` 匹配 \"a\"、\"b\" 或 \"c\"）。\n\n### 3. 功能\n\n- **正则表达式**:\n  - 正则表达式功能强大，支持复杂的匹配规则、分组、反向引用、替换等操作。可以用于文本处理、数据验证、搜索引擎等多种场景。\n\n- **通配符**:\n  - 通配符功能相对简单，主要用于文件系统中的文件名匹配（如在命令行中使用）或简单的字符串匹配。它们不支持复杂的匹配规则。\n\n### 4. 应用场景\n\n- **正则表达式**:\n  - 常用于编程语言（如 Python、Java、JavaScript、C++ 等）中的字符串处理、数据验证（如电子邮件、电话号码格式）、文本搜索和替换等。\n\n- **通配符**:\n  - 常用于文件系统操作（如在命令行中查找文件）、数据库查询（如 SQL 中的 LIKE 操作）等。\n\n### 5. 示例\n\n- **正则表达式示例**:\n  ```regex\n  ^[A-Za-z0-9]+@[A-Za-z]+\\.[A-Za-z]{2,}$\n  ```\n  - 这个正则表达式用于匹配电子邮件地址。\n\n- **通配符示例**:\n  - `*.txt`：匹配所有以 `.txt` 结尾的文件。\n  - `file?.jpg`：匹配 `file1.jpg`、`file2.jpg` 等文件，但不匹配 `file10.jpg`。\n\n### 总结\n\n- **正则表达式** 是一种功能强大的模式匹配工具，适用于复杂的字符串处理和验证。\n- **通配符** 是一种简单的模式匹配符号，主要用于文件名匹配和简单的字符串匹配。\n\n根据具体的需求选择合适的工具，可以更有效地完成字符串匹配和处理任务。","slug":"正则与通配符区别","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbm0l9a7002mgccofa60czye","content":"<p>正则表达式（Regular Expressions）和通配符（Wildcards）都是用于模式匹配的工具，但它们在功能、语法和应用场景上有显著的区别。以下是它们之间的主要区别：</p>\n<h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><ul>\n<li><strong>正则表达式</strong>:<ul>\n<li>正则表达式是一种用于描述字符串模式的强大工具，允许复杂的匹配规则。它可以用于查找、替换和验证字符串。</li>\n</ul>\n</li>\n<li><strong>通配符</strong>:<ul>\n<li>通配符是一种简单的模式匹配符号，通常用于文件名匹配或简单的字符串匹配。它们的功能相对较简单。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><ul>\n<li><p><strong>正则表达式</strong>:</p>\n<ul>\n<li>正则表达式使用特定的语法来定义模式，包括字符类、量词、边界匹配、分组等。例如：<ul>\n<li><code>^abc</code>：匹配以 “abc” 开头的字符串。</li>\n<li><code>\\d</code>：匹配任何数字字符。</li>\n<li><code>.*</code>：匹配任意字符（包括空字符）零次或多次。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>通配符</strong>:</p>\n<ul>\n<li>通配符通常使用简单的符号来表示匹配模式：<ul>\n<li><code>*</code>：匹配零个或多个字符。</li>\n<li><code>?</code>：匹配一个字符。</li>\n<li><code>[]</code>：匹配括号内的任意一个字符（例如，<code>[abc]</code> 匹配 “a”、”b” 或 “c”）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-功能\"><a href=\"#3-功能\" class=\"headerlink\" title=\"3. 功能\"></a>3. 功能</h3><ul>\n<li><p><strong>正则表达式</strong>:</p>\n<ul>\n<li>正则表达式功能强大，支持复杂的匹配规则、分组、反向引用、替换等操作。可以用于文本处理、数据验证、搜索引擎等多种场景。</li>\n</ul>\n</li>\n<li><p><strong>通配符</strong>:</p>\n<ul>\n<li>通配符功能相对简单，主要用于文件系统中的文件名匹配（如在命令行中使用）或简单的字符串匹配。它们不支持复杂的匹配规则。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-应用场景\"><a href=\"#4-应用场景\" class=\"headerlink\" title=\"4. 应用场景\"></a>4. 应用场景</h3><ul>\n<li><p><strong>正则表达式</strong>:</p>\n<ul>\n<li>常用于编程语言（如 Python、Java、JavaScript、C++ 等）中的字符串处理、数据验证（如电子邮件、电话号码格式）、文本搜索和替换等。</li>\n</ul>\n</li>\n<li><p><strong>通配符</strong>:</p>\n<ul>\n<li>常用于文件系统操作（如在命令行中查找文件）、数据库查询（如 SQL 中的 LIKE 操作）等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-示例\"><a href=\"#5-示例\" class=\"headerlink\" title=\"5. 示例\"></a>5. 示例</h3><ul>\n<li><p><strong>正则表达式示例</strong>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^[A-Za-z0-9]+@[A-Za-z]+\\.[A-Za-z]&#123;2,&#125;$</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这个正则表达式用于匹配电子邮件地址。</li>\n</ul>\n</li>\n<li><p><strong>通配符示例</strong>:</p>\n<ul>\n<li><code>*.txt</code>：匹配所有以 <code>.txt</code> 结尾的文件。</li>\n<li><code>file?.jpg</code>：匹配 <code>file1.jpg</code>、<code>file2.jpg</code> 等文件，但不匹配 <code>file10.jpg</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>正则表达式</strong> 是一种功能强大的模式匹配工具，适用于复杂的字符串处理和验证。</li>\n<li><strong>通配符</strong> 是一种简单的模式匹配符号，主要用于文件名匹配和简单的字符串匹配。</li>\n</ul>\n<p>根据具体的需求选择合适的工具，可以更有效地完成字符串匹配和处理任务。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>正则表达式（Regular Expressions）和通配符（Wildcards）都是用于模式匹配的工具，但它们在功能、语法和应用场景上有显著的区别。以下是它们之间的主要区别：</p>\n<h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><ul>\n<li><strong>正则表达式</strong>:<ul>\n<li>正则表达式是一种用于描述字符串模式的强大工具，允许复杂的匹配规则。它可以用于查找、替换和验证字符串。</li>\n</ul>\n</li>\n<li><strong>通配符</strong>:<ul>\n<li>通配符是一种简单的模式匹配符号，通常用于文件名匹配或简单的字符串匹配。它们的功能相对较简单。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><ul>\n<li><p><strong>正则表达式</strong>:</p>\n<ul>\n<li>正则表达式使用特定的语法来定义模式，包括字符类、量词、边界匹配、分组等。例如：<ul>\n<li><code>^abc</code>：匹配以 “abc” 开头的字符串。</li>\n<li><code>\\d</code>：匹配任何数字字符。</li>\n<li><code>.*</code>：匹配任意字符（包括空字符）零次或多次。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>通配符</strong>:</p>\n<ul>\n<li>通配符通常使用简单的符号来表示匹配模式：<ul>\n<li><code>*</code>：匹配零个或多个字符。</li>\n<li><code>?</code>：匹配一个字符。</li>\n<li><code>[]</code>：匹配括号内的任意一个字符（例如，<code>[abc]</code> 匹配 “a”、”b” 或 “c”）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-功能\"><a href=\"#3-功能\" class=\"headerlink\" title=\"3. 功能\"></a>3. 功能</h3><ul>\n<li><p><strong>正则表达式</strong>:</p>\n<ul>\n<li>正则表达式功能强大，支持复杂的匹配规则、分组、反向引用、替换等操作。可以用于文本处理、数据验证、搜索引擎等多种场景。</li>\n</ul>\n</li>\n<li><p><strong>通配符</strong>:</p>\n<ul>\n<li>通配符功能相对简单，主要用于文件系统中的文件名匹配（如在命令行中使用）或简单的字符串匹配。它们不支持复杂的匹配规则。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-应用场景\"><a href=\"#4-应用场景\" class=\"headerlink\" title=\"4. 应用场景\"></a>4. 应用场景</h3><ul>\n<li><p><strong>正则表达式</strong>:</p>\n<ul>\n<li>常用于编程语言（如 Python、Java、JavaScript、C++ 等）中的字符串处理、数据验证（如电子邮件、电话号码格式）、文本搜索和替换等。</li>\n</ul>\n</li>\n<li><p><strong>通配符</strong>:</p>\n<ul>\n<li>常用于文件系统操作（如在命令行中查找文件）、数据库查询（如 SQL 中的 LIKE 操作）等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-示例\"><a href=\"#5-示例\" class=\"headerlink\" title=\"5. 示例\"></a>5. 示例</h3><ul>\n<li><p><strong>正则表达式示例</strong>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^[A-Za-z0-9]+@[A-Za-z]+\\.[A-Za-z]&#123;2,&#125;$</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这个正则表达式用于匹配电子邮件地址。</li>\n</ul>\n</li>\n<li><p><strong>通配符示例</strong>:</p>\n<ul>\n<li><code>*.txt</code>：匹配所有以 <code>.txt</code> 结尾的文件。</li>\n<li><code>file?.jpg</code>：匹配 <code>file1.jpg</code>、<code>file2.jpg</code> 等文件，但不匹配 <code>file10.jpg</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>正则表达式</strong> 是一种功能强大的模式匹配工具，适用于复杂的字符串处理和验证。</li>\n<li><strong>通配符</strong> 是一种简单的模式匹配符号，主要用于文件名匹配和简单的字符串匹配。</li>\n</ul>\n<p>根据具体的需求选择合适的工具，可以更有效地完成字符串匹配和处理任务。</p>\n"}],"PostAsset":[{"_id":"source/_posts/add-Image/sharedptr1.png","post":"cmbm0l9a20019gcco0almano7","slug":"sharedptr1.png","modified":1,"renderable":1},{"_id":"source/_posts/add-Image/sharedptr2.png","post":"cmbm0l9a20019gcco0almano7","slug":"sharedptr2.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cmbm0l99y0009gcco2xo585f2","tag_id":"cmbm0l99x0007gccob7s21xld","_id":"cmbm0l99z000cgccoennmf7e0"},{"post_id":"cmbm0l99x0005gccoao9k67y8","tag_id":"cmbm0l99x0007gccob7s21xld","_id":"cmbm0l99z000egccoafj4arz9"},{"post_id":"cmbm0l99y000agcco31tuhw0n","tag_id":"cmbm0l99x0007gccob7s21xld","_id":"cmbm0l9a0000hgcco5a71ftx0"},{"post_id":"cmbm0l99x0006gccodegh69uj","tag_id":"cmbm0l99x0007gccob7s21xld","_id":"cmbm0l9a0000jgcco9u2x7y0n"},{"post_id":"cmbm0l99y0008gcco76pv0qwm","tag_id":"cmbm0l99x0007gccob7s21xld","_id":"cmbm0l9a0000mgcco7z6h9p6k"},{"post_id":"cmbm0l99z000dgcco5n3u3h3g","tag_id":"cmbm0l9a0000lgccofssyhuif","_id":"cmbm0l9a1000rgccohccm5est"},{"post_id":"cmbm0l9a0000ogcco38by0lyh","tag_id":"cmbm0l9a0000lgccofssyhuif","_id":"cmbm0l9a1000tgcco036natfm"},{"post_id":"cmbm0l99z000fgccoa3jg8ecu","tag_id":"cmbm0l9a0000lgccofssyhuif","_id":"cmbm0l9a1000wgcco7zf69cik"},{"post_id":"cmbm0l9a0000igcco5mwjdhkk","tag_id":"cmbm0l9a0000lgccofssyhuif","_id":"cmbm0l9a20013gcco2fv82tdw"},{"post_id":"cmbm0l9a0000igcco5mwjdhkk","tag_id":"cmbm0l9a1000ygcco78axagya","_id":"cmbm0l9a20015gcco11t9gxbm"},{"post_id":"cmbm0l9a0000kgcco8aga4w1m","tag_id":"cmbm0l9a0000lgccofssyhuif","_id":"cmbm0l9a20018gccog1xd7hvu"},{"post_id":"cmbm0l9a0000ngccoacq405k4","tag_id":"cmbm0l9a20016gcco53b75fom","_id":"cmbm0l9a3001cgccob6n139xo"},{"post_id":"cmbm0l9a1000qgcco4vtb6d58","tag_id":"cmbm0l9a20016gcco53b75fom","_id":"cmbm0l9a3001ggcco7cgxfrg8"},{"post_id":"cmbm0l9a1000sgccocz2y68aj","tag_id":"cmbm0l9a20016gcco53b75fom","_id":"cmbm0l9a3001kgcco51uu69vd"},{"post_id":"cmbm0l9a3001hgccodamgc2ha","tag_id":"cmbm0l9a0000lgccofssyhuif","_id":"cmbm0l9a3001mgcco7ji5ewkj"},{"post_id":"cmbm0l9a3001jgcco6306azsf","tag_id":"cmbm0l9a0000lgccofssyhuif","_id":"cmbm0l9a4001pgccogons7zjf"},{"post_id":"cmbm0l9a1000vgcco4gta1fs2","tag_id":"cmbm0l9a20016gcco53b75fom","_id":"cmbm0l9a4001rgcco9f9idfhv"},{"post_id":"cmbm0l9a1000vgcco4gta1fs2","tag_id":"cmbm0l9a0000lgccofssyhuif","_id":"cmbm0l9a4001ugcco54fsalwa"},{"post_id":"cmbm0l9a3001lgcco5g9bdi77","tag_id":"cmbm0l9a0000lgccofssyhuif","_id":"cmbm0l9a4001wgccoegsbd369"},{"post_id":"cmbm0l9a1000xgcco7l7d22dw","tag_id":"cmbm0l9a20016gcco53b75fom","_id":"cmbm0l9a4001zgcco8ptk6kao"},{"post_id":"cmbm0l9a20010gcco8bilemdt","tag_id":"cmbm0l9a20016gcco53b75fom","_id":"cmbm0l9a50021gccofanchjwx"},{"post_id":"cmbm0l9a4001vgccohqo4clcd","tag_id":"cmbm0l9a0000lgccofssyhuif","_id":"cmbm0l9a60024gccoces68ff4"},{"post_id":"cmbm0l9a20019gcco0almano7","tag_id":"cmbm0l9a4001xgcco8czeb1lm","_id":"cmbm0l9a60026gccod4hj0ree"},{"post_id":"cmbm0l9a2001bgcco7xms5h43","tag_id":"cmbm0l9a60023gccog6dk3zlh","_id":"cmbm0l9a60029gcco1ng1awce"},{"post_id":"cmbm0l9a6002agccob4wtg6la","tag_id":"cmbm0l9a0000lgccofssyhuif","_id":"cmbm0l9a6002cgccoasm0cyi0"},{"post_id":"cmbm0l9a6002bgcco6eakc2to","tag_id":"cmbm0l9a0000lgccofssyhuif","_id":"cmbm0l9a6002egcco2was1y41"}],"Tag":[{"name":"C++11","_id":"cmbm0l99x0007gccob7s21xld"},{"name":"iOS","_id":"cmbm0l9a0000lgccofssyhuif"},{"name":"ruby","_id":"cmbm0l9a1000ygcco78axagya"},{"name":"openGL","_id":"cmbm0l9a20016gcco53b75fom"},{"name":"test","_id":"cmbm0l9a4001xgcco8czeb1lm"},{"name":"c++11","_id":"cmbm0l9a60023gccog6dk3zlh"}]}}