{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"c46833ffcf99dcb46ad4ccffe7f555d907383fa3","modified":1670741499616},{"_id":"source/_posts/C++-智能指针.md","hash":"c96893723adc35dec3bf88e925a993ccfeb89770","modified":1666529550757},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1666528838991},{"_id":"source/_posts/C++中operator的重载.md","hash":"c3184c3ad48c6d62b0a0fb289ed096917b7591eb","modified":1666529561516},{"_id":"source/_posts/C++右值引用.md","hash":"58981687a1982cf532f1d770a6cac8e93455c16e","modified":1666687966025},{"_id":"source/_posts/C++实现完美转发.md","hash":"7ae1a4318ad2c2ea8999b45250e225c1732a574a","modified":1667875633674},{"_id":"source/_posts/C++构造函数.md","hash":"6690e714d570ebc825f4131eb72e60bbe222f662","modified":1666529587796},{"_id":"source/_posts/CALayer-opaque.md","hash":"d7522f9aacbdea74344b44352173765566f9187a","modified":1666529915840},{"_id":"source/_posts/CALayer属性positon和anchor.md","hash":"792de5cb4a535d8c168f8c7ebf3f945e547e864f","modified":1513763413000},{"_id":"source/_posts/CALayer的presentLayer那点事.md","hash":"af82e11e1745d65389117f6ae40d8f5f6beee65d","modified":1666529642206},{"_id":"source/_posts/How to build Apple Watch App.md","hash":"2520dba99fc20ad966689919aa93391a413cf76d","modified":1666529901288},{"_id":"source/_posts/MacOS下ruby安装.md","hash":"3f71b14964c96da93e0411ee2eaece253a101611","modified":1666529727057},{"_id":"source/_posts/OpenGL-VBO.md","hash":"25bcfa10e6a6abfcec24e7d2d474be055f40ca3a","modified":1513763413000},{"_id":"source/_posts/OpenGL-uniform和attribute.md","hash":"21003e0a8fca07b7051c4bc2dea1f03fd9fd8f86","modified":1513763413000},{"_id":"source/_posts/OpenGL-光照学习.md","hash":"42bb93bb87fbdd1940720e9db6b919c873b159f2","modified":1513763413000},{"_id":"source/_posts/OpenGL-基本框架搭建和绘制一个简单图形.md","hash":"e1aec3369a5014404c6cafc61fcda02871b70b56","modified":1666529478637},{"_id":"source/_posts/OpenGL-纹理贴图.md","hash":"4413e1025c062dff341b5ed28e10619c162c6756","modified":1666529148284},{"_id":"source/_posts/add-Image.md","hash":"fa3ffe48c50ab3d06b7df2d29b62982acf15b098","modified":1666529607162},{"_id":"source/_posts/iOS-MessageForwarding.md","hash":"9a0a66b214eb08396328e4a042952b7877bfe822","modified":1666529259457},{"_id":"source/_posts/iOS11 Simulator OpenGL Slowly.md","hash":"eaa70b4a2594deea47c90a57499892ddc4b1e6e7","modified":1513763413000},{"_id":"source/_posts/iOS准确计时.md","hash":"ff7ba31fe710f4ee39e3e1255ba2cc0f63d2b3e1","modified":1513763413000},{"_id":"source/_posts/iOS手势事件分发原理.md","hash":"d39f9a97b434d92ed17ec9dd8a1f5934631009e8","modified":1513763413000},{"_id":"source/_posts/tweak使用说明.md","hash":"b7c4d8f1339a1a787c8563d110d66955698c7195","modified":1666529947975},{"_id":"source/_posts/tweak环境搭建.md","hash":"7fee054633a5e8ece769e641dc07eae507f7a49e","modified":1666529672233},{"_id":"source/_posts/add-Image/sharedptr1.png","hash":"ef9802a63197339362725253f40a8f6af13991e2","modified":1664108876445},{"_id":"source/_posts/add-Image/sharedptr2.png","hash":"8e51afea16d9407343cefb650097d2c91b00bc39","modified":1664108876446},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1663469395268},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1663469395268},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1663469395268},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1663469395268},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1663469395269},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1663469395269},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1663469395269},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1663469395269},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1663469395270},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1663469395269},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1663469395270},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1663469395270},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1663469395270},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1663469395270},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1663469395270},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1663469395271},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1663469395271},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1663469395271},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1663469395272},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1663469395273},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1663469395273},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1663469395273},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1663469395273},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1663469395273},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1663469395273},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1663469395271},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1663469395273},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1663469395274},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"d43a28f132e7ac8cc80193652cc3609976994458","modified":1670735721168},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1663469395274},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1663469395274},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1663469395275},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1663469395275},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1663469395275},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1663469395275},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1663469395275},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1663469395275},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1663469395274},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1663469395276},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1663469395276},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1663469395276},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1663469395276},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1663469395276},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1663469395284},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1663469395285},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1663469395285},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1663469395285},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1663469395285},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1663469395285},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1663469395285},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1663469395286},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1663469395286},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1663469395287},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1663469395287},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1663469395283},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1663469395275},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1663469395278},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1663469395277},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1663469395277},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1663469395277},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1663469395277},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1663469395286},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1663469395288},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1663469395287},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1663469395288},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1663469395288},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1663469395288},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1663469395288},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1663469395288},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1663469395288},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1663469395289},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1663469395284},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1663469395287},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1663469395278},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1663469395280},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1663469395283},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1663469395284},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1663469395289},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1663469395289},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1663469395290},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1663469395289},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1663469395289},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1663469395282},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1663469395284},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1663469395282},{"_id":"public/2022/10/23/C++实现完美转发/index.html","hash":"b96cbe0dac8680950b87f3ba573c4a8bdc37626e","modified":1671982690869},{"_id":"public/2022/09/25/add-Image/index.html","hash":"d5fb3931c1863bd81de8a95a8e0bb31fa30b6503","modified":1671982690869},{"_id":"public/2022/09/25/C++-智能指针/index.html","hash":"075f4948b9dfe1d46f5ee5630622e5ea7ca82724","modified":1671982690869},{"_id":"public/2022/09/18/C++右值引用/index.html","hash":"3c547fe85a248731ef11106a8e9cd6778f742adf","modified":1671982690869},{"_id":"public/2022/09/18/C++中operator的重载/index.html","hash":"cab0298ebf8a4d0fed7ace2b43865b0b0efd947a","modified":1671982690869},{"_id":"public/2022/09/18/C++构造函数/index.html","hash":"3ef359a74ca36da21ac430f5d15c01a83d0bd16c","modified":1671982690869},{"_id":"public/2017/12/14/iOS-MessageForwarding/index.html","hash":"7ad4ba9ad4e2b36b60dfcdbdfbd49c894c05b3c3","modified":1671982690869},{"_id":"public/2017/11/12/CALayer的presentLayer那点事/index.html","hash":"8065246a9d4d7b10e260e326768d3049f1987f39","modified":1671982690869},{"_id":"public/2017/09/19/MacOS下ruby安装/index.html","hash":"0c820fba4f94c49c9a501eb15fbda48abed29d8d","modified":1671982690869},{"_id":"public/2017/09/19/iOS11 Simulator OpenGL Slowly/index.html","hash":"dd9923ede1cb06dd007abb1d10f10da92221a965","modified":1671982690869},{"_id":"public/2017/09/17/iOS准确计时/index.html","hash":"6286a1da05dc746ab92084d679302f34a3a58d0f","modified":1671982690869},{"_id":"public/2017/07/01/iOS手势事件分发原理/index.html","hash":"6042a358544bd861829efb2b04026d3acb9ce562","modified":1671982690869},{"_id":"public/2017/03/07/tweak使用说明/index.html","hash":"f2b39627855dbad99cc5fa03e01077948e6b31ea","modified":1671982690869},{"_id":"public/2017/03/07/tweak环境搭建/index.html","hash":"4ad82824790281a866c638ca88d01abfb8a7f7bf","modified":1671982690869},{"_id":"public/2017/01/03/OpenGL-纹理贴图/index.html","hash":"95408f29c427d3ea4d2a078ee538fc17308dc8ec","modified":1671982690869},{"_id":"public/2017/01/02/OpenGL-光照学习/index.html","hash":"cd28048475c76b0326ac2db0a8f4eda3c000bae7","modified":1671982690869},{"_id":"public/2017/01/02/OpenGL-VBO/index.html","hash":"4d5fce41b5e4197231d45a48d970b1710e62ce41","modified":1671982690869},{"_id":"public/2016/12/30/OpenGL-uniform和attribute/index.html","hash":"988fe141f38974a5ad6889e95fcfca1b210571cb","modified":1671982690869},{"_id":"public/2016/12/30/OpenGL-基本框架搭建和绘制一个简单图形/index.html","hash":"5003cc8ebb369a967c291110c662cfb544973433","modified":1671982690869},{"_id":"public/2016/12/30/CALayer-opaque/index.html","hash":"258a27df999f1d95e48f4ef7300d13467e6e88f8","modified":1671982690869},{"_id":"public/2016/10/26/CALayer属性positon和anchor/index.html","hash":"b03e1bc6ca7c77d0477b5265cf2b6d1973b3cdc3","modified":1671982690869},{"_id":"public/2016/10/26/How to build Apple Watch App/index.html","hash":"941828a2d96af0ada74c659e204490d48bc70388","modified":1671982690869},{"_id":"public/archives/index.html","hash":"643e0874e29bf651fdc1accb70beaacec5068356","modified":1671982690869},{"_id":"public/archives/page/2/index.html","hash":"94e829dad49c81a367e80c4942fcc494c2023ea7","modified":1671982690869},{"_id":"public/archives/page/3/index.html","hash":"e9aa70619f4bd68e2b0634c5d2a64151f17441ac","modified":1671982690869},{"_id":"public/archives/2016/index.html","hash":"d89fd44a02be5e4c96fa8c3254fe7f1505f9a1ae","modified":1671982690869},{"_id":"public/archives/2016/10/index.html","hash":"974a38ca8d09194e9befce6fa5ee51de0ae7591c","modified":1671982690869},{"_id":"public/archives/2016/12/index.html","hash":"d326bb517e2d0aa645751bf1a2b1c7edb487ef5f","modified":1671982690869},{"_id":"public/archives/2017/index.html","hash":"1b88bb7b0e2a84ab44338be52e77a79f8d9cdbd2","modified":1671982690869},{"_id":"public/archives/2017/page/2/index.html","hash":"315e49cbe7290736fc902e889737505a7de0c2c5","modified":1671982690869},{"_id":"public/archives/2017/01/index.html","hash":"9fc0e2ba6a0a8e85a0620d257328bdfe843a15cb","modified":1671982690869},{"_id":"public/archives/2017/03/index.html","hash":"06a3f7ef5c4dcff85219280c53c0bfc354bf1a69","modified":1671982690869},{"_id":"public/archives/2017/07/index.html","hash":"011373a0e95e8e17493ed43d0e65cab5bdffe1ea","modified":1671982690869},{"_id":"public/archives/2017/09/index.html","hash":"7bcc68b3f7bc67d9eddd82c38180e341575991f0","modified":1671982690869},{"_id":"public/archives/2017/11/index.html","hash":"71d70dc98627f6efa4852bf68f89c8366ce41322","modified":1671982690869},{"_id":"public/archives/2017/12/index.html","hash":"1fc5c0d7a1ac2776250201183ea672de3dfea021","modified":1671982690869},{"_id":"public/archives/2022/index.html","hash":"6b1255d463738bfc1293cc76b39caddca9b64452","modified":1671982690869},{"_id":"public/archives/2022/09/index.html","hash":"f1637ffe11b0b19e6d68f329ab8577a27abcc5d9","modified":1671982690869},{"_id":"public/archives/2022/10/index.html","hash":"2d839291911ac1890b92c8dc8152954c7520c2c6","modified":1671982690869},{"_id":"public/index.html","hash":"43f9b048e060ef28487c0ae34d5de2a32ff31e43","modified":1671982690869},{"_id":"public/page/3/index.html","hash":"dc9b5ebcf71247664ccfd8f86035b2ca634a629d","modified":1671982690869},{"_id":"public/page/2/index.html","hash":"eb651b28e8bd27c3f36bf5fff79b775c3af0fe96","modified":1671982690869},{"_id":"public/tags/C-11/index.html","hash":"e0b655ed49d010e138e0a29b8eb7520513e545db","modified":1671982690869},{"_id":"public/tags/iOS/index.html","hash":"91b1d569c43b0d561f9852b8fce545e1dce48530","modified":1671982690869},{"_id":"public/tags/iOS/page/2/index.html","hash":"4c8c7713e199f0f66beaf4464b74f48ccb8b6277","modified":1671982690869},{"_id":"public/tags/ruby/index.html","hash":"7a38465078f302abf06222f15aa1d8d41fae49e9","modified":1671982690869},{"_id":"public/tags/openGL/index.html","hash":"d6c419b76f116130386417a29fe9eeaefeda77e5","modified":1671982690869},{"_id":"public/tags/test/index.html","hash":"12fc99504dc42c5f76e110f54597fb844b229de8","modified":1671982690869},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1666534215737},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1666534215737},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1666534215737},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1666534215737},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1666534215737},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1666534215737},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1666534215737},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1666534215737},{"_id":"public/2022/09/25/add-Image/sharedptr2.png","hash":"8e51afea16d9407343cefb650097d2c91b00bc39","modified":1666534215737},{"_id":"public/2022/09/25/add-Image/sharedptr1.png","hash":"ef9802a63197339362725253f40a8f6af13991e2","modified":1666534215737},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1666534215737},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1666534215737},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1666534215737},{"_id":"public/css/style.css","hash":"3986ef4b1f56bf0ac3bc45aab261e0278794c3f1","modified":1666534215737},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1666534215737},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1666534215737},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1666534215737},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1666534215737},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1666534215737},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1666534215737},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1666534215737},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1666534215737},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1666534215737},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1666534215737},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1666534215737},{"_id":"source/_posts/trivially-copyable-拷贝不变.md","hash":"73c431942a040bc77163af24570255075f0b1f50","modified":1666688146851},{"_id":"public/2022/10/25/trivially-copyable-拷贝不变/index.html","hash":"9843ba8d43963e01602613ca68c077e0c0b68559","modified":1671982690869},{"_id":"source/_posts/OpenGL模板测试流程.md","hash":"475341f02bc6cc776e8f68051cdb9730c0e26a15","modified":1667879884802},{"_id":"public/2022/11/08/OpenGL模板测试流程/index.html","hash":"4d63ee1638b34e02087beef721086389fc522f46","modified":1671982690869},{"_id":"public/archives/2022/11/index.html","hash":"42b1f454f2fe4619ebbd5b5ed2c14db98b227b5e","modified":1671982690869},{"_id":"source/_posts/c-继承权限.md","hash":"b2630ec4e2d73ad764c280c5d96bd7d10442abe0","modified":1670165851186},{"_id":"public/2022/12/04/c-继承权限/index.html","hash":"a0108a0b63c7092a3d83a877b7e5208a877fcc4a","modified":1671982690869},{"_id":"public/archives/2022/12/index.html","hash":"60f878bf390450e18ff77c6a60a9836d00143c0c","modified":1671982690869},{"_id":"source/_posts/电子书目录.md","hash":"b1214b42ceb2ada4f21330423a4fd0f59d628d73","modified":1671982653436},{"_id":"source/_posts/c-可变参数模板.md","hash":"1627e1423222f2b2c5b22063271694fb46949013","modified":1670743574638},{"_id":"public/2022/12/25/电子书目录/index.html","hash":"44225951a18ec182ef8775adcf11cf82c512a981","modified":1671982690869},{"_id":"public/2022/12/11/c-可变参数模板/index.html","hash":"0349581b737d084a9345e03f73eea4c4a47f2e2a","modified":1671982690869},{"_id":"public/archives/2022/page/2/index.html","hash":"98a300a0f4d5582caa768802c57a909feb4b3c47","modified":1671982690869},{"_id":"public/tags/c-11/index.html","hash":"620f8da31b2bd65cfd9368ae5de8a3bd04e8fe10","modified":1671982690869}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"c++ 11 智能指针","date":"2022-09-25T07:13:02.000Z","_content":"\n## 智能指针\n\n\n### share_ptr使用\n\n\n\n\n#### sharet_ptr<T>构造函数和std::make_share<T> 的区别\n1. 两个堆内存和一个堆内存，std::make_share效率更高\n2. \n\n\n\n### weak_ptr使用\n1. expired(),返回指向对堆对象是否释放\n2. use_count,share_ptr的强引用计数\n3. lock，返回share_ptr，如果释放，返回空\n4. \n\n\n\n### share_ptr线程安全话题\n1. share_ptr引用计数本身是线程安全的\n2. 一个share_ptr对象，在多个线程操作，不能保证线程安全\n3. share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全\n\n\n\n### stl容器多线程安全时的性能考虑\n\n\n### code使用\n```\nint main()\n{\n    shared_ptr<Person> person1;\n    \n    shared_ptr<Person> person2(nullptr);\n    \n    shared_ptr<Person> person3(new Person(10));\n\n    shared_ptr<Person> person4 = std::make_shared<Person>(5); //效率更高，内存分布在一起\n    \n    shared_ptr<Person> person5(std::move(person3)); // person3无法再使用\n    \n    shared_ptr<Person> arary(new Person[10], deletePersonArray);\n    \n    weak_ptr<Person> weak_Person = person5;\n    \n    cout << weak_Person.use_count() << endl;\n    \n    shared_ptr<Person> person6 = person5;\n    \n    cout << weak_Person.use_count() << endl;\n    \n    person5.reset();\n    \n    cout << weak_Person.use_count() << endl;\n    \n    person6.reset();\n    \n    if (weak_Person.expired()) {\n        cout << weak_Person.use_count() << endl;\n        \n        auto shareptr = weak_Person.lock();\n        \n        cout << shareptr << endl;\n    }\n    \n    return 0;\n    \n}\n\n```\n\n","source":"_posts/C++-智能指针.md","raw":"---\ntitle: c++ 11 智能指针\ndate: 2022-09-25 15:13:02\ntags: C++11\n---\n\n## 智能指针\n\n\n### share_ptr使用\n\n\n\n\n#### sharet_ptr<T>构造函数和std::make_share<T> 的区别\n1. 两个堆内存和一个堆内存，std::make_share效率更高\n2. \n\n\n\n### weak_ptr使用\n1. expired(),返回指向对堆对象是否释放\n2. use_count,share_ptr的强引用计数\n3. lock，返回share_ptr，如果释放，返回空\n4. \n\n\n\n### share_ptr线程安全话题\n1. share_ptr引用计数本身是线程安全的\n2. 一个share_ptr对象，在多个线程操作，不能保证线程安全\n3. share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全\n\n\n\n### stl容器多线程安全时的性能考虑\n\n\n### code使用\n```\nint main()\n{\n    shared_ptr<Person> person1;\n    \n    shared_ptr<Person> person2(nullptr);\n    \n    shared_ptr<Person> person3(new Person(10));\n\n    shared_ptr<Person> person4 = std::make_shared<Person>(5); //效率更高，内存分布在一起\n    \n    shared_ptr<Person> person5(std::move(person3)); // person3无法再使用\n    \n    shared_ptr<Person> arary(new Person[10], deletePersonArray);\n    \n    weak_ptr<Person> weak_Person = person5;\n    \n    cout << weak_Person.use_count() << endl;\n    \n    shared_ptr<Person> person6 = person5;\n    \n    cout << weak_Person.use_count() << endl;\n    \n    person5.reset();\n    \n    cout << weak_Person.use_count() << endl;\n    \n    person6.reset();\n    \n    if (weak_Person.expired()) {\n        cout << weak_Person.use_count() << endl;\n        \n        auto shareptr = weak_Person.lock();\n        \n        cout << shareptr << endl;\n    }\n    \n    return 0;\n    \n}\n\n```\n\n","slug":"C++-智能指针","published":1,"updated":"2022-10-23T12:52:30.757Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9lffyve0000y2vqagr71lxx","content":"<h2 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h2><h3 id=\"share-ptr使用\"><a href=\"#share-ptr使用\" class=\"headerlink\" title=\"share_ptr使用\"></a>share_ptr使用</h3><h4 id=\"sharet-ptr构造函数和std-make-share-的区别\"><a href=\"#sharet-ptr构造函数和std-make-share-的区别\" class=\"headerlink\" title=\"sharet_ptr构造函数和std::make_share 的区别\"></a>sharet_ptr<T>构造函数和std::make_share<T> 的区别</h4><ol>\n<li>两个堆内存和一个堆内存，std::make_share效率更高</li>\n<li></li>\n</ol>\n<h3 id=\"weak-ptr使用\"><a href=\"#weak-ptr使用\" class=\"headerlink\" title=\"weak_ptr使用\"></a>weak_ptr使用</h3><ol>\n<li>expired(),返回指向对堆对象是否释放</li>\n<li>use_count,share_ptr的强引用计数</li>\n<li>lock，返回share_ptr，如果释放，返回空</li>\n<li></li>\n</ol>\n<h3 id=\"share-ptr线程安全话题\"><a href=\"#share-ptr线程安全话题\" class=\"headerlink\" title=\"share_ptr线程安全话题\"></a>share_ptr线程安全话题</h3><ol>\n<li>share_ptr引用计数本身是线程安全的</li>\n<li>一个share_ptr对象，在多个线程操作，不能保证线程安全</li>\n<li>share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全</li>\n</ol>\n<h3 id=\"stl容器多线程安全时的性能考虑\"><a href=\"#stl容器多线程安全时的性能考虑\" class=\"headerlink\" title=\"stl容器多线程安全时的性能考虑\"></a>stl容器多线程安全时的性能考虑</h3><h3 id=\"code使用\"><a href=\"#code使用\" class=\"headerlink\" title=\"code使用\"></a>code使用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person2(nullptr);</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person3(new Person(10));</span><br><span class=\"line\"></span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person4 = std::make_shared&lt;Person&gt;(5); //效率更高，内存分布在一起</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person5(std::move(person3)); // person3无法再使用</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; arary(new Person[10], deletePersonArray);</span><br><span class=\"line\">    </span><br><span class=\"line\">    weak_ptr&lt;Person&gt; weak_Person = person5;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person6 = person5;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    person5.reset();</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    person6.reset();</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (weak_Person.expired()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">        </span><br><span class=\"line\">        auto shareptr = weak_Person.lock();</span><br><span class=\"line\">        </span><br><span class=\"line\">        cout &lt;&lt; shareptr &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h2><h3 id=\"share-ptr使用\"><a href=\"#share-ptr使用\" class=\"headerlink\" title=\"share_ptr使用\"></a>share_ptr使用</h3><h4 id=\"sharet-ptr构造函数和std-make-share-的区别\"><a href=\"#sharet-ptr构造函数和std-make-share-的区别\" class=\"headerlink\" title=\"sharet_ptr构造函数和std::make_share 的区别\"></a>sharet_ptr<T>构造函数和std::make_share<T> 的区别</h4><ol>\n<li>两个堆内存和一个堆内存，std::make_share效率更高</li>\n<li></li>\n</ol>\n<h3 id=\"weak-ptr使用\"><a href=\"#weak-ptr使用\" class=\"headerlink\" title=\"weak_ptr使用\"></a>weak_ptr使用</h3><ol>\n<li>expired(),返回指向对堆对象是否释放</li>\n<li>use_count,share_ptr的强引用计数</li>\n<li>lock，返回share_ptr，如果释放，返回空</li>\n<li></li>\n</ol>\n<h3 id=\"share-ptr线程安全话题\"><a href=\"#share-ptr线程安全话题\" class=\"headerlink\" title=\"share_ptr线程安全话题\"></a>share_ptr线程安全话题</h3><ol>\n<li>share_ptr引用计数本身是线程安全的</li>\n<li>一个share_ptr对象，在多个线程操作，不能保证线程安全</li>\n<li>share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全</li>\n</ol>\n<h3 id=\"stl容器多线程安全时的性能考虑\"><a href=\"#stl容器多线程安全时的性能考虑\" class=\"headerlink\" title=\"stl容器多线程安全时的性能考虑\"></a>stl容器多线程安全时的性能考虑</h3><h3 id=\"code使用\"><a href=\"#code使用\" class=\"headerlink\" title=\"code使用\"></a>code使用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person2(nullptr);</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person3(new Person(10));</span><br><span class=\"line\"></span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person4 = std::make_shared&lt;Person&gt;(5); //效率更高，内存分布在一起</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person5(std::move(person3)); // person3无法再使用</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; arary(new Person[10], deletePersonArray);</span><br><span class=\"line\">    </span><br><span class=\"line\">    weak_ptr&lt;Person&gt; weak_Person = person5;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person6 = person5;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    person5.reset();</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    person6.reset();</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (weak_Person.expired()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">        </span><br><span class=\"line\">        auto shareptr = weak_Person.lock();</span><br><span class=\"line\">        </span><br><span class=\"line\">        cout &lt;&lt; shareptr &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"c++中operator的重载","date":"2022-09-18T07:10:20.000Z","_content":"\n## 两种函数允许编译器进行隐士类型转换\n1. 单一参数调用成功的constructors\n2. 隐士转换操作符\n\n```\nclass Ration {\npublic:\n    //1 隐士构造函数\n    Ration(int a) {\n        \n    }\n    //2 隐士类型转换函数\n    operator double() const {\n        return 5.0f;\n    }\n};\n\n\nint main()\n{\n    Ration ration(1);\n    cout << ration << endl;\n    return 0;\n}\n```\n\n### 如何阻止构造函数发生不期望的隐士类型转换\n```\nclass Ration {\npublic:\n    explicit Ration(int a) {\n        \n    }\n};\n\nint main()\n{\n    Ration ration(1);\n    \n    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错\n    if (ration == 2) {\n        \n    }\n    return 0;\n}\n```\n\n### 重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 && || 操作符， 原因是改变了短路运算的语义，变成函数调用。\n\n#### 这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\n\n\n###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数\n```\nclass Ration {\npublic:\n    explicit Ration(int a) {\n        \n    }\n    \n    int operator() (int a , int b, int c)\n    {\n        return 10;\n    }\n    \n    int operator() (int a , int b)\n    {\n        return 5;\n    }\n};\n\nint main()\n{\n    Ration ration(1);\n    ration(1, 2, 3);\n    ration(1, 3);\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/C++中operator的重载.md","raw":"---\ntitle: c++中operator的重载\ndate: 2022-09-18 15:10:20\ntags: C++11\n---\n\n## 两种函数允许编译器进行隐士类型转换\n1. 单一参数调用成功的constructors\n2. 隐士转换操作符\n\n```\nclass Ration {\npublic:\n    //1 隐士构造函数\n    Ration(int a) {\n        \n    }\n    //2 隐士类型转换函数\n    operator double() const {\n        return 5.0f;\n    }\n};\n\n\nint main()\n{\n    Ration ration(1);\n    cout << ration << endl;\n    return 0;\n}\n```\n\n### 如何阻止构造函数发生不期望的隐士类型转换\n```\nclass Ration {\npublic:\n    explicit Ration(int a) {\n        \n    }\n};\n\nint main()\n{\n    Ration ration(1);\n    \n    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错\n    if (ration == 2) {\n        \n    }\n    return 0;\n}\n```\n\n### 重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 && || 操作符， 原因是改变了短路运算的语义，变成函数调用。\n\n#### 这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\n\n\n###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数\n```\nclass Ration {\npublic:\n    explicit Ration(int a) {\n        \n    }\n    \n    int operator() (int a , int b, int c)\n    {\n        return 10;\n    }\n    \n    int operator() (int a , int b)\n    {\n        return 5;\n    }\n};\n\nint main()\n{\n    Ration ration(1);\n    ration(1, 2, 3);\n    ration(1, 3);\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"C++中operator的重载","published":1,"updated":"2022-10-23T12:52:41.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9lffyvj0001y2vqbzv818m7","content":"<h2 id=\"两种函数允许编译器进行隐士类型转换\"><a href=\"#两种函数允许编译器进行隐士类型转换\" class=\"headerlink\" title=\"两种函数允许编译器进行隐士类型转换\"></a>两种函数允许编译器进行隐士类型转换</h2><ol>\n<li>单一参数调用成功的constructors</li>\n<li>隐士转换操作符</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //1 隐士构造函数</span><br><span class=\"line\">    Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //2 隐士类型转换函数</span><br><span class=\"line\">    operator double() const &#123;</span><br><span class=\"line\">        return 5.0f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    cout &lt;&lt; ration &lt;&lt; endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如何阻止构造函数发生不期望的隐士类型转换\"><a href=\"#如何阻止构造函数发生不期望的隐士类型转换\" class=\"headerlink\" title=\"如何阻止构造函数发生不期望的隐士类型转换\"></a>如何阻止构造函数发生不期望的隐士类型转换</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错</span><br><span class=\"line\">    if (ration == 2) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。\"><a href=\"#重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。\" class=\"headerlink\" title=\"重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。\"></a>重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。</h3><h4 id=\"这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\"><a href=\"#这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\" class=\"headerlink\" title=\"这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\"></a>这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。</h4><p>###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int operator() (int a , int b, int c)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int operator() (int a , int b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    ration(1, 2, 3);</span><br><span class=\"line\">    ration(1, 3);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"两种函数允许编译器进行隐士类型转换\"><a href=\"#两种函数允许编译器进行隐士类型转换\" class=\"headerlink\" title=\"两种函数允许编译器进行隐士类型转换\"></a>两种函数允许编译器进行隐士类型转换</h2><ol>\n<li>单一参数调用成功的constructors</li>\n<li>隐士转换操作符</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //1 隐士构造函数</span><br><span class=\"line\">    Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //2 隐士类型转换函数</span><br><span class=\"line\">    operator double() const &#123;</span><br><span class=\"line\">        return 5.0f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    cout &lt;&lt; ration &lt;&lt; endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如何阻止构造函数发生不期望的隐士类型转换\"><a href=\"#如何阻止构造函数发生不期望的隐士类型转换\" class=\"headerlink\" title=\"如何阻止构造函数发生不期望的隐士类型转换\"></a>如何阻止构造函数发生不期望的隐士类型转换</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错</span><br><span class=\"line\">    if (ration == 2) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。\"><a href=\"#重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。\" class=\"headerlink\" title=\"重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。\"></a>重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。</h3><h4 id=\"这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\"><a href=\"#这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\" class=\"headerlink\" title=\"这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\"></a>这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。</h4><p>###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int operator() (int a , int b, int c)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int operator() (int a , int b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    ration(1, 2, 3);</span><br><span class=\"line\">    ration(1, 3);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"c++ 右值引用","date":"2022-09-18T08:15:56.000Z","_content":"\n### 1. 什么是右值？\n有名称，可以取地址的值，是左值。\n没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。\nc++11中，所有的值，必属于左值，将亡值，和纯右值。\n\n\n\n### 2. 左值引用，右值引用\n\n```\nint main() {\n    \n    int a = 0; //ok\n    \n    int& b = a; //ok,左值引用\n    int& c = 0; // not ok,左值引用无法引用右值\n    \n    const int& d = 0; // ok，常左值引用，可以绑定右值\n    const int& e = a; // ok，常左值引用，可以绑定左值\n    \n    int&& f = 0;//ok 右值引用绑定右值\n    const int && g = 0; // ok,常右值引用可以绑定右值\n    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗\n    \n    int&& h = a;//not ok，右值引用无法绑定左值\n    \n    return 0;\n}\n```\n左值引用，只能绑定左值\n常左值引用，可以绑定常量左值，右值，非常量左值和右值\n右值引用，只能绑定非常量右值\n常右值引用，可以绑定常量右值，非常量右值\n\n\n### 3. 讨论右值引用，要注意排除返回值优化\n如果关闭返回值优化，可以参考\n<https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO>\n\n```\nPerson GetPerson(){\n    return Person();\n}\n\nint main()\n{\n    Person person = GetPerson();\n    person.print();\n    \n    /*\n     一共执行三次构造\n    1 Person()默认构造函数\n    2 GetPerson函数返回时，生成临时对象，调用移动构造函数\n    3 使用临时对象，构造person，调用移动构造函数\n     */\n    return 0;\n}\n```\n\n\n```\nPerson&& GetPerson(){\n    return Person();\n}\n\nint main()\n{\n    Person person = GetPerson();\n    person.print();\n    \n    /*\n     一共执行两次次构造，这种写法是错的，会有warnning\n     Returning reference to local temporary object\n    1 Person()默认构造函数\n    2 右值引用，引用了已经析构的临时对象\n    3 使用临时对象，构造person，调用移动构造函数\n     */\n    return 0;\n}\n```\n\n### 4. 函数返回值，如果没有写左值引用，就是临时变量属于右值\n\n```\nPerson GetPerson(){\n    return Person();\n}\n\nint main() {\n    \n    Person person1 = GetPerson(); //调用一次构造，两次次移动构造\n    \n    Person&& person2 = GetPerson(); //调用一次构造，一次移动构造\n    \n    return 0;\n}\n```\n理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象\nperson2是直接对临时变量的右值引用\n\n#### 注意\n```\nconst Person& GetPerson1(){\n    return Person();\n}\n\nPerson&& GetPerson2(){\n    return Person();\n}\n```\n上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告\n\n`Returning reference to local temporary object`\n\n\n\n\n\n","source":"_posts/C++右值引用.md","raw":"---\ntitle: c++ 右值引用\ndate: 2022-09-18 16:15:56\ntags:\n\t- C++11\n---\n\n### 1. 什么是右值？\n有名称，可以取地址的值，是左值。\n没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。\nc++11中，所有的值，必属于左值，将亡值，和纯右值。\n\n\n\n### 2. 左值引用，右值引用\n\n```\nint main() {\n    \n    int a = 0; //ok\n    \n    int& b = a; //ok,左值引用\n    int& c = 0; // not ok,左值引用无法引用右值\n    \n    const int& d = 0; // ok，常左值引用，可以绑定右值\n    const int& e = a; // ok，常左值引用，可以绑定左值\n    \n    int&& f = 0;//ok 右值引用绑定右值\n    const int && g = 0; // ok,常右值引用可以绑定右值\n    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗\n    \n    int&& h = a;//not ok，右值引用无法绑定左值\n    \n    return 0;\n}\n```\n左值引用，只能绑定左值\n常左值引用，可以绑定常量左值，右值，非常量左值和右值\n右值引用，只能绑定非常量右值\n常右值引用，可以绑定常量右值，非常量右值\n\n\n### 3. 讨论右值引用，要注意排除返回值优化\n如果关闭返回值优化，可以参考\n<https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO>\n\n```\nPerson GetPerson(){\n    return Person();\n}\n\nint main()\n{\n    Person person = GetPerson();\n    person.print();\n    \n    /*\n     一共执行三次构造\n    1 Person()默认构造函数\n    2 GetPerson函数返回时，生成临时对象，调用移动构造函数\n    3 使用临时对象，构造person，调用移动构造函数\n     */\n    return 0;\n}\n```\n\n\n```\nPerson&& GetPerson(){\n    return Person();\n}\n\nint main()\n{\n    Person person = GetPerson();\n    person.print();\n    \n    /*\n     一共执行两次次构造，这种写法是错的，会有warnning\n     Returning reference to local temporary object\n    1 Person()默认构造函数\n    2 右值引用，引用了已经析构的临时对象\n    3 使用临时对象，构造person，调用移动构造函数\n     */\n    return 0;\n}\n```\n\n### 4. 函数返回值，如果没有写左值引用，就是临时变量属于右值\n\n```\nPerson GetPerson(){\n    return Person();\n}\n\nint main() {\n    \n    Person person1 = GetPerson(); //调用一次构造，两次次移动构造\n    \n    Person&& person2 = GetPerson(); //调用一次构造，一次移动构造\n    \n    return 0;\n}\n```\n理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象\nperson2是直接对临时变量的右值引用\n\n#### 注意\n```\nconst Person& GetPerson1(){\n    return Person();\n}\n\nPerson&& GetPerson2(){\n    return Person();\n}\n```\n上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告\n\n`Returning reference to local temporary object`\n\n\n\n\n\n","slug":"C++右值引用","published":1,"updated":"2022-10-25T08:52:46.025Z","_id":"cl9lffyvm0003y2vq4py2b97x","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-什么是右值？\"><a href=\"#1-什么是右值？\" class=\"headerlink\" title=\"1. 什么是右值？\"></a>1. 什么是右值？</h3><p>有名称，可以取地址的值，是左值。<br>没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。<br>c++11中，所有的值，必属于左值，将亡值，和纯右值。</p>\n<h3 id=\"2-左值引用，右值引用\"><a href=\"#2-左值引用，右值引用\" class=\"headerlink\" title=\"2. 左值引用，右值引用\"></a>2. 左值引用，右值引用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int a = 0; //ok</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp; b = a; //ok,左值引用</span><br><span class=\"line\">    int&amp; c = 0; // not ok,左值引用无法引用右值</span><br><span class=\"line\">    </span><br><span class=\"line\">    const int&amp; d = 0; // ok，常左值引用，可以绑定右值</span><br><span class=\"line\">    const int&amp; e = a; // ok，常左值引用，可以绑定左值</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp;&amp; f = 0;//ok 右值引用绑定右值</span><br><span class=\"line\">    const int &amp;&amp; g = 0; // ok,常右值引用可以绑定右值</span><br><span class=\"line\">    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp;&amp; h = a;//not ok，右值引用无法绑定左值</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>左值引用，只能绑定左值<br>常左值引用，可以绑定常量左值，右值，非常量左值和右值<br>右值引用，只能绑定非常量右值<br>常右值引用，可以绑定常量右值，非常量右值</p>\n<h3 id=\"3-讨论右值引用，要注意排除返回值优化\"><a href=\"#3-讨论右值引用，要注意排除返回值优化\" class=\"headerlink\" title=\"3. 讨论右值引用，要注意排除返回值优化\"></a>3. 讨论右值引用，要注意排除返回值优化</h3><p>如果关闭返回值优化，可以参考<br><a href=\"https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO\">https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person = GetPerson();</span><br><span class=\"line\">    person.print();</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     一共执行三次构造</span><br><span class=\"line\">    1 Person()默认构造函数</span><br><span class=\"line\">    2 GetPerson函数返回时，生成临时对象，调用移动构造函数</span><br><span class=\"line\">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person&amp;&amp; GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person = GetPerson();</span><br><span class=\"line\">    person.print();</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     一共执行两次次构造，这种写法是错的，会有warnning</span><br><span class=\"line\">     Returning reference to local temporary object</span><br><span class=\"line\">    1 Person()默认构造函数</span><br><span class=\"line\">    2 右值引用，引用了已经析构的临时对象</span><br><span class=\"line\">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-函数返回值，如果没有写左值引用，就是临时变量属于右值\"><a href=\"#4-函数返回值，如果没有写左值引用，就是临时变量属于右值\" class=\"headerlink\" title=\"4. 函数返回值，如果没有写左值引用，就是临时变量属于右值\"></a>4. 函数返回值，如果没有写左值引用，就是临时变量属于右值</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person person1 = GetPerson(); //调用一次构造，两次次移动构造</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person&amp;&amp; person2 = GetPerson(); //调用一次构造，一次移动构造</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象<br>person2是直接对临时变量的右值引用</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Person&amp; GetPerson1()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person&amp;&amp; GetPerson2()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告</p>\n<p><code>Returning reference to local temporary object</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-什么是右值？\"><a href=\"#1-什么是右值？\" class=\"headerlink\" title=\"1. 什么是右值？\"></a>1. 什么是右值？</h3><p>有名称，可以取地址的值，是左值。<br>没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。<br>c++11中，所有的值，必属于左值，将亡值，和纯右值。</p>\n<h3 id=\"2-左值引用，右值引用\"><a href=\"#2-左值引用，右值引用\" class=\"headerlink\" title=\"2. 左值引用，右值引用\"></a>2. 左值引用，右值引用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int a = 0; //ok</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp; b = a; //ok,左值引用</span><br><span class=\"line\">    int&amp; c = 0; // not ok,左值引用无法引用右值</span><br><span class=\"line\">    </span><br><span class=\"line\">    const int&amp; d = 0; // ok，常左值引用，可以绑定右值</span><br><span class=\"line\">    const int&amp; e = a; // ok，常左值引用，可以绑定左值</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp;&amp; f = 0;//ok 右值引用绑定右值</span><br><span class=\"line\">    const int &amp;&amp; g = 0; // ok,常右值引用可以绑定右值</span><br><span class=\"line\">    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp;&amp; h = a;//not ok，右值引用无法绑定左值</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>左值引用，只能绑定左值<br>常左值引用，可以绑定常量左值，右值，非常量左值和右值<br>右值引用，只能绑定非常量右值<br>常右值引用，可以绑定常量右值，非常量右值</p>\n<h3 id=\"3-讨论右值引用，要注意排除返回值优化\"><a href=\"#3-讨论右值引用，要注意排除返回值优化\" class=\"headerlink\" title=\"3. 讨论右值引用，要注意排除返回值优化\"></a>3. 讨论右值引用，要注意排除返回值优化</h3><p>如果关闭返回值优化，可以参考<br><a href=\"https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO\">https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person = GetPerson();</span><br><span class=\"line\">    person.print();</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     一共执行三次构造</span><br><span class=\"line\">    1 Person()默认构造函数</span><br><span class=\"line\">    2 GetPerson函数返回时，生成临时对象，调用移动构造函数</span><br><span class=\"line\">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person&amp;&amp; GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person = GetPerson();</span><br><span class=\"line\">    person.print();</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     一共执行两次次构造，这种写法是错的，会有warnning</span><br><span class=\"line\">     Returning reference to local temporary object</span><br><span class=\"line\">    1 Person()默认构造函数</span><br><span class=\"line\">    2 右值引用，引用了已经析构的临时对象</span><br><span class=\"line\">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-函数返回值，如果没有写左值引用，就是临时变量属于右值\"><a href=\"#4-函数返回值，如果没有写左值引用，就是临时变量属于右值\" class=\"headerlink\" title=\"4. 函数返回值，如果没有写左值引用，就是临时变量属于右值\"></a>4. 函数返回值，如果没有写左值引用，就是临时变量属于右值</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person person1 = GetPerson(); //调用一次构造，两次次移动构造</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person&amp;&amp; person2 = GetPerson(); //调用一次构造，一次移动构造</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象<br>person2是直接对临时变量的右值引用</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Person&amp; GetPerson1()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person&amp;&amp; GetPerson2()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告</p>\n<p><code>Returning reference to local temporary object</code></p>\n"},{"title":"实现完美转发","date":"2022-10-23T12:36:59.000Z","_content":"\n\n### 什么是完美转发？\n\n#### 在理解什么是完美转发之前，需要知道什么是万能引用?\n在模板推导过程中，使用T&& a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。\n\n```\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    cout << a << endl;\n    cout << b << endl;\n}\n\nint main() {\n    \n    Add(4, 5); // a，b的类型会被推导成int&&\n    int a = 0;\n    int b = 0;\n    Add(a, b); // a，b的类型会被推导成int&\n    \n    return 0;\n}\n```\n根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用\n\n\n#### 万能引用遇到的问题？\n上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.\n```\ntemplate <typename T>\nvoid AddImp(T&& a, T&& b) {\n    cout << a << endl;\n    cout << b << endl;\n}\n\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    AddImp(a, b);\n}\n\nint main() {\n    \n    Add(4, 5);\n    int a = 0;\n    int b = 0;\n    Add(a, b);\n    \n    return 0;\n}\n```\n\n#### 解决方案: std::forward<T>\n```\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    AddImp(std::forward<T>(a), std::forward<T>(b));\n}\n\n```\nstd::forward的具体实现\n```\ntemplate <class _Tp>\n_Tp&& forward(typename remove_reference<_Tp>::type& __t) \n{\n  return static_cast<_Tp&&>(__t);\n}\n```\n\n具体分析一下，也是通过引用折叠来实现\n1. 如果_Tp的类型是int&， 通过引用折叠 int& && 折叠后是左值引用int&\n2. 如果_Tp的类型是int&&， 通过引用折叠 int&& && 折叠后是int&&\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/C++实现完美转发.md","raw":"---\ntitle: 实现完美转发\ndate: 2022-10-23 20:36:59\ntags: C++11\n---\n\n\n### 什么是完美转发？\n\n#### 在理解什么是完美转发之前，需要知道什么是万能引用?\n在模板推导过程中，使用T&& a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。\n\n```\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    cout << a << endl;\n    cout << b << endl;\n}\n\nint main() {\n    \n    Add(4, 5); // a，b的类型会被推导成int&&\n    int a = 0;\n    int b = 0;\n    Add(a, b); // a，b的类型会被推导成int&\n    \n    return 0;\n}\n```\n根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用\n\n\n#### 万能引用遇到的问题？\n上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.\n```\ntemplate <typename T>\nvoid AddImp(T&& a, T&& b) {\n    cout << a << endl;\n    cout << b << endl;\n}\n\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    AddImp(a, b);\n}\n\nint main() {\n    \n    Add(4, 5);\n    int a = 0;\n    int b = 0;\n    Add(a, b);\n    \n    return 0;\n}\n```\n\n#### 解决方案: std::forward<T>\n```\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    AddImp(std::forward<T>(a), std::forward<T>(b));\n}\n\n```\nstd::forward的具体实现\n```\ntemplate <class _Tp>\n_Tp&& forward(typename remove_reference<_Tp>::type& __t) \n{\n  return static_cast<_Tp&&>(__t);\n}\n```\n\n具体分析一下，也是通过引用折叠来实现\n1. 如果_Tp的类型是int&， 通过引用折叠 int& && 折叠后是左值引用int&\n2. 如果_Tp的类型是int&&， 通过引用折叠 int&& && 折叠后是int&&\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"C++实现完美转发","published":1,"updated":"2022-11-08T02:47:13.674Z","_id":"cl9lffyvn0004y2vq69avcwmr","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"什么是完美转发？\"><a href=\"#什么是完美转发？\" class=\"headerlink\" title=\"什么是完美转发？\"></a>什么是完美转发？</h3><h4 id=\"在理解什么是完美转发之前，需要知道什么是万能引用\"><a href=\"#在理解什么是完美转发之前，需要知道什么是万能引用\" class=\"headerlink\" title=\"在理解什么是完美转发之前，需要知道什么是万能引用?\"></a>在理解什么是完美转发之前，需要知道什么是万能引用?</h4><p>在模板推导过程中，使用T&amp;&amp; a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Add(4, 5); // a，b的类型会被推导成int&amp;&amp;</span><br><span class=\"line\">    int a = 0;</span><br><span class=\"line\">    int b = 0;</span><br><span class=\"line\">    Add(a, b); // a，b的类型会被推导成int&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用</p>\n<h4 id=\"万能引用遇到的问题？\"><a href=\"#万能引用遇到的问题？\" class=\"headerlink\" title=\"万能引用遇到的问题？\"></a>万能引用遇到的问题？</h4><p>上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void AddImp(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    AddImp(a, b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Add(4, 5);</span><br><span class=\"line\">    int a = 0;</span><br><span class=\"line\">    int b = 0;</span><br><span class=\"line\">    Add(a, b);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"解决方案-std-forward\"><a href=\"#解决方案-std-forward\" class=\"headerlink\" title=\"解决方案: std::forward\"></a>解决方案: std::forward<T></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    AddImp(std::forward&lt;T&gt;(a), std::forward&lt;T&gt;(b));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>std::forward的具体实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class _Tp&gt;</span><br><span class=\"line\">_Tp&amp;&amp; forward(typename remove_reference&lt;_Tp&gt;::type&amp; __t) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体分析一下，也是通过引用折叠来实现</p>\n<ol>\n<li>如果_Tp的类型是int&amp;， 通过引用折叠 int&amp; &amp;&amp; 折叠后是左值引用int&amp;</li>\n<li>如果_Tp的类型是int&amp;&amp;， 通过引用折叠 int&amp;&amp; &amp;&amp; 折叠后是int&amp;&amp;</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是完美转发？\"><a href=\"#什么是完美转发？\" class=\"headerlink\" title=\"什么是完美转发？\"></a>什么是完美转发？</h3><h4 id=\"在理解什么是完美转发之前，需要知道什么是万能引用\"><a href=\"#在理解什么是完美转发之前，需要知道什么是万能引用\" class=\"headerlink\" title=\"在理解什么是完美转发之前，需要知道什么是万能引用?\"></a>在理解什么是完美转发之前，需要知道什么是万能引用?</h4><p>在模板推导过程中，使用T&amp;&amp; a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Add(4, 5); // a，b的类型会被推导成int&amp;&amp;</span><br><span class=\"line\">    int a = 0;</span><br><span class=\"line\">    int b = 0;</span><br><span class=\"line\">    Add(a, b); // a，b的类型会被推导成int&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用</p>\n<h4 id=\"万能引用遇到的问题？\"><a href=\"#万能引用遇到的问题？\" class=\"headerlink\" title=\"万能引用遇到的问题？\"></a>万能引用遇到的问题？</h4><p>上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void AddImp(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    AddImp(a, b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Add(4, 5);</span><br><span class=\"line\">    int a = 0;</span><br><span class=\"line\">    int b = 0;</span><br><span class=\"line\">    Add(a, b);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"解决方案-std-forward\"><a href=\"#解决方案-std-forward\" class=\"headerlink\" title=\"解决方案: std::forward\"></a>解决方案: std::forward<T></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    AddImp(std::forward&lt;T&gt;(a), std::forward&lt;T&gt;(b));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>std::forward的具体实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class _Tp&gt;</span><br><span class=\"line\">_Tp&amp;&amp; forward(typename remove_reference&lt;_Tp&gt;::type&amp; __t) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体分析一下，也是通过引用折叠来实现</p>\n<ol>\n<li>如果_Tp的类型是int&amp;， 通过引用折叠 int&amp; &amp;&amp; 折叠后是左值引用int&amp;</li>\n<li>如果_Tp的类型是int&amp;&amp;， 通过引用折叠 int&amp;&amp; &amp;&amp; 折叠后是int&amp;&amp;</li>\n</ol>\n"},{"title":"C++ 构造函数","date":"2022-09-18T02:54:51.000Z","_content":"\n## C++ 构造函数\n\n1. 默认构造\n2. copy构造\n3. 移动构造\n4. operator= 赋值函数\n\n\n### 说明\n\n1. 对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用\n\n```\nclass Person\n{\npublic:\n    Person() {\n        cout << \"Person()\" << endl;\n    };\n    ~Person() {\n        cout << \"~Person()\" << endl;\n    };\n\n    Person(const Person& Person) {\n        cout << \"Person(Person& Person)\" << endl;\n    }\n    \n    Person(Person&& Person) {\n        cout << \"Person(Person&& Person)\" << endl;\n    }\n    \n    Person& operator=(const Person&)\n    {\n        cout << \"operator=(const Person&)\" << endl;\n        return *this;\n    }\n};\n\n```\n\n2. 对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。\n\n```\nclass Person\n{\npublic:\n//    Person() {\n//        cout << \"Person()\" << endl;\n//    };\n    ~Person() {\n        cout << \"~Person()\" << endl;\n    };\n\n//    Person(const Person& Person) {\n//        cout << \"Person(Person& Person)\" << endl;\n//    }\n\n    Person(Person&& Person) {\n        cout << \"Person(Person&& Person)\" << endl;\n    }\n\n    Person& operator=(const Person&)\n    {\n        cout << \"operator=(const Person&)\" << endl;\n        return *this;\n    }\n};\n\nint main()\n{\n    Person person; //编译报错，找不到匹配的构造函数\n    return 0;\n\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/C++构造函数.md","raw":"---\ntitle: C++ 构造函数\ndate: 2022-09-18 10:54:51\ntags: C++11\n---\n\n## C++ 构造函数\n\n1. 默认构造\n2. copy构造\n3. 移动构造\n4. operator= 赋值函数\n\n\n### 说明\n\n1. 对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用\n\n```\nclass Person\n{\npublic:\n    Person() {\n        cout << \"Person()\" << endl;\n    };\n    ~Person() {\n        cout << \"~Person()\" << endl;\n    };\n\n    Person(const Person& Person) {\n        cout << \"Person(Person& Person)\" << endl;\n    }\n    \n    Person(Person&& Person) {\n        cout << \"Person(Person&& Person)\" << endl;\n    }\n    \n    Person& operator=(const Person&)\n    {\n        cout << \"operator=(const Person&)\" << endl;\n        return *this;\n    }\n};\n\n```\n\n2. 对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。\n\n```\nclass Person\n{\npublic:\n//    Person() {\n//        cout << \"Person()\" << endl;\n//    };\n    ~Person() {\n        cout << \"~Person()\" << endl;\n    };\n\n//    Person(const Person& Person) {\n//        cout << \"Person(Person& Person)\" << endl;\n//    }\n\n    Person(Person&& Person) {\n        cout << \"Person(Person&& Person)\" << endl;\n    }\n\n    Person& operator=(const Person&)\n    {\n        cout << \"operator=(const Person&)\" << endl;\n        return *this;\n    }\n};\n\nint main()\n{\n    Person person; //编译报错，找不到匹配的构造函数\n    return 0;\n\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"C++构造函数","published":1,"updated":"2022-10-23T12:53:07.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9lffyvo0005y2vq4sih91wm","content":"<h2 id=\"C-构造函数\"><a href=\"#C-构造函数\" class=\"headerlink\" title=\"C++ 构造函数\"></a>C++ 构造函数</h2><ol>\n<li>默认构造</li>\n<li>copy构造</li>\n<li>移动构造</li>\n<li>operator= 赋值函数</li>\n</ol>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><ol>\n<li>对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(const Person&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person(Person&amp;&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person&amp; operator=(const Person&amp;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">//    Person() &#123;</span><br><span class=\"line\">//        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">//    &#125;;</span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//    Person(const Person&amp; Person) &#123;</span><br><span class=\"line\">//        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">//    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(Person&amp;&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person&amp; operator=(const Person&amp;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person; //编译报错，找不到匹配的构造函数</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-构造函数\"><a href=\"#C-构造函数\" class=\"headerlink\" title=\"C++ 构造函数\"></a>C++ 构造函数</h2><ol>\n<li>默认构造</li>\n<li>copy构造</li>\n<li>移动构造</li>\n<li>operator= 赋值函数</li>\n</ol>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><ol>\n<li>对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(const Person&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person(Person&amp;&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person&amp; operator=(const Person&amp;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">//    Person() &#123;</span><br><span class=\"line\">//        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">//    &#125;;</span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//    Person(const Person&amp; Person) &#123;</span><br><span class=\"line\">//        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">//    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(Person&amp;&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person&amp; operator=(const Person&amp;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person; //编译报错，找不到匹配的构造函数</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"layout":"post","title":"CALayer opaque","date":"2016-12-30T02:51:46.000Z","_content":"\n### 颜色合成公式\n\n**R = S + D \\* ( 1 – Sa )**\n\n ![20130819170332968](/Users/baidu/Downloads/20130819170332968.png)\n\n其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。\n\n设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算\n\n注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期\n","source":"_posts/CALayer-opaque.md","raw":"---\nlayout: post\ntitle: CALayer opaque\ndate: 2016-12-30 10:51:46\ntags: iOS\n\n---\n\n### 颜色合成公式\n\n**R = S + D \\* ( 1 – Sa )**\n\n ![20130819170332968](/Users/baidu/Downloads/20130819170332968.png)\n\n其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。\n\n设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算\n\n注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期\n","slug":"CALayer-opaque","published":1,"updated":"2022-10-23T12:58:35.840Z","comments":1,"photos":[],"link":"","_id":"cl9lffyvq0008y2vq3tkbh4xb","content":"<h3 id=\"颜色合成公式\"><a href=\"#颜色合成公式\" class=\"headerlink\" title=\"颜色合成公式\"></a>颜色合成公式</h3><p><strong>R = S + D * ( 1 – Sa )</strong></p>\n<p> <img src=\"/Users/baidu/Downloads/20130819170332968.png\" alt=\"20130819170332968\"></p>\n<p>其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。</p>\n<p>设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算</p>\n<p>注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"颜色合成公式\"><a href=\"#颜色合成公式\" class=\"headerlink\" title=\"颜色合成公式\"></a>颜色合成公式</h3><p><strong>R = S + D * ( 1 – Sa )</strong></p>\n<p> <img src=\"/Users/baidu/Downloads/20130819170332968.png\" alt=\"20130819170332968\"></p>\n<p>其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。</p>\n<p>设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算</p>\n<p>注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期</p>\n"},{"layout":"post","title":"CALayer属性positon和anchor","date":"2016-10-26T06:24:18.000Z","_content":"\n\n\n### CALayer 的frame，bounds, position和anchor\n\nframe描述的是在父layer上的坐标和尺寸\n\nbounds是类似于View的bounds\n\nanchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）\n\nposition描述的是anchor的在父layer的坐标\n\n\n\n举例来说，一个View的Frame是（40，40，100，100）\n\n那么layer的frame是（40，40，100，100）\n\nbound是（0，0，100，100）\n\nposition是：（140，140）\n\nposition计算：\n\npos.x = origin.x + anchor.x*size.with\n\npos.y = origin.y + anchor.y*size.height\n\n\n如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化\n\n如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可\n\n    CGRect oldFrame = _redView.frame;\n    _redView.layer.anchorPoint = CGPointMake(0.5, 1);\n    _redView.frame = oldFrame;\n注意，position并不适用这一点","source":"_posts/CALayer属性positon和anchor.md","raw":"---\nlayout: post\ntitle: CALayer属性positon和anchor\ndate: 2016-10-26 14:24:18\ntags: iOS\n---\n\n\n\n### CALayer 的frame，bounds, position和anchor\n\nframe描述的是在父layer上的坐标和尺寸\n\nbounds是类似于View的bounds\n\nanchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）\n\nposition描述的是anchor的在父layer的坐标\n\n\n\n举例来说，一个View的Frame是（40，40，100，100）\n\n那么layer的frame是（40，40，100，100）\n\nbound是（0，0，100，100）\n\nposition是：（140，140）\n\nposition计算：\n\npos.x = origin.x + anchor.x*size.with\n\npos.y = origin.y + anchor.y*size.height\n\n\n如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化\n\n如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可\n\n    CGRect oldFrame = _redView.frame;\n    _redView.layer.anchorPoint = CGPointMake(0.5, 1);\n    _redView.frame = oldFrame;\n注意，position并不适用这一点","slug":"CALayer属性positon和anchor","published":1,"updated":"2017-12-20T09:50:13.000Z","comments":1,"photos":[],"link":"","_id":"cl9lffyvr000ay2vqgxs0fhnu","content":"<h3 id=\"CALayer-的frame，bounds-position和anchor\"><a href=\"#CALayer-的frame，bounds-position和anchor\" class=\"headerlink\" title=\"CALayer 的frame，bounds, position和anchor\"></a>CALayer 的frame，bounds, position和anchor</h3><p>frame描述的是在父layer上的坐标和尺寸</p>\n<p>bounds是类似于View的bounds</p>\n<p>anchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）</p>\n<p>position描述的是anchor的在父layer的坐标</p>\n<p>举例来说，一个View的Frame是（40，40，100，100）</p>\n<p>那么layer的frame是（40，40，100，100）</p>\n<p>bound是（0，0，100，100）</p>\n<p>position是：（140，140）</p>\n<p>position计算：</p>\n<p>pos.x = origin.x + anchor.x*size.with</p>\n<p>pos.y = origin.y + anchor.y*size.height</p>\n<p>如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化</p>\n<p>如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可</p>\n<pre><code>CGRect oldFrame = _redView.frame;\n_redView.layer.anchorPoint = CGPointMake(0.5, 1);\n_redView.frame = oldFrame;\n</code></pre>\n<p>注意，position并不适用这一点</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"CALayer-的frame，bounds-position和anchor\"><a href=\"#CALayer-的frame，bounds-position和anchor\" class=\"headerlink\" title=\"CALayer 的frame，bounds, position和anchor\"></a>CALayer 的frame，bounds, position和anchor</h3><p>frame描述的是在父layer上的坐标和尺寸</p>\n<p>bounds是类似于View的bounds</p>\n<p>anchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）</p>\n<p>position描述的是anchor的在父layer的坐标</p>\n<p>举例来说，一个View的Frame是（40，40，100，100）</p>\n<p>那么layer的frame是（40，40，100，100）</p>\n<p>bound是（0，0，100，100）</p>\n<p>position是：（140，140）</p>\n<p>position计算：</p>\n<p>pos.x = origin.x + anchor.x*size.with</p>\n<p>pos.y = origin.y + anchor.y*size.height</p>\n<p>如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化</p>\n<p>如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可</p>\n<pre><code>CGRect oldFrame = _redView.frame;\n_redView.layer.anchorPoint = CGPointMake(0.5, 1);\n_redView.frame = oldFrame;\n</code></pre>\n<p>注意，position并不适用这一点</p>\n"},{"layout":"post","title":"iOSCALayer的presentLayer那点事","subtitle":"关于PresentLayer","date":"2017-11-11T16:00:00.000Z","author":"jack","header-img":"img/post-bg-ios9-web.jpg","catalog":true,"_content":"\n\n> 最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决\n\n\n\n### 动画过程中，如何获取它的实时位置\n\n这个话题涉及对CALayer的理解和使用\n\nCALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer\n\n\n\n- modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据\n- presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试\n\n\n\n```\nUIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];\n\n    view.backgroundColor = [UIColor redColor];\n\n    [self.view addSubview:view];\n\n    NSLog(@\"model   Layeer = %@\", NSStringFromCGRect([view.layer modelLayer].frame));\n\n    NSLog(@\"present Layeer = %@\", NSStringFromCGRect([view.layer presentationLayer].frame));\n\n    [UIView animateWithDuration:10 animations:^{\n\n        view.frame = CGRectMake(200, 100, 100, 100);\n        \n    } completion:^(BOOL finished) {\n    }];\n\n    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n    \n        NSLog(@\"model   Layeer = %@\", NSStringFromCGRect([view.layer modelLayer].frame));\n        NSLog(@\"present Layeer = %@\", NSStringFromCGRect([view.layer presentationLayer].frame));\n    }];\n\n```\n\n\n\n通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置\n","source":"_posts/CALayer的presentLayer那点事.md","raw":"---\nlayout:     post\ntitle:      iOSCALayer的presentLayer那点事\nsubtitle:   关于PresentLayer\ndate:       2017-11-12\nauthor:     jack\nheader-img: img/post-bg-ios9-web.jpg\ncatalog: true\ntags:\n    - iOS\n---\n\n\n> 最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决\n\n\n\n### 动画过程中，如何获取它的实时位置\n\n这个话题涉及对CALayer的理解和使用\n\nCALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer\n\n\n\n- modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据\n- presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试\n\n\n\n```\nUIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];\n\n    view.backgroundColor = [UIColor redColor];\n\n    [self.view addSubview:view];\n\n    NSLog(@\"model   Layeer = %@\", NSStringFromCGRect([view.layer modelLayer].frame));\n\n    NSLog(@\"present Layeer = %@\", NSStringFromCGRect([view.layer presentationLayer].frame));\n\n    [UIView animateWithDuration:10 animations:^{\n\n        view.frame = CGRectMake(200, 100, 100, 100);\n        \n    } completion:^(BOOL finished) {\n    }];\n\n    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n    \n        NSLog(@\"model   Layeer = %@\", NSStringFromCGRect([view.layer modelLayer].frame));\n        NSLog(@\"present Layeer = %@\", NSStringFromCGRect([view.layer presentationLayer].frame));\n    }];\n\n```\n\n\n\n通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置\n","slug":"CALayer的presentLayer那点事","published":1,"updated":"2022-10-23T12:54:02.206Z","comments":1,"photos":[],"link":"","_id":"cl9lffyvt000dy2vq2v714z0j","content":"<blockquote>\n<p>最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决</p>\n</blockquote>\n<h3 id=\"动画过程中，如何获取它的实时位置\"><a href=\"#动画过程中，如何获取它的实时位置\" class=\"headerlink\" title=\"动画过程中，如何获取它的实时位置\"></a>动画过程中，如何获取它的实时位置</h3><p>这个话题涉及对CALayer的理解和使用</p>\n<p>CALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer</p>\n<ul>\n<li>modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据</li>\n<li>presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class=\"line\"></span><br><span class=\"line\">    view.backgroundColor = [UIColor redColor];</span><br><span class=\"line\"></span><br><span class=\"line\">    [self.view addSubview:view];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class=\"line\"></span><br><span class=\"line\">    [UIView animateWithDuration:10 animations:^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        view.frame = CGRectMake(200, 100, 100, 100);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; completion:^(BOOL finished) &#123;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class=\"line\">        NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决</p>\n</blockquote>\n<h3 id=\"动画过程中，如何获取它的实时位置\"><a href=\"#动画过程中，如何获取它的实时位置\" class=\"headerlink\" title=\"动画过程中，如何获取它的实时位置\"></a>动画过程中，如何获取它的实时位置</h3><p>这个话题涉及对CALayer的理解和使用</p>\n<p>CALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer</p>\n<ul>\n<li>modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据</li>\n<li>presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class=\"line\"></span><br><span class=\"line\">    view.backgroundColor = [UIColor redColor];</span><br><span class=\"line\"></span><br><span class=\"line\">    [self.view addSubview:view];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class=\"line\"></span><br><span class=\"line\">    [UIView animateWithDuration:10 animations:^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        view.frame = CGRectMake(200, 100, 100, 100);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; completion:^(BOOL finished) &#123;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class=\"line\">        NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置</p>\n"},{"layout":"post","title":"怎么build apple watch app","date":"2016-10-26T06:24:18.000Z","_content":"\n### step1\n\n在IphoneCom 的Embedded Binaries中添加Watch.app\n\n### step2\n\nRun IphoneCom\n\n### Step3\n\nrun WachApp\n","source":"_posts/How to build Apple Watch App.md","raw":"---\nlayout: post\ntitle: 怎么build apple watch app\ndate: 2016-10-26 14:24:18\ntags: iOS\n---\n\n### step1\n\n在IphoneCom 的Embedded Binaries中添加Watch.app\n\n### step2\n\nRun IphoneCom\n\n### Step3\n\nrun WachApp\n","slug":"How to build Apple Watch App","published":1,"updated":"2022-10-23T12:58:21.288Z","comments":1,"photos":[],"link":"","_id":"cl9lffyvu000fy2vq44oy9srb","content":"<h3 id=\"step1\"><a href=\"#step1\" class=\"headerlink\" title=\"step1\"></a>step1</h3><p>在IphoneCom 的Embedded Binaries中添加Watch.app</p>\n<h3 id=\"step2\"><a href=\"#step2\" class=\"headerlink\" title=\"step2\"></a>step2</h3><p>Run IphoneCom</p>\n<h3 id=\"Step3\"><a href=\"#Step3\" class=\"headerlink\" title=\"Step3\"></a>Step3</h3><p>run WachApp</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"step1\"><a href=\"#step1\" class=\"headerlink\" title=\"step1\"></a>step1</h3><p>在IphoneCom 的Embedded Binaries中添加Watch.app</p>\n<h3 id=\"step2\"><a href=\"#step2\" class=\"headerlink\" title=\"step2\"></a>step2</h3><p>Run IphoneCom</p>\n<h3 id=\"Step3\"><a href=\"#Step3\" class=\"headerlink\" title=\"Step3\"></a>Step3</h3><p>run WachApp</p>\n"},{"layout":"post","title":"Mac环境下安装Ruby","subtitle":"ruby2.2","date":"2017-09-18T16:00:00.000Z","author":"jack","catalog":true,"_content":"\n## 使用rvm来安装ruby\n\n### step1\n```\n\t$ curl -L get.rvm.io | bash -s stable  \n```\n### step2  \n```\n\t$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  \n\t$ source ~/.bash_profile  \n\t$ rvm -v  \n```\t\n### step3  \n```\t\n\t$ rvm list known  \n```\t\n### step4\n```    \n\t$ rvm install 2.2.0  \n```\n\n### 如果Step4失败，可以进行如下尝试\n```\n\tsudo chown -R $(whoami):admin /usr/local\n\tcd /usr/local\n\tgit remote set-url origin git://mirrors.ustc.edu.cn/brew.git\n\tbrew update\n\tsudo chown root:wheel /usr/local\n\trvm install 2.2.0\n```\n","source":"_posts/MacOS下ruby安装.md","raw":"---\nlayout:     post\ntitle:      Mac环境下安装Ruby\nsubtitle:   ruby2.2\ndate:       2017-09-19\nauthor:     jack\ncatalog: true\ntags:\n    - iOS\n    - ruby\n---\n\n## 使用rvm来安装ruby\n\n### step1\n```\n\t$ curl -L get.rvm.io | bash -s stable  \n```\n### step2  \n```\n\t$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  \n\t$ source ~/.bash_profile  \n\t$ rvm -v  \n```\t\n### step3  \n```\t\n\t$ rvm list known  \n```\t\n### step4\n```    \n\t$ rvm install 2.2.0  \n```\n\n### 如果Step4失败，可以进行如下尝试\n```\n\tsudo chown -R $(whoami):admin /usr/local\n\tcd /usr/local\n\tgit remote set-url origin git://mirrors.ustc.edu.cn/brew.git\n\tbrew update\n\tsudo chown root:wheel /usr/local\n\trvm install 2.2.0\n```\n","slug":"MacOS下ruby安装","published":1,"updated":"2022-10-23T12:55:27.057Z","comments":1,"photos":[],"link":"","_id":"cl9lffyvw000iy2vqeknfd1ia","content":"<h2 id=\"使用rvm来安装ruby\"><a href=\"#使用rvm来安装ruby\" class=\"headerlink\" title=\"使用rvm来安装ruby\"></a>使用rvm来安装ruby</h2><h3 id=\"step1\"><a href=\"#step1\" class=\"headerlink\" title=\"step1\"></a>step1</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -L get.rvm.io | bash -s stable  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step2\"><a href=\"#step2\" class=\"headerlink\" title=\"step2\"></a>step2</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  </span><br><span class=\"line\">$ source ~/.bash_profile  </span><br><span class=\"line\">$ rvm -v  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step3\"><a href=\"#step3\" class=\"headerlink\" title=\"step3\"></a>step3</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rvm list known  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step4\"><a href=\"#step4\" class=\"headerlink\" title=\"step4\"></a>step4</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rvm install 2.2.0  </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如果Step4失败，可以进行如下尝试\"><a href=\"#如果Step4失败，可以进行如下尝试\" class=\"headerlink\" title=\"如果Step4失败，可以进行如下尝试\"></a>如果Step4失败，可以进行如下尝试</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown -R $(whoami):admin /usr/local</span><br><span class=\"line\">cd /usr/local</span><br><span class=\"line\">git remote set-url origin git://mirrors.ustc.edu.cn/brew.git</span><br><span class=\"line\">brew update</span><br><span class=\"line\">sudo chown root:wheel /usr/local</span><br><span class=\"line\">rvm install 2.2.0</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"使用rvm来安装ruby\"><a href=\"#使用rvm来安装ruby\" class=\"headerlink\" title=\"使用rvm来安装ruby\"></a>使用rvm来安装ruby</h2><h3 id=\"step1\"><a href=\"#step1\" class=\"headerlink\" title=\"step1\"></a>step1</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -L get.rvm.io | bash -s stable  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step2\"><a href=\"#step2\" class=\"headerlink\" title=\"step2\"></a>step2</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  </span><br><span class=\"line\">$ source ~/.bash_profile  </span><br><span class=\"line\">$ rvm -v  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step3\"><a href=\"#step3\" class=\"headerlink\" title=\"step3\"></a>step3</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rvm list known  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step4\"><a href=\"#step4\" class=\"headerlink\" title=\"step4\"></a>step4</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rvm install 2.2.0  </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如果Step4失败，可以进行如下尝试\"><a href=\"#如果Step4失败，可以进行如下尝试\" class=\"headerlink\" title=\"如果Step4失败，可以进行如下尝试\"></a>如果Step4失败，可以进行如下尝试</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown -R $(whoami):admin /usr/local</span><br><span class=\"line\">cd /usr/local</span><br><span class=\"line\">git remote set-url origin git://mirrors.ustc.edu.cn/brew.git</span><br><span class=\"line\">brew update</span><br><span class=\"line\">sudo chown root:wheel /usr/local</span><br><span class=\"line\">rvm install 2.2.0</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"VBO","date":"2017-01-02T05:19:23.000Z","_content":"\n### VBO的目的：\n\n主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间\n\n两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER\n\n分别对应顶点数据和索引\n\n使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量\n\n### VBO使用的大概流程：\n\n```\n    //获取一个操作句柄\n    glGenBuffers(1, &_vertexBuffer);\n    //设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引\n    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);\n    //分配内存空间\n    glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);\n    \n    在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别\n    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);\n    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);\n    glEnableVertexAttribArray(_positionSlot);\n    \n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);\n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);\n    \n    //可以在清理时，释放VBO\n    glDeleteBuffers(1, &_vertexBuffer);\n    _vertexBuffer = 0;\n    \n    glDeleteBuffers(1, &_triangleIndexBuffer);\n    _triangleIndexBuffer = 0;\n    \n```\n\n","source":"_posts/OpenGL-VBO.md","raw":"---\nlayout: post\ntitle: VBO\ndate: 2017-01-02 13:19:23\ntags: openGL\n---\n\n### VBO的目的：\n\n主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间\n\n两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER\n\n分别对应顶点数据和索引\n\n使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量\n\n### VBO使用的大概流程：\n\n```\n    //获取一个操作句柄\n    glGenBuffers(1, &_vertexBuffer);\n    //设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引\n    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);\n    //分配内存空间\n    glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);\n    \n    在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别\n    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);\n    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);\n    glEnableVertexAttribArray(_positionSlot);\n    \n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);\n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);\n    \n    //可以在清理时，释放VBO\n    glDeleteBuffers(1, &_vertexBuffer);\n    _vertexBuffer = 0;\n    \n    glDeleteBuffers(1, &_triangleIndexBuffer);\n    _triangleIndexBuffer = 0;\n    \n```\n\n","slug":"OpenGL-VBO","published":1,"updated":"2017-12-20T09:50:13.000Z","comments":1,"photos":[],"link":"","_id":"cl9lffyvx000jy2vq8dnc9pxr","content":"<h3 id=\"VBO的目的：\"><a href=\"#VBO的目的：\" class=\"headerlink\" title=\"VBO的目的：\"></a>VBO的目的：</h3><p>主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间</p>\n<p>两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER</p>\n<p>分别对应顶点数据和索引</p>\n<p>使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量</p>\n<h3 id=\"VBO使用的大概流程：\"><a href=\"#VBO使用的大概流程：\" class=\"headerlink\" title=\"VBO使用的大概流程：\"></a>VBO使用的大概流程：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取一个操作句柄</span><br><span class=\"line\">glGenBuffers(1, &amp;_vertexBuffer);</span><br><span class=\"line\">//设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class=\"line\">//分配内存空间</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class=\"line\">glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);</span><br><span class=\"line\">glEnableVertexAttribArray(_positionSlot);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//可以在清理时，释放VBO</span><br><span class=\"line\">glDeleteBuffers(1, &amp;_vertexBuffer);</span><br><span class=\"line\">_vertexBuffer = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">glDeleteBuffers(1, &amp;_triangleIndexBuffer);</span><br><span class=\"line\">_triangleIndexBuffer = 0;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"VBO的目的：\"><a href=\"#VBO的目的：\" class=\"headerlink\" title=\"VBO的目的：\"></a>VBO的目的：</h3><p>主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间</p>\n<p>两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER</p>\n<p>分别对应顶点数据和索引</p>\n<p>使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量</p>\n<h3 id=\"VBO使用的大概流程：\"><a href=\"#VBO使用的大概流程：\" class=\"headerlink\" title=\"VBO使用的大概流程：\"></a>VBO使用的大概流程：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取一个操作句柄</span><br><span class=\"line\">glGenBuffers(1, &amp;_vertexBuffer);</span><br><span class=\"line\">//设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class=\"line\">//分配内存空间</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class=\"line\">glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);</span><br><span class=\"line\">glEnableVertexAttribArray(_positionSlot);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//可以在清理时，释放VBO</span><br><span class=\"line\">glDeleteBuffers(1, &amp;_vertexBuffer);</span><br><span class=\"line\">_vertexBuffer = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">glDeleteBuffers(1, &amp;_triangleIndexBuffer);</span><br><span class=\"line\">_triangleIndexBuffer = 0;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"layout":"post","title":"uniform和attribute区别","date":"2016-12-30T08:17:50.000Z","_content":"\n#### 简单对比一下\n\nattribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用\n\nuniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用\n\n\n\n使用上的区别：\n\n1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法\n\n2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制\n\n3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements\n\n","source":"_posts/OpenGL-uniform和attribute.md","raw":"---\nlayout: post\ntitle: uniform和attribute区别\ndate: 2016-12-30 16:17:50\ntags: openGL\n---\n\n#### 简单对比一下\n\nattribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用\n\nuniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用\n\n\n\n使用上的区别：\n\n1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法\n\n2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制\n\n3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements\n\n","slug":"OpenGL-uniform和attribute","published":1,"updated":"2017-12-20T09:50:13.000Z","comments":1,"photos":[],"link":"","_id":"cl9lffyvy000ly2vq4fyy2hn8","content":"<h4 id=\"简单对比一下\"><a href=\"#简单对比一下\" class=\"headerlink\" title=\"简单对比一下\"></a>简单对比一下</h4><p>attribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用</p>\n<p>uniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用</p>\n<p>使用上的区别：</p>\n<p>1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法</p>\n<p>2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制</p>\n<p>3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简单对比一下\"><a href=\"#简单对比一下\" class=\"headerlink\" title=\"简单对比一下\"></a>简单对比一下</h4><p>attribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用</p>\n<p>uniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用</p>\n<p>使用上的区别：</p>\n<p>1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法</p>\n<p>2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制</p>\n<p>3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements</p>\n"},{"layout":"post","title":"光照学习","date":"2017-01-02T05:43:54.000Z","_content":"\n### 基本概念\n\n1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性\n\n2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）\n\n3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射\n\n4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节\n\n\n\n### 光的计算：\n\n1 发射光计算：发射颜色=物体的发射材质颜色\n\n2 环境光计算\n\n环境颜色 = 光源的环境光颜色*物体的环境材质颜色\n\n3 漫反射计算：\n\n漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor\n\n其中DiffuseFactor = max（0，dot（N，L））\n\ndot表示两个向量夹角的cos\n\n4 镜面反射：\n\n镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor\n\nSpecularFactor = power（max（0， dot（N，H）），shininess）\n\nH = normalise（L+E）\n\n","source":"_posts/OpenGL-光照学习.md","raw":"---\nlayout: post\ntitle: 光照学习\ndate: 2017-01-02 13:43:54\ntags: openGL\n---\n\n### 基本概念\n\n1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性\n\n2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）\n\n3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射\n\n4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节\n\n\n\n### 光的计算：\n\n1 发射光计算：发射颜色=物体的发射材质颜色\n\n2 环境光计算\n\n环境颜色 = 光源的环境光颜色*物体的环境材质颜色\n\n3 漫反射计算：\n\n漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor\n\n其中DiffuseFactor = max（0，dot（N，L））\n\ndot表示两个向量夹角的cos\n\n4 镜面反射：\n\n镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor\n\nSpecularFactor = power（max（0， dot（N，H）），shininess）\n\nH = normalise（L+E）\n\n","slug":"OpenGL-光照学习","published":1,"updated":"2017-12-20T09:50:13.000Z","comments":1,"photos":[],"link":"","_id":"cl9lffyvz000ny2vq61m3em0n","content":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性</p>\n<p>2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）</p>\n<p>3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射</p>\n<p>4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节</p>\n<h3 id=\"光的计算：\"><a href=\"#光的计算：\" class=\"headerlink\" title=\"光的计算：\"></a>光的计算：</h3><p>1 发射光计算：发射颜色=物体的发射材质颜色</p>\n<p>2 环境光计算</p>\n<p>环境颜色 = 光源的环境光颜色*物体的环境材质颜色</p>\n<p>3 漫反射计算：</p>\n<p>漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor</p>\n<p>其中DiffuseFactor = max（0，dot（N，L））</p>\n<p>dot表示两个向量夹角的cos</p>\n<p>4 镜面反射：</p>\n<p>镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor</p>\n<p>SpecularFactor = power（max（0， dot（N，H）），shininess）</p>\n<p>H = normalise（L+E）</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性</p>\n<p>2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）</p>\n<p>3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射</p>\n<p>4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节</p>\n<h3 id=\"光的计算：\"><a href=\"#光的计算：\" class=\"headerlink\" title=\"光的计算：\"></a>光的计算：</h3><p>1 发射光计算：发射颜色=物体的发射材质颜色</p>\n<p>2 环境光计算</p>\n<p>环境颜色 = 光源的环境光颜色*物体的环境材质颜色</p>\n<p>3 漫反射计算：</p>\n<p>漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor</p>\n<p>其中DiffuseFactor = max（0，dot（N，L））</p>\n<p>dot表示两个向量夹角的cos</p>\n<p>4 镜面反射：</p>\n<p>镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor</p>\n<p>SpecularFactor = power（max（0， dot（N，H）），shininess）</p>\n<p>H = normalise（L+E）</p>\n"},{"layout":"post","title":"opengl iOS创建OpenGL环境绘制一个简单三角形","date":"2016-12-30T07:42:35.000Z","_content":"\n### EAGLView创建要点\n\n1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性\n\n```\n- (void)setupLayer{\n\n    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;\n    \n    layer.opaque = YES;\n    \n    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,\n                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];\n}\n```\n\n2  创建EAGLContext\n\n```\n_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];\n```\n\n3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：\n\na获取着色器源文件，创建shader，编译\n\nb创建program，attachShader，link，useProgram\n\nc从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)\n\n这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext\n\n4 每一帧绘制流程\n\n在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是\n\n```\n- (void)drawFrame{\n\n    [_eaglView setFramebuffer];\n    \n    [_eaglView draw];\n    \n    [_eaglView presentFramebuffer];\n}\n```\n\n5 关于frameBuffetObject的创建和释放\n\n前提：context确保设置\n\n流程大致是\n\n```\n- (void)createBuffer{\n    \n    [self checkContext];\n    \n    glGenRenderbuffers(1, &_colorRenderBuffer);\n    \n    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);\n    \n    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];\n    \n    glGenFramebuffers(1, &_frameBuffer);\n    \n    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);\n    \n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,\n    \t\t\t\t\t\tGL_RENDERBUFFER, _colorRenderBuffer);\n}\n\n- (void)deleteBuffer{\n\n    [self checkContext];\n    \n    glDeleteRenderbuffers(1, &_colorRenderBuffer);\n    \n    _colorRenderBuffer = 0;\n    \n    glDeleteFramebuffers(1, &_frameBuffer);\n    \n    _frameBuffer = 0;\n}\n\n- (void)setFramebuffer\n{\n    if ([self checkContext])\n    {\n        if (!_frameBuffer){\n            [self createBuffer];\n        }\n        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);\n    }\n}\n\n- (BOOL)presentFramebuffer\n{\n    BOOL success = FALSE;\n    \n    if ([self checkContext])\n    {\n        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);\n        \n        success = [_context presentRenderbuffer:GL_RENDERBUFFER];\n    }\n    return success;\n}\n```\n\n6 关于绘制三角形\n\n```\n- (void)draw{\n    //设置背景颜色为绿色\n    glClearColor(0, 1.0, 0,1.0);\n    glClear(GL_COLOR_BUFFER_BIT);\n    //设置管区域大小\n    glViewport(0, 0, self.frame.size.width, self.frame.size.height);\n    \n    GLfloat vertices[] = {\n        0.0f,  0.5f, 0.0f,\n        -0.5f, -0.5f, 0.0f,\n        0.5f,  -0.5f, 0.0f };\n    //设置着色器中的vPositon\n    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);\n    //使上一步的设置生效\n    glEnableVertexAttribArray(_positionSlot);\n    //绘制三角形\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n}\n```\n","source":"_posts/OpenGL-基本框架搭建和绘制一个简单图形.md","raw":"---\nlayout: post\ntitle: opengl iOS创建OpenGL环境绘制一个简单三角形\ndate: 2016-12-30 15:42:35\ntags: \n    - openGL \n    - iOS\n---\n\n### EAGLView创建要点\n\n1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性\n\n```\n- (void)setupLayer{\n\n    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;\n    \n    layer.opaque = YES;\n    \n    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,\n                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];\n}\n```\n\n2  创建EAGLContext\n\n```\n_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];\n```\n\n3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：\n\na获取着色器源文件，创建shader，编译\n\nb创建program，attachShader，link，useProgram\n\nc从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)\n\n这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext\n\n4 每一帧绘制流程\n\n在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是\n\n```\n- (void)drawFrame{\n\n    [_eaglView setFramebuffer];\n    \n    [_eaglView draw];\n    \n    [_eaglView presentFramebuffer];\n}\n```\n\n5 关于frameBuffetObject的创建和释放\n\n前提：context确保设置\n\n流程大致是\n\n```\n- (void)createBuffer{\n    \n    [self checkContext];\n    \n    glGenRenderbuffers(1, &_colorRenderBuffer);\n    \n    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);\n    \n    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];\n    \n    glGenFramebuffers(1, &_frameBuffer);\n    \n    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);\n    \n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,\n    \t\t\t\t\t\tGL_RENDERBUFFER, _colorRenderBuffer);\n}\n\n- (void)deleteBuffer{\n\n    [self checkContext];\n    \n    glDeleteRenderbuffers(1, &_colorRenderBuffer);\n    \n    _colorRenderBuffer = 0;\n    \n    glDeleteFramebuffers(1, &_frameBuffer);\n    \n    _frameBuffer = 0;\n}\n\n- (void)setFramebuffer\n{\n    if ([self checkContext])\n    {\n        if (!_frameBuffer){\n            [self createBuffer];\n        }\n        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);\n    }\n}\n\n- (BOOL)presentFramebuffer\n{\n    BOOL success = FALSE;\n    \n    if ([self checkContext])\n    {\n        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);\n        \n        success = [_context presentRenderbuffer:GL_RENDERBUFFER];\n    }\n    return success;\n}\n```\n\n6 关于绘制三角形\n\n```\n- (void)draw{\n    //设置背景颜色为绿色\n    glClearColor(0, 1.0, 0,1.0);\n    glClear(GL_COLOR_BUFFER_BIT);\n    //设置管区域大小\n    glViewport(0, 0, self.frame.size.width, self.frame.size.height);\n    \n    GLfloat vertices[] = {\n        0.0f,  0.5f, 0.0f,\n        -0.5f, -0.5f, 0.0f,\n        0.5f,  -0.5f, 0.0f };\n    //设置着色器中的vPositon\n    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);\n    //使上一步的设置生效\n    glEnableVertexAttribArray(_positionSlot);\n    //绘制三角形\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n}\n```\n","slug":"OpenGL-基本框架搭建和绘制一个简单图形","published":1,"updated":"2022-10-23T12:51:18.637Z","comments":1,"photos":[],"link":"","_id":"cl9lffyw0000py2vqfxfcfujp","content":"<h3 id=\"EAGLView创建要点\"><a href=\"#EAGLView创建要点\" class=\"headerlink\" title=\"EAGLView创建要点\"></a>EAGLView创建要点</h3><p>1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setupLayer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    layer.opaque = YES;</span><br><span class=\"line\">    </span><br><span class=\"line\">    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,</span><br><span class=\"line\">                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2  创建EAGLContext</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br></pre></td></tr></table></figure>\n\n<p>3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：</p>\n<p>a获取着色器源文件，创建shader，编译</p>\n<p>b创建program，attachShader，link，useProgram</p>\n<p>c从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)</p>\n<p>这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext</p>\n<p>4 每一帧绘制流程</p>\n<p>在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)drawFrame&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [_eaglView setFramebuffer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_eaglView draw];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_eaglView presentFramebuffer];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5 关于frameBuffetObject的创建和释放</p>\n<p>前提：context确保设置</p>\n<p>流程大致是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)createBuffer&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self checkContext];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenFramebuffers(1, &amp;_frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class=\"line\">    \t\t\t\t\t\tGL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)deleteBuffer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [self checkContext];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDeleteRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    _colorRenderBuffer = 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDeleteFramebuffers(1, &amp;_frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    _frameBuffer = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setFramebuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if ([self checkContext])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (!_frameBuffer)&#123;</span><br><span class=\"line\">            [self createBuffer];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)presentFramebuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BOOL success = FALSE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if ([self checkContext])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">        </span><br><span class=\"line\">        success = [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return success;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6 关于绘制三角形</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)draw&#123;</span><br><span class=\"line\">    //设置背景颜色为绿色</span><br><span class=\"line\">    glClearColor(0, 1.0, 0,1.0);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    //设置管区域大小</span><br><span class=\"line\">    glViewport(0, 0, self.frame.size.width, self.frame.size.height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        0.0f,  0.5f, 0.0f,</span><br><span class=\"line\">        -0.5f, -0.5f, 0.0f,</span><br><span class=\"line\">        0.5f,  -0.5f, 0.0f &#125;;</span><br><span class=\"line\">    //设置着色器中的vPositon</span><br><span class=\"line\">    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);</span><br><span class=\"line\">    //使上一步的设置生效</span><br><span class=\"line\">    glEnableVertexAttribArray(_positionSlot);</span><br><span class=\"line\">    //绘制三角形</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"EAGLView创建要点\"><a href=\"#EAGLView创建要点\" class=\"headerlink\" title=\"EAGLView创建要点\"></a>EAGLView创建要点</h3><p>1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setupLayer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    layer.opaque = YES;</span><br><span class=\"line\">    </span><br><span class=\"line\">    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,</span><br><span class=\"line\">                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2  创建EAGLContext</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br></pre></td></tr></table></figure>\n\n<p>3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：</p>\n<p>a获取着色器源文件，创建shader，编译</p>\n<p>b创建program，attachShader，link，useProgram</p>\n<p>c从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)</p>\n<p>这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext</p>\n<p>4 每一帧绘制流程</p>\n<p>在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)drawFrame&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [_eaglView setFramebuffer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_eaglView draw];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_eaglView presentFramebuffer];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5 关于frameBuffetObject的创建和释放</p>\n<p>前提：context确保设置</p>\n<p>流程大致是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)createBuffer&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self checkContext];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenFramebuffers(1, &amp;_frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class=\"line\">    \t\t\t\t\t\tGL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)deleteBuffer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [self checkContext];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDeleteRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    _colorRenderBuffer = 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDeleteFramebuffers(1, &amp;_frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    _frameBuffer = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setFramebuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if ([self checkContext])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (!_frameBuffer)&#123;</span><br><span class=\"line\">            [self createBuffer];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)presentFramebuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BOOL success = FALSE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if ([self checkContext])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">        </span><br><span class=\"line\">        success = [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return success;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6 关于绘制三角形</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)draw&#123;</span><br><span class=\"line\">    //设置背景颜色为绿色</span><br><span class=\"line\">    glClearColor(0, 1.0, 0,1.0);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    //设置管区域大小</span><br><span class=\"line\">    glViewport(0, 0, self.frame.size.width, self.frame.size.height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        0.0f,  0.5f, 0.0f,</span><br><span class=\"line\">        -0.5f, -0.5f, 0.0f,</span><br><span class=\"line\">        0.5f,  -0.5f, 0.0f &#125;;</span><br><span class=\"line\">    //设置着色器中的vPositon</span><br><span class=\"line\">    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);</span><br><span class=\"line\">    //使上一步的设置生效</span><br><span class=\"line\">    glEnableVertexAttribArray(_positionSlot);</span><br><span class=\"line\">    //绘制三角形</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"纹理贴图","date":"2017-01-03T03:11:26.000Z","_content":"\n1 VertexShader\n\n```\nattribute vec2 TexCoordIn; // New\nvarying vec2 TexCoordOut; // New\n\nvoid main(void) { \n    DestinationColor = SourceColor; \n    gl_Position = Projection * Modelview * Position;\n    TexCoordOut = TexCoordIn; // New\n}\n```\n\n2 FragmentShader\n\n```\nvarying lowp vec4 DestinationColor;\nvarying lowp vec2 TexCoordOut; // New\nuniform sampler2D Texture; // New\n\nvoid main(void) {\n    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New\n}\n```\n\n3 将图片资源转换成位图数据，绑定到对应纹理ID中\n\n```\n+ (GLuint)createTextureWithImage:(UIImage *)image{\n    \n    //转换为CGImage，获取图片基本参数\n    CGImageRef cgImageRef = [image CGImage];\n    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);\n    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);\n    CGRect rect = CGRectMake(0, 0, width, height);\n    \n    //绘制图片\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    void *imageData = malloc(width * height * 4);\n    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);\n    CGContextTranslateCTM(context, 0, height);\n    CGContextScaleCTM(context, 1.0f, -1.0f);\n    CGColorSpaceRelease(colorSpace);\n    CGContextClearRect(context, rect);\n    CGContextDrawImage(context, rect, cgImageRef);\n    \n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_2D, textureID);\n    \n    //纹理一些设置，可有可无\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    \n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);\n    \n    glBindTexture(GL_TEXTURE_2D, 0);\n    \n    //释放内存\n    CGContextRelease(context);\n    free(imageData);\n    \n    return textureID;\n}\n```\n\n4 绘制时使用纹理\n\n```\n    glActiveTexture(GL_TEXTURE0);\n    //载入纹理\n    glBindTexture(GL_TEXTURE_2D, _textTureId);\n\n    glUniform1i(_textureSlot, 0);\n    \n    const GLfloat texCoords[] = {\n        0, 0,//左下\n        1, 0,//右下\n        0, 1,//左上\n        1, 1,//右上\n    };\n    glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);\n    glEnableVertexAttribArray(_textureCoordsSlot);\n```\n\n5 关于纹理坐标\n","source":"_posts/OpenGL-纹理贴图.md","raw":"---\nlayout: post\ntitle: 纹理贴图\ndate: 2017-01-03 11:11:26\ntags: openGL\n---\n\n1 VertexShader\n\n```\nattribute vec2 TexCoordIn; // New\nvarying vec2 TexCoordOut; // New\n\nvoid main(void) { \n    DestinationColor = SourceColor; \n    gl_Position = Projection * Modelview * Position;\n    TexCoordOut = TexCoordIn; // New\n}\n```\n\n2 FragmentShader\n\n```\nvarying lowp vec4 DestinationColor;\nvarying lowp vec2 TexCoordOut; // New\nuniform sampler2D Texture; // New\n\nvoid main(void) {\n    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New\n}\n```\n\n3 将图片资源转换成位图数据，绑定到对应纹理ID中\n\n```\n+ (GLuint)createTextureWithImage:(UIImage *)image{\n    \n    //转换为CGImage，获取图片基本参数\n    CGImageRef cgImageRef = [image CGImage];\n    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);\n    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);\n    CGRect rect = CGRectMake(0, 0, width, height);\n    \n    //绘制图片\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    void *imageData = malloc(width * height * 4);\n    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);\n    CGContextTranslateCTM(context, 0, height);\n    CGContextScaleCTM(context, 1.0f, -1.0f);\n    CGColorSpaceRelease(colorSpace);\n    CGContextClearRect(context, rect);\n    CGContextDrawImage(context, rect, cgImageRef);\n    \n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_2D, textureID);\n    \n    //纹理一些设置，可有可无\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    \n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);\n    \n    glBindTexture(GL_TEXTURE_2D, 0);\n    \n    //释放内存\n    CGContextRelease(context);\n    free(imageData);\n    \n    return textureID;\n}\n```\n\n4 绘制时使用纹理\n\n```\n    glActiveTexture(GL_TEXTURE0);\n    //载入纹理\n    glBindTexture(GL_TEXTURE_2D, _textTureId);\n\n    glUniform1i(_textureSlot, 0);\n    \n    const GLfloat texCoords[] = {\n        0, 0,//左下\n        1, 0,//右下\n        0, 1,//左上\n        1, 1,//右上\n    };\n    glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);\n    glEnableVertexAttribArray(_textureCoordsSlot);\n```\n\n5 关于纹理坐标\n","slug":"OpenGL-纹理贴图","published":1,"updated":"2022-10-23T12:45:48.284Z","comments":1,"photos":[],"link":"","_id":"cl9lffyw1000ry2vq1hiy961v","content":"<p>1 VertexShader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attribute vec2 TexCoordIn; // New</span><br><span class=\"line\">varying vec2 TexCoordOut; // New</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123; </span><br><span class=\"line\">    DestinationColor = SourceColor; </span><br><span class=\"line\">    gl_Position = Projection * Modelview * Position;</span><br><span class=\"line\">    TexCoordOut = TexCoordIn; // New</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2 FragmentShader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying lowp vec4 DestinationColor;</span><br><span class=\"line\">varying lowp vec2 TexCoordOut; // New</span><br><span class=\"line\">uniform sampler2D Texture; // New</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123;</span><br><span class=\"line\">    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3 将图片资源转换成位图数据，绑定到对应纹理ID中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (GLuint)createTextureWithImage:(UIImage *)image&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //转换为CGImage，获取图片基本参数</span><br><span class=\"line\">    CGImageRef cgImageRef = [image CGImage];</span><br><span class=\"line\">    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);</span><br><span class=\"line\">    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);</span><br><span class=\"line\">    CGRect rect = CGRectMake(0, 0, width, height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //绘制图片</span><br><span class=\"line\">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class=\"line\">    void *imageData = malloc(width * height * 4);</span><br><span class=\"line\">    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class=\"line\">    CGContextTranslateCTM(context, 0, height);</span><br><span class=\"line\">    CGContextScaleCTM(context, 1.0f, -1.0f);</span><br><span class=\"line\">    CGColorSpaceRelease(colorSpace);</span><br><span class=\"line\">    CGContextClearRect(context, rect);</span><br><span class=\"line\">    CGContextDrawImage(context, rect, cgImageRef);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLuint textureID;</span><br><span class=\"line\">    glGenTextures(1, &amp;textureID);</span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, textureID);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //纹理一些设置，可有可无</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, 0);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //释放内存</span><br><span class=\"line\">    CGContextRelease(context);</span><br><span class=\"line\">    free(imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return textureID;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4 绘制时使用纹理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">//载入纹理</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, _textTureId);</span><br><span class=\"line\"></span><br><span class=\"line\">glUniform1i(_textureSlot, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">const GLfloat texCoords[] = &#123;</span><br><span class=\"line\">    0, 0,//左下</span><br><span class=\"line\">    1, 0,//右下</span><br><span class=\"line\">    0, 1,//左上</span><br><span class=\"line\">    1, 1,//右上</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);</span><br><span class=\"line\">glEnableVertexAttribArray(_textureCoordsSlot);</span><br></pre></td></tr></table></figure>\n\n<p>5 关于纹理坐标</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1 VertexShader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attribute vec2 TexCoordIn; // New</span><br><span class=\"line\">varying vec2 TexCoordOut; // New</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123; </span><br><span class=\"line\">    DestinationColor = SourceColor; </span><br><span class=\"line\">    gl_Position = Projection * Modelview * Position;</span><br><span class=\"line\">    TexCoordOut = TexCoordIn; // New</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2 FragmentShader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying lowp vec4 DestinationColor;</span><br><span class=\"line\">varying lowp vec2 TexCoordOut; // New</span><br><span class=\"line\">uniform sampler2D Texture; // New</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123;</span><br><span class=\"line\">    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3 将图片资源转换成位图数据，绑定到对应纹理ID中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (GLuint)createTextureWithImage:(UIImage *)image&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //转换为CGImage，获取图片基本参数</span><br><span class=\"line\">    CGImageRef cgImageRef = [image CGImage];</span><br><span class=\"line\">    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);</span><br><span class=\"line\">    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);</span><br><span class=\"line\">    CGRect rect = CGRectMake(0, 0, width, height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //绘制图片</span><br><span class=\"line\">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class=\"line\">    void *imageData = malloc(width * height * 4);</span><br><span class=\"line\">    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class=\"line\">    CGContextTranslateCTM(context, 0, height);</span><br><span class=\"line\">    CGContextScaleCTM(context, 1.0f, -1.0f);</span><br><span class=\"line\">    CGColorSpaceRelease(colorSpace);</span><br><span class=\"line\">    CGContextClearRect(context, rect);</span><br><span class=\"line\">    CGContextDrawImage(context, rect, cgImageRef);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLuint textureID;</span><br><span class=\"line\">    glGenTextures(1, &amp;textureID);</span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, textureID);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //纹理一些设置，可有可无</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, 0);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //释放内存</span><br><span class=\"line\">    CGContextRelease(context);</span><br><span class=\"line\">    free(imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return textureID;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4 绘制时使用纹理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">//载入纹理</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, _textTureId);</span><br><span class=\"line\"></span><br><span class=\"line\">glUniform1i(_textureSlot, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">const GLfloat texCoords[] = &#123;</span><br><span class=\"line\">    0, 0,//左下</span><br><span class=\"line\">    1, 0,//右下</span><br><span class=\"line\">    0, 1,//左上</span><br><span class=\"line\">    1, 1,//右上</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);</span><br><span class=\"line\">glEnableVertexAttribArray(_textureCoordsSlot);</span><br></pre></td></tr></table></figure>\n\n<p>5 关于纹理坐标</p>\n"},{"title":"add Image","date":"2022-09-25T12:26:19.000Z","_content":"\n\n###测试插入一张图片\n\n\n![](../add-Image/sharedptr1.png)\n\n\ntest end\n\n\n\n","source":"_posts/add-Image.md","raw":"---\ntitle: add Image\ndate: 2022-09-25 20:26:19\ntags: test\n---\n\n\n###测试插入一张图片\n\n\n![](../add-Image/sharedptr1.png)\n\n\ntest end\n\n\n\n","slug":"add-Image","published":1,"updated":"2022-10-23T12:53:27.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9lffyw2000ty2vqh991a146","content":"<p>###测试插入一张图片</p>\n<p><img src=\"/2022/09/25/add-Image/sharedptr1.png\"></p>\n<p>test end</p>\n","site":{"data":{}},"excerpt":"","more":"<p>###测试插入一张图片</p>\n<p><img src=\"/2022/09/25/add-Image/sharedptr1.png\"></p>\n<p>test end</p>\n"},{"layout":"post","title":"iOS运行时消息转发","subtitle":"iOS Runtime","date":"2017-12-13T16:00:00.000Z","_content":"\n\n> 最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解\n\n\n\n### iOS 方法调用探讨\n\n这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, ...)方法这种方式\n\n在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding\n\n如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：\n\n![image.png](https://oh144b0ji.qnssl.com/OC%20runTime.jpg)\n\n\n\n主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程\n\n1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法\n\n```\n+ (BOOL)resolveInstanceMethod:(SEL)aSEL{\n  \n    if (aSEL == @selector(notFoundFunctiion)) {\n        \n        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, \"v@:\");\n        return YES;\n    }\n    \n    return [super resolveInstanceMethod:aSEL];\n}\n```\n\n​\t需要注意的是，不仅[self notFoundFunctiion]会触发这里，在\n\n```\n[self respondsToSelector:@selector(notFoundFunctiion)]\n```\n\n​\t这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。\n\n\n\n2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程\n\n可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO\n\n\n\n#### 参考文章：\n\n[Objective-C Runtime Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html)\n\n\n\n\n","source":"_posts/iOS-MessageForwarding.md","raw":"---\nlayout:     post\ntitle:      iOS运行时消息转发\nsubtitle:   iOS Runtime\ndate:       2017-12-14\ntags:\n    - iOS\n---\n\n\n> 最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解\n\n\n\n### iOS 方法调用探讨\n\n这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, ...)方法这种方式\n\n在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding\n\n如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：\n\n![image.png](https://oh144b0ji.qnssl.com/OC%20runTime.jpg)\n\n\n\n主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程\n\n1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法\n\n```\n+ (BOOL)resolveInstanceMethod:(SEL)aSEL{\n  \n    if (aSEL == @selector(notFoundFunctiion)) {\n        \n        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, \"v@:\");\n        return YES;\n    }\n    \n    return [super resolveInstanceMethod:aSEL];\n}\n```\n\n​\t需要注意的是，不仅[self notFoundFunctiion]会触发这里，在\n\n```\n[self respondsToSelector:@selector(notFoundFunctiion)]\n```\n\n​\t这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。\n\n\n\n2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程\n\n可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO\n\n\n\n#### 参考文章：\n\n[Objective-C Runtime Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html)\n\n\n\n\n","slug":"iOS-MessageForwarding","published":1,"updated":"2022-10-23T12:47:39.457Z","comments":1,"photos":[],"link":"","_id":"cl9lffyw3000vy2vqc3e55i0z","content":"<blockquote>\n<p>最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解</p>\n</blockquote>\n<h3 id=\"iOS-方法调用探讨\"><a href=\"#iOS-方法调用探讨\" class=\"headerlink\" title=\"iOS 方法调用探讨\"></a>iOS 方法调用探讨</h3><p>这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, …)方法这种方式</p>\n<p>在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding</p>\n<p>如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：</p>\n<p><img src=\"https://oh144b0ji.qnssl.com/OC%20runTime.jpg\" alt=\"image.png\"></p>\n<p>主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程</p>\n<p>1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    if (aSEL == @selector(notFoundFunctiion)) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return [super resolveInstanceMethod:aSEL];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    需要注意的是，不仅[self notFoundFunctiion]会触发这里，在</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self respondsToSelector:@selector(notFoundFunctiion)]</span><br></pre></td></tr></table></figure>\n\n<p>​    这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。</p>\n<p>2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程</p>\n<p>可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO</p>\n<h4 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h4><p><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html\">Objective-C Runtime Programming Guide</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解</p>\n</blockquote>\n<h3 id=\"iOS-方法调用探讨\"><a href=\"#iOS-方法调用探讨\" class=\"headerlink\" title=\"iOS 方法调用探讨\"></a>iOS 方法调用探讨</h3><p>这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, …)方法这种方式</p>\n<p>在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding</p>\n<p>如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：</p>\n<p><img src=\"https://oh144b0ji.qnssl.com/OC%20runTime.jpg\" alt=\"image.png\"></p>\n<p>主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程</p>\n<p>1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    if (aSEL == @selector(notFoundFunctiion)) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return [super resolveInstanceMethod:aSEL];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    需要注意的是，不仅[self notFoundFunctiion]会触发这里，在</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self respondsToSelector:@selector(notFoundFunctiion)]</span><br></pre></td></tr></table></figure>\n\n<p>​    这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。</p>\n<p>2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程</p>\n<p>可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO</p>\n<h4 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h4><p><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html\">Objective-C Runtime Programming Guide</a></p>\n"},{"layout":"post","title":"iOS11模拟器运行OpenGL相关程序卡顿","subtitle":"Xcode9.0 problem","date":"2017-09-18T16:00:00.000Z","author":"jack","header-img":"img/post-bg-ios9-web.jpg","catalog":true,"_content":"\n\n> 最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug\n\n\n\n### 具体的解决方案是\n替换此路径下的文件用附件文件，替换此路径下文件即可\n\n*/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib*  \n\n[libCoreVMClient.dylib下载链接](http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib)\n\n\n\n### 参考文献\n\n[苹果开发者论坛](https://forums.developer.apple.com/thread/83570)","source":"_posts/iOS11 Simulator OpenGL Slowly.md","raw":"---\nlayout:     post\ntitle:      iOS11模拟器运行OpenGL相关程序卡顿\nsubtitle:   Xcode9.0 problem\ndate:       2017-09-19\nauthor:     jack\nheader-img: img/post-bg-ios9-web.jpg\ncatalog: true\ntags:\n    - iOS\n---\n\n\n> 最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug\n\n\n\n### 具体的解决方案是\n替换此路径下的文件用附件文件，替换此路径下文件即可\n\n*/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib*  \n\n[libCoreVMClient.dylib下载链接](http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib)\n\n\n\n### 参考文献\n\n[苹果开发者论坛](https://forums.developer.apple.com/thread/83570)","slug":"iOS11 Simulator OpenGL Slowly","published":1,"updated":"2017-12-20T09:50:13.000Z","comments":1,"photos":[],"link":"","_id":"cl9lffyw4000xy2vq3jqdfy1n","content":"<blockquote>\n<p>最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug</p>\n</blockquote>\n<h3 id=\"具体的解决方案是\"><a href=\"#具体的解决方案是\" class=\"headerlink\" title=\"具体的解决方案是\"></a>具体的解决方案是</h3><p>替换此路径下的文件用附件文件，替换此路径下文件即可</p>\n<p><em>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib</em>  </p>\n<p><a href=\"http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib\">libCoreVMClient.dylib下载链接</a></p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://forums.developer.apple.com/thread/83570\">苹果开发者论坛</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug</p>\n</blockquote>\n<h3 id=\"具体的解决方案是\"><a href=\"#具体的解决方案是\" class=\"headerlink\" title=\"具体的解决方案是\"></a>具体的解决方案是</h3><p>替换此路径下的文件用附件文件，替换此路径下文件即可</p>\n<p><em>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib</em>  </p>\n<p><a href=\"http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib\">libCoreVMClient.dylib下载链接</a></p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://forums.developer.apple.com/thread/83570\">苹果开发者论坛</a></p>\n"},{"layout":"post","title":"iOS不受用户手动修改时间的影响的计时技术","subtitle":"一种不受系统时钟影响的实现","date":"2017-09-16T16:00:00.000Z","author":"jack","header-img":"img/post-bg-ios9-web.jpg","catalog":true,"_content":"\n### iOS不受用户手动修改时间的影响的计时技术\n\n### 前言\n\n这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案\n\n\n\n### 解决问题\n\n直接说最终方案\n\n`[[NSProcessInfo processInfo] systemUptime];`\n\n这个函数返回的是开机到当前的时间，秒数为单位，并且**不受系统时钟的影响**，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.\n\n\n\n### 参考文献\n\n[苹果接口文档](https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc)","source":"_posts/iOS准确计时.md","raw":"---\nlayout:     post\ntitle:      iOS不受用户手动修改时间的影响的计时技术\nsubtitle:   一种不受系统时钟影响的实现\ndate:       2017-09-17\nauthor:     jack\nheader-img: img/post-bg-ios9-web.jpg\ncatalog: true\ntags:\n    - iOS\n---\n\n### iOS不受用户手动修改时间的影响的计时技术\n\n### 前言\n\n这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案\n\n\n\n### 解决问题\n\n直接说最终方案\n\n`[[NSProcessInfo processInfo] systemUptime];`\n\n这个函数返回的是开机到当前的时间，秒数为单位，并且**不受系统时钟的影响**，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.\n\n\n\n### 参考文献\n\n[苹果接口文档](https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc)","slug":"iOS准确计时","published":1,"updated":"2017-12-20T09:50:13.000Z","comments":1,"photos":[],"link":"","_id":"cl9lffyw5000zy2vqavs7hjwf","content":"<h3 id=\"iOS不受用户手动修改时间的影响的计时技术\"><a href=\"#iOS不受用户手动修改时间的影响的计时技术\" class=\"headerlink\" title=\"iOS不受用户手动修改时间的影响的计时技术\"></a>iOS不受用户手动修改时间的影响的计时技术</h3><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案</p>\n<h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>直接说最终方案</p>\n<p><code>[[NSProcessInfo processInfo] systemUptime];</code></p>\n<p>这个函数返回的是开机到当前的时间，秒数为单位，并且<strong>不受系统时钟的影响</strong>，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc\">苹果接口文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"iOS不受用户手动修改时间的影响的计时技术\"><a href=\"#iOS不受用户手动修改时间的影响的计时技术\" class=\"headerlink\" title=\"iOS不受用户手动修改时间的影响的计时技术\"></a>iOS不受用户手动修改时间的影响的计时技术</h3><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案</p>\n<h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>直接说最终方案</p>\n<p><code>[[NSProcessInfo processInfo] systemUptime];</code></p>\n<p>这个函数返回的是开机到当前的时间，秒数为单位，并且<strong>不受系统时钟的影响</strong>，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc\">苹果接口文档</a></p>\n"},{"layout":"post","title":"tweak心得","date":"2017-03-07T01:20:39.000Z","_content":"\n### 1 关于ssh\n\n一般形式 ssh root@192.168.2.17或者ssh mobile@192.168.2.17\n\nroot和mobile分别为iOS上默认用户，alpine是默认密码\n\n可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码\n\n### 2 scp source dest\n\n一般为\n\nscp ~/123.txt mobile@192.168.2.17:/usr/bin\n\n### 3 Makefile\n\n可以配置手机的IP，framework，arch等参数\n\nTHEOS_DEVICE_IP = 192.168.31.202\nARCHS = armv7 arm64\nTARGET = iphone:latest:8.0\n\niOSREGreetings_FRAMEWORKS = UIKit \n\n### 4 关于bundleID\n\n.plist中的bundle就是你想hook的程序的bundleID\n","source":"_posts/tweak使用说明.md","raw":"---\nlayout: post\ntitle: tweak心得\ndate: 2017-03-07 09:20:39\ntags: iOS\n---\n\n### 1 关于ssh\n\n一般形式 ssh root@192.168.2.17或者ssh mobile@192.168.2.17\n\nroot和mobile分别为iOS上默认用户，alpine是默认密码\n\n可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码\n\n### 2 scp source dest\n\n一般为\n\nscp ~/123.txt mobile@192.168.2.17:/usr/bin\n\n### 3 Makefile\n\n可以配置手机的IP，framework，arch等参数\n\nTHEOS_DEVICE_IP = 192.168.31.202\nARCHS = armv7 arm64\nTARGET = iphone:latest:8.0\n\niOSREGreetings_FRAMEWORKS = UIKit \n\n### 4 关于bundleID\n\n.plist中的bundle就是你想hook的程序的bundleID\n","slug":"tweak使用说明","published":1,"updated":"2022-10-23T12:59:07.975Z","comments":1,"photos":[],"link":"","_id":"cl9lffyw70012y2vq7o8tb306","content":"<h3 id=\"1-关于ssh\"><a href=\"#1-关于ssh\" class=\"headerlink\" title=\"1 关于ssh\"></a>1 关于ssh</h3><p>一般形式 ssh <a href=\"mailto:&#x72;&#x6f;&#111;&#x74;&#64;&#49;&#57;&#50;&#46;&#x31;&#54;&#x38;&#x2e;&#x32;&#x2e;&#x31;&#x37;\">&#x72;&#x6f;&#111;&#x74;&#64;&#49;&#57;&#50;&#46;&#x31;&#54;&#x38;&#x2e;&#x32;&#x2e;&#x31;&#x37;</a>或者ssh <a href=\"mailto:&#109;&#x6f;&#98;&#x69;&#108;&#x65;&#64;&#49;&#x39;&#50;&#46;&#49;&#54;&#56;&#46;&#50;&#46;&#49;&#55;\">&#109;&#x6f;&#98;&#x69;&#108;&#x65;&#64;&#49;&#x39;&#50;&#46;&#49;&#54;&#56;&#46;&#50;&#46;&#49;&#55;</a></p>\n<p>root和mobile分别为iOS上默认用户，alpine是默认密码</p>\n<p>可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码</p>\n<h3 id=\"2-scp-source-dest\"><a href=\"#2-scp-source-dest\" class=\"headerlink\" title=\"2 scp source dest\"></a>2 scp source dest</h3><p>一般为</p>\n<p>scp ~/123.txt <a href=\"mailto:&#109;&#x6f;&#98;&#x69;&#x6c;&#x65;&#x40;&#x31;&#57;&#50;&#46;&#x31;&#54;&#x38;&#46;&#x32;&#46;&#49;&#55;\">&#109;&#x6f;&#98;&#x69;&#x6c;&#x65;&#x40;&#x31;&#57;&#50;&#46;&#x31;&#54;&#x38;&#46;&#x32;&#46;&#49;&#55;</a>:/usr/bin</p>\n<h3 id=\"3-Makefile\"><a href=\"#3-Makefile\" class=\"headerlink\" title=\"3 Makefile\"></a>3 Makefile</h3><p>可以配置手机的IP，framework，arch等参数</p>\n<p>THEOS_DEVICE_IP = 192.168.31.202<br>ARCHS = armv7 arm64<br>TARGET = iphone:latest:8.0</p>\n<p>iOSREGreetings_FRAMEWORKS = UIKit </p>\n<h3 id=\"4-关于bundleID\"><a href=\"#4-关于bundleID\" class=\"headerlink\" title=\"4 关于bundleID\"></a>4 关于bundleID</h3><p>.plist中的bundle就是你想hook的程序的bundleID</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-关于ssh\"><a href=\"#1-关于ssh\" class=\"headerlink\" title=\"1 关于ssh\"></a>1 关于ssh</h3><p>一般形式 ssh <a href=\"mailto:&#x72;&#x6f;&#111;&#x74;&#64;&#49;&#57;&#50;&#46;&#x31;&#54;&#x38;&#x2e;&#x32;&#x2e;&#x31;&#x37;\">&#x72;&#x6f;&#111;&#x74;&#64;&#49;&#57;&#50;&#46;&#x31;&#54;&#x38;&#x2e;&#x32;&#x2e;&#x31;&#x37;</a>或者ssh <a href=\"mailto:&#109;&#x6f;&#98;&#x69;&#108;&#x65;&#64;&#49;&#x39;&#50;&#46;&#49;&#54;&#56;&#46;&#50;&#46;&#49;&#55;\">&#109;&#x6f;&#98;&#x69;&#108;&#x65;&#64;&#49;&#x39;&#50;&#46;&#49;&#54;&#56;&#46;&#50;&#46;&#49;&#55;</a></p>\n<p>root和mobile分别为iOS上默认用户，alpine是默认密码</p>\n<p>可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码</p>\n<h3 id=\"2-scp-source-dest\"><a href=\"#2-scp-source-dest\" class=\"headerlink\" title=\"2 scp source dest\"></a>2 scp source dest</h3><p>一般为</p>\n<p>scp ~/123.txt <a href=\"mailto:&#109;&#x6f;&#98;&#x69;&#x6c;&#x65;&#x40;&#x31;&#57;&#50;&#46;&#x31;&#54;&#x38;&#46;&#x32;&#46;&#49;&#55;\">&#109;&#x6f;&#98;&#x69;&#x6c;&#x65;&#x40;&#x31;&#57;&#50;&#46;&#x31;&#54;&#x38;&#46;&#x32;&#46;&#49;&#55;</a>:/usr/bin</p>\n<h3 id=\"3-Makefile\"><a href=\"#3-Makefile\" class=\"headerlink\" title=\"3 Makefile\"></a>3 Makefile</h3><p>可以配置手机的IP，framework，arch等参数</p>\n<p>THEOS_DEVICE_IP = 192.168.31.202<br>ARCHS = armv7 arm64<br>TARGET = iphone:latest:8.0</p>\n<p>iOSREGreetings_FRAMEWORKS = UIKit </p>\n<h3 id=\"4-关于bundleID\"><a href=\"#4-关于bundleID\" class=\"headerlink\" title=\"4 关于bundleID\"></a>4 关于bundleID</h3><p>.plist中的bundle就是你想hook的程序的bundleID</p>\n"},{"layout":"post","title":"iOS手势事件分发原理","subtitle":"iOSHitTest和PointInSide实现探究","date":"2017-06-30T16:00:00.000Z","author":"jack","header-img":"img/post-bg-ios9-web.jpg","catalog":true,"_content":"\nHitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理\n\n```\n- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event{\n    \n    //apple文档描述，不接受事件的情况\n    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha < 0.01) {\n        return nil;\n    }\n    \n    //如果当前View包含此Point\n    if ([self pointInside:point withEvent:event]) {\n        \n        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的\n        for (NSInteger i=self.subviews.count-1; i>=0; i--) {\n            \n            UIView* subView = [self.subviews objectAtIndex:i];\n            \n            //将父View的Point转换成子View坐标系的Point\n            CGPoint pointInSubView = [subView convertPoint:point fromView:self];\n            \n            //递归子View调用HitTest:\n            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];\n            \n            //找到了子View可以响应\n            if (resultView) {\n                return resultView;\n            }\n            \n        }\n        \n        //没有找到可以响应的子View，返回自己\n        return self;\n    }\n    \n    //返回nil，告诉上一级自己无法响应此事件\n    return nil;\n}\n```\n\n流程图总结\n\n![image.png](http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","source":"_posts/iOS手势事件分发原理.md","raw":"---\nlayout:     post\ntitle:      iOS手势事件分发原理\nsubtitle:   iOSHitTest和PointInSide实现探究\ndate:       2017-07-01\nauthor:     jack\nheader-img: img/post-bg-ios9-web.jpg\ncatalog: true\ntags:\n    - iOS\n---\n\nHitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理\n\n```\n- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event{\n    \n    //apple文档描述，不接受事件的情况\n    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha < 0.01) {\n        return nil;\n    }\n    \n    //如果当前View包含此Point\n    if ([self pointInside:point withEvent:event]) {\n        \n        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的\n        for (NSInteger i=self.subviews.count-1; i>=0; i--) {\n            \n            UIView* subView = [self.subviews objectAtIndex:i];\n            \n            //将父View的Point转换成子View坐标系的Point\n            CGPoint pointInSubView = [subView convertPoint:point fromView:self];\n            \n            //递归子View调用HitTest:\n            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];\n            \n            //找到了子View可以响应\n            if (resultView) {\n                return resultView;\n            }\n            \n        }\n        \n        //没有找到可以响应的子View，返回自己\n        return self;\n    }\n    \n    //返回nil，告诉上一级自己无法响应此事件\n    return nil;\n}\n```\n\n流程图总结\n\n![image.png](http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","slug":"iOS手势事件分发原理","published":1,"updated":"2017-12-20T09:50:13.000Z","comments":1,"photos":[],"link":"","_id":"cl9lffyw70014y2vqbt2h0g5p","content":"<p>HitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //apple文档描述，不接受事件的情况</span><br><span class=\"line\">    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha &lt; 0.01) &#123;</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //如果当前View包含此Point</span><br><span class=\"line\">    if ([self pointInside:point withEvent:event]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的</span><br><span class=\"line\">        for (NSInteger i=self.subviews.count-1; i&gt;=0; i--) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            UIView* subView = [self.subviews objectAtIndex:i];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //将父View的Point转换成子View坐标系的Point</span><br><span class=\"line\">            CGPoint pointInSubView = [subView convertPoint:point fromView:self];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //递归子View调用HitTest:</span><br><span class=\"line\">            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //找到了子View可以响应</span><br><span class=\"line\">            if (resultView) &#123;</span><br><span class=\"line\">                return resultView;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //没有找到可以响应的子View，返回自己</span><br><span class=\"line\">        return self;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //返回nil，告诉上一级自己无法响应此事件</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>流程图总结</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>HitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //apple文档描述，不接受事件的情况</span><br><span class=\"line\">    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha &lt; 0.01) &#123;</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //如果当前View包含此Point</span><br><span class=\"line\">    if ([self pointInside:point withEvent:event]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的</span><br><span class=\"line\">        for (NSInteger i=self.subviews.count-1; i&gt;=0; i--) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            UIView* subView = [self.subviews objectAtIndex:i];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //将父View的Point转换成子View坐标系的Point</span><br><span class=\"line\">            CGPoint pointInSubView = [subView convertPoint:point fromView:self];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //递归子View调用HitTest:</span><br><span class=\"line\">            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //找到了子View可以响应</span><br><span class=\"line\">            if (resultView) &#123;</span><br><span class=\"line\">                return resultView;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //没有找到可以响应的子View，返回自己</span><br><span class=\"line\">        return self;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //返回nil，告诉上一级自己无法响应此事件</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>流程图总结</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n"},{"layout":"post","title":"tweak环境搭建","date":"2017-03-07T00:43:58.000Z","_content":"\n### 0 设置环境变量 export THEOS=/opt/theos\n\n可以设置~/.zshrc中添加，修改后用source命令重新加载\n\n### 1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下\n\n### 2 下载ldid，放到/opt/theos/bin下\n\nsudo chmod 777 /opt/theos/bin/ldid\n\n### 3 配置CydiaSubstrate\n\n在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib\n\n并将头文件substrate.h也scp 到/opt/theos/include下\n\nsudo /opt/theos/bin/bootstrap.sh substrate\n\n### 4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/\n\nsuodo chmod 777 /opt/bin/dpkg-deb\n\n基本就搭建完成，可以练习创建工程\n\n/opt/theos/bin/nic.pl\n\n然后进行make package \n\nmake package install\n\n","source":"_posts/tweak环境搭建.md","raw":"---\nlayout: post\ntitle: tweak环境搭建\ndate: 2017-03-07 08:43:58\ntags: iOS\n---\n\n### 0 设置环境变量 export THEOS=/opt/theos\n\n可以设置~/.zshrc中添加，修改后用source命令重新加载\n\n### 1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下\n\n### 2 下载ldid，放到/opt/theos/bin下\n\nsudo chmod 777 /opt/theos/bin/ldid\n\n### 3 配置CydiaSubstrate\n\n在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib\n\n并将头文件substrate.h也scp 到/opt/theos/include下\n\nsudo /opt/theos/bin/bootstrap.sh substrate\n\n### 4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/\n\nsuodo chmod 777 /opt/bin/dpkg-deb\n\n基本就搭建完成，可以练习创建工程\n\n/opt/theos/bin/nic.pl\n\n然后进行make package \n\nmake package install\n\n","slug":"tweak环境搭建","published":1,"updated":"2022-10-23T12:54:32.233Z","comments":1,"photos":[],"link":"","_id":"cl9lffyw80017y2vq1nzphzwc","content":"<h3 id=\"0-设置环境变量-export-THEOS-opt-theos\"><a href=\"#0-设置环境变量-export-THEOS-opt-theos\" class=\"headerlink\" title=\"0 设置环境变量 export THEOS=/opt/theos\"></a>0 设置环境变量 export THEOS=/opt/theos</h3><p>可以设置~/.zshrc中添加，修改后用source命令重新加载</p>\n<h3 id=\"1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下\"><a href=\"#1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下\" class=\"headerlink\" title=\"1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下\"></a>1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下</h3><h3 id=\"2-下载ldid，放到-opt-theos-bin下\"><a href=\"#2-下载ldid，放到-opt-theos-bin下\" class=\"headerlink\" title=\"2 下载ldid，放到/opt/theos/bin下\"></a>2 下载ldid，放到/opt/theos/bin下</h3><p>sudo chmod 777 /opt/theos/bin/ldid</p>\n<h3 id=\"3-配置CydiaSubstrate\"><a href=\"#3-配置CydiaSubstrate\" class=\"headerlink\" title=\"3 配置CydiaSubstrate\"></a>3 配置CydiaSubstrate</h3><p>在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib</p>\n<p>并将头文件substrate.h也scp 到/opt/theos/include下</p>\n<p>sudo /opt/theos/bin/bootstrap.sh substrate</p>\n<h3 id=\"4-将dm-pl重命名为dpkg-deb，cp到-opt-bin\"><a href=\"#4-将dm-pl重命名为dpkg-deb，cp到-opt-bin\" class=\"headerlink\" title=\"4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/\"></a>4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/</h3><p>suodo chmod 777 /opt/bin/dpkg-deb</p>\n<p>基本就搭建完成，可以练习创建工程</p>\n<p>/opt/theos/bin/nic.pl</p>\n<p>然后进行make package </p>\n<p>make package install</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"0-设置环境变量-export-THEOS-opt-theos\"><a href=\"#0-设置环境变量-export-THEOS-opt-theos\" class=\"headerlink\" title=\"0 设置环境变量 export THEOS=/opt/theos\"></a>0 设置环境变量 export THEOS=/opt/theos</h3><p>可以设置~/.zshrc中添加，修改后用source命令重新加载</p>\n<h3 id=\"1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下\"><a href=\"#1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下\" class=\"headerlink\" title=\"1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下\"></a>1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下</h3><h3 id=\"2-下载ldid，放到-opt-theos-bin下\"><a href=\"#2-下载ldid，放到-opt-theos-bin下\" class=\"headerlink\" title=\"2 下载ldid，放到/opt/theos/bin下\"></a>2 下载ldid，放到/opt/theos/bin下</h3><p>sudo chmod 777 /opt/theos/bin/ldid</p>\n<h3 id=\"3-配置CydiaSubstrate\"><a href=\"#3-配置CydiaSubstrate\" class=\"headerlink\" title=\"3 配置CydiaSubstrate\"></a>3 配置CydiaSubstrate</h3><p>在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib</p>\n<p>并将头文件substrate.h也scp 到/opt/theos/include下</p>\n<p>sudo /opt/theos/bin/bootstrap.sh substrate</p>\n<h3 id=\"4-将dm-pl重命名为dpkg-deb，cp到-opt-bin\"><a href=\"#4-将dm-pl重命名为dpkg-deb，cp到-opt-bin\" class=\"headerlink\" title=\"4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/\"></a>4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/</h3><p>suodo chmod 777 /opt/bin/dpkg-deb</p>\n<p>基本就搭建完成，可以练习创建工程</p>\n<p>/opt/theos/bin/nic.pl</p>\n<p>然后进行make package </p>\n<p>make package install</p>\n"},{"title":"trivially copyable(拷贝不变)","date":"2022-10-25T08:55:46.000Z","_content":"","source":"_posts/trivially-copyable-拷贝不变.md","raw":"---\ntitle: trivially copyable(拷贝不变)\ndate: 2022-10-25 16:55:46\ntags:\n---\n","slug":"trivially-copyable-拷贝不变","published":1,"updated":"2022-10-25T08:55:46.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cla7m84aj00004zvq6iv84leh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"OpenGL模板测试流程","date":"2022-11-08T03:51:27.000Z","_content":"\n\n### 模板测试流程\n\n不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试\n\n#### 模板测试一般使用流程：\n\t1. 启用模板缓冲写入\n\t2. 渲染物体，更新模板缓冲\n\t3. 禁用模板缓冲写入\n\t4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段\n\n\n##### 使用模板测试绘制物体轮廓的例子\n\n\t```\n\tglStencilMask();\n\tglStencilFunc(GLenum func, GLint ref, GLuint mask);\n\tglStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);\n\t```\n\n\t1. 开启模板测试和深度测试\n\t2. 第一次render pass，主要是绘制，并写入模板\n\t\t1. 开启模板测试和深度测试\n\t\t2. glStencilMask(0xFF);\n\t\t3. glStencilOp(keep, keep, replace);\n\t\t4. glStencilFunc(always, 1, 0xFF);\n\t\t5. 绘制物体\n\t3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素\n\t\t1. 将物体缩放变大\n\t\t2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系\n\t\t3. 关闭模板写入glStencilMask(0x00);\n\t\t4. glStencilFunc(not_equal, 1, 0xFF);\n\t\t5. 绘制物体\n\n\n### 关于OpenGL里面的Mask\n\t1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&运算后写入\n\t2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入\n\t3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入\n","source":"_posts/OpenGL模板测试流程.md","raw":"---\ntitle: OpenGL模板测试流程\ndate: 2022-11-08 11:51:27\ntags: openGL\n---\n\n\n### 模板测试流程\n\n不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试\n\n#### 模板测试一般使用流程：\n\t1. 启用模板缓冲写入\n\t2. 渲染物体，更新模板缓冲\n\t3. 禁用模板缓冲写入\n\t4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段\n\n\n##### 使用模板测试绘制物体轮廓的例子\n\n\t```\n\tglStencilMask();\n\tglStencilFunc(GLenum func, GLint ref, GLuint mask);\n\tglStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);\n\t```\n\n\t1. 开启模板测试和深度测试\n\t2. 第一次render pass，主要是绘制，并写入模板\n\t\t1. 开启模板测试和深度测试\n\t\t2. glStencilMask(0xFF);\n\t\t3. glStencilOp(keep, keep, replace);\n\t\t4. glStencilFunc(always, 1, 0xFF);\n\t\t5. 绘制物体\n\t3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素\n\t\t1. 将物体缩放变大\n\t\t2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系\n\t\t3. 关闭模板写入glStencilMask(0x00);\n\t\t4. glStencilFunc(not_equal, 1, 0xFF);\n\t\t5. 绘制物体\n\n\n### 关于OpenGL里面的Mask\n\t1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&运算后写入\n\t2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入\n\t3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入\n","slug":"OpenGL模板测试流程","published":1,"updated":"2022-11-08T03:58:04.802Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cla7onlj70000ztvqh5nb73ei","content":"<h3 id=\"模板测试流程\"><a href=\"#模板测试流程\" class=\"headerlink\" title=\"模板测试流程\"></a>模板测试流程</h3><p>不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试</p>\n<h4 id=\"模板测试一般使用流程：\"><a href=\"#模板测试一般使用流程：\" class=\"headerlink\" title=\"模板测试一般使用流程：\"></a>模板测试一般使用流程：</h4><pre><code>1. 启用模板缓冲写入\n2. 渲染物体，更新模板缓冲\n3. 禁用模板缓冲写入\n4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段\n</code></pre>\n<h5 id=\"使用模板测试绘制物体轮廓的例子\"><a href=\"#使用模板测试绘制物体轮廓的例子\" class=\"headerlink\" title=\"使用模板测试绘制物体轮廓的例子\"></a>使用模板测试绘制物体轮廓的例子</h5><pre><code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glStencilMask();</span><br><span class=\"line\">glStencilFunc(GLenum func, GLint ref, GLuint mask);</span><br><span class=\"line\">glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);</span><br></pre></td></tr></table></figure>\n\n1. 开启模板测试和深度测试\n2. 第一次render pass，主要是绘制，并写入模板\n    1. 开启模板测试和深度测试\n    2. glStencilMask(0xFF);\n    3. glStencilOp(keep, keep, replace);\n    4. glStencilFunc(always, 1, 0xFF);\n    5. 绘制物体\n3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素\n    1. 将物体缩放变大\n    2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系\n    3. 关闭模板写入glStencilMask(0x00);\n    4. glStencilFunc(not_equal, 1, 0xFF);\n    5. 绘制物体\n</code></pre>\n<h3 id=\"关于OpenGL里面的Mask\"><a href=\"#关于OpenGL里面的Mask\" class=\"headerlink\" title=\"关于OpenGL里面的Mask\"></a>关于OpenGL里面的Mask</h3><pre><code>1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&amp;运算后写入\n2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入\n3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"模板测试流程\"><a href=\"#模板测试流程\" class=\"headerlink\" title=\"模板测试流程\"></a>模板测试流程</h3><p>不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试</p>\n<h4 id=\"模板测试一般使用流程：\"><a href=\"#模板测试一般使用流程：\" class=\"headerlink\" title=\"模板测试一般使用流程：\"></a>模板测试一般使用流程：</h4><pre><code>1. 启用模板缓冲写入\n2. 渲染物体，更新模板缓冲\n3. 禁用模板缓冲写入\n4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段\n</code></pre>\n<h5 id=\"使用模板测试绘制物体轮廓的例子\"><a href=\"#使用模板测试绘制物体轮廓的例子\" class=\"headerlink\" title=\"使用模板测试绘制物体轮廓的例子\"></a>使用模板测试绘制物体轮廓的例子</h5><pre><code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glStencilMask();</span><br><span class=\"line\">glStencilFunc(GLenum func, GLint ref, GLuint mask);</span><br><span class=\"line\">glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);</span><br></pre></td></tr></table></figure>\n\n1. 开启模板测试和深度测试\n2. 第一次render pass，主要是绘制，并写入模板\n    1. 开启模板测试和深度测试\n    2. glStencilMask(0xFF);\n    3. glStencilOp(keep, keep, replace);\n    4. glStencilFunc(always, 1, 0xFF);\n    5. 绘制物体\n3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素\n    1. 将物体缩放变大\n    2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系\n    3. 关闭模板写入glStencilMask(0x00);\n    4. glStencilFunc(not_equal, 1, 0xFF);\n    5. 绘制物体\n</code></pre>\n<h3 id=\"关于OpenGL里面的Mask\"><a href=\"#关于OpenGL里面的Mask\" class=\"headerlink\" title=\"关于OpenGL里面的Mask\"></a>关于OpenGL里面的Mask</h3><pre><code>1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&amp;运算后写入\n2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入\n3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入\n</code></pre>\n"},{"title":"c++继承权限","date":"2022-12-04T14:52:54.000Z","_content":"\n1. 继承有三种权限，public，proteced，private，默认不写是private\n\n2. 权限的最低是public，其次是protected，最高private\n\n3. 继承方式代表是父类属性在当前类中的最低呈现\n\n4. 父类中的privated属性在子类中不可访问\n\n","source":"_posts/c-继承权限.md","raw":"---\ntitle: c++继承权限\ndate: 2022-12-04 22:52:54\ntags:\n---\n\n1. 继承有三种权限，public，proteced，private，默认不写是private\n\n2. 权限的最低是public，其次是protected，最高private\n\n3. 继承方式代表是父类属性在当前类中的最低呈现\n\n4. 父类中的privated属性在子类中不可访问\n\n","slug":"c-继承权限","published":1,"updated":"2022-12-04T14:57:31.186Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbiwqnu50000dbvqewni94x2","content":"<ol>\n<li><p>继承有三种权限，public，proteced，private，默认不写是private</p>\n</li>\n<li><p>权限的最低是public，其次是protected，最高private</p>\n</li>\n<li><p>继承方式代表是父类属性在当前类中的最低呈现</p>\n</li>\n<li><p>父类中的privated属性在子类中不可访问</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>继承有三种权限，public，proteced，private，默认不写是private</p>\n</li>\n<li><p>权限的最低是public，其次是protected，最高private</p>\n</li>\n<li><p>继承方式代表是父类属性在当前类中的最低呈现</p>\n</li>\n<li><p>父类中的privated属性在子类中不可访问</p>\n</li>\n</ol>\n"},{"title":"c++ 可变参数模板","date":"2022-12-11T06:50:04.000Z","_content":"\n\n\n### 可变模版参数(variadic templates)\n可以对参数进行高度泛化，标识0到任意个数参数\n\n#### 两种展开形式\n1. 使用特化的终止函数结合递归\n\n```\n#include <iostream>\nusing namespace std;\n\n//终止函数\nint multiply()\n{\n    return 1;\n}\n\n//递归展开\ntemplate <typename T, typename ...Args>\nint multiply(T&& t, Args&& ...arg)\n{\n    return t * multiply(arg...);\n}\n\nint main(int argc, const char * argv[]) {\n    \n    cout << multiply(3, 4, 5) << endl;\n    \n    cout << multiply() << endl;\n    \n    return 0;\n}\n```\n\n2. 使用逗号表达式\n初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)...}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc... )，最终会创建一个元素值都为0的数组int arr[sizeof...(Args)]\n\n\n```\ntemplate<class F, class... Args>void expand(const F& f, Args&&...args)\n{\n  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》\n  initializer_list<int>{(f(std::forward< Args>(args)),0)...};\n}\n\nint main(int argc, const char * argv[]) {\n    \n    expand([](int i) {\n        cout<<i<<endl;\n    }, 1,2,3);\n    return 0;\n}\n\n```\n\n### initializer_list\n为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板\n\n```\nstruct myclass {\n    myclass(int,int)\n    {\n        cout << \"myclass constructor\" << endl;\n    }\n    myclass(initializer_list<int>)\n    {\n        cout << \"myclass initializer_list constructor\" << endl;\n    }\n};\n\n\nint main(int argc, const char * argv[]) {\n    \n    auto il = {10, 20, 30};\n    \n    myclass foo {10,20};  // calls initializer_list constructor\n    myclass bar (10,20);  // calls first constructo\n    \n    return 0;\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/c-可变参数模板.md","raw":"---\ntitle: c++ 可变参数模板\ndate: 2022-12-11 14:50:04\ntags: c++11\n---\n\n\n\n### 可变模版参数(variadic templates)\n可以对参数进行高度泛化，标识0到任意个数参数\n\n#### 两种展开形式\n1. 使用特化的终止函数结合递归\n\n```\n#include <iostream>\nusing namespace std;\n\n//终止函数\nint multiply()\n{\n    return 1;\n}\n\n//递归展开\ntemplate <typename T, typename ...Args>\nint multiply(T&& t, Args&& ...arg)\n{\n    return t * multiply(arg...);\n}\n\nint main(int argc, const char * argv[]) {\n    \n    cout << multiply(3, 4, 5) << endl;\n    \n    cout << multiply() << endl;\n    \n    return 0;\n}\n```\n\n2. 使用逗号表达式\n初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)...}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc... )，最终会创建一个元素值都为0的数组int arr[sizeof...(Args)]\n\n\n```\ntemplate<class F, class... Args>void expand(const F& f, Args&&...args)\n{\n  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》\n  initializer_list<int>{(f(std::forward< Args>(args)),0)...};\n}\n\nint main(int argc, const char * argv[]) {\n    \n    expand([](int i) {\n        cout<<i<<endl;\n    }, 1,2,3);\n    return 0;\n}\n\n```\n\n### initializer_list\n为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板\n\n```\nstruct myclass {\n    myclass(int,int)\n    {\n        cout << \"myclass constructor\" << endl;\n    }\n    myclass(initializer_list<int>)\n    {\n        cout << \"myclass initializer_list constructor\" << endl;\n    }\n};\n\n\nint main(int argc, const char * argv[]) {\n    \n    auto il = {10, 20, 30};\n    \n    myclass foo {10,20};  // calls initializer_list constructor\n    myclass bar (10,20);  // calls first constructo\n    \n    return 0;\n}\n```\n\n\n\n\n\n\n\n","slug":"c-可变参数模板","published":1,"updated":"2022-12-11T07:26:14.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clc3jbpcl0000dlvq58w60usi","content":"<h3 id=\"可变模版参数-variadic-templates\"><a href=\"#可变模版参数-variadic-templates\" class=\"headerlink\" title=\"可变模版参数(variadic templates)\"></a>可变模版参数(variadic templates)</h3><p>可以对参数进行高度泛化，标识0到任意个数参数</p>\n<h4 id=\"两种展开形式\"><a href=\"#两种展开形式\" class=\"headerlink\" title=\"两种展开形式\"></a>两种展开形式</h4><ol>\n<li>使用特化的终止函数结合递归</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">//终止函数</span><br><span class=\"line\">int multiply()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//递归展开</span><br><span class=\"line\">template &lt;typename T, typename ...Args&gt;</span><br><span class=\"line\">int multiply(T&amp;&amp; t, Args&amp;&amp; ...arg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return t * multiply(arg...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; multiply(3, 4, 5) &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; multiply() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用逗号表达式<br>初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc… )，最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class F, class... Args&gt;void expand(const F&amp; f, Args&amp;&amp;...args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》</span><br><span class=\"line\">  initializer_list&lt;int&gt;&#123;(f(std::forward&lt; Args&gt;(args)),0)...&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    expand([](int i) &#123;</span><br><span class=\"line\">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class=\"line\">    &#125;, 1,2,3);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"initializer-list\"><a href=\"#initializer-list\" class=\"headerlink\" title=\"initializer_list\"></a>initializer_list</h3><p>为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct myclass &#123;</span><br><span class=\"line\">    myclass(int,int)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;myclass constructor&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    myclass(initializer_list&lt;int&gt;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;myclass initializer_list constructor&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    auto il = &#123;10, 20, 30&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    myclass foo &#123;10,20&#125;;  // calls initializer_list constructor</span><br><span class=\"line\">    myclass bar (10,20);  // calls first constructo</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"可变模版参数-variadic-templates\"><a href=\"#可变模版参数-variadic-templates\" class=\"headerlink\" title=\"可变模版参数(variadic templates)\"></a>可变模版参数(variadic templates)</h3><p>可以对参数进行高度泛化，标识0到任意个数参数</p>\n<h4 id=\"两种展开形式\"><a href=\"#两种展开形式\" class=\"headerlink\" title=\"两种展开形式\"></a>两种展开形式</h4><ol>\n<li>使用特化的终止函数结合递归</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">//终止函数</span><br><span class=\"line\">int multiply()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//递归展开</span><br><span class=\"line\">template &lt;typename T, typename ...Args&gt;</span><br><span class=\"line\">int multiply(T&amp;&amp; t, Args&amp;&amp; ...arg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return t * multiply(arg...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; multiply(3, 4, 5) &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; multiply() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用逗号表达式<br>初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc… )，最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class F, class... Args&gt;void expand(const F&amp; f, Args&amp;&amp;...args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》</span><br><span class=\"line\">  initializer_list&lt;int&gt;&#123;(f(std::forward&lt; Args&gt;(args)),0)...&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    expand([](int i) &#123;</span><br><span class=\"line\">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class=\"line\">    &#125;, 1,2,3);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"initializer-list\"><a href=\"#initializer-list\" class=\"headerlink\" title=\"initializer_list\"></a>initializer_list</h3><p>为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct myclass &#123;</span><br><span class=\"line\">    myclass(int,int)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;myclass constructor&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    myclass(initializer_list&lt;int&gt;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;myclass initializer_list constructor&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    auto il = &#123;10, 20, 30&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    myclass foo &#123;10,20&#125;;  // calls initializer_list constructor</span><br><span class=\"line\">    myclass bar (10,20);  // calls first constructo</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n"},{"title":"电子书目录","date":"2022-12-25T15:36:30.000Z","_content":"\n## 渲染整理\n\n\n#### 开放世界的场景管理\n\t1. 切成tile\n\t2. 数据分级LOD\n\t3. 根据天顶角，调整远平面，裁剪数据\n\n#### 游戏引擎分层架构\n\t1. EditorLayer\n\t2. FuntionLayer\n\t\t1. Rendering\n\t\t2. Animation\n\t\t3. Camera\n\t\t4. Physics\n\t\t5. Script\n\t3. ResourceLayer\n\t4. CoreLayer\n\t\t1. threadPoolManagement\n\t\t2. memoryPool\n\t\t3. mathLibrary\n\t5. PlatformLayer\n\t\t1. RHI\n\n#### Renderable\n\t1. shader\n\t\t1. vs,fs\n\t\t2. macro\n\t2. RenderState\n\t3. MVP \n\t4. Texture\n\t5. DrawImp\n\n#### 渲染效果\n\t1. 前向渲染\n  \t\t1. PBR\n  \t\t2. 布林冯模型\n\t2. 阴影shadowMap：\n\t\t1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性\n\t\t2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度\n\t3. 楼的倒影\n\t4. AO\n\t5. 聚光灯效果\n\t6. UV动画\n\n#### 技术点提炼\n\t1. 楼块\n\t\t1. 切成小块\n\t\t2. 柔化圆角\n\t\t3. 贴UV\n\t2. 3d瓦片绘制\n\t\t1. 瓦片的加载，与cache\n\t\t2. 非实施例渲染，按材质进行分类渲染\n\t\t3. 实例化渲染，动态计算lod进行渲染\n\t3. 模型渲染\n\t\t1. PBR渲染\n\t\t2. 非PBR渲染","source":"_posts/电子书目录.md","raw":"---\ntitle: 电子书目录\ndate: 2022-12-25 23:36:30\ntags:\n---\n\n## 渲染整理\n\n\n#### 开放世界的场景管理\n\t1. 切成tile\n\t2. 数据分级LOD\n\t3. 根据天顶角，调整远平面，裁剪数据\n\n#### 游戏引擎分层架构\n\t1. EditorLayer\n\t2. FuntionLayer\n\t\t1. Rendering\n\t\t2. Animation\n\t\t3. Camera\n\t\t4. Physics\n\t\t5. Script\n\t3. ResourceLayer\n\t4. CoreLayer\n\t\t1. threadPoolManagement\n\t\t2. memoryPool\n\t\t3. mathLibrary\n\t5. PlatformLayer\n\t\t1. RHI\n\n#### Renderable\n\t1. shader\n\t\t1. vs,fs\n\t\t2. macro\n\t2. RenderState\n\t3. MVP \n\t4. Texture\n\t5. DrawImp\n\n#### 渲染效果\n\t1. 前向渲染\n  \t\t1. PBR\n  \t\t2. 布林冯模型\n\t2. 阴影shadowMap：\n\t\t1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性\n\t\t2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度\n\t3. 楼的倒影\n\t4. AO\n\t5. 聚光灯效果\n\t6. UV动画\n\n#### 技术点提炼\n\t1. 楼块\n\t\t1. 切成小块\n\t\t2. 柔化圆角\n\t\t3. 贴UV\n\t2. 3d瓦片绘制\n\t\t1. 瓦片的加载，与cache\n\t\t2. 非实施例渲染，按材质进行分类渲染\n\t\t3. 实例化渲染，动态计算lod进行渲染\n\t3. 模型渲染\n\t\t1. PBR渲染\n\t\t2. 非PBR渲染","slug":"电子书目录","published":1,"updated":"2022-12-25T15:37:33.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clc3jbpcq0001dlvq12d2ayeo","content":"<h2 id=\"渲染整理\"><a href=\"#渲染整理\" class=\"headerlink\" title=\"渲染整理\"></a>渲染整理</h2><h4 id=\"开放世界的场景管理\"><a href=\"#开放世界的场景管理\" class=\"headerlink\" title=\"开放世界的场景管理\"></a>开放世界的场景管理</h4><pre><code>1. 切成tile\n2. 数据分级LOD\n3. 根据天顶角，调整远平面，裁剪数据\n</code></pre>\n<h4 id=\"游戏引擎分层架构\"><a href=\"#游戏引擎分层架构\" class=\"headerlink\" title=\"游戏引擎分层架构\"></a>游戏引擎分层架构</h4><pre><code>1. EditorLayer\n2. FuntionLayer\n    1. Rendering\n    2. Animation\n    3. Camera\n    4. Physics\n    5. Script\n3. ResourceLayer\n4. CoreLayer\n    1. threadPoolManagement\n    2. memoryPool\n    3. mathLibrary\n5. PlatformLayer\n    1. RHI\n</code></pre>\n<h4 id=\"Renderable\"><a href=\"#Renderable\" class=\"headerlink\" title=\"Renderable\"></a>Renderable</h4><pre><code>1. shader\n    1. vs,fs\n    2. macro\n2. RenderState\n3. MVP \n4. Texture\n5. DrawImp\n</code></pre>\n<h4 id=\"渲染效果\"><a href=\"#渲染效果\" class=\"headerlink\" title=\"渲染效果\"></a>渲染效果</h4><pre><code>1. 前向渲染\n      1. PBR\n      2. 布林冯模型\n2. 阴影shadowMap：\n    1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性\n    2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度\n3. 楼的倒影\n4. AO\n5. 聚光灯效果\n6. UV动画\n</code></pre>\n<h4 id=\"技术点提炼\"><a href=\"#技术点提炼\" class=\"headerlink\" title=\"技术点提炼\"></a>技术点提炼</h4><pre><code>1. 楼块\n    1. 切成小块\n    2. 柔化圆角\n    3. 贴UV\n2. 3d瓦片绘制\n    1. 瓦片的加载，与cache\n    2. 非实施例渲染，按材质进行分类渲染\n    3. 实例化渲染，动态计算lod进行渲染\n3. 模型渲染\n    1. PBR渲染\n    2. 非PBR渲染\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"渲染整理\"><a href=\"#渲染整理\" class=\"headerlink\" title=\"渲染整理\"></a>渲染整理</h2><h4 id=\"开放世界的场景管理\"><a href=\"#开放世界的场景管理\" class=\"headerlink\" title=\"开放世界的场景管理\"></a>开放世界的场景管理</h4><pre><code>1. 切成tile\n2. 数据分级LOD\n3. 根据天顶角，调整远平面，裁剪数据\n</code></pre>\n<h4 id=\"游戏引擎分层架构\"><a href=\"#游戏引擎分层架构\" class=\"headerlink\" title=\"游戏引擎分层架构\"></a>游戏引擎分层架构</h4><pre><code>1. EditorLayer\n2. FuntionLayer\n    1. Rendering\n    2. Animation\n    3. Camera\n    4. Physics\n    5. Script\n3. ResourceLayer\n4. CoreLayer\n    1. threadPoolManagement\n    2. memoryPool\n    3. mathLibrary\n5. PlatformLayer\n    1. RHI\n</code></pre>\n<h4 id=\"Renderable\"><a href=\"#Renderable\" class=\"headerlink\" title=\"Renderable\"></a>Renderable</h4><pre><code>1. shader\n    1. vs,fs\n    2. macro\n2. RenderState\n3. MVP \n4. Texture\n5. DrawImp\n</code></pre>\n<h4 id=\"渲染效果\"><a href=\"#渲染效果\" class=\"headerlink\" title=\"渲染效果\"></a>渲染效果</h4><pre><code>1. 前向渲染\n      1. PBR\n      2. 布林冯模型\n2. 阴影shadowMap：\n    1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性\n    2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度\n3. 楼的倒影\n4. AO\n5. 聚光灯效果\n6. UV动画\n</code></pre>\n<h4 id=\"技术点提炼\"><a href=\"#技术点提炼\" class=\"headerlink\" title=\"技术点提炼\"></a>技术点提炼</h4><pre><code>1. 楼块\n    1. 切成小块\n    2. 柔化圆角\n    3. 贴UV\n2. 3d瓦片绘制\n    1. 瓦片的加载，与cache\n    2. 非实施例渲染，按材质进行分类渲染\n    3. 实例化渲染，动态计算lod进行渲染\n3. 模型渲染\n    1. PBR渲染\n    2. 非PBR渲染\n</code></pre>\n"}],"PostAsset":[{"_id":"source/_posts/add-Image/sharedptr1.png","slug":"sharedptr1.png","post":"cl9lffyw2000ty2vqh991a146","modified":0,"renderable":0},{"_id":"source/_posts/add-Image/sharedptr2.png","slug":"sharedptr2.png","post":"cl9lffyw2000ty2vqh991a146","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cl9lffyvn0004y2vq69avcwmr","tag_id":"cl9lffyvl0002y2vq0nrkcg4s","_id":"cl9lffyvq0007y2vq4pmph69q"},{"post_id":"cl9lffyve0000y2vqagr71lxx","tag_id":"cl9lffyvl0002y2vq0nrkcg4s","_id":"cl9lffyvr0009y2vq7pad8xi3"},{"post_id":"cl9lffyvo0005y2vq4sih91wm","tag_id":"cl9lffyvl0002y2vq0nrkcg4s","_id":"cl9lffyvt000cy2vqb1t622do"},{"post_id":"cl9lffyvj0001y2vqbzv818m7","tag_id":"cl9lffyvl0002y2vq0nrkcg4s","_id":"cl9lffyvu000ey2vq00px2c4o"},{"post_id":"cl9lffyvm0003y2vq4py2b97x","tag_id":"cl9lffyvl0002y2vq0nrkcg4s","_id":"cl9lffyvw000hy2vqdforeqk5"},{"post_id":"cl9lffyvq0008y2vq3tkbh4xb","tag_id":"cl9lffyvv000gy2vq2han25vm","_id":"cl9lffyvz000my2vqb50l69nx"},{"post_id":"cl9lffyvr000ay2vqgxs0fhnu","tag_id":"cl9lffyvv000gy2vq2han25vm","_id":"cl9lffyw1000qy2vqhl4c1nue"},{"post_id":"cl9lffyvt000dy2vq2v714z0j","tag_id":"cl9lffyvv000gy2vq2han25vm","_id":"cl9lffyw3000uy2vqdgbicb3z"},{"post_id":"cl9lffyvu000fy2vq44oy9srb","tag_id":"cl9lffyvv000gy2vq2han25vm","_id":"cl9lffyw5000yy2vqcr9s9sz1"},{"post_id":"cl9lffyw3000vy2vqc3e55i0z","tag_id":"cl9lffyvv000gy2vq2han25vm","_id":"cl9lffyw60010y2vqgcqngivb"},{"post_id":"cl9lffyw4000xy2vq3jqdfy1n","tag_id":"cl9lffyvv000gy2vq2han25vm","_id":"cl9lffyw70013y2vqek3od2cd"},{"post_id":"cl9lffyvw000iy2vqeknfd1ia","tag_id":"cl9lffyvv000gy2vq2han25vm","_id":"cl9lffyw80015y2vq7ujg1ebf"},{"post_id":"cl9lffyvw000iy2vqeknfd1ia","tag_id":"cl9lffyw4000wy2vqbt6kfb65","_id":"cl9lffyw90018y2vq35i6er6i"},{"post_id":"cl9lffyw5000zy2vqavs7hjwf","tag_id":"cl9lffyvv000gy2vq2han25vm","_id":"cl9lffywa0019y2vqhp8r32q4"},{"post_id":"cl9lffyw70012y2vq7o8tb306","tag_id":"cl9lffyvv000gy2vq2han25vm","_id":"cl9lffywa001by2vq7xkpdcjc"},{"post_id":"cl9lffyvx000jy2vq8dnc9pxr","tag_id":"cl9lffyw60011y2vq1du36y50","_id":"cl9lffywa001cy2vq351w07kc"},{"post_id":"cl9lffyw70014y2vqbt2h0g5p","tag_id":"cl9lffyvv000gy2vq2han25vm","_id":"cl9lffywb001ey2vqei8w2ipk"},{"post_id":"cl9lffyw80017y2vq1nzphzwc","tag_id":"cl9lffyvv000gy2vq2han25vm","_id":"cl9lffywb001fy2vqf1lq6szk"},{"post_id":"cl9lffyvy000ly2vq4fyy2hn8","tag_id":"cl9lffyw60011y2vq1du36y50","_id":"cl9lffywb001hy2vq6l7u83ch"},{"post_id":"cl9lffyvz000ny2vq61m3em0n","tag_id":"cl9lffyw60011y2vq1du36y50","_id":"cl9lffywb001iy2vqb1xr9lfy"},{"post_id":"cl9lffyw0000py2vqfxfcfujp","tag_id":"cl9lffyw60011y2vq1du36y50","_id":"cl9lffywc001ky2vq2wq47u61"},{"post_id":"cl9lffyw0000py2vqfxfcfujp","tag_id":"cl9lffyvv000gy2vq2han25vm","_id":"cl9lffywc001ly2vq0gj51pch"},{"post_id":"cl9lffyw1000ry2vq1hiy961v","tag_id":"cl9lffyw60011y2vq1du36y50","_id":"cl9lffywc001my2vq84q7hark"},{"post_id":"cl9lffyw2000ty2vqh991a146","tag_id":"cl9lffywc001jy2vq0kvb7k1z","_id":"cl9lffywc001ny2vq6fzn8sry"},{"post_id":"cla7onlj70000ztvqh5nb73ei","tag_id":"cl9lffyw60011y2vq1du36y50","_id":"cla7onljc0001ztvq053u65vc"},{"post_id":"clc3jbpcl0000dlvq58w60usi","tag_id":"clc3jbpcs0002dlvq1ims7u2j","_id":"clc3jbpcz0003dlvq4gsw2blo"}],"Tag":[{"name":"C++11","_id":"cl9lffyvl0002y2vq0nrkcg4s"},{"name":"iOS","_id":"cl9lffyvv000gy2vq2han25vm"},{"name":"ruby","_id":"cl9lffyw4000wy2vqbt6kfb65"},{"name":"openGL","_id":"cl9lffyw60011y2vq1du36y50"},{"name":"test","_id":"cl9lffywc001jy2vq0kvb7k1z"},{"name":"c++11","_id":"clc3jbpcs0002dlvq1ims7u2j"}]}}