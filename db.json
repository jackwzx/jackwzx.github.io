{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/baidu_verify.html","hash":"c122504f727ea8ff038abc082ce498bf44bb4128","modified":1749285300402},{"_id":"source/google_verify.html","hash":"a8c5ff3508f30c751eb16e1146b3274ba14ec907","modified":1749285292410},{"_id":"source/.DS_Store","hash":"bac5a892d4d7fabdfae66400255e3519a1309ca8","modified":1749283366513},{"_id":"source/googlef6f290aede027823.html","hash":"9543bec41cf242b21f83e87b0480898a0ef578ba","modified":1749285812509},{"_id":"source/_posts/AddressSanitizer实现原理.md","hash":"308bad60421cc0fa9f11ebeb76bd9133e4c845b2","modified":1740056868000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1666528838000},{"_id":"source/robots.txt","hash":"2f88235dff1bbf48f7841075a244dde57037345f","modified":1749285284892},{"_id":"source/_posts/C++-智能指针.md","hash":"c96893723adc35dec3bf88e925a993ccfeb89770","modified":1740056868000},{"_id":"source/_posts/AndoirdEGLContext销毁管理.md","hash":"fed0322b95d57c55f97b74163dc438431921775c","modified":1740056868000},{"_id":"source/_posts/C++实现完美转发.md","hash":"7ae1a4318ad2c2ea8999b45250e225c1732a574a","modified":1740056868000},{"_id":"source/_posts/C++中operator的重载.md","hash":"c3184c3ad48c6d62b0a0fb289ed096917b7591eb","modified":1740056868000},{"_id":"source/_posts/C++构造函数.md","hash":"6690e714d570ebc825f4131eb72e60bbe222f662","modified":1740056868000},{"_id":"source/_posts/C++右值引用.md","hash":"58981687a1982cf532f1d770a6cac8e93455c16e","modified":1740056868000},{"_id":"source/_posts/CALayer-opaque.md","hash":"d7522f9aacbdea74344b44352173765566f9187a","modified":1740056868000},{"_id":"source/_posts/CALayer属性positon和anchor.md","hash":"792de5cb4a535d8c168f8c7ebf3f945e547e864f","modified":1740056868000},{"_id":"source/_posts/CALayer的presentLayer那点事.md","hash":"af82e11e1745d65389117f6ae40d8f5f6beee65d","modified":1740056868000},{"_id":"source/_posts/How to build Apple Watch App.md","hash":"2520dba99fc20ad966689919aa93391a413cf76d","modified":1740056868000},{"_id":"source/_posts/MacOS下ruby安装.md","hash":"3f71b14964c96da93e0411ee2eaece253a101611","modified":1740056868000},{"_id":"source/_posts/OpenGL-VBO.md","hash":"25bcfa10e6a6abfcec24e7d2d474be055f40ca3a","modified":1740056868000},{"_id":"source/_posts/OpenGL-uniform和attribute.md","hash":"21003e0a8fca07b7051c4bc2dea1f03fd9fd8f86","modified":1740056868000},{"_id":"source/_posts/OpenGL-光照学习.md","hash":"42bb93bb87fbdd1940720e9db6b919c873b159f2","modified":1740056868000},{"_id":"source/_posts/C++类型转换陷阱-有符号和无符号整数比较.md","hash":"ff0de26493c0d8b0475488c95e073293f973a2e9","modified":1749715708440},{"_id":"source/_posts/OpenGL-基本框架搭建和绘制一个简单图形.md","hash":"e1aec3369a5014404c6cafc61fcda02871b70b56","modified":1740056868000},{"_id":"source/_posts/OpenGL-纹理贴图.md","hash":"4413e1025c062dff341b5ed28e10619c162c6756","modified":1740056868000},{"_id":"source/_posts/OpenGLE-VAO局部影响vs全局影响.md","hash":"e9c884f45e1ffe8e506da6f353065f6aca6fdaaa","modified":1740056868000},{"_id":"source/_posts/OpenGLES设置顶点属性的默认值.md","hash":"cf545dc8f9a0161d5df22b1249caf1302f1c1e43","modified":1740056868000},{"_id":"source/_posts/OpenGL模板测试流程.md","hash":"475341f02bc6cc776e8f68051cdb9730c0e26a15","modified":1740056868000},{"_id":"source/_posts/add-Image.md","hash":"fa3ffe48c50ab3d06b7df2d29b62982acf15b098","modified":1740056868000},{"_id":"source/_posts/UTF编码内存角度比较-md.md","hash":"c872f6f1dee879dae8e3c1a1bd21b9cc59eec335","modified":1740056868000},{"_id":"source/_posts/c-可变参数模板.md","hash":"1627e1423222f2b2c5b22063271694fb46949013","modified":1740056868000},{"_id":"source/_posts/c-继承权限.md","hash":"b2630ec4e2d73ad764c280c5d96bd7d10442abe0","modified":1740056868000},{"_id":"source/_posts/iOS-MessageForwarding.md","hash":"9a0a66b214eb08396328e4a042952b7877bfe822","modified":1740056868000},{"_id":"source/_posts/SDF实现CornerRadius.md","hash":"e531d10e1dce1549617eb3de80bc3f3b8a14a1e3","modified":1749288133086},{"_id":"source/_posts/iOS11 Simulator OpenGL Slowly.md","hash":"eaa70b4a2594deea47c90a57499892ddc4b1e6e7","modified":1740056868000},{"_id":"source/_posts/iOS准确计时.md","hash":"ff7ba31fe710f4ee39e3e1255ba2cc0f63d2b3e1","modified":1740056868000},{"_id":"source/_posts/iOS手势事件分发原理.md","hash":"d39f9a97b434d92ed17ec9dd8a1f5934631009e8","modified":1740056868000},{"_id":"source/_posts/c-模版函数delete防止隐士类型转换-md.md","hash":"d6b0d75b2e74db0b53b061b14c16cd100b8a6583","modified":1749287998875},{"_id":"source/_posts/shell和子shell环境变量.md","hash":"4dc57799c53b3b4566d8850ec0d4bebe64b195d3","modified":1740056868000},{"_id":"source/_posts/std-nth-element实现.md","hash":"f493cc4efd1f1f0d93e73a28e830e89c5d754213","modified":1740056868000},{"_id":"source/_posts/texelFetch.md","hash":"453e463453b0e1afad158181bc7d4cf20feade38","modified":1740056868000},{"_id":"source/_posts/smoothStep实现.md","hash":"0905c49618c38fd55a63de233451331c072507ae","modified":1749289146409},{"_id":"source/_posts/tag-dispatch.md","hash":"b5cf4d7f05ffb0bc45abeee92ddeb84dfa1befb2","modified":1740056868000},{"_id":"source/_posts/lamda-初始化捕获用法.md","hash":"36ff6c11a06c86f3e7ab66ac507fdcf68bd58f92","modified":1749288141066},{"_id":"source/_posts/pthread-create设置栈size.md","hash":"0e61dc0e8ce80ae6428c961a3b811b75baeb2b80","modified":1749288285445},{"_id":"source/_posts/traits设计和用法.md","hash":"5c434a0c55be7bfb0a8200350d2032f902ff7a0b","modified":1740056868000},{"_id":"source/_posts/tweak使用说明.md","hash":"b7c4d8f1339a1a787c8563d110d66955698c7195","modified":1740056868000},{"_id":"source/_posts/tweak环境搭建.md","hash":"7fee054633a5e8ece769e641dc07eae507f7a49e","modified":1740056868000},{"_id":"source/_posts/使用-asan-unpoison-memory-region屏蔽某处内存检查.md","hash":"c95ae15a53a6b4f6029983a9c849041fb539d122","modified":1740056868000},{"_id":"source/_posts/从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵.md","hash":"020036d2019c77c1730984a9bab08f4f700635aa","modified":1740056868000},{"_id":"source/_posts/trivially-copyable-拷贝不变.md","hash":"899fc9536f4c46b786a91a04ddb461fcfb4d6b9b","modified":1749288154965},{"_id":"source/_posts/type-script.md","hash":"8ea07dfdd217ba5b2cb27567cc68686ca82d100b","modified":1742052368876},{"_id":"source/_posts/what-is-mpx.md","hash":"0939b58d470be252abce8f80e90c393c95cf9d4c","modified":1742051368145},{"_id":"source/_posts/分支预测.md","hash":"411dcd66dbf1077eac718e1afe48a234e6f1754e","modified":1740056868000},{"_id":"source/_posts/模板规则推导.md","hash":"06306b48d8017c1732aa28ddc2a9e40bafc0a080","modified":1740056868000},{"_id":"source/_posts/正则与通配符区别.md","hash":"992ca4e2d730fb543f201f3278852532585641bc","modified":1740056868000},{"_id":"source/_posts/电子书目录.md","hash":"191ef11e421a9256c160b7223559a3f2a94bb926","modified":1740056868000},{"_id":"source/_posts/命令行通配符.md","hash":"aefb31ae287212235e34ea12b1d3383a8ac46c74","modified":1749287779436},{"_id":"source/_posts/如何让孩子戒掉手机爱上阅读-实用策略指南.md","hash":"26be65577123278d4948f1ab1b10c015a10ecdbe","modified":1749289237530},{"_id":"source/_posts/培养孩子阅读习惯的优质书单推荐.md","hash":"1fa40b69381792a8c56985239ce644039f413ce2","modified":1749289865668},{"_id":"source/_posts/add-Image/sharedptr1.png","hash":"ef9802a63197339362725253f40a8f6af13991e2","modified":1740056868000},{"_id":"source/_posts/add-Image/sharedptr2.png","hash":"8e51afea16d9407343cefb650097d2c91b00bc39","modified":1740056868000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1740056868000},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1740056868000},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1740056868000},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1740056868000},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1740056868000},{"_id":"themes/landscape/_config.yml","hash":"e3abc40dcd514a78fd69d02a48351b57fe288236","modified":1749287635398},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1740056868000},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1740056868000},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1740056868000},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1740056868000},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1740056868000},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1740056868000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1740056868000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1740056868000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1740056868000},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1740056868000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1740056868000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1740056868000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1740056868000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1740056868000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1740056868000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1740056868000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1740056868000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1740056868000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1740056868000},{"_id":"themes/landscape/layout/layout.ejs","hash":"fec72d1fe70469ba7f0debe02b69ef228b2841a2","modified":1749286852840},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"d43a28f132e7ac8cc80193652cc3609976994458","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"291183319b7f6df04466136c174b6c8f937b7d56","modified":1749284797251},{"_id":"themes/landscape/layout/_partial/google-adsense.ejs","hash":"c270861fe387745a35e708ee27435e86505d920f","modified":1749283969729},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"7e9361b8c9df49fb65a260de383631848ad5b515","modified":1749283977794},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1740056868000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1740056868000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1740056868000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/local-search.ejs","hash":"30a64abebd69dd031336aff9b7ba72c5711dbe7e","modified":1749287394168},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"9ea6b90f4477b46901add1d8a22dcb0599a4f2e4","modified":1749286866810},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1740056868000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1740056868000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1740056868000},{"_id":"themes/landscape/source/css/style.styl","hash":"134ef546dc91d7301c7496bfd3be895a765ddede","modified":1749286833193},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1740056868000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1740056868000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"63e2e00e368c9375738a69101de28ebd1cccc0c2","modified":1749287706306},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/search.styl","hash":"4fcf417d0ec4a0521a974599618c0663096c0b30","modified":1749287367042},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1740056868000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1740056868000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1740056868000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1740056868000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1740056868000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1740056868000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1740056868000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1740056868000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1740056868000},{"_id":"public/baidu_verify.html","hash":"50539f0a06697be3c65e24c858d22f4123b6e0e8","modified":1749957141254},{"_id":"public/google_verify.html","hash":"8db3b213ce77708d05b6392946810f8340ef11f0","modified":1749957141254},{"_id":"public/baidusitemap.xml","hash":"dac63ab8ee0dc2d5bb444683413d6c35d0249d2d","modified":1750755738636},{"_id":"public/googlef6f290aede027823.html","hash":"933a63c2fa95353be03c88fcc7bba75f695c6f63","modified":1749957141254},{"_id":"public/atom.xml","hash":"453a4f36d26ad097e70ddd68eed1c46062f7bb66","modified":1750755738636},{"_id":"public/search.xml","hash":"f2c797181d3b6646c1d655982d084eef7ad3143a","modified":1750755738636},{"_id":"public/sitemap.xml","hash":"4e9465c405b910d0e85a3a3e51d3e5d174751057","modified":1750755738636},{"_id":"public/2025/06/08/C++类型转换陷阱-有符号和无符号整数比较/index.html","hash":"32ba3b7960814711115be0d59edf0c2e431b7f51","modified":1750755738636},{"_id":"public/2025/06/07/培养孩子阅读习惯的优质书单推荐/index.html","hash":"fce1f8ad8b855df5a15bbc6c8464ce864faa4cfc","modified":1750755738636},{"_id":"public/2025/06/07/如何让孩子戒掉手机爱上阅读-实用策略指南/index.html","hash":"562aa31e0b3dd4a048c9dac8af44309f18477d27","modified":1750755738636},{"_id":"public/2025/03/15/type-script/index.html","hash":"2c03f7a6e9375fcd6d87faf2dbf84076b54eaf5f","modified":1750755738636},{"_id":"public/2025/03/15/what-is-mpx/index.html","hash":"d480b54ffd571b6209a1b32453ecc0b5ec7aea2e","modified":1750755738636},{"_id":"public/2024/11/04/命令行通配符/index.html","hash":"fc6315036487a4a5c927068d7785002950fd0402","modified":1750755738636},{"_id":"public/2024/10/11/正则与通配符区别/index.html","hash":"4e340aa76e6a7013181d6bae019bfad12e9ca4af","modified":1750755738636},{"_id":"public/2024/10/08/std-nth-element实现/index.html","hash":"d574008c51e7fdc74009ce65bcc8391f337e98c6","modified":1750755738636},{"_id":"public/2024/10/06/texelFetch/index.html","hash":"ea1de3edd441f1b5958bbfa793800e0836d714ea","modified":1750755738636},{"_id":"public/2024/09/29/traits设计和用法/index.html","hash":"d9feea9bf3f06dd0d9a51f85dd10f22e4557dd66","modified":1750755738636},{"_id":"public/2024/09/29/shell和子shell环境变量/index.html","hash":"25bbe9a75e3001ba9f648da177fab14f9594244c","modified":1750755738636},{"_id":"public/2024/09/27/分支预测/index.html","hash":"de699d9e758a693bbaee75f64b4cc3033dac5f6a","modified":1750755738636},{"_id":"public/2024/09/26/c-模版函数delete防止隐士类型转换-md/index.html","hash":"c00887039f77b8105bc1083ecbaaf90b445541f0","modified":1750755738636},{"_id":"public/2024/08/01/AndoirdEGLContext销毁管理/index.html","hash":"4c9f990484190245b143f1673ef6f0b535d73966","modified":1750755738636},{"_id":"public/2024/07/30/从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵/index.html","hash":"acec38625df7b3cd28b4a723f3cdcb671581dad7","modified":1750755738636},{"_id":"public/2024/07/28/OpenGLE-VAO局部影响vs全局影响/index.html","hash":"a354eb948f7d8cdd9c2f2fa020bc7f69f389bddd","modified":1750755738636},{"_id":"public/2024/07/28/OpenGLES设置顶点属性的默认值/index.html","hash":"a0849c85ab7e345ecb631a405bc01032e0657936","modified":1750755738636},{"_id":"public/2024/07/28/AddressSanitizer实现原理/index.html","hash":"bdfd068e6123a1947caebc1b98c86383080fe224","modified":1750755738636},{"_id":"public/2024/07/28/pthread-create设置栈size/index.html","hash":"32f52367facca275b8b594d911a24caf6e45a72f","modified":1750755738636},{"_id":"public/2024/07/22/使用-asan-unpoison-memory-region屏蔽某处内存检查/index.html","hash":"dfa12328a00e86173f3eb3701ac80dc35241884f","modified":1750755738636},{"_id":"public/2024/07/11/UTF编码内存角度比较-md/index.html","hash":"a744c2c1056f111c3115815a10555a794a9a8f81","modified":1750755738636},{"_id":"public/2023/12/28/SDF实现CornerRadius/index.html","hash":"15e50287cc44ffb2fbbe75c0108891170c357d56","modified":1750755738636},{"_id":"public/2023/12/27/lamda-初始化捕获用法/index.html","hash":"9ec2de043dcf8f7a432acbe89b69c260555b4970","modified":1750755738636},{"_id":"public/2023/12/24/tag-dispatch/index.html","hash":"f24f7dfbd535f633fd0bc6876c0b7041028c66b8","modified":1750755738636},{"_id":"public/2023/12/22/smoothStep实现/index.html","hash":"5efd194279ee73d602f929ae94a094b7f9ea72e0","modified":1750755738636},{"_id":"public/2023/12/21/模板规则推导/index.html","hash":"1c863b6fa9b55069492563967816004e30f81851","modified":1750755738636},{"_id":"public/2022/12/25/电子书目录/index.html","hash":"910b53074b0784fc62540c84fa93a94d62798911","modified":1750755738636},{"_id":"public/2022/12/11/c-可变参数模板/index.html","hash":"cd4d2df28b5edf96f7a1824b51e5676ce22f087f","modified":1750755738636},{"_id":"public/2022/12/04/c-继承权限/index.html","hash":"7fee6d0b69b006085ae2cb21d7a820389c623b46","modified":1750755738636},{"_id":"public/2022/11/08/OpenGL模板测试流程/index.html","hash":"33bed639291365a07e170244def07e2505d3c03b","modified":1750755738636},{"_id":"public/2022/10/25/trivially-copyable-拷贝不变/index.html","hash":"f0e157604b2009aea8e96b85f8e5bcb4ef73a1aa","modified":1750755738636},{"_id":"public/2022/10/23/C++实现完美转发/index.html","hash":"82c69805c7c10ab0b6f2d85ccb03298879d3bfef","modified":1750755738636},{"_id":"public/2022/09/25/add-Image/index.html","hash":"78c96a3547d6a4031b695b3a4fef1d8881074f9b","modified":1750755738636},{"_id":"public/2022/09/25/C++-智能指针/index.html","hash":"b1638901153a4b605e7fd01978600f7810b61e6b","modified":1750755738636},{"_id":"public/2022/09/18/C++右值引用/index.html","hash":"de5cd97771c3a018f1ee61ae5291710631c6d814","modified":1750755738636},{"_id":"public/2022/09/18/C++中operator的重载/index.html","hash":"0e69163582cff9b66c6e454f02be1e4ea1a13de2","modified":1750755738636},{"_id":"public/2022/09/18/C++构造函数/index.html","hash":"714bc57a1b747ee4d360684eeb041a9c9086de77","modified":1750755738636},{"_id":"public/2017/12/14/iOS-MessageForwarding/index.html","hash":"adacdc5325a40e584746375290ed817f4eec1839","modified":1750755738636},{"_id":"public/2017/11/12/CALayer的presentLayer那点事/index.html","hash":"5b66e5515e0ce1cb051caafaa31f4ab0d089db2b","modified":1750755738636},{"_id":"public/2017/09/19/MacOS下ruby安装/index.html","hash":"373605f1440003928163c32a70a30df53a781a6c","modified":1750755738636},{"_id":"public/2017/09/19/iOS11 Simulator OpenGL Slowly/index.html","hash":"45d41e9d576b47c0c816bd2bfc9b77a7e2f7b054","modified":1750755738636},{"_id":"public/2017/09/17/iOS准确计时/index.html","hash":"9ca757b8b8ec774ad36589bedbb1f08c79f34730","modified":1750755738636},{"_id":"public/2017/07/01/iOS手势事件分发原理/index.html","hash":"5bc91135a14e75714818e499b879a3b767abe4e9","modified":1750755738636},{"_id":"public/2017/03/07/tweak使用说明/index.html","hash":"c320ca39edef62f975d539ab1c8ef93d8345c347","modified":1750755738636},{"_id":"public/2017/03/07/tweak环境搭建/index.html","hash":"1303de6169809cdff5e01b14828d56d7ad92c8f7","modified":1750755738636},{"_id":"public/2017/01/03/OpenGL-纹理贴图/index.html","hash":"52f4d67829f9d3ea8edf2fcac1e7fd9d04228596","modified":1750755738636},{"_id":"public/2017/01/02/OpenGL-光照学习/index.html","hash":"0110b743b65ca4729eac90ff374c85baf19035d1","modified":1750755738636},{"_id":"public/2017/01/02/OpenGL-VBO/index.html","hash":"037ce6925747a4a3faab421868e1b6df5aef3b57","modified":1750755738636},{"_id":"public/2016/12/30/OpenGL-uniform和attribute/index.html","hash":"830b05be4942d6300c5fb536a2930b9196882177","modified":1750755738636},{"_id":"public/2016/12/30/OpenGL-基本框架搭建和绘制一个简单图形/index.html","hash":"735de209f1af239d5e65b74431575bc93824d2fe","modified":1750755738636},{"_id":"public/2016/12/30/CALayer-opaque/index.html","hash":"3e90b23f21c2c00c3ba73ca67ed1b56b41eaf655","modified":1750755738636},{"_id":"public/2016/10/26/CALayer属性positon和anchor/index.html","hash":"56fdb4e9caf0513ce9c3c83aada1cdf75f13cd9d","modified":1750755738636},{"_id":"public/2016/10/26/How to build Apple Watch App/index.html","hash":"51d6486be7b52cbea30e49cc65f89a32681e7a3c","modified":1750755738636},{"_id":"public/archives/index.html","hash":"ee0793611d35a60b6c52a6ca338e7931d210e954","modified":1750755738636},{"_id":"public/archives/page/2/index.html","hash":"8f3a6902b1f94e14a659ac072b34072cb3348b92","modified":1750755738636},{"_id":"public/archives/page/3/index.html","hash":"787d7c15fa7dca83098c2fd18e46614006100b09","modified":1750755738636},{"_id":"public/archives/page/4/index.html","hash":"245665768c12f9797f3c8d8fb961027e610650a8","modified":1750755738636},{"_id":"public/archives/page/5/index.html","hash":"9d8e0578c664af383d3c9f7480f8b0b29cac3cca","modified":1750755738636},{"_id":"public/archives/page/6/index.html","hash":"38e79bbdda4318e9c13357ed312c84b6dc7737c8","modified":1750755738636},{"_id":"public/archives/2016/index.html","hash":"b42ffff865ad67ed0fc045deb1461c8edae89bac","modified":1750755738636},{"_id":"public/archives/2016/10/index.html","hash":"8ce3c5287347a7427e378f8a4ec9845028bd4ba1","modified":1750755738636},{"_id":"public/archives/2016/12/index.html","hash":"30e09f1dfd710af1b9307df2a741e90b6948834b","modified":1750755738636},{"_id":"public/archives/2017/index.html","hash":"797711c580a89a8f49a4384a2c1430b3f8bb65a9","modified":1750755738636},{"_id":"public/archives/2017/page/2/index.html","hash":"512f361bddf247d7a209c6d2ff639a454ca8683f","modified":1750755738636},{"_id":"public/archives/2017/01/index.html","hash":"95adbc862367bd43baab038b8c5b1143c3ba93c5","modified":1750755738636},{"_id":"public/archives/2017/03/index.html","hash":"82a912d8fb82afabfa47c30dad4f78875df03d3c","modified":1750755738636},{"_id":"public/archives/2017/07/index.html","hash":"6d17b12fc469ddf112dca2bb58206b90061ff891","modified":1750755738636},{"_id":"public/archives/2017/09/index.html","hash":"b8bb2972b4f6e5606a7fc92d0eb22383d0ea0feb","modified":1750755738636},{"_id":"public/archives/2017/11/index.html","hash":"77472d622b74d5ccd734a29058a37787085712fc","modified":1750755738636},{"_id":"public/archives/2017/12/index.html","hash":"63585ff6684b41d9fed54885b4bf896a458c00c0","modified":1750755738636},{"_id":"public/archives/2022/index.html","hash":"1f9fe756954b79caff7ea0da3121290d8e011747","modified":1750755738636},{"_id":"public/archives/2022/page/2/index.html","hash":"2c7f734f48070b83ba1c1c89e2adadb6fc9fde09","modified":1750755738636},{"_id":"public/archives/2022/09/index.html","hash":"499a0f8631c4cebf9799097c608cf7511a4270b4","modified":1750755738636},{"_id":"public/archives/2022/10/index.html","hash":"65043c9a2065f209a0731a2a93b4df349d60f32d","modified":1750755738636},{"_id":"public/archives/2022/11/index.html","hash":"8fe8c97a6d965848884fac99a30af731d13a7a99","modified":1750755738636},{"_id":"public/archives/2022/12/index.html","hash":"6a1ecfbae3b145ceb5d4cf7143ae5ff669fb4550","modified":1750755738636},{"_id":"public/archives/2023/index.html","hash":"670ef32510a5147d2209a72647aa6af927171480","modified":1750755738636},{"_id":"public/archives/2023/12/index.html","hash":"b097ef38fb8c8268c3e13339fe1d03249e001c32","modified":1750755738636},{"_id":"public/archives/2024/index.html","hash":"29c74cd9edd07bce80761fd008f7490f4097dfb0","modified":1750755738636},{"_id":"public/archives/2024/page/2/index.html","hash":"181d6e68bf60cd923170f4dc0aafa25c20854192","modified":1750755738636},{"_id":"public/archives/2024/07/index.html","hash":"c2261f9bff9725ed57f12554e1e4f3a8add6e8dc","modified":1750755738636},{"_id":"public/archives/2024/08/index.html","hash":"fa6e4b7c933547b4f4f6eafb0aea1dc5c442f5ae","modified":1750755738636},{"_id":"public/archives/2024/09/index.html","hash":"047b27420b89a4fa78b72f785ec0833ea063fbb2","modified":1750755738636},{"_id":"public/archives/2024/10/index.html","hash":"c9c650803fd0aba50d90500ba4e342bf7d966e12","modified":1750755738636},{"_id":"public/archives/2024/11/index.html","hash":"856dd2b621fde4b98461425e9d0ad59e3be69af2","modified":1750755738636},{"_id":"public/archives/2025/index.html","hash":"a7925726bd309b736654f7a3c84f651cf77fe75b","modified":1750755738636},{"_id":"public/archives/2025/03/index.html","hash":"ad8506bc4f8985946ffb070514de93f34db751f4","modified":1750755738636},{"_id":"public/archives/2025/06/index.html","hash":"cfdcf5aed301a48e99d79deb83360a9e1cdc501c","modified":1750755738636},{"_id":"public/categories/编程技术/index.html","hash":"26d8b34791cbf265dfd95a041cd86655dd0655e9","modified":1750755738636},{"_id":"public/categories/家庭教育/index.html","hash":"9378eb14947646aa924f78b2cfe0ecad94ff7a7a","modified":1750755738636},{"_id":"public/index.html","hash":"913ad0b3800cdeafcb4679b38d52ffb47b584827","modified":1750755738636},{"_id":"public/page/2/index.html","hash":"0210499e29342d4f2ed0840889c349aa95bc096c","modified":1750755738636},{"_id":"public/page/3/index.html","hash":"3ed04a37264889bdc1fdb3c826682aebe4579684","modified":1750755738636},{"_id":"public/page/4/index.html","hash":"9d1c205e7e0fa18d109b55684b44eec9148c615a","modified":1750755738636},{"_id":"public/page/5/index.html","hash":"b7a9b9a3f27cb6aa862af71e81850c5506dc4d3c","modified":1750755738636},{"_id":"public/page/6/index.html","hash":"9a8a5616d8c11c3b3214d8a24219b5b982d0b637","modified":1750755738636},{"_id":"public/tags/C-11/index.html","hash":"4af442cd3877122242310004baeca00e5ae05e20","modified":1750755738636},{"_id":"public/tags/iOS/index.html","hash":"628642f63734ba3741130955c9a9e758d4562cf9","modified":1750755738636},{"_id":"public/tags/iOS/page/2/index.html","hash":"3dc3fbbf13a6a2c3d07353881d094b32efc6c373","modified":1750755738636},{"_id":"public/tags/C/index.html","hash":"5c62bafb563ae13a1ae1c73ca0e7280f7f92713c","modified":1750755738636},{"_id":"public/tags/编程陷阱/index.html","hash":"93cf057d1acfda0ddf97b662c05c03c96441e14a","modified":1750755738636},{"_id":"public/tags/类型转换/index.html","hash":"91ca3f703fef010f11fa3a8e053438b1572e3b20","modified":1750755738636},{"_id":"public/tags/ruby/index.html","hash":"210133292938605b898ef1d76bb299502458e682","modified":1750755738636},{"_id":"public/tags/openGL/index.html","hash":"ab565928e6caea38f11d49998b29f2dce0cc5bf7","modified":1750755738636},{"_id":"public/tags/test/index.html","hash":"834f570b02ed7d21c6f7e95b4cd8f6c9f5557aa0","modified":1750755738636},{"_id":"public/tags/c-11/index.html","hash":"dbb48bdc5cac0c2b427462c91e1c2a347203101f","modified":1750755738636},{"_id":"public/tags/教育/index.html","hash":"9d546dc2f4ba05949258a8be520fd1b8088bf89a","modified":1750755738636},{"_id":"public/tags/亲子/index.html","hash":"c1117fc4fb6e9a056c4c8e2af822e53943621467","modified":1750755738636},{"_id":"public/tags/阅读/index.html","hash":"339d7f0d1ace7667f2ccf694e4e80b272ee23c1d","modified":1750755738636},{"_id":"public/tags/手机成瘾/index.html","hash":"0ae1677e18b784c1fd33c0a15ff1a184f3a21a17","modified":1750755738636},{"_id":"public/tags/书单/index.html","hash":"91d54a3b22f0a893d12ca4721ac341bc4331c50c","modified":1750755738636},{"_id":"public/tags/儿童教育/index.html","hash":"e41add2422784def45c8786ec0ff032f8142423c","modified":1750755738636},{"_id":"public/robots.txt","hash":"2f88235dff1bbf48f7841075a244dde57037345f","modified":1749957141254},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1749957141254},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1749957141254},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1749957141254},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1749957141254},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1749957141254},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1749957141254},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1749957141254},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1749957141254},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1749957141254},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1749957141254},{"_id":"public/2022/09/25/add-Image/sharedptr2.png","hash":"8e51afea16d9407343cefb650097d2c91b00bc39","modified":1749957141254},{"_id":"public/2022/09/25/add-Image/sharedptr1.png","hash":"ef9802a63197339362725253f40a8f6af13991e2","modified":1749957141254},{"_id":"public/css/style.css","hash":"bd631a48148a30760032c287783827496a0b746c","modified":1749957141254},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1749957141254},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1749957141254},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1749957141254},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1749957141254},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1749957141254},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1749957141254},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1749957141254},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1749957141254},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1749957141254},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1749957141254},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1749957141254},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1749957141254},{"_id":"source/_posts/cpp-macro-analysis-podcast.md","hash":"027c133ed1b0af3ea63ff252b84dda767bf68ded","modified":1749957230380},{"_id":"public/2025/01/27/cpp-macro-analysis-podcast/index.html","hash":"4237174fcf34b09d3f2b9c427ad1a511dc3b14be","modified":1749957141254},{"_id":"public/categories/编程技术/C/index.html","hash":"27010192e848d8e9eb6a69d7ee7ced3d09a3fda4","modified":1750755738636},{"_id":"public/tags/宏定义/index.html","hash":"087f7455fe116ccbe070d4bf3d9b3a9953e662f3","modified":1750755738636},{"_id":"public/tags/预处理器/index.html","hash":"6fb1653e975e02649efa3796a4e3f50595671acb","modified":1750755738636},{"_id":"public/tags/播客/index.html","hash":"04b486eb0d2027cb2b414dda6527d18814978151","modified":1750755738636},{"_id":"public/archives/2025/01/index.html","hash":"4d2d56d330ece4b8479944c6e213ae14068c3eb7","modified":1750755738636},{"_id":"public/2025/06/15/cpp-macro-analysis-podcast/index.html","hash":"d4f35b6d2cf5eb63131d8985fb574305dfedb1b8","modified":1750755738636},{"_id":"source/_posts/high-performance-string-implementation.md","hash":"be5a71ef46cb2e400354d02d7bb45cab1015db1c","modified":1749958926156},{"_id":"source/_posts/mobile-ssao-implementation.md","hash":"603488b845bd65e9c6b948b093d65117218533b6","modified":1749958842108},{"_id":"public/2025/01/27/high-performance-string-implementation/index.html","hash":"b1e0f1671b2342e84af1f01c3c164af827a13481","modified":1750755738636},{"_id":"public/2025/01/27/mobile-ssao-implementation/index.html","hash":"941710eae2fed94c0b6aea0907446d05182a517e","modified":1750755738636},{"_id":"public/categories/图形渲染/index.html","hash":"8f4d2e20444aa036e5bc76cba1537f716cb06d5f","modified":1750755738636},{"_id":"public/tags/字符串/index.html","hash":"f34a30e3eb69d655c3c8a6cddc800df3fb3eed35","modified":1750755738636},{"_id":"public/tags/性能优化/index.html","hash":"254aeae4ad3e43b180ba60d379bb88920f5fde0d","modified":1750755738636},{"_id":"public/tags/图形学/index.html","hash":"1edcdaa235b3bc430e25e020b85cf3d39eb96126","modified":1750755738636},{"_id":"public/tags/SSAO/index.html","hash":"45b78cf046dba0337e09f80fd1346bb3639a4748","modified":1750755738636},{"_id":"public/tags/移动端优化/index.html","hash":"1a777e5ca6d337b23e13e01f13d0381c8707bc5c","modified":1750755738636},{"_id":"source/_posts/GLSL中的smoothstep函数详解.md","hash":"a9213deaae1dc8f4ba0293e549ea58fad0d1ab9d","modified":1750755715360},{"_id":"source/_posts/Android动态库加载-dlopen与System.loadLibrary对比.md","hash":"00ad6571c2641f829da90d30d81277e48452ad44","modified":1749786351453},{"_id":"public/2024/12/18/GLSL中的smoothstep函数详解/index.html","hash":"f1607a4a3617e63b2e422141bd73f7dc397dd240","modified":1750755478346},{"_id":"public/2024/06/12/Android动态库加载-dlopen与System.loadLibrary对比/index.html","hash":"33f786cdb6daa1a7335c125fbdbd63c336a64ed7","modified":1750755738636},{"_id":"public/archives/2024/12/index.html","hash":"5fd1fdcfc7e52a005bba120c5e15e9e5026ee449","modified":1750755478346},{"_id":"public/archives/2024/06/index.html","hash":"201e666d964e7a96992baae1e2f63fd85ced3480","modified":1750755738636},{"_id":"public/tags/GLSL/index.html","hash":"bc37d7bc9f40072cbbec88f00d2c4f911d4259a9","modified":1750755738636},{"_id":"public/tags/Shader/index.html","hash":"25661a6a747d8ed44a180cf87074f0b079eebde3","modified":1750755738636},{"_id":"public/tags/图形编程/index.html","hash":"d09e15255e73c763b13c24a0194b4ee1f80d6ed5","modified":1750755738636},{"_id":"public/tags/JNI/index.html","hash":"f21facceb31f5f8772e157c9b59716224df1c675","modified":1750755738636},{"_id":"public/tags/Android/index.html","hash":"bacc04a6395a14ed56e3446e296d04031f12ca0e","modified":1750755738636},{"_id":"public/tags/动态库/index.html","hash":"365ef50f7f8a46a63b94dc66ad7740fad2e11969","modified":1750755738636},{"_id":"public/tags/计算机图形学/index.html","hash":"47d18fed0a5a4101ed123fac496f22829cfbae60","modified":1750755738636},{"_id":"source/_posts/C++11委托构造函数和继承构造函数.md","hash":"82113be2b9c2624086e817cee358074b3235ea8e","modified":1750755676877},{"_id":"public/2024/01/15/C++11委托构造函数和继承构造函数/index.html","hash":"b99e4920ab7fca1ce173db4060ff6a414e861c49","modified":1750755478346},{"_id":"public/archives/2024/01/index.html","hash":"e39b8e632b5218841bf1b2655439ab82049f7baa","modified":1750755478346},{"_id":"public/tags/构造函数/index.html","hash":"0444e48292f9e9edfe39734a54578f910568347a","modified":1750755738636},{"_id":"source/_posts/HSV颜色空间和插值优势详解.md","hash":"d452f732af8f702b6ad0492dc3b0f0c3ebb10cb0","modified":1750755679878},{"_id":"public/2024/01/15/HSV颜色空间和插值优势详解/index.html","hash":"58ac99a4b62e041e149c81678c5117822ae77b66","modified":1750755478346},{"_id":"public/tags/颜色空间/index.html","hash":"a3a4b228afd818ce0fa6475d3434885ead18f62f","modified":1750755738636},{"_id":"public/tags/插值算法/index.html","hash":"1ecd26ad4293ac26bbfa2433cdbef88a792512a5","modified":1750755738636},{"_id":"public/2025/06/24/HSV颜色空间和插值优势详解/index.html","hash":"0c1d385b1876312ff291d448cb2bf364cdb80ec8","modified":1750755738636},{"_id":"public/2025/06/24/C++11委托构造函数和继承构造函数/index.html","hash":"8b1e0501167080de9357112dfa891403173cec43","modified":1750755738636},{"_id":"public/2025/06/24/GLSL中的smoothstep函数详解/index.html","hash":"448a89c2a98419233ecad04ad6553023f691fb6e","modified":1750755738636},{"_id":"public/archives/2025/page/2/index.html","hash":"421bb9a5f83fe733bd9bb9469244de284ef1048b","modified":1750755738636}],"Category":[{"name":"编程技术","_id":"cmbt3hg8c000j1xco0eks2nrq"},{"name":"家庭教育","_id":"cmbt3hg8l002v1xco71ef3hq8"},{"name":"C++","parent":"cmbt3hg8c000j1xco0eks2nrq","_id":"cmbx3as1k000296j228qz6x25"},{"name":"图形渲染","_id":"cmbx4ojek0003h2j201ki8sc6"}],"Data":[],"Page":[{"layout":"false","_content":"<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>百度网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为百度站长平台提供的验证码 -->\n  <meta name=\"baidu-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> ","source":"baidu_verify.html","raw":"---\nlayout: false\n---\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>百度网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为百度站长平台提供的验证码 -->\n  <meta name=\"baidu-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> ","date":"2025-06-07T08:35:00.402Z","updated":"2025-06-07T08:35:00.402Z","path":"baidu_verify.html","title":"","comments":1,"_id":"cmbt3hg8600001xcohw0n4v7n","content":"<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>百度网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为百度站长平台提供的验证码 -->\n  <meta name=\"baidu-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> ","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>百度网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为百度站长平台提供的验证码 -->\n  <meta name=\"baidu-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> "},{"layout":"false","_content":"<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Google网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为Google Search Console提供的验证码 -->\n  <meta name=\"google-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> ","source":"google_verify.html","raw":"---\nlayout: false\n---\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Google网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为Google Search Console提供的验证码 -->\n  <meta name=\"google-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> ","date":"2025-06-07T08:42:28.428Z","updated":"2025-06-07T08:34:52.410Z","path":"google_verify.html","title":"","comments":1,"_id":"cmbt3hg8800021xco7qtc3qmt","content":"<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Google网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为Google Search Console提供的验证码 -->\n  <meta name=\"google-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> ","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Google网站所有权验证</title>\n</head>\n<body>\n  <!-- 请将下面的内容替换为Google Search Console提供的验证码 -->\n  <meta name=\"google-site-verification\" content=\"YOUR_VERIFICATION_CODE\" />\n</body>\n</html> "},{"layout":"false","_content":"google-site-verification: googlef6f290aede027823.html ","source":"googlef6f290aede027823.html","raw":"---\nlayout: false\n---\ngoogle-site-verification: googlef6f290aede027823.html ","date":"2025-06-07T08:43:32.509Z","updated":"2025-06-07T08:43:32.509Z","path":"googlef6f290aede027823.html","title":"","comments":1,"_id":"cmbt3hg8900041xco5s4qdys4","content":"google-site-verification: googlef6f290aede027823.html ","site":{"data":{}},"excerpt":"","more":"google-site-verification: googlef6f290aede027823.html "}],"Post":[{"title":"AddressSanitizer实现原理","date":"2024-07-28T04:23:56.000Z","_content":"\nAddressSanitizer（简称ASan）是一种内存错误检测工具，用于捕捉诸如缓冲区溢出、使用已释放内存、堆栈溢出等内存错误。ASan在编译时和运行时对程序进行处理，以检测和报告内存相关的错误。以下是AddressSanitizer的实现原理的详细解释：\n\n### 1. 编译时插桩\n\nASan在编译时对代码进行插桩，插入额外的检查代码。这些检查代码会在每次内存访问时执行，以验证访问是否合法。具体过程包括：\n\n- **插入检查代码**：在每次内存分配、释放和访问操作前后插入检查代码。\n- **标记内存区域**：在内存分配和释放时，更新内存区域的元数据，以记录该区域的状态（已分配、已释放等）。\n\n### 2. Shadow Memory\n\nASan使用影子内存（Shadow Memory）来记录主内存的状态。影子内存是主内存的一个映射区域，每个字节的影子内存对应主内存的几个字节（通常是8字节）。影子内存的值用于指示主内存的哪些部分是合法访问的，哪些部分是非法的。\n\n- **影子内存布局**：影子内存占用主内存的1/8，因为每个影子字节代表8个主内存字节。\n- **影子内存值**：影子内存中的值表示主内存的状态。例如，0表示所有8个字节都是合法的，负值表示不合法的访问，正值表示部分合法访问。\n\n### 3. 内存分配和释放\n\nASan对内存分配和释放函数（如`malloc`和`free`）进行重载，以维护内存区域的元数据。这些元数据包括：\n\n- **红色区域（Redzones）**：在每个分配的内存块周围添加红色区域，用于检测缓冲区溢出。红色区域被标记为非法访问区域。\n- **元数据**：记录每个内存块的大小、分配堆栈等信息，以便在检测到错误时提供详细报告。\n\n### 4. 运行时检查\n\n在运行时，ASan插入的检查代码会在每次内存访问时执行，检查访问的地址是否在合法范围内。如果访问非法区域，则报告错误并终止程序。\n\n- **内存访问检查**：每次内存读取或写入时，检查影子内存中的值，以确定访问是否合法。\n- **错误报告**：在检测到非法访问时，ASan会生成详细的错误报告，包含访问地址、内存块信息、调用堆栈等。\n\n### 5. 错误类型检测\n\nASan能够检测多种类型的内存错误，包括：\n\n- **缓冲区溢出**：访问数组或内存块的边界外的区域。\n- **使用未初始化内存**：访问未初始化的内存。\n- **使用已释放内存**：访问已经释放的内存。\n- **双重释放**：重复释放同一块内存。\n- **堆栈溢出**：访问栈帧之外的内存。\n\n### 6. 性能与开销\n\nASan在检测内存错误时会引入一定的性能开销和内存开销：\n\n- **性能开销**：由于插入了额外的检查代码，程序的执行速度会有所降低。通常，ASan引入的性能开销在2-3倍左右。\n- **内存开销**：影子内存和红色区域会增加内存使用量，通常内存开销在2倍左右。\n\n### 总结\n\nAddressSanitizer通过编译时插桩、使用影子内存和运行时检查等机制，能够有效地检测和报告内存相关的错误。尽管引入了一定的性能和内存开销，但它在提高程序安全性和稳定性方面具有重要意义，是开发和调试C/C++程序的强大工具。","source":"_posts/AddressSanitizer实现原理.md","raw":"---\ntitle: AddressSanitizer实现原理\ndate: 2024-07-28 12:23:56\ntags:\n---\n\nAddressSanitizer（简称ASan）是一种内存错误检测工具，用于捕捉诸如缓冲区溢出、使用已释放内存、堆栈溢出等内存错误。ASan在编译时和运行时对程序进行处理，以检测和报告内存相关的错误。以下是AddressSanitizer的实现原理的详细解释：\n\n### 1. 编译时插桩\n\nASan在编译时对代码进行插桩，插入额外的检查代码。这些检查代码会在每次内存访问时执行，以验证访问是否合法。具体过程包括：\n\n- **插入检查代码**：在每次内存分配、释放和访问操作前后插入检查代码。\n- **标记内存区域**：在内存分配和释放时，更新内存区域的元数据，以记录该区域的状态（已分配、已释放等）。\n\n### 2. Shadow Memory\n\nASan使用影子内存（Shadow Memory）来记录主内存的状态。影子内存是主内存的一个映射区域，每个字节的影子内存对应主内存的几个字节（通常是8字节）。影子内存的值用于指示主内存的哪些部分是合法访问的，哪些部分是非法的。\n\n- **影子内存布局**：影子内存占用主内存的1/8，因为每个影子字节代表8个主内存字节。\n- **影子内存值**：影子内存中的值表示主内存的状态。例如，0表示所有8个字节都是合法的，负值表示不合法的访问，正值表示部分合法访问。\n\n### 3. 内存分配和释放\n\nASan对内存分配和释放函数（如`malloc`和`free`）进行重载，以维护内存区域的元数据。这些元数据包括：\n\n- **红色区域（Redzones）**：在每个分配的内存块周围添加红色区域，用于检测缓冲区溢出。红色区域被标记为非法访问区域。\n- **元数据**：记录每个内存块的大小、分配堆栈等信息，以便在检测到错误时提供详细报告。\n\n### 4. 运行时检查\n\n在运行时，ASan插入的检查代码会在每次内存访问时执行，检查访问的地址是否在合法范围内。如果访问非法区域，则报告错误并终止程序。\n\n- **内存访问检查**：每次内存读取或写入时，检查影子内存中的值，以确定访问是否合法。\n- **错误报告**：在检测到非法访问时，ASan会生成详细的错误报告，包含访问地址、内存块信息、调用堆栈等。\n\n### 5. 错误类型检测\n\nASan能够检测多种类型的内存错误，包括：\n\n- **缓冲区溢出**：访问数组或内存块的边界外的区域。\n- **使用未初始化内存**：访问未初始化的内存。\n- **使用已释放内存**：访问已经释放的内存。\n- **双重释放**：重复释放同一块内存。\n- **堆栈溢出**：访问栈帧之外的内存。\n\n### 6. 性能与开销\n\nASan在检测内存错误时会引入一定的性能开销和内存开销：\n\n- **性能开销**：由于插入了额外的检查代码，程序的执行速度会有所降低。通常，ASan引入的性能开销在2-3倍左右。\n- **内存开销**：影子内存和红色区域会增加内存使用量，通常内存开销在2倍左右。\n\n### 总结\n\nAddressSanitizer通过编译时插桩、使用影子内存和运行时检查等机制，能够有效地检测和报告内存相关的错误。尽管引入了一定的性能和内存开销，但它在提高程序安全性和稳定性方面具有重要意义，是开发和调试C/C++程序的强大工具。","slug":"AddressSanitizer实现原理","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8700011xco7ltc5v13","content":"<p>AddressSanitizer（简称ASan）是一种内存错误检测工具，用于捕捉诸如缓冲区溢出、使用已释放内存、堆栈溢出等内存错误。ASan在编译时和运行时对程序进行处理，以检测和报告内存相关的错误。以下是AddressSanitizer的实现原理的详细解释：</p>\n<span id=\"more\"></span>\n\n<h3 id=\"1-编译时插桩\"><a href=\"#1-编译时插桩\" class=\"headerlink\" title=\"1. 编译时插桩\"></a>1. 编译时插桩</h3><p>ASan在编译时对代码进行插桩，插入额外的检查代码。这些检查代码会在每次内存访问时执行，以验证访问是否合法。具体过程包括：</p>\n<ul>\n<li><strong>插入检查代码</strong>：在每次内存分配、释放和访问操作前后插入检查代码。</li>\n<li><strong>标记内存区域</strong>：在内存分配和释放时，更新内存区域的元数据，以记录该区域的状态（已分配、已释放等）。</li>\n</ul>\n<h3 id=\"2-Shadow-Memory\"><a href=\"#2-Shadow-Memory\" class=\"headerlink\" title=\"2. Shadow Memory\"></a>2. Shadow Memory</h3><p>ASan使用影子内存（Shadow Memory）来记录主内存的状态。影子内存是主内存的一个映射区域，每个字节的影子内存对应主内存的几个字节（通常是8字节）。影子内存的值用于指示主内存的哪些部分是合法访问的，哪些部分是非法的。</p>\n<ul>\n<li><strong>影子内存布局</strong>：影子内存占用主内存的1/8，因为每个影子字节代表8个主内存字节。</li>\n<li><strong>影子内存值</strong>：影子内存中的值表示主内存的状态。例如，0表示所有8个字节都是合法的，负值表示不合法的访问，正值表示部分合法访问。</li>\n</ul>\n<h3 id=\"3-内存分配和释放\"><a href=\"#3-内存分配和释放\" class=\"headerlink\" title=\"3. 内存分配和释放\"></a>3. 内存分配和释放</h3><p>ASan对内存分配和释放函数（如<code>malloc</code>和<code>free</code>）进行重载，以维护内存区域的元数据。这些元数据包括：</p>\n<ul>\n<li><strong>红色区域（Redzones）</strong>：在每个分配的内存块周围添加红色区域，用于检测缓冲区溢出。红色区域被标记为非法访问区域。</li>\n<li><strong>元数据</strong>：记录每个内存块的大小、分配堆栈等信息，以便在检测到错误时提供详细报告。</li>\n</ul>\n<h3 id=\"4-运行时检查\"><a href=\"#4-运行时检查\" class=\"headerlink\" title=\"4. 运行时检查\"></a>4. 运行时检查</h3><p>在运行时，ASan插入的检查代码会在每次内存访问时执行，检查访问的地址是否在合法范围内。如果访问非法区域，则报告错误并终止程序。</p>\n<ul>\n<li><strong>内存访问检查</strong>：每次内存读取或写入时，检查影子内存中的值，以确定访问是否合法。</li>\n<li><strong>错误报告</strong>：在检测到非法访问时，ASan会生成详细的错误报告，包含访问地址、内存块信息、调用堆栈等。</li>\n</ul>\n<h3 id=\"5-错误类型检测\"><a href=\"#5-错误类型检测\" class=\"headerlink\" title=\"5. 错误类型检测\"></a>5. 错误类型检测</h3><p>ASan能够检测多种类型的内存错误，包括：</p>\n<ul>\n<li><strong>缓冲区溢出</strong>：访问数组或内存块的边界外的区域。</li>\n<li><strong>使用未初始化内存</strong>：访问未初始化的内存。</li>\n<li><strong>使用已释放内存</strong>：访问已经释放的内存。</li>\n<li><strong>双重释放</strong>：重复释放同一块内存。</li>\n<li><strong>堆栈溢出</strong>：访问栈帧之外的内存。</li>\n</ul>\n<h3 id=\"6-性能与开销\"><a href=\"#6-性能与开销\" class=\"headerlink\" title=\"6. 性能与开销\"></a>6. 性能与开销</h3><p>ASan在检测内存错误时会引入一定的性能开销和内存开销：</p>\n<ul>\n<li><strong>性能开销</strong>：由于插入了额外的检查代码，程序的执行速度会有所降低。通常，ASan引入的性能开销在2-3倍左右。</li>\n<li><strong>内存开销</strong>：影子内存和红色区域会增加内存使用量，通常内存开销在2倍左右。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>AddressSanitizer通过编译时插桩、使用影子内存和运行时检查等机制，能够有效地检测和报告内存相关的错误。尽管引入了一定的性能和内存开销，但它在提高程序安全性和稳定性方面具有重要意义，是开发和调试C/C++程序的强大工具。</p>\n","site":{"data":{}},"excerpt":"<p>AddressSanitizer（简称ASan）是一种内存错误检测工具，用于捕捉诸如缓冲区溢出、使用已释放内存、堆栈溢出等内存错误。ASan在编译时和运行时对程序进行处理，以检测和报告内存相关的错误。以下是AddressSanitizer的实现原理的详细解释：</p>","more":"<h3 id=\"1-编译时插桩\"><a href=\"#1-编译时插桩\" class=\"headerlink\" title=\"1. 编译时插桩\"></a>1. 编译时插桩</h3><p>ASan在编译时对代码进行插桩，插入额外的检查代码。这些检查代码会在每次内存访问时执行，以验证访问是否合法。具体过程包括：</p>\n<ul>\n<li><strong>插入检查代码</strong>：在每次内存分配、释放和访问操作前后插入检查代码。</li>\n<li><strong>标记内存区域</strong>：在内存分配和释放时，更新内存区域的元数据，以记录该区域的状态（已分配、已释放等）。</li>\n</ul>\n<h3 id=\"2-Shadow-Memory\"><a href=\"#2-Shadow-Memory\" class=\"headerlink\" title=\"2. Shadow Memory\"></a>2. Shadow Memory</h3><p>ASan使用影子内存（Shadow Memory）来记录主内存的状态。影子内存是主内存的一个映射区域，每个字节的影子内存对应主内存的几个字节（通常是8字节）。影子内存的值用于指示主内存的哪些部分是合法访问的，哪些部分是非法的。</p>\n<ul>\n<li><strong>影子内存布局</strong>：影子内存占用主内存的1/8，因为每个影子字节代表8个主内存字节。</li>\n<li><strong>影子内存值</strong>：影子内存中的值表示主内存的状态。例如，0表示所有8个字节都是合法的，负值表示不合法的访问，正值表示部分合法访问。</li>\n</ul>\n<h3 id=\"3-内存分配和释放\"><a href=\"#3-内存分配和释放\" class=\"headerlink\" title=\"3. 内存分配和释放\"></a>3. 内存分配和释放</h3><p>ASan对内存分配和释放函数（如<code>malloc</code>和<code>free</code>）进行重载，以维护内存区域的元数据。这些元数据包括：</p>\n<ul>\n<li><strong>红色区域（Redzones）</strong>：在每个分配的内存块周围添加红色区域，用于检测缓冲区溢出。红色区域被标记为非法访问区域。</li>\n<li><strong>元数据</strong>：记录每个内存块的大小、分配堆栈等信息，以便在检测到错误时提供详细报告。</li>\n</ul>\n<h3 id=\"4-运行时检查\"><a href=\"#4-运行时检查\" class=\"headerlink\" title=\"4. 运行时检查\"></a>4. 运行时检查</h3><p>在运行时，ASan插入的检查代码会在每次内存访问时执行，检查访问的地址是否在合法范围内。如果访问非法区域，则报告错误并终止程序。</p>\n<ul>\n<li><strong>内存访问检查</strong>：每次内存读取或写入时，检查影子内存中的值，以确定访问是否合法。</li>\n<li><strong>错误报告</strong>：在检测到非法访问时，ASan会生成详细的错误报告，包含访问地址、内存块信息、调用堆栈等。</li>\n</ul>\n<h3 id=\"5-错误类型检测\"><a href=\"#5-错误类型检测\" class=\"headerlink\" title=\"5. 错误类型检测\"></a>5. 错误类型检测</h3><p>ASan能够检测多种类型的内存错误，包括：</p>\n<ul>\n<li><strong>缓冲区溢出</strong>：访问数组或内存块的边界外的区域。</li>\n<li><strong>使用未初始化内存</strong>：访问未初始化的内存。</li>\n<li><strong>使用已释放内存</strong>：访问已经释放的内存。</li>\n<li><strong>双重释放</strong>：重复释放同一块内存。</li>\n<li><strong>堆栈溢出</strong>：访问栈帧之外的内存。</li>\n</ul>\n<h3 id=\"6-性能与开销\"><a href=\"#6-性能与开销\" class=\"headerlink\" title=\"6. 性能与开销\"></a>6. 性能与开销</h3><p>ASan在检测内存错误时会引入一定的性能开销和内存开销：</p>\n<ul>\n<li><strong>性能开销</strong>：由于插入了额外的检查代码，程序的执行速度会有所降低。通常，ASan引入的性能开销在2-3倍左右。</li>\n<li><strong>内存开销</strong>：影子内存和红色区域会增加内存使用量，通常内存开销在2倍左右。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>AddressSanitizer通过编译时插桩、使用影子内存和运行时检查等机制，能够有效地检测和报告内存相关的错误。尽管引入了一定的性能和内存开销，但它在提高程序安全性和稳定性方面具有重要意义，是开发和调试C/C++程序的强大工具。</p>"},{"title":"AndoirdEGLContext销毁管理","date":"2024-07-31T16:19:32.000Z","_content":"\n```java\npublic interface EGLContextFactory {\n    EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);\n    void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);\n} \n```\n### EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗\n\n### 在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\n\n具体来说，当你调用 `EGLContextFactory` 接口的 `destroyContext` 方法来销毁一个 EGLContext 时，OpenGL ES 会自动处理这个上下文的清理工作，包括删除所有在该上下文中创建的资源。\n\n因此，你不需要手动删除这些资源，销毁上下文的过程会自动处理它们的释放。\n\n不过，如果你需要提前释放某些资源以便在上下文还没有销毁之前释放内存，你可以在合适的时机手动删除这些资源（例如通过调用 `glDeleteBuffers`、`glDeleteTextures`、`glDeleteFramebuffers` 等方法）。","source":"_posts/AndoirdEGLContext销毁管理.md","raw":"---\ntitle: AndoirdEGLContext销毁管理\ndate: 2024-08-01 00:19:32\ntags:\n---\n\n```java\npublic interface EGLContextFactory {\n    EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);\n    void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);\n} \n```\n### EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗\n\n### 在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\n\n具体来说，当你调用 `EGLContextFactory` 接口的 `destroyContext` 方法来销毁一个 EGLContext 时，OpenGL ES 会自动处理这个上下文的清理工作，包括删除所有在该上下文中创建的资源。\n\n因此，你不需要手动删除这些资源，销毁上下文的过程会自动处理它们的释放。\n\n不过，如果你需要提前释放某些资源以便在上下文还没有销毁之前释放内存，你可以在合适的时机手动删除这些资源（例如通过调用 `glDeleteBuffers`、`glDeleteTextures`、`glDeleteFramebuffers` 等方法）。","slug":"AndoirdEGLContext销毁管理","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8800031xco71cmc8jk","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">EGLContextFactory</span> &#123;</span><br><span class=\"line\">    EGLContext <span class=\"title function_\">createContext</span><span class=\"params\">(EGL10 egl, EGLDisplay display, EGLConfig eglConfig)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">destroyContext</span><span class=\"params\">(EGL10 egl, EGLDisplay display, EGLContext context)</span>;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<h3 id=\"EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗\"><a href=\"#EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗\" class=\"headerlink\" title=\"EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗\"></a>EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗</h3><span id=\"more\"></span>\n\n<h3 id=\"在-OpenGL-ES-中，当一个-EGLContext-被销毁时，所有在该上下文中创建的-OpenGL-资源（如-buffer、texture-和-framebuffer-objects-FBO-等）都会被删除。这是因为这些资源是与特定的-OpenGL-上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\"><a href=\"#在-OpenGL-ES-中，当一个-EGLContext-被销毁时，所有在该上下文中创建的-OpenGL-资源（如-buffer、texture-和-framebuffer-objects-FBO-等）都会被删除。这是因为这些资源是与特定的-OpenGL-上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\" class=\"headerlink\" title=\"在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\"></a>在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。</h3><p>具体来说，当你调用 <code>EGLContextFactory</code> 接口的 <code>destroyContext</code> 方法来销毁一个 EGLContext 时，OpenGL ES 会自动处理这个上下文的清理工作，包括删除所有在该上下文中创建的资源。</p>\n<p>因此，你不需要手动删除这些资源，销毁上下文的过程会自动处理它们的释放。</p>\n<p>不过，如果你需要提前释放某些资源以便在上下文还没有销毁之前释放内存，你可以在合适的时机手动删除这些资源（例如通过调用 <code>glDeleteBuffers</code>、<code>glDeleteTextures</code>、<code>glDeleteFramebuffers</code> 等方法）。</p>\n","site":{"data":{}},"excerpt":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">EGLContextFactory</span> &#123;</span><br><span class=\"line\">    EGLContext <span class=\"title function_\">createContext</span><span class=\"params\">(EGL10 egl, EGLDisplay display, EGLConfig eglConfig)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">destroyContext</span><span class=\"params\">(EGL10 egl, EGLDisplay display, EGLContext context)</span>;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<h3 id=\"EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗\"><a href=\"#EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗\" class=\"headerlink\" title=\"EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗\"></a>EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗</h3>","more":"<h3 id=\"在-OpenGL-ES-中，当一个-EGLContext-被销毁时，所有在该上下文中创建的-OpenGL-资源（如-buffer、texture-和-framebuffer-objects-FBO-等）都会被删除。这是因为这些资源是与特定的-OpenGL-上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\"><a href=\"#在-OpenGL-ES-中，当一个-EGLContext-被销毁时，所有在该上下文中创建的-OpenGL-资源（如-buffer、texture-和-framebuffer-objects-FBO-等）都会被删除。这是因为这些资源是与特定的-OpenGL-上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\" class=\"headerlink\" title=\"在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。\"></a>在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。</h3><p>具体来说，当你调用 <code>EGLContextFactory</code> 接口的 <code>destroyContext</code> 方法来销毁一个 EGLContext 时，OpenGL ES 会自动处理这个上下文的清理工作，包括删除所有在该上下文中创建的资源。</p>\n<p>因此，你不需要手动删除这些资源，销毁上下文的过程会自动处理它们的释放。</p>\n<p>不过，如果你需要提前释放某些资源以便在上下文还没有销毁之前释放内存，你可以在合适的时机手动删除这些资源（例如通过调用 <code>glDeleteBuffers</code>、<code>glDeleteTextures</code>、<code>glDeleteFramebuffers</code> 等方法）。</p>"},{"title":"c++ 11 智能指针","date":"2022-09-25T07:13:02.000Z","_content":"\n## 智能指针\n\n\n### share_ptr使用\n\n\n\n\n#### sharet_ptr<T>构造函数和std::make_share<T> 的区别\n1. 两个堆内存和一个堆内存，std::make_share效率更高\n2. \n\n\n\n### weak_ptr使用\n1. expired(),返回指向对堆对象是否释放\n2. use_count,share_ptr的强引用计数\n3. lock，返回share_ptr，如果释放，返回空\n4. \n\n\n\n### share_ptr线程安全话题\n1. share_ptr引用计数本身是线程安全的\n2. 一个share_ptr对象，在多个线程操作，不能保证线程安全\n3. share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全\n\n\n\n### stl容器多线程安全时的性能考虑\n\n\n### code使用\n```\nint main()\n{\n    shared_ptr<Person> person1;\n    \n    shared_ptr<Person> person2(nullptr);\n    \n    shared_ptr<Person> person3(new Person(10));\n\n    shared_ptr<Person> person4 = std::make_shared<Person>(5); //效率更高，内存分布在一起\n    \n    shared_ptr<Person> person5(std::move(person3)); // person3无法再使用\n    \n    shared_ptr<Person> arary(new Person[10], deletePersonArray);\n    \n    weak_ptr<Person> weak_Person = person5;\n    \n    cout << weak_Person.use_count() << endl;\n    \n    shared_ptr<Person> person6 = person5;\n    \n    cout << weak_Person.use_count() << endl;\n    \n    person5.reset();\n    \n    cout << weak_Person.use_count() << endl;\n    \n    person6.reset();\n    \n    if (weak_Person.expired()) {\n        cout << weak_Person.use_count() << endl;\n        \n        auto shareptr = weak_Person.lock();\n        \n        cout << shareptr << endl;\n    }\n    \n    return 0;\n    \n}\n\n```\n\n","source":"_posts/C++-智能指针.md","raw":"---\ntitle: c++ 11 智能指针\ndate: 2022-09-25 15:13:02\ntags: C++11\n---\n\n## 智能指针\n\n\n### share_ptr使用\n\n\n\n\n#### sharet_ptr<T>构造函数和std::make_share<T> 的区别\n1. 两个堆内存和一个堆内存，std::make_share效率更高\n2. \n\n\n\n### weak_ptr使用\n1. expired(),返回指向对堆对象是否释放\n2. use_count,share_ptr的强引用计数\n3. lock，返回share_ptr，如果释放，返回空\n4. \n\n\n\n### share_ptr线程安全话题\n1. share_ptr引用计数本身是线程安全的\n2. 一个share_ptr对象，在多个线程操作，不能保证线程安全\n3. share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全\n\n\n\n### stl容器多线程安全时的性能考虑\n\n\n### code使用\n```\nint main()\n{\n    shared_ptr<Person> person1;\n    \n    shared_ptr<Person> person2(nullptr);\n    \n    shared_ptr<Person> person3(new Person(10));\n\n    shared_ptr<Person> person4 = std::make_shared<Person>(5); //效率更高，内存分布在一起\n    \n    shared_ptr<Person> person5(std::move(person3)); // person3无法再使用\n    \n    shared_ptr<Person> arary(new Person[10], deletePersonArray);\n    \n    weak_ptr<Person> weak_Person = person5;\n    \n    cout << weak_Person.use_count() << endl;\n    \n    shared_ptr<Person> person6 = person5;\n    \n    cout << weak_Person.use_count() << endl;\n    \n    person5.reset();\n    \n    cout << weak_Person.use_count() << endl;\n    \n    person6.reset();\n    \n    if (weak_Person.expired()) {\n        cout << weak_Person.use_count() << endl;\n        \n        auto shareptr = weak_Person.lock();\n        \n        cout << shareptr << endl;\n    }\n    \n    return 0;\n    \n}\n\n```\n\n","slug":"C++-智能指针","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8900051xco6kod505d","content":"<h2 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h2><h3 id=\"share-ptr使用\"><a href=\"#share-ptr使用\" class=\"headerlink\" title=\"share_ptr使用\"></a>share_ptr使用</h3><span id=\"more\"></span>\n\n\n\n\n<h4 id=\"sharet-ptr构造函数和std-make-share-的区别\"><a href=\"#sharet-ptr构造函数和std-make-share-的区别\" class=\"headerlink\" title=\"sharet_ptr构造函数和std::make_share 的区别\"></a>sharet_ptr<T>构造函数和std::make_share<T> 的区别</h4><ol>\n<li>两个堆内存和一个堆内存，std::make_share效率更高</li>\n<li></li>\n</ol>\n<h3 id=\"weak-ptr使用\"><a href=\"#weak-ptr使用\" class=\"headerlink\" title=\"weak_ptr使用\"></a>weak_ptr使用</h3><ol>\n<li>expired(),返回指向对堆对象是否释放</li>\n<li>use_count,share_ptr的强引用计数</li>\n<li>lock，返回share_ptr，如果释放，返回空</li>\n<li></li>\n</ol>\n<h3 id=\"share-ptr线程安全话题\"><a href=\"#share-ptr线程安全话题\" class=\"headerlink\" title=\"share_ptr线程安全话题\"></a>share_ptr线程安全话题</h3><ol>\n<li>share_ptr引用计数本身是线程安全的</li>\n<li>一个share_ptr对象，在多个线程操作，不能保证线程安全</li>\n<li>share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全</li>\n</ol>\n<h3 id=\"stl容器多线程安全时的性能考虑\"><a href=\"#stl容器多线程安全时的性能考虑\" class=\"headerlink\" title=\"stl容器多线程安全时的性能考虑\"></a>stl容器多线程安全时的性能考虑</h3><h3 id=\"code使用\"><a href=\"#code使用\" class=\"headerlink\" title=\"code使用\"></a>code使用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person2(nullptr);</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person3(new Person(10));</span><br><span class=\"line\"></span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person4 = std::make_shared&lt;Person&gt;(5); //效率更高，内存分布在一起</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person5(std::move(person3)); // person3无法再使用</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; arary(new Person[10], deletePersonArray);</span><br><span class=\"line\">    </span><br><span class=\"line\">    weak_ptr&lt;Person&gt; weak_Person = person5;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person6 = person5;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    person5.reset();</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    person6.reset();</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (weak_Person.expired()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">        </span><br><span class=\"line\">        auto shareptr = weak_Person.lock();</span><br><span class=\"line\">        </span><br><span class=\"line\">        cout &lt;&lt; shareptr &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h2 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h2><h3 id=\"share-ptr使用\"><a href=\"#share-ptr使用\" class=\"headerlink\" title=\"share_ptr使用\"></a>share_ptr使用</h3>","more":"<h4 id=\"sharet-ptr构造函数和std-make-share-的区别\"><a href=\"#sharet-ptr构造函数和std-make-share-的区别\" class=\"headerlink\" title=\"sharet_ptr构造函数和std::make_share 的区别\"></a>sharet_ptr<T>构造函数和std::make_share<T> 的区别</h4><ol>\n<li>两个堆内存和一个堆内存，std::make_share效率更高</li>\n<li></li>\n</ol>\n<h3 id=\"weak-ptr使用\"><a href=\"#weak-ptr使用\" class=\"headerlink\" title=\"weak_ptr使用\"></a>weak_ptr使用</h3><ol>\n<li>expired(),返回指向对堆对象是否释放</li>\n<li>use_count,share_ptr的强引用计数</li>\n<li>lock，返回share_ptr，如果释放，返回空</li>\n<li></li>\n</ol>\n<h3 id=\"share-ptr线程安全话题\"><a href=\"#share-ptr线程安全话题\" class=\"headerlink\" title=\"share_ptr线程安全话题\"></a>share_ptr线程安全话题</h3><ol>\n<li>share_ptr引用计数本身是线程安全的</li>\n<li>一个share_ptr对象，在多个线程操作，不能保证线程安全</li>\n<li>share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全</li>\n</ol>\n<h3 id=\"stl容器多线程安全时的性能考虑\"><a href=\"#stl容器多线程安全时的性能考虑\" class=\"headerlink\" title=\"stl容器多线程安全时的性能考虑\"></a>stl容器多线程安全时的性能考虑</h3><h3 id=\"code使用\"><a href=\"#code使用\" class=\"headerlink\" title=\"code使用\"></a>code使用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person2(nullptr);</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person3(new Person(10));</span><br><span class=\"line\"></span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person4 = std::make_shared&lt;Person&gt;(5); //效率更高，内存分布在一起</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person5(std::move(person3)); // person3无法再使用</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; arary(new Person[10], deletePersonArray);</span><br><span class=\"line\">    </span><br><span class=\"line\">    weak_ptr&lt;Person&gt; weak_Person = person5;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    shared_ptr&lt;Person&gt; person6 = person5;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    person5.reset();</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    person6.reset();</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (weak_Person.expired()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class=\"line\">        </span><br><span class=\"line\">        auto shareptr = weak_Person.lock();</span><br><span class=\"line\">        </span><br><span class=\"line\">        cout &lt;&lt; shareptr &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"c++中operator的重载","date":"2022-09-18T07:10:20.000Z","_content":"\n## 两种函数允许编译器进行隐士类型转换\n1. 单一参数调用成功的constructors\n2. 隐士转换操作符\n\n```\nclass Ration {\npublic:\n    //1 隐士构造函数\n    Ration(int a) {\n        \n    }\n    //2 隐士类型转换函数\n    operator double() const {\n        return 5.0f;\n    }\n};\n\n\nint main()\n{\n    Ration ration(1);\n    cout << ration << endl;\n    return 0;\n}\n```\n\n### 如何阻止构造函数发生不期望的隐士类型转换\n```\nclass Ration {\npublic:\n    explicit Ration(int a) {\n        \n    }\n};\n\nint main()\n{\n    Ration ration(1);\n    \n    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错\n    if (ration == 2) {\n        \n    }\n    return 0;\n}\n```\n\n### 重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 && || 操作符， 原因是改变了短路运算的语义，变成函数调用。\n\n#### 这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\n\n\n###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数\n```\nclass Ration {\npublic:\n    explicit Ration(int a) {\n        \n    }\n    \n    int operator() (int a , int b, int c)\n    {\n        return 10;\n    }\n    \n    int operator() (int a , int b)\n    {\n        return 5;\n    }\n};\n\nint main()\n{\n    Ration ration(1);\n    ration(1, 2, 3);\n    ration(1, 3);\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/C++中operator的重载.md","raw":"---\ntitle: c++中operator的重载\ndate: 2022-09-18 15:10:20\ntags: C++11\n---\n\n## 两种函数允许编译器进行隐士类型转换\n1. 单一参数调用成功的constructors\n2. 隐士转换操作符\n\n```\nclass Ration {\npublic:\n    //1 隐士构造函数\n    Ration(int a) {\n        \n    }\n    //2 隐士类型转换函数\n    operator double() const {\n        return 5.0f;\n    }\n};\n\n\nint main()\n{\n    Ration ration(1);\n    cout << ration << endl;\n    return 0;\n}\n```\n\n### 如何阻止构造函数发生不期望的隐士类型转换\n```\nclass Ration {\npublic:\n    explicit Ration(int a) {\n        \n    }\n};\n\nint main()\n{\n    Ration ration(1);\n    \n    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错\n    if (ration == 2) {\n        \n    }\n    return 0;\n}\n```\n\n### 重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 && || 操作符， 原因是改变了短路运算的语义，变成函数调用。\n\n#### 这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\n\n\n###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数\n```\nclass Ration {\npublic:\n    explicit Ration(int a) {\n        \n    }\n    \n    int operator() (int a , int b, int c)\n    {\n        return 10;\n    }\n    \n    int operator() (int a , int b)\n    {\n        return 5;\n    }\n};\n\nint main()\n{\n    Ration ration(1);\n    ration(1, 2, 3);\n    ration(1, 3);\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"C++中operator的重载","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8900061xco90fj7rdu","content":"<h2 id=\"两种函数允许编译器进行隐士类型转换\"><a href=\"#两种函数允许编译器进行隐士类型转换\" class=\"headerlink\" title=\"两种函数允许编译器进行隐士类型转换\"></a>两种函数允许编译器进行隐士类型转换</h2><ol>\n<li>单一参数调用成功的constructors</li>\n<li>隐士转换操作符</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //1 隐士构造函数</span><br><span class=\"line\">    Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //2 隐士类型转换函数</span><br><span class=\"line\">    operator double() const &#123;</span><br><span class=\"line\">        return 5.0f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    cout &lt;&lt; ration &lt;&lt; endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<span id=\"more\"></span>\n\n<h3 id=\"如何阻止构造函数发生不期望的隐士类型转换\"><a href=\"#如何阻止构造函数发生不期望的隐士类型转换\" class=\"headerlink\" title=\"如何阻止构造函数发生不期望的隐士类型转换\"></a>如何阻止构造函数发生不期望的隐士类型转换</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错</span><br><span class=\"line\">    if (ration == 2) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。\"><a href=\"#重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。\" class=\"headerlink\" title=\"重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。\"></a>重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。</h3><h4 id=\"这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\"><a href=\"#这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\" class=\"headerlink\" title=\"这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\"></a>这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。</h4><p>###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int operator() (int a , int b, int c)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int operator() (int a , int b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    ration(1, 2, 3);</span><br><span class=\"line\">    ration(1, 3);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<h2 id=\"两种函数允许编译器进行隐士类型转换\"><a href=\"#两种函数允许编译器进行隐士类型转换\" class=\"headerlink\" title=\"两种函数允许编译器进行隐士类型转换\"></a>两种函数允许编译器进行隐士类型转换</h2><ol>\n<li>单一参数调用成功的constructors</li>\n<li>隐士转换操作符</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //1 隐士构造函数</span><br><span class=\"line\">    Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //2 隐士类型转换函数</span><br><span class=\"line\">    operator double() const &#123;</span><br><span class=\"line\">        return 5.0f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    cout &lt;&lt; ration &lt;&lt; endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"如何阻止构造函数发生不期望的隐士类型转换\"><a href=\"#如何阻止构造函数发生不期望的隐士类型转换\" class=\"headerlink\" title=\"如何阻止构造函数发生不期望的隐士类型转换\"></a>如何阻止构造函数发生不期望的隐士类型转换</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错</span><br><span class=\"line\">    if (ration == 2) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。\"><a href=\"#重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。\" class=\"headerlink\" title=\"重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。\"></a>重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。</h3><h4 id=\"这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\"><a href=\"#这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\" class=\"headerlink\" title=\"这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。\"></a>这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。</h4><p>###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Ration &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Ration(int a) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int operator() (int a , int b, int c)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int operator() (int a , int b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Ration ration(1);</span><br><span class=\"line\">    ration(1, 2, 3);</span><br><span class=\"line\">    ration(1, 3);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"c++ 右值引用","date":"2022-09-18T08:15:56.000Z","_content":"\n### 1. 什么是右值？\n有名称，可以取地址的值，是左值。\n没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。\nc++11中，所有的值，必属于左值，将亡值，和纯右值。\n\n\n\n### 2. 左值引用，右值引用\n\n```\nint main() {\n    \n    int a = 0; //ok\n    \n    int& b = a; //ok,左值引用\n    int& c = 0; // not ok,左值引用无法引用右值\n    \n    const int& d = 0; // ok，常左值引用，可以绑定右值\n    const int& e = a; // ok，常左值引用，可以绑定左值\n    \n    int&& f = 0;//ok 右值引用绑定右值\n    const int && g = 0; // ok,常右值引用可以绑定右值\n    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗\n    \n    int&& h = a;//not ok，右值引用无法绑定左值\n    \n    return 0;\n}\n```\n左值引用，只能绑定左值\n常左值引用，可以绑定常量左值，右值，非常量左值和右值\n右值引用，只能绑定非常量右值\n常右值引用，可以绑定常量右值，非常量右值\n\n\n### 3. 讨论右值引用，要注意排除返回值优化\n如果关闭返回值优化，可以参考\n<https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO>\n\n```\nPerson GetPerson(){\n    return Person();\n}\n\nint main()\n{\n    Person person = GetPerson();\n    person.print();\n    \n    /*\n     一共执行三次构造\n    1 Person()默认构造函数\n    2 GetPerson函数返回时，生成临时对象，调用移动构造函数\n    3 使用临时对象，构造person，调用移动构造函数\n     */\n    return 0;\n}\n```\n\n\n```\nPerson&& GetPerson(){\n    return Person();\n}\n\nint main()\n{\n    Person person = GetPerson();\n    person.print();\n    \n    /*\n     一共执行两次次构造，这种写法是错的，会有warnning\n     Returning reference to local temporary object\n    1 Person()默认构造函数\n    2 右值引用，引用了已经析构的临时对象\n    3 使用临时对象，构造person，调用移动构造函数\n     */\n    return 0;\n}\n```\n\n### 4. 函数返回值，如果没有写左值引用，就是临时变量属于右值\n\n```\nPerson GetPerson(){\n    return Person();\n}\n\nint main() {\n    \n    Person person1 = GetPerson(); //调用一次构造，两次次移动构造\n    \n    Person&& person2 = GetPerson(); //调用一次构造，一次移动构造\n    \n    return 0;\n}\n```\n理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象\nperson2是直接对临时变量的右值引用\n\n#### 注意\n```\nconst Person& GetPerson1(){\n    return Person();\n}\n\nPerson&& GetPerson2(){\n    return Person();\n}\n```\n上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告\n\n`Returning reference to local temporary object`\n\n\n\n\n\n","source":"_posts/C++右值引用.md","raw":"---\ntitle: c++ 右值引用\ndate: 2022-09-18 16:15:56\ntags:\n\t- C++11\n---\n\n### 1. 什么是右值？\n有名称，可以取地址的值，是左值。\n没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。\nc++11中，所有的值，必属于左值，将亡值，和纯右值。\n\n\n\n### 2. 左值引用，右值引用\n\n```\nint main() {\n    \n    int a = 0; //ok\n    \n    int& b = a; //ok,左值引用\n    int& c = 0; // not ok,左值引用无法引用右值\n    \n    const int& d = 0; // ok，常左值引用，可以绑定右值\n    const int& e = a; // ok，常左值引用，可以绑定左值\n    \n    int&& f = 0;//ok 右值引用绑定右值\n    const int && g = 0; // ok,常右值引用可以绑定右值\n    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗\n    \n    int&& h = a;//not ok，右值引用无法绑定左值\n    \n    return 0;\n}\n```\n左值引用，只能绑定左值\n常左值引用，可以绑定常量左值，右值，非常量左值和右值\n右值引用，只能绑定非常量右值\n常右值引用，可以绑定常量右值，非常量右值\n\n\n### 3. 讨论右值引用，要注意排除返回值优化\n如果关闭返回值优化，可以参考\n<https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO>\n\n```\nPerson GetPerson(){\n    return Person();\n}\n\nint main()\n{\n    Person person = GetPerson();\n    person.print();\n    \n    /*\n     一共执行三次构造\n    1 Person()默认构造函数\n    2 GetPerson函数返回时，生成临时对象，调用移动构造函数\n    3 使用临时对象，构造person，调用移动构造函数\n     */\n    return 0;\n}\n```\n\n\n```\nPerson&& GetPerson(){\n    return Person();\n}\n\nint main()\n{\n    Person person = GetPerson();\n    person.print();\n    \n    /*\n     一共执行两次次构造，这种写法是错的，会有warnning\n     Returning reference to local temporary object\n    1 Person()默认构造函数\n    2 右值引用，引用了已经析构的临时对象\n    3 使用临时对象，构造person，调用移动构造函数\n     */\n    return 0;\n}\n```\n\n### 4. 函数返回值，如果没有写左值引用，就是临时变量属于右值\n\n```\nPerson GetPerson(){\n    return Person();\n}\n\nint main() {\n    \n    Person person1 = GetPerson(); //调用一次构造，两次次移动构造\n    \n    Person&& person2 = GetPerson(); //调用一次构造，一次移动构造\n    \n    return 0;\n}\n```\n理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象\nperson2是直接对临时变量的右值引用\n\n#### 注意\n```\nconst Person& GetPerson1(){\n    return Person();\n}\n\nPerson&& GetPerson2(){\n    return Person();\n}\n```\n上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告\n\n`Returning reference to local temporary object`\n\n\n\n\n\n","slug":"C++右值引用","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8a00081xco47ufaezy","content":"<h3 id=\"1-什么是右值？\"><a href=\"#1-什么是右值？\" class=\"headerlink\" title=\"1. 什么是右值？\"></a>1. 什么是右值？</h3><p>有名称，可以取地址的值，是左值。<br>没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。<br>c++11中，所有的值，必属于左值，将亡值，和纯右值。</p>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"2-左值引用，右值引用\"><a href=\"#2-左值引用，右值引用\" class=\"headerlink\" title=\"2. 左值引用，右值引用\"></a>2. 左值引用，右值引用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int a = 0; //ok</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp; b = a; //ok,左值引用</span><br><span class=\"line\">    int&amp; c = 0; // not ok,左值引用无法引用右值</span><br><span class=\"line\">    </span><br><span class=\"line\">    const int&amp; d = 0; // ok，常左值引用，可以绑定右值</span><br><span class=\"line\">    const int&amp; e = a; // ok，常左值引用，可以绑定左值</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp;&amp; f = 0;//ok 右值引用绑定右值</span><br><span class=\"line\">    const int &amp;&amp; g = 0; // ok,常右值引用可以绑定右值</span><br><span class=\"line\">    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp;&amp; h = a;//not ok，右值引用无法绑定左值</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>左值引用，只能绑定左值<br>常左值引用，可以绑定常量左值，右值，非常量左值和右值<br>右值引用，只能绑定非常量右值<br>常右值引用，可以绑定常量右值，非常量右值</p>\n<h3 id=\"3-讨论右值引用，要注意排除返回值优化\"><a href=\"#3-讨论右值引用，要注意排除返回值优化\" class=\"headerlink\" title=\"3. 讨论右值引用，要注意排除返回值优化\"></a>3. 讨论右值引用，要注意排除返回值优化</h3><p>如果关闭返回值优化，可以参考<br><a href=\"https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO\">https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person = GetPerson();</span><br><span class=\"line\">    person.print();</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     一共执行三次构造</span><br><span class=\"line\">    1 Person()默认构造函数</span><br><span class=\"line\">    2 GetPerson函数返回时，生成临时对象，调用移动构造函数</span><br><span class=\"line\">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person&amp;&amp; GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person = GetPerson();</span><br><span class=\"line\">    person.print();</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     一共执行两次次构造，这种写法是错的，会有warnning</span><br><span class=\"line\">     Returning reference to local temporary object</span><br><span class=\"line\">    1 Person()默认构造函数</span><br><span class=\"line\">    2 右值引用，引用了已经析构的临时对象</span><br><span class=\"line\">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-函数返回值，如果没有写左值引用，就是临时变量属于右值\"><a href=\"#4-函数返回值，如果没有写左值引用，就是临时变量属于右值\" class=\"headerlink\" title=\"4. 函数返回值，如果没有写左值引用，就是临时变量属于右值\"></a>4. 函数返回值，如果没有写左值引用，就是临时变量属于右值</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person person1 = GetPerson(); //调用一次构造，两次次移动构造</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person&amp;&amp; person2 = GetPerson(); //调用一次构造，一次移动构造</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象<br>person2是直接对临时变量的右值引用</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Person&amp; GetPerson1()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person&amp;&amp; GetPerson2()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告</p>\n<p><code>Returning reference to local temporary object</code></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-什么是右值？\"><a href=\"#1-什么是右值？\" class=\"headerlink\" title=\"1. 什么是右值？\"></a>1. 什么是右值？</h3><p>有名称，可以取地址的值，是左值。<br>没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。<br>c++11中，所有的值，必属于左值，将亡值，和纯右值。</p>","more":"<h3 id=\"2-左值引用，右值引用\"><a href=\"#2-左值引用，右值引用\" class=\"headerlink\" title=\"2. 左值引用，右值引用\"></a>2. 左值引用，右值引用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int a = 0; //ok</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp; b = a; //ok,左值引用</span><br><span class=\"line\">    int&amp; c = 0; // not ok,左值引用无法引用右值</span><br><span class=\"line\">    </span><br><span class=\"line\">    const int&amp; d = 0; // ok，常左值引用，可以绑定右值</span><br><span class=\"line\">    const int&amp; e = a; // ok，常左值引用，可以绑定左值</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp;&amp; f = 0;//ok 右值引用绑定右值</span><br><span class=\"line\">    const int &amp;&amp; g = 0; // ok,常右值引用可以绑定右值</span><br><span class=\"line\">    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗</span><br><span class=\"line\">    </span><br><span class=\"line\">    int&amp;&amp; h = a;//not ok，右值引用无法绑定左值</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>左值引用，只能绑定左值<br>常左值引用，可以绑定常量左值，右值，非常量左值和右值<br>右值引用，只能绑定非常量右值<br>常右值引用，可以绑定常量右值，非常量右值</p>\n<h3 id=\"3-讨论右值引用，要注意排除返回值优化\"><a href=\"#3-讨论右值引用，要注意排除返回值优化\" class=\"headerlink\" title=\"3. 讨论右值引用，要注意排除返回值优化\"></a>3. 讨论右值引用，要注意排除返回值优化</h3><p>如果关闭返回值优化，可以参考<br><a href=\"https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO\">https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person = GetPerson();</span><br><span class=\"line\">    person.print();</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     一共执行三次构造</span><br><span class=\"line\">    1 Person()默认构造函数</span><br><span class=\"line\">    2 GetPerson函数返回时，生成临时对象，调用移动构造函数</span><br><span class=\"line\">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person&amp;&amp; GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person = GetPerson();</span><br><span class=\"line\">    person.print();</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     一共执行两次次构造，这种写法是错的，会有warnning</span><br><span class=\"line\">     Returning reference to local temporary object</span><br><span class=\"line\">    1 Person()默认构造函数</span><br><span class=\"line\">    2 右值引用，引用了已经析构的临时对象</span><br><span class=\"line\">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-函数返回值，如果没有写左值引用，就是临时变量属于右值\"><a href=\"#4-函数返回值，如果没有写左值引用，就是临时变量属于右值\" class=\"headerlink\" title=\"4. 函数返回值，如果没有写左值引用，就是临时变量属于右值\"></a>4. 函数返回值，如果没有写左值引用，就是临时变量属于右值</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person GetPerson()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person person1 = GetPerson(); //调用一次构造，两次次移动构造</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person&amp;&amp; person2 = GetPerson(); //调用一次构造，一次移动构造</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象<br>person2是直接对临时变量的右值引用</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Person&amp; GetPerson1()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person&amp;&amp; GetPerson2()&#123;</span><br><span class=\"line\">    return Person();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告</p>\n<p><code>Returning reference to local temporary object</code></p>"},{"title":"实现完美转发","date":"2022-10-23T12:36:59.000Z","_content":"\n\n### 什么是完美转发？\n\n#### 在理解什么是完美转发之前，需要知道什么是万能引用?\n在模板推导过程中，使用T&& a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。\n\n```\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    cout << a << endl;\n    cout << b << endl;\n}\n\nint main() {\n    \n    Add(4, 5); // a，b的类型会被推导成int&&\n    int a = 0;\n    int b = 0;\n    Add(a, b); // a，b的类型会被推导成int&\n    \n    return 0;\n}\n```\n根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用\n\n\n#### 万能引用遇到的问题？\n上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.\n```\ntemplate <typename T>\nvoid AddImp(T&& a, T&& b) {\n    cout << a << endl;\n    cout << b << endl;\n}\n\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    AddImp(a, b);\n}\n\nint main() {\n    \n    Add(4, 5);\n    int a = 0;\n    int b = 0;\n    Add(a, b);\n    \n    return 0;\n}\n```\n\n#### 解决方案: std::forward<T>\n```\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    AddImp(std::forward<T>(a), std::forward<T>(b));\n}\n\n```\nstd::forward的具体实现\n```\ntemplate <class _Tp>\n_Tp&& forward(typename remove_reference<_Tp>::type& __t) \n{\n  return static_cast<_Tp&&>(__t);\n}\n```\n\n具体分析一下，也是通过引用折叠来实现\n1. 如果_Tp的类型是int&， 通过引用折叠 int& && 折叠后是左值引用int&\n2. 如果_Tp的类型是int&&， 通过引用折叠 int&& && 折叠后是int&&\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/C++实现完美转发.md","raw":"---\ntitle: 实现完美转发\ndate: 2022-10-23 20:36:59\ntags: C++11\n---\n\n\n### 什么是完美转发？\n\n#### 在理解什么是完美转发之前，需要知道什么是万能引用?\n在模板推导过程中，使用T&& a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。\n\n```\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    cout << a << endl;\n    cout << b << endl;\n}\n\nint main() {\n    \n    Add(4, 5); // a，b的类型会被推导成int&&\n    int a = 0;\n    int b = 0;\n    Add(a, b); // a，b的类型会被推导成int&\n    \n    return 0;\n}\n```\n根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用\n\n\n#### 万能引用遇到的问题？\n上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.\n```\ntemplate <typename T>\nvoid AddImp(T&& a, T&& b) {\n    cout << a << endl;\n    cout << b << endl;\n}\n\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    AddImp(a, b);\n}\n\nint main() {\n    \n    Add(4, 5);\n    int a = 0;\n    int b = 0;\n    Add(a, b);\n    \n    return 0;\n}\n```\n\n#### 解决方案: std::forward<T>\n```\ntemplate <typename T>\nvoid Add(T&& a, T&& b) {\n    AddImp(std::forward<T>(a), std::forward<T>(b));\n}\n\n```\nstd::forward的具体实现\n```\ntemplate <class _Tp>\n_Tp&& forward(typename remove_reference<_Tp>::type& __t) \n{\n  return static_cast<_Tp&&>(__t);\n}\n```\n\n具体分析一下，也是通过引用折叠来实现\n1. 如果_Tp的类型是int&， 通过引用折叠 int& && 折叠后是左值引用int&\n2. 如果_Tp的类型是int&&， 通过引用折叠 int&& && 折叠后是int&&\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"C++实现完美转发","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8a00091xcobzvue3wu","content":"<h3 id=\"什么是完美转发？\"><a href=\"#什么是完美转发？\" class=\"headerlink\" title=\"什么是完美转发？\"></a>什么是完美转发？</h3><span id=\"more\"></span>\n\n<h4 id=\"在理解什么是完美转发之前，需要知道什么是万能引用\"><a href=\"#在理解什么是完美转发之前，需要知道什么是万能引用\" class=\"headerlink\" title=\"在理解什么是完美转发之前，需要知道什么是万能引用?\"></a>在理解什么是完美转发之前，需要知道什么是万能引用?</h4><p>在模板推导过程中，使用T&amp;&amp; a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Add(4, 5); // a，b的类型会被推导成int&amp;&amp;</span><br><span class=\"line\">    int a = 0;</span><br><span class=\"line\">    int b = 0;</span><br><span class=\"line\">    Add(a, b); // a，b的类型会被推导成int&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用</p>\n<h4 id=\"万能引用遇到的问题？\"><a href=\"#万能引用遇到的问题？\" class=\"headerlink\" title=\"万能引用遇到的问题？\"></a>万能引用遇到的问题？</h4><p>上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void AddImp(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    AddImp(a, b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Add(4, 5);</span><br><span class=\"line\">    int a = 0;</span><br><span class=\"line\">    int b = 0;</span><br><span class=\"line\">    Add(a, b);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"解决方案-std-forward\"><a href=\"#解决方案-std-forward\" class=\"headerlink\" title=\"解决方案: std::forward\"></a>解决方案: std::forward<T></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    AddImp(std::forward&lt;T&gt;(a), std::forward&lt;T&gt;(b));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>std::forward的具体实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class _Tp&gt;</span><br><span class=\"line\">_Tp&amp;&amp; forward(typename remove_reference&lt;_Tp&gt;::type&amp; __t) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体分析一下，也是通过引用折叠来实现</p>\n<ol>\n<li>如果_Tp的类型是int&amp;， 通过引用折叠 int&amp; &amp;&amp; 折叠后是左值引用int&amp;</li>\n<li>如果_Tp的类型是int&amp;&amp;， 通过引用折叠 int&amp;&amp; &amp;&amp; 折叠后是int&amp;&amp;</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是完美转发？\"><a href=\"#什么是完美转发？\" class=\"headerlink\" title=\"什么是完美转发？\"></a>什么是完美转发？</h3>","more":"<h4 id=\"在理解什么是完美转发之前，需要知道什么是万能引用\"><a href=\"#在理解什么是完美转发之前，需要知道什么是万能引用\" class=\"headerlink\" title=\"在理解什么是完美转发之前，需要知道什么是万能引用?\"></a>在理解什么是完美转发之前，需要知道什么是万能引用?</h4><p>在模板推导过程中，使用T&amp;&amp; a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Add(4, 5); // a，b的类型会被推导成int&amp;&amp;</span><br><span class=\"line\">    int a = 0;</span><br><span class=\"line\">    int b = 0;</span><br><span class=\"line\">    Add(a, b); // a，b的类型会被推导成int&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用</p>\n<h4 id=\"万能引用遇到的问题？\"><a href=\"#万能引用遇到的问题？\" class=\"headerlink\" title=\"万能引用遇到的问题？\"></a>万能引用遇到的问题？</h4><p>上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void AddImp(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    AddImp(a, b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Add(4, 5);</span><br><span class=\"line\">    int a = 0;</span><br><span class=\"line\">    int b = 0;</span><br><span class=\"line\">    Add(a, b);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"解决方案-std-forward\"><a href=\"#解决方案-std-forward\" class=\"headerlink\" title=\"解决方案: std::forward\"></a>解决方案: std::forward<T></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class=\"line\">    AddImp(std::forward&lt;T&gt;(a), std::forward&lt;T&gt;(b));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>std::forward的具体实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class _Tp&gt;</span><br><span class=\"line\">_Tp&amp;&amp; forward(typename remove_reference&lt;_Tp&gt;::type&amp; __t) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体分析一下，也是通过引用折叠来实现</p>\n<ol>\n<li>如果_Tp的类型是int&amp;， 通过引用折叠 int&amp; &amp;&amp; 折叠后是左值引用int&amp;</li>\n<li>如果_Tp的类型是int&amp;&amp;， 通过引用折叠 int&amp;&amp; &amp;&amp; 折叠后是int&amp;&amp;</li>\n</ol>"},{"title":"C++ 构造函数","date":"2022-09-18T02:54:51.000Z","_content":"\n## C++ 构造函数\n\n1. 默认构造\n2. copy构造\n3. 移动构造\n4. operator= 赋值函数\n\n\n### 说明\n\n1. 对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用\n\n```\nclass Person\n{\npublic:\n    Person() {\n        cout << \"Person()\" << endl;\n    };\n    ~Person() {\n        cout << \"~Person()\" << endl;\n    };\n\n    Person(const Person& Person) {\n        cout << \"Person(Person& Person)\" << endl;\n    }\n    \n    Person(Person&& Person) {\n        cout << \"Person(Person&& Person)\" << endl;\n    }\n    \n    Person& operator=(const Person&)\n    {\n        cout << \"operator=(const Person&)\" << endl;\n        return *this;\n    }\n};\n\n```\n\n2. 对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。\n\n```\nclass Person\n{\npublic:\n//    Person() {\n//        cout << \"Person()\" << endl;\n//    };\n    ~Person() {\n        cout << \"~Person()\" << endl;\n    };\n\n//    Person(const Person& Person) {\n//        cout << \"Person(Person& Person)\" << endl;\n//    }\n\n    Person(Person&& Person) {\n        cout << \"Person(Person&& Person)\" << endl;\n    }\n\n    Person& operator=(const Person&)\n    {\n        cout << \"operator=(const Person&)\" << endl;\n        return *this;\n    }\n};\n\nint main()\n{\n    Person person; //编译报错，找不到匹配的构造函数\n    return 0;\n\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/C++构造函数.md","raw":"---\ntitle: C++ 构造函数\ndate: 2022-09-18 10:54:51\ntags: C++11\n---\n\n## C++ 构造函数\n\n1. 默认构造\n2. copy构造\n3. 移动构造\n4. operator= 赋值函数\n\n\n### 说明\n\n1. 对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用\n\n```\nclass Person\n{\npublic:\n    Person() {\n        cout << \"Person()\" << endl;\n    };\n    ~Person() {\n        cout << \"~Person()\" << endl;\n    };\n\n    Person(const Person& Person) {\n        cout << \"Person(Person& Person)\" << endl;\n    }\n    \n    Person(Person&& Person) {\n        cout << \"Person(Person&& Person)\" << endl;\n    }\n    \n    Person& operator=(const Person&)\n    {\n        cout << \"operator=(const Person&)\" << endl;\n        return *this;\n    }\n};\n\n```\n\n2. 对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。\n\n```\nclass Person\n{\npublic:\n//    Person() {\n//        cout << \"Person()\" << endl;\n//    };\n    ~Person() {\n        cout << \"~Person()\" << endl;\n    };\n\n//    Person(const Person& Person) {\n//        cout << \"Person(Person& Person)\" << endl;\n//    }\n\n    Person(Person&& Person) {\n        cout << \"Person(Person&& Person)\" << endl;\n    }\n\n    Person& operator=(const Person&)\n    {\n        cout << \"operator=(const Person&)\" << endl;\n        return *this;\n    }\n};\n\nint main()\n{\n    Person person; //编译报错，找不到匹配的构造函数\n    return 0;\n\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"C++构造函数","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8a000a1xco1wra0wlm","content":"<h2 id=\"C-构造函数\"><a href=\"#C-构造函数\" class=\"headerlink\" title=\"C++ 构造函数\"></a>C++ 构造函数</h2><ol>\n<li>默认构造</li>\n<li>copy构造</li>\n<li>移动构造</li>\n<li>operator= 赋值函数</li>\n</ol>\n<span id=\"more\"></span>\n\n\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><ol>\n<li>对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(const Person&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person(Person&amp;&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person&amp; operator=(const Person&amp;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">//    Person() &#123;</span><br><span class=\"line\">//        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">//    &#125;;</span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//    Person(const Person&amp; Person) &#123;</span><br><span class=\"line\">//        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">//    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(Person&amp;&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person&amp; operator=(const Person&amp;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person; //编译报错，找不到匹配的构造函数</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<h2 id=\"C-构造函数\"><a href=\"#C-构造函数\" class=\"headerlink\" title=\"C++ 构造函数\"></a>C++ 构造函数</h2><ol>\n<li>默认构造</li>\n<li>copy构造</li>\n<li>移动构造</li>\n<li>operator= 赋值函数</li>\n</ol>","more":"<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><ol>\n<li>对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(const Person&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person(Person&amp;&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person&amp; operator=(const Person&amp;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">//    Person() &#123;</span><br><span class=\"line\">//        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">//    &#125;;</span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//    Person(const Person&amp; Person) &#123;</span><br><span class=\"line\">//        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">//    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(Person&amp;&amp; Person) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person&amp; operator=(const Person&amp;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Person person; //编译报错，找不到匹配的构造函数</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"CALayer opaque","date":"2016-12-30T02:51:46.000Z","_content":"\n### 颜色合成公式\n\n**R = S + D \\* ( 1 – Sa )**\n\n ![20130819170332968](/Users/baidu/Downloads/20130819170332968.png)\n\n其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。\n\n设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算\n\n注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期\n","source":"_posts/CALayer-opaque.md","raw":"---\nlayout: post\ntitle: CALayer opaque\ndate: 2016-12-30 10:51:46\ntags: iOS\n\n---\n\n### 颜色合成公式\n\n**R = S + D \\* ( 1 – Sa )**\n\n ![20130819170332968](/Users/baidu/Downloads/20130819170332968.png)\n\n其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。\n\n设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算\n\n注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期\n","slug":"CALayer-opaque","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8b000d1xcoc3k1bb2k","content":"<h3 id=\"颜色合成公式\"><a href=\"#颜色合成公式\" class=\"headerlink\" title=\"颜色合成公式\"></a>颜色合成公式</h3><p><strong>R = S + D * ( 1 – Sa )</strong></p>\n<p> <img src=\"/Users/baidu/Downloads/20130819170332968.png\" alt=\"20130819170332968\"></p>\n<p>其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。</p>\n<p>设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算</p>\n<p>注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"颜色合成公式\"><a href=\"#颜色合成公式\" class=\"headerlink\" title=\"颜色合成公式\"></a>颜色合成公式</h3><p><strong>R = S + D * ( 1 – Sa )</strong></p>\n<p> <img src=\"/Users/baidu/Downloads/20130819170332968.png\" alt=\"20130819170332968\"></p>\n<p>其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。</p>\n<p>设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算</p>\n<p>注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期</p>\n"},{"title":"C++类型转换陷阱：有符号和无符号整数比较","date":"2025-06-08T02:00:00.000Z","_content":"\n在C++编程中，有一些看似简单的操作可能会带来意想不到的结果。今天我们要讨论一个常见但容易被忽视的问题：有符号整数（signed）和无符号整数（unsigned）的比较操作。\n\n<!-- more -->\n\n## 问题重现\n\n让我们看一个具体的例子：\n\n```cpp\nint32_t a = -1;\nuint b = 4152;\n\nbool isLess = a < b; // 预期结果：true，实际结果：false\n```\n\n这段代码的运行结果可能会让人感到困惑。虽然-1显然小于4152，但比较结果却返回false。这是为什么呢？\n\n## 背后的机制\n\n### 类型转换规则\n\n在C++中，当有符号整数和无符号整数进行比较时，会发生以下转换：\n\n1. **有符号整数会被转换为无符号整数**\n2. **转换规则遵循补码表示**\n\n在我们的例子中：\n- `-1`的补码表示为`0xFFFFFFFF`\n- 当转换为无符号整数时，这个值被解释为`4294967295`\n- 因此实际的比较变成了：`4294967295 < 4152`\n- 显然这个比较会返回`false`\n\n### 为什么会这样设计？\n\n这个设计有其历史原因：\n- 处理器进行整数比较时，实际是在比较二进制位\n- 无符号整数的比较更简单且更快\n- C++继承了C语言的这一特性\n\n## 如何避免这类问题\n\n### 1. 使用相同的类型\n\n最简单的解决方案是确保比较的两个数使用相同的类型：\n\n```cpp\n// 方案1：都使用有符号整数\nint32_t m_IBufferMaxValue = -1;\nint32_t pointCount = 4152;\n\n// 方案2：都使用无符号整数（如果数值总是非负的话）\nuint32_t m_IBufferMaxValue = 0;  // 或其他非负值\nuint32_t pointCount = 4152;\n```\n\n### 2. 显式类型转换\n\n如果必须使用不同的类型，请使用显式类型转换并注意检查值的范围：\n\n```cpp\n// 使用static_cast进行显式转换\nbool isLess = m_IBufferMaxValue < static_cast<int32_t>(pointCount);\n\n// 或者先进行范围检查\nif (pointCount <= INT32_MAX) {\n    bool isLess = m_IBufferMaxValue < static_cast<int32_t>(pointCount);\n}\n```\n\n### 3. 使用类型安全的比较函数\n\n可以封装一个安全的比较函数：\n\n```cpp\ntemplate<typename T1, typename T2>\nbool SafeCompare(T1 a, T2 b) {\n    if constexpr (std::is_signed_v<T1> && std::is_unsigned_v<T2>) {\n        if (a < 0) return true;\n        return static_cast<std::make_unsigned_t<T1>>(a) < b;\n    }\n    // 添加其他类型组合的处理...\n    return a < b;\n}\n```\n\n### 4. 代码检查工具\n\n- 使用静态代码分析工具\n- 启用编译器警告\n- 使用`-Wsign-compare`警告选项\n\n## 最佳实践建议\n\n1. **明确变量类型**\n   - 在声明变量时就明确其是否需要支持负值\n   - 如果数值永远不会为负，就使用无符号类型\n\n2. **统一类型使用**\n   - 在同一个模块或相关的代码中保持类型的一致性\n   - 避免混合使用有符号和无符号类型\n\n3. **文档和注释**\n   - 在可能发生类型转换的地方添加清晰的注释\n   - 记录类型选择的原因和注意事项\n\n4. **单元测试**\n   - 编写测试用例覆盖边界条件\n   - 特别注意类型转换可能发生的场景\n\n## 总结\n\n类型转换的陷阱虽然看似简单，但在实际开发中经常会造成难以发现的bug。通过：\n- 理解类型转换规则\n- 采用一致的类型\n- 使用显式转换\n- 添加适当的检查\n\n我们可以有效地避免这类问题。记住，在处理不同整数类型的比较时，宁可多写几行代码，也要确保类型转换的安全性。\n\n## 参考资料\n\n- C++ Standard Library\n- Effective C++\n- C++ Core Guidelines ","source":"_posts/C++类型转换陷阱-有符号和无符号整数比较.md","raw":"---\ntitle: C++类型转换陷阱：有符号和无符号整数比较\ndate: 2025-06-08 10:00:00\ntags: [C++, 编程陷阱, 类型转换]\ncategories: [编程技术]\n---\n\n在C++编程中，有一些看似简单的操作可能会带来意想不到的结果。今天我们要讨论一个常见但容易被忽视的问题：有符号整数（signed）和无符号整数（unsigned）的比较操作。\n\n<!-- more -->\n\n## 问题重现\n\n让我们看一个具体的例子：\n\n```cpp\nint32_t a = -1;\nuint b = 4152;\n\nbool isLess = a < b; // 预期结果：true，实际结果：false\n```\n\n这段代码的运行结果可能会让人感到困惑。虽然-1显然小于4152，但比较结果却返回false。这是为什么呢？\n\n## 背后的机制\n\n### 类型转换规则\n\n在C++中，当有符号整数和无符号整数进行比较时，会发生以下转换：\n\n1. **有符号整数会被转换为无符号整数**\n2. **转换规则遵循补码表示**\n\n在我们的例子中：\n- `-1`的补码表示为`0xFFFFFFFF`\n- 当转换为无符号整数时，这个值被解释为`4294967295`\n- 因此实际的比较变成了：`4294967295 < 4152`\n- 显然这个比较会返回`false`\n\n### 为什么会这样设计？\n\n这个设计有其历史原因：\n- 处理器进行整数比较时，实际是在比较二进制位\n- 无符号整数的比较更简单且更快\n- C++继承了C语言的这一特性\n\n## 如何避免这类问题\n\n### 1. 使用相同的类型\n\n最简单的解决方案是确保比较的两个数使用相同的类型：\n\n```cpp\n// 方案1：都使用有符号整数\nint32_t m_IBufferMaxValue = -1;\nint32_t pointCount = 4152;\n\n// 方案2：都使用无符号整数（如果数值总是非负的话）\nuint32_t m_IBufferMaxValue = 0;  // 或其他非负值\nuint32_t pointCount = 4152;\n```\n\n### 2. 显式类型转换\n\n如果必须使用不同的类型，请使用显式类型转换并注意检查值的范围：\n\n```cpp\n// 使用static_cast进行显式转换\nbool isLess = m_IBufferMaxValue < static_cast<int32_t>(pointCount);\n\n// 或者先进行范围检查\nif (pointCount <= INT32_MAX) {\n    bool isLess = m_IBufferMaxValue < static_cast<int32_t>(pointCount);\n}\n```\n\n### 3. 使用类型安全的比较函数\n\n可以封装一个安全的比较函数：\n\n```cpp\ntemplate<typename T1, typename T2>\nbool SafeCompare(T1 a, T2 b) {\n    if constexpr (std::is_signed_v<T1> && std::is_unsigned_v<T2>) {\n        if (a < 0) return true;\n        return static_cast<std::make_unsigned_t<T1>>(a) < b;\n    }\n    // 添加其他类型组合的处理...\n    return a < b;\n}\n```\n\n### 4. 代码检查工具\n\n- 使用静态代码分析工具\n- 启用编译器警告\n- 使用`-Wsign-compare`警告选项\n\n## 最佳实践建议\n\n1. **明确变量类型**\n   - 在声明变量时就明确其是否需要支持负值\n   - 如果数值永远不会为负，就使用无符号类型\n\n2. **统一类型使用**\n   - 在同一个模块或相关的代码中保持类型的一致性\n   - 避免混合使用有符号和无符号类型\n\n3. **文档和注释**\n   - 在可能发生类型转换的地方添加清晰的注释\n   - 记录类型选择的原因和注意事项\n\n4. **单元测试**\n   - 编写测试用例覆盖边界条件\n   - 特别注意类型转换可能发生的场景\n\n## 总结\n\n类型转换的陷阱虽然看似简单，但在实际开发中经常会造成难以发现的bug。通过：\n- 理解类型转换规则\n- 采用一致的类型\n- 使用显式转换\n- 添加适当的检查\n\n我们可以有效地避免这类问题。记住，在处理不同整数类型的比较时，宁可多写几行代码，也要确保类型转换的安全性。\n\n## 参考资料\n\n- C++ Standard Library\n- Effective C++\n- C++ Core Guidelines ","slug":"C++类型转换陷阱-有符号和无符号整数比较","published":1,"updated":"2025-06-12T08:08:28.440Z","_id":"cmbt3hg8b000f1xco9wpc4r9o","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在C++编程中，有一些看似简单的操作可能会带来意想不到的结果。今天我们要讨论一个常见但容易被忽视的问题：有符号整数（signed）和无符号整数（unsigned）的比较操作。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"问题重现\"><a href=\"#问题重现\" class=\"headerlink\" title=\"问题重现\"></a>问题重现</h2><p>让我们看一个具体的例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int32_t</span> a = <span class=\"number\">-1</span>;</span><br><span class=\"line\">uint b = <span class=\"number\">4152</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> isLess = a &lt; b; <span class=\"comment\">// 预期结果：true，实际结果：false</span></span><br></pre></td></tr></table></figure>\n\n<p>这段代码的运行结果可能会让人感到困惑。虽然-1显然小于4152，但比较结果却返回false。这是为什么呢？</p>\n<h2 id=\"背后的机制\"><a href=\"#背后的机制\" class=\"headerlink\" title=\"背后的机制\"></a>背后的机制</h2><h3 id=\"类型转换规则\"><a href=\"#类型转换规则\" class=\"headerlink\" title=\"类型转换规则\"></a>类型转换规则</h3><p>在C++中，当有符号整数和无符号整数进行比较时，会发生以下转换：</p>\n<ol>\n<li><strong>有符号整数会被转换为无符号整数</strong></li>\n<li><strong>转换规则遵循补码表示</strong></li>\n</ol>\n<p>在我们的例子中：</p>\n<ul>\n<li><code>-1</code>的补码表示为<code>0xFFFFFFFF</code></li>\n<li>当转换为无符号整数时，这个值被解释为<code>4294967295</code></li>\n<li>因此实际的比较变成了：<code>4294967295 &lt; 4152</code></li>\n<li>显然这个比较会返回<code>false</code></li>\n</ul>\n<h3 id=\"为什么会这样设计？\"><a href=\"#为什么会这样设计？\" class=\"headerlink\" title=\"为什么会这样设计？\"></a>为什么会这样设计？</h3><p>这个设计有其历史原因：</p>\n<ul>\n<li>处理器进行整数比较时，实际是在比较二进制位</li>\n<li>无符号整数的比较更简单且更快</li>\n<li>C++继承了C语言的这一特性</li>\n</ul>\n<h2 id=\"如何避免这类问题\"><a href=\"#如何避免这类问题\" class=\"headerlink\" title=\"如何避免这类问题\"></a>如何避免这类问题</h2><h3 id=\"1-使用相同的类型\"><a href=\"#1-使用相同的类型\" class=\"headerlink\" title=\"1. 使用相同的类型\"></a>1. 使用相同的类型</h3><p>最简单的解决方案是确保比较的两个数使用相同的类型：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案1：都使用有符号整数</span></span><br><span class=\"line\"><span class=\"type\">int32_t</span> m_IBufferMaxValue = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"type\">int32_t</span> pointCount = <span class=\"number\">4152</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方案2：都使用无符号整数（如果数值总是非负的话）</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> m_IBufferMaxValue = <span class=\"number\">0</span>;  <span class=\"comment\">// 或其他非负值</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> pointCount = <span class=\"number\">4152</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-显式类型转换\"><a href=\"#2-显式类型转换\" class=\"headerlink\" title=\"2. 显式类型转换\"></a>2. 显式类型转换</h3><p>如果必须使用不同的类型，请使用显式类型转换并注意检查值的范围：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用static_cast进行显式转换</span></span><br><span class=\"line\"><span class=\"type\">bool</span> isLess = m_IBufferMaxValue &lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int32_t</span>&gt;(pointCount);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者先进行范围检查</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointCount &lt;= INT32_MAX) &#123;</span><br><span class=\"line\">    <span class=\"type\">bool</span> isLess = m_IBufferMaxValue &lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int32_t</span>&gt;(pointCount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用类型安全的比较函数\"><a href=\"#3-使用类型安全的比较函数\" class=\"headerlink\" title=\"3. 使用类型安全的比较函数\"></a>3. 使用类型安全的比较函数</h3><p>可以封装一个安全的比较函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">SafeCompare</span><span class=\"params\">(T1 a, T2 b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">if</span> <span class=\"title\">constexpr</span> <span class=\"params\">(std::is_signed_v&lt;T1&gt; &amp;&amp; std::is_unsigned_v&lt;T2&gt;)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;std::<span class=\"type\">make_unsigned_t</span>&lt;T1&gt;&gt;(a) &lt; b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 添加其他类型组合的处理...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &lt; b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-代码检查工具\"><a href=\"#4-代码检查工具\" class=\"headerlink\" title=\"4. 代码检查工具\"></a>4. 代码检查工具</h3><ul>\n<li>使用静态代码分析工具</li>\n<li>启用编译器警告</li>\n<li>使用<code>-Wsign-compare</code>警告选项</li>\n</ul>\n<h2 id=\"最佳实践建议\"><a href=\"#最佳实践建议\" class=\"headerlink\" title=\"最佳实践建议\"></a>最佳实践建议</h2><ol>\n<li><p><strong>明确变量类型</strong></p>\n<ul>\n<li>在声明变量时就明确其是否需要支持负值</li>\n<li>如果数值永远不会为负，就使用无符号类型</li>\n</ul>\n</li>\n<li><p><strong>统一类型使用</strong></p>\n<ul>\n<li>在同一个模块或相关的代码中保持类型的一致性</li>\n<li>避免混合使用有符号和无符号类型</li>\n</ul>\n</li>\n<li><p><strong>文档和注释</strong></p>\n<ul>\n<li>在可能发生类型转换的地方添加清晰的注释</li>\n<li>记录类型选择的原因和注意事项</li>\n</ul>\n</li>\n<li><p><strong>单元测试</strong></p>\n<ul>\n<li>编写测试用例覆盖边界条件</li>\n<li>特别注意类型转换可能发生的场景</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>类型转换的陷阱虽然看似简单，但在实际开发中经常会造成难以发现的bug。通过：</p>\n<ul>\n<li>理解类型转换规则</li>\n<li>采用一致的类型</li>\n<li>使用显式转换</li>\n<li>添加适当的检查</li>\n</ul>\n<p>我们可以有效地避免这类问题。记住，在处理不同整数类型的比较时，宁可多写几行代码，也要确保类型转换的安全性。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li>C++ Standard Library</li>\n<li>Effective C++</li>\n<li>C++ Core Guidelines </li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在C++编程中，有一些看似简单的操作可能会带来意想不到的结果。今天我们要讨论一个常见但容易被忽视的问题：有符号整数（signed）和无符号整数（unsigned）的比较操作。</p>","more":"<h2 id=\"问题重现\"><a href=\"#问题重现\" class=\"headerlink\" title=\"问题重现\"></a>问题重现</h2><p>让我们看一个具体的例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int32_t</span> a = <span class=\"number\">-1</span>;</span><br><span class=\"line\">uint b = <span class=\"number\">4152</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> isLess = a &lt; b; <span class=\"comment\">// 预期结果：true，实际结果：false</span></span><br></pre></td></tr></table></figure>\n\n<p>这段代码的运行结果可能会让人感到困惑。虽然-1显然小于4152，但比较结果却返回false。这是为什么呢？</p>\n<h2 id=\"背后的机制\"><a href=\"#背后的机制\" class=\"headerlink\" title=\"背后的机制\"></a>背后的机制</h2><h3 id=\"类型转换规则\"><a href=\"#类型转换规则\" class=\"headerlink\" title=\"类型转换规则\"></a>类型转换规则</h3><p>在C++中，当有符号整数和无符号整数进行比较时，会发生以下转换：</p>\n<ol>\n<li><strong>有符号整数会被转换为无符号整数</strong></li>\n<li><strong>转换规则遵循补码表示</strong></li>\n</ol>\n<p>在我们的例子中：</p>\n<ul>\n<li><code>-1</code>的补码表示为<code>0xFFFFFFFF</code></li>\n<li>当转换为无符号整数时，这个值被解释为<code>4294967295</code></li>\n<li>因此实际的比较变成了：<code>4294967295 &lt; 4152</code></li>\n<li>显然这个比较会返回<code>false</code></li>\n</ul>\n<h3 id=\"为什么会这样设计？\"><a href=\"#为什么会这样设计？\" class=\"headerlink\" title=\"为什么会这样设计？\"></a>为什么会这样设计？</h3><p>这个设计有其历史原因：</p>\n<ul>\n<li>处理器进行整数比较时，实际是在比较二进制位</li>\n<li>无符号整数的比较更简单且更快</li>\n<li>C++继承了C语言的这一特性</li>\n</ul>\n<h2 id=\"如何避免这类问题\"><a href=\"#如何避免这类问题\" class=\"headerlink\" title=\"如何避免这类问题\"></a>如何避免这类问题</h2><h3 id=\"1-使用相同的类型\"><a href=\"#1-使用相同的类型\" class=\"headerlink\" title=\"1. 使用相同的类型\"></a>1. 使用相同的类型</h3><p>最简单的解决方案是确保比较的两个数使用相同的类型：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案1：都使用有符号整数</span></span><br><span class=\"line\"><span class=\"type\">int32_t</span> m_IBufferMaxValue = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"type\">int32_t</span> pointCount = <span class=\"number\">4152</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方案2：都使用无符号整数（如果数值总是非负的话）</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> m_IBufferMaxValue = <span class=\"number\">0</span>;  <span class=\"comment\">// 或其他非负值</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> pointCount = <span class=\"number\">4152</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-显式类型转换\"><a href=\"#2-显式类型转换\" class=\"headerlink\" title=\"2. 显式类型转换\"></a>2. 显式类型转换</h3><p>如果必须使用不同的类型，请使用显式类型转换并注意检查值的范围：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用static_cast进行显式转换</span></span><br><span class=\"line\"><span class=\"type\">bool</span> isLess = m_IBufferMaxValue &lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int32_t</span>&gt;(pointCount);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者先进行范围检查</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pointCount &lt;= INT32_MAX) &#123;</span><br><span class=\"line\">    <span class=\"type\">bool</span> isLess = m_IBufferMaxValue &lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int32_t</span>&gt;(pointCount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用类型安全的比较函数\"><a href=\"#3-使用类型安全的比较函数\" class=\"headerlink\" title=\"3. 使用类型安全的比较函数\"></a>3. 使用类型安全的比较函数</h3><p>可以封装一个安全的比较函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">SafeCompare</span><span class=\"params\">(T1 a, T2 b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">if</span> <span class=\"title\">constexpr</span> <span class=\"params\">(std::is_signed_v&lt;T1&gt; &amp;&amp; std::is_unsigned_v&lt;T2&gt;)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;std::<span class=\"type\">make_unsigned_t</span>&lt;T1&gt;&gt;(a) &lt; b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 添加其他类型组合的处理...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &lt; b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-代码检查工具\"><a href=\"#4-代码检查工具\" class=\"headerlink\" title=\"4. 代码检查工具\"></a>4. 代码检查工具</h3><ul>\n<li>使用静态代码分析工具</li>\n<li>启用编译器警告</li>\n<li>使用<code>-Wsign-compare</code>警告选项</li>\n</ul>\n<h2 id=\"最佳实践建议\"><a href=\"#最佳实践建议\" class=\"headerlink\" title=\"最佳实践建议\"></a>最佳实践建议</h2><ol>\n<li><p><strong>明确变量类型</strong></p>\n<ul>\n<li>在声明变量时就明确其是否需要支持负值</li>\n<li>如果数值永远不会为负，就使用无符号类型</li>\n</ul>\n</li>\n<li><p><strong>统一类型使用</strong></p>\n<ul>\n<li>在同一个模块或相关的代码中保持类型的一致性</li>\n<li>避免混合使用有符号和无符号类型</li>\n</ul>\n</li>\n<li><p><strong>文档和注释</strong></p>\n<ul>\n<li>在可能发生类型转换的地方添加清晰的注释</li>\n<li>记录类型选择的原因和注意事项</li>\n</ul>\n</li>\n<li><p><strong>单元测试</strong></p>\n<ul>\n<li>编写测试用例覆盖边界条件</li>\n<li>特别注意类型转换可能发生的场景</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>类型转换的陷阱虽然看似简单，但在实际开发中经常会造成难以发现的bug。通过：</p>\n<ul>\n<li>理解类型转换规则</li>\n<li>采用一致的类型</li>\n<li>使用显式转换</li>\n<li>添加适当的检查</li>\n</ul>\n<p>我们可以有效地避免这类问题。记住，在处理不同整数类型的比较时，宁可多写几行代码，也要确保类型转换的安全性。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li>C++ Standard Library</li>\n<li>Effective C++</li>\n<li>C++ Core Guidelines </li>\n</ul>"},{"layout":"post","title":"CALayer属性positon和anchor","date":"2016-10-26T06:24:18.000Z","_content":"\n\n\n### CALayer 的frame，bounds, position和anchor\n\nframe描述的是在父layer上的坐标和尺寸\n\nbounds是类似于View的bounds\n\nanchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）\n\nposition描述的是anchor的在父layer的坐标\n\n\n\n举例来说，一个View的Frame是（40，40，100，100）\n\n那么layer的frame是（40，40，100，100）\n\nbound是（0，0，100，100）\n\nposition是：（140，140）\n\nposition计算：\n\npos.x = origin.x + anchor.x*size.with\n\npos.y = origin.y + anchor.y*size.height\n\n\n如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化\n\n如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可\n\n    CGRect oldFrame = _redView.frame;\n    _redView.layer.anchorPoint = CGPointMake(0.5, 1);\n    _redView.frame = oldFrame;\n注意，position并不适用这一点","source":"_posts/CALayer属性positon和anchor.md","raw":"---\nlayout: post\ntitle: CALayer属性positon和anchor\ndate: 2016-10-26 14:24:18\ntags: iOS\n---\n\n\n\n### CALayer 的frame，bounds, position和anchor\n\nframe描述的是在父layer上的坐标和尺寸\n\nbounds是类似于View的bounds\n\nanchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）\n\nposition描述的是anchor的在父layer的坐标\n\n\n\n举例来说，一个View的Frame是（40，40，100，100）\n\n那么layer的frame是（40，40，100，100）\n\nbound是（0，0，100，100）\n\nposition是：（140，140）\n\nposition计算：\n\npos.x = origin.x + anchor.x*size.with\n\npos.y = origin.y + anchor.y*size.height\n\n\n如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化\n\n如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可\n\n    CGRect oldFrame = _redView.frame;\n    _redView.layer.anchorPoint = CGPointMake(0.5, 1);\n    _redView.frame = oldFrame;\n注意，position并不适用这一点","slug":"CALayer属性positon和anchor","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8c000i1xcocjjuebc0","content":"<h3 id=\"CALayer-的frame，bounds-position和anchor\"><a href=\"#CALayer-的frame，bounds-position和anchor\" class=\"headerlink\" title=\"CALayer 的frame，bounds, position和anchor\"></a>CALayer 的frame，bounds, position和anchor</h3><span id=\"more\"></span>\n\n<p>frame描述的是在父layer上的坐标和尺寸</p>\n<p>bounds是类似于View的bounds</p>\n<p>anchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）</p>\n<p>position描述的是anchor的在父layer的坐标</p>\n<p>举例来说，一个View的Frame是（40，40，100，100）</p>\n<p>那么layer的frame是（40，40，100，100）</p>\n<p>bound是（0，0，100，100）</p>\n<p>position是：（140，140）</p>\n<p>position计算：</p>\n<p>pos.x = origin.x + anchor.x*size.with</p>\n<p>pos.y = origin.y + anchor.y*size.height</p>\n<p>如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化</p>\n<p>如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可</p>\n<pre><code>CGRect oldFrame = _redView.frame;\n_redView.layer.anchorPoint = CGPointMake(0.5, 1);\n_redView.frame = oldFrame;\n</code></pre>\n<p>注意，position并不适用这一点</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"CALayer-的frame，bounds-position和anchor\"><a href=\"#CALayer-的frame，bounds-position和anchor\" class=\"headerlink\" title=\"CALayer 的frame，bounds, position和anchor\"></a>CALayer 的frame，bounds, position和anchor</h3>","more":"<p>frame描述的是在父layer上的坐标和尺寸</p>\n<p>bounds是类似于View的bounds</p>\n<p>anchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）</p>\n<p>position描述的是anchor的在父layer的坐标</p>\n<p>举例来说，一个View的Frame是（40，40，100，100）</p>\n<p>那么layer的frame是（40，40，100，100）</p>\n<p>bound是（0，0，100，100）</p>\n<p>position是：（140，140）</p>\n<p>position计算：</p>\n<p>pos.x = origin.x + anchor.x*size.with</p>\n<p>pos.y = origin.y + anchor.y*size.height</p>\n<p>如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化</p>\n<p>如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可</p>\n<pre><code>CGRect oldFrame = _redView.frame;\n_redView.layer.anchorPoint = CGPointMake(0.5, 1);\n_redView.frame = oldFrame;\n</code></pre>\n<p>注意，position并不适用这一点</p>"},{"layout":"post","title":"怎么build apple watch app","date":"2016-10-26T06:24:18.000Z","_content":"\n### step1\n\n在IphoneCom 的Embedded Binaries中添加Watch.app\n\n### step2\n\nRun IphoneCom\n\n### Step3\n\nrun WachApp\n","source":"_posts/How to build Apple Watch App.md","raw":"---\nlayout: post\ntitle: 怎么build apple watch app\ndate: 2016-10-26 14:24:18\ntags: iOS\n---\n\n### step1\n\n在IphoneCom 的Embedded Binaries中添加Watch.app\n\n### step2\n\nRun IphoneCom\n\n### Step3\n\nrun WachApp\n","slug":"How to build Apple Watch App","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8c000l1xco7qe4er45","content":"<h3 id=\"step1\"><a href=\"#step1\" class=\"headerlink\" title=\"step1\"></a>step1</h3><p>在IphoneCom 的Embedded Binaries中添加Watch.app</p>\n<h3 id=\"step2\"><a href=\"#step2\" class=\"headerlink\" title=\"step2\"></a>step2</h3><p>Run IphoneCom</p>\n<h3 id=\"Step3\"><a href=\"#Step3\" class=\"headerlink\" title=\"Step3\"></a>Step3</h3><p>run WachApp</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"step1\"><a href=\"#step1\" class=\"headerlink\" title=\"step1\"></a>step1</h3><p>在IphoneCom 的Embedded Binaries中添加Watch.app</p>\n<h3 id=\"step2\"><a href=\"#step2\" class=\"headerlink\" title=\"step2\"></a>step2</h3><p>Run IphoneCom</p>\n<h3 id=\"Step3\"><a href=\"#Step3\" class=\"headerlink\" title=\"Step3\"></a>Step3</h3><p>run WachApp</p>\n"},{"layout":"post","title":"iOSCALayer的presentLayer那点事","subtitle":"关于PresentLayer","date":"2017-11-11T16:00:00.000Z","author":"jack","header-img":"img/post-bg-ios9-web.jpg","catalog":true,"_content":"\n\n> 最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决\n\n\n\n### 动画过程中，如何获取它的实时位置\n\n这个话题涉及对CALayer的理解和使用\n\nCALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer\n\n\n\n- modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据\n- presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试\n\n\n\n```\nUIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];\n\n    view.backgroundColor = [UIColor redColor];\n\n    [self.view addSubview:view];\n\n    NSLog(@\"model   Layeer = %@\", NSStringFromCGRect([view.layer modelLayer].frame));\n\n    NSLog(@\"present Layeer = %@\", NSStringFromCGRect([view.layer presentationLayer].frame));\n\n    [UIView animateWithDuration:10 animations:^{\n\n        view.frame = CGRectMake(200, 100, 100, 100);\n        \n    } completion:^(BOOL finished) {\n    }];\n\n    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n    \n        NSLog(@\"model   Layeer = %@\", NSStringFromCGRect([view.layer modelLayer].frame));\n        NSLog(@\"present Layeer = %@\", NSStringFromCGRect([view.layer presentationLayer].frame));\n    }];\n\n```\n\n\n\n通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置\n","source":"_posts/CALayer的presentLayer那点事.md","raw":"---\nlayout:     post\ntitle:      iOSCALayer的presentLayer那点事\nsubtitle:   关于PresentLayer\ndate:       2017-11-12\nauthor:     jack\nheader-img: img/post-bg-ios9-web.jpg\ncatalog: true\ntags:\n    - iOS\n---\n\n\n> 最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决\n\n\n\n### 动画过程中，如何获取它的实时位置\n\n这个话题涉及对CALayer的理解和使用\n\nCALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer\n\n\n\n- modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据\n- presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试\n\n\n\n```\nUIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];\n\n    view.backgroundColor = [UIColor redColor];\n\n    [self.view addSubview:view];\n\n    NSLog(@\"model   Layeer = %@\", NSStringFromCGRect([view.layer modelLayer].frame));\n\n    NSLog(@\"present Layeer = %@\", NSStringFromCGRect([view.layer presentationLayer].frame));\n\n    [UIView animateWithDuration:10 animations:^{\n\n        view.frame = CGRectMake(200, 100, 100, 100);\n        \n    } completion:^(BOOL finished) {\n    }];\n\n    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n    \n        NSLog(@\"model   Layeer = %@\", NSStringFromCGRect([view.layer modelLayer].frame));\n        NSLog(@\"present Layeer = %@\", NSStringFromCGRect([view.layer presentationLayer].frame));\n    }];\n\n```\n\n\n\n通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置\n","slug":"CALayer的presentLayer那点事","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8d000o1xcodwug80sc","content":"<blockquote>\n<p>最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决</p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"动画过程中，如何获取它的实时位置\"><a href=\"#动画过程中，如何获取它的实时位置\" class=\"headerlink\" title=\"动画过程中，如何获取它的实时位置\"></a>动画过程中，如何获取它的实时位置</h3><p>这个话题涉及对CALayer的理解和使用</p>\n<p>CALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer</p>\n<ul>\n<li>modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据</li>\n<li>presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class=\"line\"></span><br><span class=\"line\">    view.backgroundColor = [UIColor redColor];</span><br><span class=\"line\"></span><br><span class=\"line\">    [self.view addSubview:view];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class=\"line\"></span><br><span class=\"line\">    [UIView animateWithDuration:10 animations:^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        view.frame = CGRectMake(200, 100, 100, 100);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; completion:^(BOOL finished) &#123;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class=\"line\">        NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决</p>\n</blockquote>","more":"<h3 id=\"动画过程中，如何获取它的实时位置\"><a href=\"#动画过程中，如何获取它的实时位置\" class=\"headerlink\" title=\"动画过程中，如何获取它的实时位置\"></a>动画过程中，如何获取它的实时位置</h3><p>这个话题涉及对CALayer的理解和使用</p>\n<p>CALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer</p>\n<ul>\n<li>modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据</li>\n<li>presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class=\"line\"></span><br><span class=\"line\">    view.backgroundColor = [UIColor redColor];</span><br><span class=\"line\"></span><br><span class=\"line\">    [self.view addSubview:view];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class=\"line\"></span><br><span class=\"line\">    [UIView animateWithDuration:10 animations:^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        view.frame = CGRectMake(200, 100, 100, 100);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; completion:^(BOOL finished) &#123;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class=\"line\">        NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置</p>"},{"layout":"post","title":"Mac环境下安装Ruby","subtitle":"ruby2.2","date":"2017-09-18T16:00:00.000Z","author":"jack","catalog":true,"_content":"\n## 使用rvm来安装ruby\n\n### step1\n```\n\t$ curl -L get.rvm.io | bash -s stable  \n```\n### step2  \n```\n\t$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  \n\t$ source ~/.bash_profile  \n\t$ rvm -v  \n```\t\n### step3  \n```\t\n\t$ rvm list known  \n```\t\n### step4\n```    \n\t$ rvm install 2.2.0  \n```\n\n### 如果Step4失败，可以进行如下尝试\n```\n\tsudo chown -R $(whoami):admin /usr/local\n\tcd /usr/local\n\tgit remote set-url origin git://mirrors.ustc.edu.cn/brew.git\n\tbrew update\n\tsudo chown root:wheel /usr/local\n\trvm install 2.2.0\n```\n","source":"_posts/MacOS下ruby安装.md","raw":"---\nlayout:     post\ntitle:      Mac环境下安装Ruby\nsubtitle:   ruby2.2\ndate:       2017-09-19\nauthor:     jack\ncatalog: true\ntags:\n    - iOS\n    - ruby\n---\n\n## 使用rvm来安装ruby\n\n### step1\n```\n\t$ curl -L get.rvm.io | bash -s stable  \n```\n### step2  \n```\n\t$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  \n\t$ source ~/.bash_profile  \n\t$ rvm -v  \n```\t\n### step3  \n```\t\n\t$ rvm list known  \n```\t\n### step4\n```    \n\t$ rvm install 2.2.0  \n```\n\n### 如果Step4失败，可以进行如下尝试\n```\n\tsudo chown -R $(whoami):admin /usr/local\n\tcd /usr/local\n\tgit remote set-url origin git://mirrors.ustc.edu.cn/brew.git\n\tbrew update\n\tsudo chown root:wheel /usr/local\n\trvm install 2.2.0\n```\n","slug":"MacOS下ruby安装","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8d000p1xco4tjo1o5h","content":"<h2 id=\"使用rvm来安装ruby\"><a href=\"#使用rvm来安装ruby\" class=\"headerlink\" title=\"使用rvm来安装ruby\"></a>使用rvm来安装ruby</h2><h3 id=\"step1\"><a href=\"#step1\" class=\"headerlink\" title=\"step1\"></a>step1</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -L get.rvm.io | bash -s stable  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step2\"><a href=\"#step2\" class=\"headerlink\" title=\"step2\"></a>step2</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  </span><br><span class=\"line\">$ source ~/.bash_profile  </span><br><span class=\"line\">$ rvm -v  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step3\"><a href=\"#step3\" class=\"headerlink\" title=\"step3\"></a>step3</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rvm list known  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step4\"><a href=\"#step4\" class=\"headerlink\" title=\"step4\"></a>step4</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rvm install 2.2.0  </span><br></pre></td></tr></table></figure>\n\n\n\n<span id=\"more\"></span>\n\n<h3 id=\"如果Step4失败，可以进行如下尝试\"><a href=\"#如果Step4失败，可以进行如下尝试\" class=\"headerlink\" title=\"如果Step4失败，可以进行如下尝试\"></a>如果Step4失败，可以进行如下尝试</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown -R $(whoami):admin /usr/local</span><br><span class=\"line\">cd /usr/local</span><br><span class=\"line\">git remote set-url origin git://mirrors.ustc.edu.cn/brew.git</span><br><span class=\"line\">brew update</span><br><span class=\"line\">sudo chown root:wheel /usr/local</span><br><span class=\"line\">rvm install 2.2.0</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"使用rvm来安装ruby\"><a href=\"#使用rvm来安装ruby\" class=\"headerlink\" title=\"使用rvm来安装ruby\"></a>使用rvm来安装ruby</h2><h3 id=\"step1\"><a href=\"#step1\" class=\"headerlink\" title=\"step1\"></a>step1</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -L get.rvm.io | bash -s stable  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step2\"><a href=\"#step2\" class=\"headerlink\" title=\"step2\"></a>step2</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  </span><br><span class=\"line\">$ source ~/.bash_profile  </span><br><span class=\"line\">$ rvm -v  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step3\"><a href=\"#step3\" class=\"headerlink\" title=\"step3\"></a>step3</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rvm list known  </span><br></pre></td></tr></table></figure>\n<h3 id=\"step4\"><a href=\"#step4\" class=\"headerlink\" title=\"step4\"></a>step4</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rvm install 2.2.0  </span><br></pre></td></tr></table></figure>","more":"<h3 id=\"如果Step4失败，可以进行如下尝试\"><a href=\"#如果Step4失败，可以进行如下尝试\" class=\"headerlink\" title=\"如果Step4失败，可以进行如下尝试\"></a>如果Step4失败，可以进行如下尝试</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown -R $(whoami):admin /usr/local</span><br><span class=\"line\">cd /usr/local</span><br><span class=\"line\">git remote set-url origin git://mirrors.ustc.edu.cn/brew.git</span><br><span class=\"line\">brew update</span><br><span class=\"line\">sudo chown root:wheel /usr/local</span><br><span class=\"line\">rvm install 2.2.0</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"VBO","date":"2017-01-02T05:19:23.000Z","_content":"\n### VBO的目的：\n\n主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间\n\n两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER\n\n分别对应顶点数据和索引\n\n使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量\n\n### VBO使用的大概流程：\n\n```\n    //获取一个操作句柄\n    glGenBuffers(1, &_vertexBuffer);\n    //设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引\n    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);\n    //分配内存空间\n    glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);\n    \n    在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别\n    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);\n    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);\n    glEnableVertexAttribArray(_positionSlot);\n    \n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);\n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);\n    \n    //可以在清理时，释放VBO\n    glDeleteBuffers(1, &_vertexBuffer);\n    _vertexBuffer = 0;\n    \n    glDeleteBuffers(1, &_triangleIndexBuffer);\n    _triangleIndexBuffer = 0;\n    \n```\n\n","source":"_posts/OpenGL-VBO.md","raw":"---\nlayout: post\ntitle: VBO\ndate: 2017-01-02 13:19:23\ntags: openGL\n---\n\n### VBO的目的：\n\n主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间\n\n两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER\n\n分别对应顶点数据和索引\n\n使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量\n\n### VBO使用的大概流程：\n\n```\n    //获取一个操作句柄\n    glGenBuffers(1, &_vertexBuffer);\n    //设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引\n    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);\n    //分配内存空间\n    glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);\n    \n    在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别\n    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);\n    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);\n    glEnableVertexAttribArray(_positionSlot);\n    \n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);\n    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);\n    \n    //可以在清理时，释放VBO\n    glDeleteBuffers(1, &_vertexBuffer);\n    _vertexBuffer = 0;\n    \n    glDeleteBuffers(1, &_triangleIndexBuffer);\n    _triangleIndexBuffer = 0;\n    \n```\n\n","slug":"OpenGL-VBO","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8d000s1xcodbay8bm5","content":"<h3 id=\"VBO的目的：\"><a href=\"#VBO的目的：\" class=\"headerlink\" title=\"VBO的目的：\"></a>VBO的目的：</h3><p>主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间</p>\n<span id=\"more\"></span>\n\n<p>两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER</p>\n<p>分别对应顶点数据和索引</p>\n<p>使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量</p>\n<h3 id=\"VBO使用的大概流程：\"><a href=\"#VBO使用的大概流程：\" class=\"headerlink\" title=\"VBO使用的大概流程：\"></a>VBO使用的大概流程：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取一个操作句柄</span><br><span class=\"line\">glGenBuffers(1, &amp;_vertexBuffer);</span><br><span class=\"line\">//设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class=\"line\">//分配内存空间</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class=\"line\">glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);</span><br><span class=\"line\">glEnableVertexAttribArray(_positionSlot);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//可以在清理时，释放VBO</span><br><span class=\"line\">glDeleteBuffers(1, &amp;_vertexBuffer);</span><br><span class=\"line\">_vertexBuffer = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">glDeleteBuffers(1, &amp;_triangleIndexBuffer);</span><br><span class=\"line\">_triangleIndexBuffer = 0;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"VBO的目的：\"><a href=\"#VBO的目的：\" class=\"headerlink\" title=\"VBO的目的：\"></a>VBO的目的：</h3><p>主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间</p>","more":"<p>两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER</p>\n<p>分别对应顶点数据和索引</p>\n<p>使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量</p>\n<h3 id=\"VBO使用的大概流程：\"><a href=\"#VBO使用的大概流程：\" class=\"headerlink\" title=\"VBO使用的大概流程：\"></a>VBO使用的大概流程：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取一个操作句柄</span><br><span class=\"line\">glGenBuffers(1, &amp;_vertexBuffer);</span><br><span class=\"line\">//设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class=\"line\">//分配内存空间</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class=\"line\">glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);</span><br><span class=\"line\">glEnableVertexAttribArray(_positionSlot);</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//可以在清理时，释放VBO</span><br><span class=\"line\">glDeleteBuffers(1, &amp;_vertexBuffer);</span><br><span class=\"line\">_vertexBuffer = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">glDeleteBuffers(1, &amp;_triangleIndexBuffer);</span><br><span class=\"line\">_triangleIndexBuffer = 0;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"uniform和attribute区别","date":"2016-12-30T08:17:50.000Z","_content":"\n#### 简单对比一下\n\nattribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用\n\nuniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用\n\n\n\n使用上的区别：\n\n1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法\n\n2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制\n\n3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements\n\n","source":"_posts/OpenGL-uniform和attribute.md","raw":"---\nlayout: post\ntitle: uniform和attribute区别\ndate: 2016-12-30 16:17:50\ntags: openGL\n---\n\n#### 简单对比一下\n\nattribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用\n\nuniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用\n\n\n\n使用上的区别：\n\n1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法\n\n2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制\n\n3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements\n\n","slug":"OpenGL-uniform和attribute","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8d000u1xcog582f3ip","content":"<h4 id=\"简单对比一下\"><a href=\"#简单对比一下\" class=\"headerlink\" title=\"简单对比一下\"></a>简单对比一下</h4><p>attribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用</p>\n<span id=\"more\"></span>\n\n<p>uniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用</p>\n<p>使用上的区别：</p>\n<p>1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法</p>\n<p>2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制</p>\n<p>3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"简单对比一下\"><a href=\"#简单对比一下\" class=\"headerlink\" title=\"简单对比一下\"></a>简单对比一下</h4><p>attribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用</p>","more":"<p>uniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用</p>\n<p>使用上的区别：</p>\n<p>1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法</p>\n<p>2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制</p>\n<p>3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements</p>"},{"layout":"post","title":"光照学习","date":"2017-01-02T05:43:54.000Z","_content":"\n### 基本概念\n\n1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性\n\n2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）\n\n3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射\n\n4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节\n\n\n\n### 光的计算：\n\n1 发射光计算：发射颜色=物体的发射材质颜色\n\n2 环境光计算\n\n环境颜色 = 光源的环境光颜色*物体的环境材质颜色\n\n3 漫反射计算：\n\n漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor\n\n其中DiffuseFactor = max（0，dot（N，L））\n\ndot表示两个向量夹角的cos\n\n4 镜面反射：\n\n镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor\n\nSpecularFactor = power（max（0， dot（N，H）），shininess）\n\nH = normalise（L+E）\n\n","source":"_posts/OpenGL-光照学习.md","raw":"---\nlayout: post\ntitle: 光照学习\ndate: 2017-01-02 13:43:54\ntags: openGL\n---\n\n### 基本概念\n\n1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性\n\n2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）\n\n3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射\n\n4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节\n\n\n\n### 光的计算：\n\n1 发射光计算：发射颜色=物体的发射材质颜色\n\n2 环境光计算\n\n环境颜色 = 光源的环境光颜色*物体的环境材质颜色\n\n3 漫反射计算：\n\n漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor\n\n其中DiffuseFactor = max（0，dot（N，L））\n\ndot表示两个向量夹角的cos\n\n4 镜面反射：\n\n镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor\n\nSpecularFactor = power（max（0， dot（N，H）），shininess）\n\nH = normalise（L+E）\n\n","slug":"OpenGL-光照学习","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8e000x1xco28iu75za","content":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性</p>\n<span id=\"more\"></span>\n\n<p>2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）</p>\n<p>3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射</p>\n<p>4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节</p>\n<h3 id=\"光的计算：\"><a href=\"#光的计算：\" class=\"headerlink\" title=\"光的计算：\"></a>光的计算：</h3><p>1 发射光计算：发射颜色=物体的发射材质颜色</p>\n<p>2 环境光计算</p>\n<p>环境颜色 = 光源的环境光颜色*物体的环境材质颜色</p>\n<p>3 漫反射计算：</p>\n<p>漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor</p>\n<p>其中DiffuseFactor = max（0，dot（N，L））</p>\n<p>dot表示两个向量夹角的cos</p>\n<p>4 镜面反射：</p>\n<p>镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor</p>\n<p>SpecularFactor = power（max（0， dot（N，H）），shininess）</p>\n<p>H = normalise（L+E）</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性</p>","more":"<p>2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）</p>\n<p>3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射</p>\n<p>4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节</p>\n<h3 id=\"光的计算：\"><a href=\"#光的计算：\" class=\"headerlink\" title=\"光的计算：\"></a>光的计算：</h3><p>1 发射光计算：发射颜色=物体的发射材质颜色</p>\n<p>2 环境光计算</p>\n<p>环境颜色 = 光源的环境光颜色*物体的环境材质颜色</p>\n<p>3 漫反射计算：</p>\n<p>漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor</p>\n<p>其中DiffuseFactor = max（0，dot（N，L））</p>\n<p>dot表示两个向量夹角的cos</p>\n<p>4 镜面反射：</p>\n<p>镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor</p>\n<p>SpecularFactor = power（max（0， dot（N，H）），shininess）</p>\n<p>H = normalise（L+E）</p>"},{"layout":"post","title":"opengl iOS创建OpenGL环境绘制一个简单三角形","date":"2016-12-30T07:42:35.000Z","_content":"\n### EAGLView创建要点\n\n1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性\n\n```\n- (void)setupLayer{\n\n    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;\n    \n    layer.opaque = YES;\n    \n    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,\n                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];\n}\n```\n\n2  创建EAGLContext\n\n```\n_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];\n```\n\n3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：\n\na获取着色器源文件，创建shader，编译\n\nb创建program，attachShader，link，useProgram\n\nc从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)\n\n这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext\n\n4 每一帧绘制流程\n\n在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是\n\n```\n- (void)drawFrame{\n\n    [_eaglView setFramebuffer];\n    \n    [_eaglView draw];\n    \n    [_eaglView presentFramebuffer];\n}\n```\n\n5 关于frameBuffetObject的创建和释放\n\n前提：context确保设置\n\n流程大致是\n\n```\n- (void)createBuffer{\n    \n    [self checkContext];\n    \n    glGenRenderbuffers(1, &_colorRenderBuffer);\n    \n    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);\n    \n    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];\n    \n    glGenFramebuffers(1, &_frameBuffer);\n    \n    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);\n    \n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,\n    \t\t\t\t\t\tGL_RENDERBUFFER, _colorRenderBuffer);\n}\n\n- (void)deleteBuffer{\n\n    [self checkContext];\n    \n    glDeleteRenderbuffers(1, &_colorRenderBuffer);\n    \n    _colorRenderBuffer = 0;\n    \n    glDeleteFramebuffers(1, &_frameBuffer);\n    \n    _frameBuffer = 0;\n}\n\n- (void)setFramebuffer\n{\n    if ([self checkContext])\n    {\n        if (!_frameBuffer){\n            [self createBuffer];\n        }\n        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);\n    }\n}\n\n- (BOOL)presentFramebuffer\n{\n    BOOL success = FALSE;\n    \n    if ([self checkContext])\n    {\n        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);\n        \n        success = [_context presentRenderbuffer:GL_RENDERBUFFER];\n    }\n    return success;\n}\n```\n\n6 关于绘制三角形\n\n```\n- (void)draw{\n    //设置背景颜色为绿色\n    glClearColor(0, 1.0, 0,1.0);\n    glClear(GL_COLOR_BUFFER_BIT);\n    //设置管区域大小\n    glViewport(0, 0, self.frame.size.width, self.frame.size.height);\n    \n    GLfloat vertices[] = {\n        0.0f,  0.5f, 0.0f,\n        -0.5f, -0.5f, 0.0f,\n        0.5f,  -0.5f, 0.0f };\n    //设置着色器中的vPositon\n    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);\n    //使上一步的设置生效\n    glEnableVertexAttribArray(_positionSlot);\n    //绘制三角形\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n}\n```\n","source":"_posts/OpenGL-基本框架搭建和绘制一个简单图形.md","raw":"---\nlayout: post\ntitle: opengl iOS创建OpenGL环境绘制一个简单三角形\ndate: 2016-12-30 15:42:35\ntags: \n    - openGL \n    - iOS\n---\n\n### EAGLView创建要点\n\n1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性\n\n```\n- (void)setupLayer{\n\n    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;\n    \n    layer.opaque = YES;\n    \n    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,\n                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];\n}\n```\n\n2  创建EAGLContext\n\n```\n_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];\n```\n\n3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：\n\na获取着色器源文件，创建shader，编译\n\nb创建program，attachShader，link，useProgram\n\nc从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)\n\n这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext\n\n4 每一帧绘制流程\n\n在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是\n\n```\n- (void)drawFrame{\n\n    [_eaglView setFramebuffer];\n    \n    [_eaglView draw];\n    \n    [_eaglView presentFramebuffer];\n}\n```\n\n5 关于frameBuffetObject的创建和释放\n\n前提：context确保设置\n\n流程大致是\n\n```\n- (void)createBuffer{\n    \n    [self checkContext];\n    \n    glGenRenderbuffers(1, &_colorRenderBuffer);\n    \n    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);\n    \n    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];\n    \n    glGenFramebuffers(1, &_frameBuffer);\n    \n    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);\n    \n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,\n    \t\t\t\t\t\tGL_RENDERBUFFER, _colorRenderBuffer);\n}\n\n- (void)deleteBuffer{\n\n    [self checkContext];\n    \n    glDeleteRenderbuffers(1, &_colorRenderBuffer);\n    \n    _colorRenderBuffer = 0;\n    \n    glDeleteFramebuffers(1, &_frameBuffer);\n    \n    _frameBuffer = 0;\n}\n\n- (void)setFramebuffer\n{\n    if ([self checkContext])\n    {\n        if (!_frameBuffer){\n            [self createBuffer];\n        }\n        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);\n    }\n}\n\n- (BOOL)presentFramebuffer\n{\n    BOOL success = FALSE;\n    \n    if ([self checkContext])\n    {\n        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);\n        \n        success = [_context presentRenderbuffer:GL_RENDERBUFFER];\n    }\n    return success;\n}\n```\n\n6 关于绘制三角形\n\n```\n- (void)draw{\n    //设置背景颜色为绿色\n    glClearColor(0, 1.0, 0,1.0);\n    glClear(GL_COLOR_BUFFER_BIT);\n    //设置管区域大小\n    glViewport(0, 0, self.frame.size.width, self.frame.size.height);\n    \n    GLfloat vertices[] = {\n        0.0f,  0.5f, 0.0f,\n        -0.5f, -0.5f, 0.0f,\n        0.5f,  -0.5f, 0.0f };\n    //设置着色器中的vPositon\n    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);\n    //使上一步的设置生效\n    glEnableVertexAttribArray(_positionSlot);\n    //绘制三角形\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n}\n```\n","slug":"OpenGL-基本框架搭建和绘制一个简单图形","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8e000y1xco25oa8bxh","content":"<h3 id=\"EAGLView创建要点\"><a href=\"#EAGLView创建要点\" class=\"headerlink\" title=\"EAGLView创建要点\"></a>EAGLView创建要点</h3><p>1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setupLayer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    layer.opaque = YES;</span><br><span class=\"line\">    </span><br><span class=\"line\">    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,</span><br><span class=\"line\">                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2  创建EAGLContext</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br></pre></td></tr></table></figure>\n\n<p>3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：</p>\n<p>a获取着色器源文件，创建shader，编译</p>\n<p>b创建program，attachShader，link，useProgram</p>\n<p>c从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)</p>\n<p>这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext</p>\n<p>4 每一帧绘制流程</p>\n<p>在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)drawFrame&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [_eaglView setFramebuffer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_eaglView draw];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_eaglView presentFramebuffer];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5 关于frameBuffetObject的创建和释放</p>\n<p>前提：context确保设置</p>\n<p>流程大致是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)createBuffer&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self checkContext];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenFramebuffers(1, &amp;_frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class=\"line\">    \t\t\t\t\t\tGL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)deleteBuffer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [self checkContext];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDeleteRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    _colorRenderBuffer = 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDeleteFramebuffers(1, &amp;_frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    _frameBuffer = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setFramebuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if ([self checkContext])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (!_frameBuffer)&#123;</span><br><span class=\"line\">            [self createBuffer];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)presentFramebuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BOOL success = FALSE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if ([self checkContext])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">        </span><br><span class=\"line\">        success = [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return success;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6 关于绘制三角形</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)draw&#123;</span><br><span class=\"line\">    //设置背景颜色为绿色</span><br><span class=\"line\">    glClearColor(0, 1.0, 0,1.0);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    //设置管区域大小</span><br><span class=\"line\">    glViewport(0, 0, self.frame.size.width, self.frame.size.height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        0.0f,  0.5f, 0.0f,</span><br><span class=\"line\">        -0.5f, -0.5f, 0.0f,</span><br><span class=\"line\">        0.5f,  -0.5f, 0.0f &#125;;</span><br><span class=\"line\">    //设置着色器中的vPositon</span><br><span class=\"line\">    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);</span><br><span class=\"line\">    //使上一步的设置生效</span><br><span class=\"line\">    glEnableVertexAttribArray(_positionSlot);</span><br><span class=\"line\">    //绘制三角形</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"EAGLView创建要点\"><a href=\"#EAGLView创建要点\" class=\"headerlink\" title=\"EAGLView创建要点\"></a>EAGLView创建要点</h3><p>1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性</p>","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setupLayer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    layer.opaque = YES;</span><br><span class=\"line\">    </span><br><span class=\"line\">    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,</span><br><span class=\"line\">                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2  创建EAGLContext</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br></pre></td></tr></table></figure>\n\n<p>3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：</p>\n<p>a获取着色器源文件，创建shader，编译</p>\n<p>b创建program，attachShader，link，useProgram</p>\n<p>c从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)</p>\n<p>这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext</p>\n<p>4 每一帧绘制流程</p>\n<p>在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)drawFrame&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [_eaglView setFramebuffer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_eaglView draw];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_eaglView presentFramebuffer];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5 关于frameBuffetObject的创建和释放</p>\n<p>前提：context确保设置</p>\n<p>流程大致是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)createBuffer&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self checkContext];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glGenFramebuffers(1, &amp;_frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class=\"line\">    \t\t\t\t\t\tGL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)deleteBuffer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [self checkContext];</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDeleteRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    _colorRenderBuffer = 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glDeleteFramebuffers(1, &amp;_frameBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    _frameBuffer = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setFramebuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if ([self checkContext])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (!_frameBuffer)&#123;</span><br><span class=\"line\">            [self createBuffer];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)presentFramebuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BOOL success = FALSE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if ([self checkContext])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class=\"line\">        </span><br><span class=\"line\">        success = [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return success;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6 关于绘制三角形</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)draw&#123;</span><br><span class=\"line\">    //设置背景颜色为绿色</span><br><span class=\"line\">    glClearColor(0, 1.0, 0,1.0);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    //设置管区域大小</span><br><span class=\"line\">    glViewport(0, 0, self.frame.size.width, self.frame.size.height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLfloat vertices[] = &#123;</span><br><span class=\"line\">        0.0f,  0.5f, 0.0f,</span><br><span class=\"line\">        -0.5f, -0.5f, 0.0f,</span><br><span class=\"line\">        0.5f,  -0.5f, 0.0f &#125;;</span><br><span class=\"line\">    //设置着色器中的vPositon</span><br><span class=\"line\">    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);</span><br><span class=\"line\">    //使上一步的设置生效</span><br><span class=\"line\">    glEnableVertexAttribArray(_positionSlot);</span><br><span class=\"line\">    //绘制三角形</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"纹理贴图","date":"2017-01-03T03:11:26.000Z","_content":"\n1 VertexShader\n\n```\nattribute vec2 TexCoordIn; // New\nvarying vec2 TexCoordOut; // New\n\nvoid main(void) { \n    DestinationColor = SourceColor; \n    gl_Position = Projection * Modelview * Position;\n    TexCoordOut = TexCoordIn; // New\n}\n```\n\n2 FragmentShader\n\n```\nvarying lowp vec4 DestinationColor;\nvarying lowp vec2 TexCoordOut; // New\nuniform sampler2D Texture; // New\n\nvoid main(void) {\n    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New\n}\n```\n\n3 将图片资源转换成位图数据，绑定到对应纹理ID中\n\n```\n+ (GLuint)createTextureWithImage:(UIImage *)image{\n    \n    //转换为CGImage，获取图片基本参数\n    CGImageRef cgImageRef = [image CGImage];\n    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);\n    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);\n    CGRect rect = CGRectMake(0, 0, width, height);\n    \n    //绘制图片\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    void *imageData = malloc(width * height * 4);\n    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);\n    CGContextTranslateCTM(context, 0, height);\n    CGContextScaleCTM(context, 1.0f, -1.0f);\n    CGColorSpaceRelease(colorSpace);\n    CGContextClearRect(context, rect);\n    CGContextDrawImage(context, rect, cgImageRef);\n    \n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_2D, textureID);\n    \n    //纹理一些设置，可有可无\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    \n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);\n    \n    glBindTexture(GL_TEXTURE_2D, 0);\n    \n    //释放内存\n    CGContextRelease(context);\n    free(imageData);\n    \n    return textureID;\n}\n```\n\n4 绘制时使用纹理\n\n```\n    glActiveTexture(GL_TEXTURE0);\n    //载入纹理\n    glBindTexture(GL_TEXTURE_2D, _textTureId);\n\n    glUniform1i(_textureSlot, 0);\n    \n    const GLfloat texCoords[] = {\n        0, 0,//左下\n        1, 0,//右下\n        0, 1,//左上\n        1, 1,//右上\n    };\n    glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);\n    glEnableVertexAttribArray(_textureCoordsSlot);\n```\n\n5 关于纹理坐标\n","source":"_posts/OpenGL-纹理贴图.md","raw":"---\nlayout: post\ntitle: 纹理贴图\ndate: 2017-01-03 11:11:26\ntags: openGL\n---\n\n1 VertexShader\n\n```\nattribute vec2 TexCoordIn; // New\nvarying vec2 TexCoordOut; // New\n\nvoid main(void) { \n    DestinationColor = SourceColor; \n    gl_Position = Projection * Modelview * Position;\n    TexCoordOut = TexCoordIn; // New\n}\n```\n\n2 FragmentShader\n\n```\nvarying lowp vec4 DestinationColor;\nvarying lowp vec2 TexCoordOut; // New\nuniform sampler2D Texture; // New\n\nvoid main(void) {\n    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New\n}\n```\n\n3 将图片资源转换成位图数据，绑定到对应纹理ID中\n\n```\n+ (GLuint)createTextureWithImage:(UIImage *)image{\n    \n    //转换为CGImage，获取图片基本参数\n    CGImageRef cgImageRef = [image CGImage];\n    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);\n    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);\n    CGRect rect = CGRectMake(0, 0, width, height);\n    \n    //绘制图片\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    void *imageData = malloc(width * height * 4);\n    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);\n    CGContextTranslateCTM(context, 0, height);\n    CGContextScaleCTM(context, 1.0f, -1.0f);\n    CGColorSpaceRelease(colorSpace);\n    CGContextClearRect(context, rect);\n    CGContextDrawImage(context, rect, cgImageRef);\n    \n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_2D, textureID);\n    \n    //纹理一些设置，可有可无\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    \n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);\n    \n    glBindTexture(GL_TEXTURE_2D, 0);\n    \n    //释放内存\n    CGContextRelease(context);\n    free(imageData);\n    \n    return textureID;\n}\n```\n\n4 绘制时使用纹理\n\n```\n    glActiveTexture(GL_TEXTURE0);\n    //载入纹理\n    glBindTexture(GL_TEXTURE_2D, _textTureId);\n\n    glUniform1i(_textureSlot, 0);\n    \n    const GLfloat texCoords[] = {\n        0, 0,//左下\n        1, 0,//右下\n        0, 1,//左上\n        1, 1,//右上\n    };\n    glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);\n    glEnableVertexAttribArray(_textureCoordsSlot);\n```\n\n5 关于纹理坐标\n","slug":"OpenGL-纹理贴图","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8e00101xcoek332mgo","content":"<p>1 VertexShader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attribute vec2 TexCoordIn; // New</span><br><span class=\"line\">varying vec2 TexCoordOut; // New</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123; </span><br><span class=\"line\">    DestinationColor = SourceColor; </span><br><span class=\"line\">    gl_Position = Projection * Modelview * Position;</span><br><span class=\"line\">    TexCoordOut = TexCoordIn; // New</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<span id=\"more\"></span>\n\n<p>2 FragmentShader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying lowp vec4 DestinationColor;</span><br><span class=\"line\">varying lowp vec2 TexCoordOut; // New</span><br><span class=\"line\">uniform sampler2D Texture; // New</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123;</span><br><span class=\"line\">    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3 将图片资源转换成位图数据，绑定到对应纹理ID中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (GLuint)createTextureWithImage:(UIImage *)image&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //转换为CGImage，获取图片基本参数</span><br><span class=\"line\">    CGImageRef cgImageRef = [image CGImage];</span><br><span class=\"line\">    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);</span><br><span class=\"line\">    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);</span><br><span class=\"line\">    CGRect rect = CGRectMake(0, 0, width, height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //绘制图片</span><br><span class=\"line\">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class=\"line\">    void *imageData = malloc(width * height * 4);</span><br><span class=\"line\">    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class=\"line\">    CGContextTranslateCTM(context, 0, height);</span><br><span class=\"line\">    CGContextScaleCTM(context, 1.0f, -1.0f);</span><br><span class=\"line\">    CGColorSpaceRelease(colorSpace);</span><br><span class=\"line\">    CGContextClearRect(context, rect);</span><br><span class=\"line\">    CGContextDrawImage(context, rect, cgImageRef);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLuint textureID;</span><br><span class=\"line\">    glGenTextures(1, &amp;textureID);</span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, textureID);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //纹理一些设置，可有可无</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, 0);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //释放内存</span><br><span class=\"line\">    CGContextRelease(context);</span><br><span class=\"line\">    free(imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return textureID;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4 绘制时使用纹理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">//载入纹理</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, _textTureId);</span><br><span class=\"line\"></span><br><span class=\"line\">glUniform1i(_textureSlot, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">const GLfloat texCoords[] = &#123;</span><br><span class=\"line\">    0, 0,//左下</span><br><span class=\"line\">    1, 0,//右下</span><br><span class=\"line\">    0, 1,//左上</span><br><span class=\"line\">    1, 1,//右上</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);</span><br><span class=\"line\">glEnableVertexAttribArray(_textureCoordsSlot);</span><br></pre></td></tr></table></figure>\n\n<p>5 关于纹理坐标</p>\n","site":{"data":{}},"excerpt":"<p>1 VertexShader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attribute vec2 TexCoordIn; // New</span><br><span class=\"line\">varying vec2 TexCoordOut; // New</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123; </span><br><span class=\"line\">    DestinationColor = SourceColor; </span><br><span class=\"line\">    gl_Position = Projection * Modelview * Position;</span><br><span class=\"line\">    TexCoordOut = TexCoordIn; // New</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<p>2 FragmentShader</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying lowp vec4 DestinationColor;</span><br><span class=\"line\">varying lowp vec2 TexCoordOut; // New</span><br><span class=\"line\">uniform sampler2D Texture; // New</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123;</span><br><span class=\"line\">    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3 将图片资源转换成位图数据，绑定到对应纹理ID中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (GLuint)createTextureWithImage:(UIImage *)image&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //转换为CGImage，获取图片基本参数</span><br><span class=\"line\">    CGImageRef cgImageRef = [image CGImage];</span><br><span class=\"line\">    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);</span><br><span class=\"line\">    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);</span><br><span class=\"line\">    CGRect rect = CGRectMake(0, 0, width, height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //绘制图片</span><br><span class=\"line\">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class=\"line\">    void *imageData = malloc(width * height * 4);</span><br><span class=\"line\">    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class=\"line\">    CGContextTranslateCTM(context, 0, height);</span><br><span class=\"line\">    CGContextScaleCTM(context, 1.0f, -1.0f);</span><br><span class=\"line\">    CGColorSpaceRelease(colorSpace);</span><br><span class=\"line\">    CGContextClearRect(context, rect);</span><br><span class=\"line\">    CGContextDrawImage(context, rect, cgImageRef);</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLuint textureID;</span><br><span class=\"line\">    glGenTextures(1, &amp;textureID);</span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, textureID);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //纹理一些设置，可有可无</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, 0);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //释放内存</span><br><span class=\"line\">    CGContextRelease(context);</span><br><span class=\"line\">    free(imageData);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return textureID;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4 绘制时使用纹理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">//载入纹理</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, _textTureId);</span><br><span class=\"line\"></span><br><span class=\"line\">glUniform1i(_textureSlot, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">const GLfloat texCoords[] = &#123;</span><br><span class=\"line\">    0, 0,//左下</span><br><span class=\"line\">    1, 0,//右下</span><br><span class=\"line\">    0, 1,//左上</span><br><span class=\"line\">    1, 1,//右上</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);</span><br><span class=\"line\">glEnableVertexAttribArray(_textureCoordsSlot);</span><br></pre></td></tr></table></figure>\n\n<p>5 关于纹理坐标</p>"},{"title":"OpenGLE_VAO局部影响vs全局影响","date":"2024-07-28T08:57:48.000Z","_content":"\n\n### 全局顶点属性数组使能状态\n\n`glEnableVertexAttribArray` 和 `glDisableVertexAttribArray` 确实是全局状态。这意味着在不使用 VAO 的情况下，启用或禁用特定的顶点属性数组会影响所有后续的绘制调用，直到该状态被改变。例如：\n\n```c\n// 启用顶点属性数组索引 0\nglEnableVertexAttribArray(0);\n\n// 进行绘制调用，使用索引 0 的顶点属性数组\nglDrawArrays(GL_TRIANGLES, 0, 3);\n\n// 禁用顶点属性数组索引 0\nglDisableVertexAttribArray(0);\n\n// 再次进行绘制调用，此时索引 0 的顶点属性数组将不会被使用\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n### 顶点数组对象（VAO）\n\n当使用 VAO 时，`glEnableVertexAttribArray` 和 `glVertexAttribPointer` 等顶点属性相关的状态是存储在 VAO 中的。这意味着当你绑定一个 VAO 时，它会恢复之前存储的所有顶点属性状态，包括哪些属性数组是启用的。这样，每个 VAO 可以拥有自己独立的顶点属性配置。例如：\n\n```c\n// 创建并绑定第一个 VAO\nGLuint vao1;\nglGenVertexArrays(1, &vao1);\nglBindVertexArray(vao1);\n\n// 设置顶点属性指针和启用顶点属性数组\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (void*)0);\nglEnableVertexAttribArray(0);\n\n// 解绑 VAO\nglBindVertexArray(0);\n\n// 创建并绑定第二个 VAO\nGLuint vao2;\nglGenVertexArrays(1, &vao2);\nglBindVertexArray(vao2);\n\n// 设置不同的顶点属性指针和启用顶点属性数组\nglVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), (void*)0);\nglEnableVertexAttribArray(1);\n\n// 解绑 VAO\nglBindVertexArray(0);\n\n// 使用第一个 VAO 进行绘制\nglBindVertexArray(vao1);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n\n// 使用第二个 VAO 进行绘制\nglBindVertexArray(vao2);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n在这个例子中：\n\n- `vao1` 存储了顶点属性索引 0 的配置和使能状态。\n- `vao2` 存储了顶点属性索引 1 的配置和使能状态。\n\n绑定 `vao1` 会恢复其配置和状态，绑定 `vao2` 则会恢复其自身的配置和状态。\n\n### 总结\n\n- **全局顶点属性数组使能状态**：在不使用 VAO 时，`glEnableVertexAttribArray` 和 `glDisableVertexAttribArray` 对所有后续绘制调用生效，直到状态被改变。\n  \n- **顶点数组对象（VAO）**：存储了顶点属性相关的所有状态，包括使能状态。当绑定 VAO 时，会恢复之前存储的顶点属性配置和使能状态，使得每个 VAO 拥有独立的顶点属性配置。\n\n使用 VAO 是管理复杂场景和多个对象的最佳实践，因为它简化了状态管理，并且可以提高渲染性能。\n","source":"_posts/OpenGLE-VAO局部影响vs全局影响.md","raw":"---\ntitle: OpenGLE_VAO局部影响vs全局影响\ndate: 2024-07-28 16:57:48\ntags:\n---\n\n\n### 全局顶点属性数组使能状态\n\n`glEnableVertexAttribArray` 和 `glDisableVertexAttribArray` 确实是全局状态。这意味着在不使用 VAO 的情况下，启用或禁用特定的顶点属性数组会影响所有后续的绘制调用，直到该状态被改变。例如：\n\n```c\n// 启用顶点属性数组索引 0\nglEnableVertexAttribArray(0);\n\n// 进行绘制调用，使用索引 0 的顶点属性数组\nglDrawArrays(GL_TRIANGLES, 0, 3);\n\n// 禁用顶点属性数组索引 0\nglDisableVertexAttribArray(0);\n\n// 再次进行绘制调用，此时索引 0 的顶点属性数组将不会被使用\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n### 顶点数组对象（VAO）\n\n当使用 VAO 时，`glEnableVertexAttribArray` 和 `glVertexAttribPointer` 等顶点属性相关的状态是存储在 VAO 中的。这意味着当你绑定一个 VAO 时，它会恢复之前存储的所有顶点属性状态，包括哪些属性数组是启用的。这样，每个 VAO 可以拥有自己独立的顶点属性配置。例如：\n\n```c\n// 创建并绑定第一个 VAO\nGLuint vao1;\nglGenVertexArrays(1, &vao1);\nglBindVertexArray(vao1);\n\n// 设置顶点属性指针和启用顶点属性数组\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (void*)0);\nglEnableVertexAttribArray(0);\n\n// 解绑 VAO\nglBindVertexArray(0);\n\n// 创建并绑定第二个 VAO\nGLuint vao2;\nglGenVertexArrays(1, &vao2);\nglBindVertexArray(vao2);\n\n// 设置不同的顶点属性指针和启用顶点属性数组\nglVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), (void*)0);\nglEnableVertexAttribArray(1);\n\n// 解绑 VAO\nglBindVertexArray(0);\n\n// 使用第一个 VAO 进行绘制\nglBindVertexArray(vao1);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n\n// 使用第二个 VAO 进行绘制\nglBindVertexArray(vao2);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n在这个例子中：\n\n- `vao1` 存储了顶点属性索引 0 的配置和使能状态。\n- `vao2` 存储了顶点属性索引 1 的配置和使能状态。\n\n绑定 `vao1` 会恢复其配置和状态，绑定 `vao2` 则会恢复其自身的配置和状态。\n\n### 总结\n\n- **全局顶点属性数组使能状态**：在不使用 VAO 时，`glEnableVertexAttribArray` 和 `glDisableVertexAttribArray` 对所有后续绘制调用生效，直到状态被改变。\n  \n- **顶点数组对象（VAO）**：存储了顶点属性相关的所有状态，包括使能状态。当绑定 VAO 时，会恢复之前存储的顶点属性配置和使能状态，使得每个 VAO 拥有独立的顶点属性配置。\n\n使用 VAO 是管理复杂场景和多个对象的最佳实践，因为它简化了状态管理，并且可以提高渲染性能。\n","slug":"OpenGLE-VAO局部影响vs全局影响","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8e00111xco2rpc12nf","content":"<h3 id=\"全局顶点属性数组使能状态\"><a href=\"#全局顶点属性数组使能状态\" class=\"headerlink\" title=\"全局顶点属性数组使能状态\"></a>全局顶点属性数组使能状态</h3><span id=\"more\"></span>\n\n<p><code>glEnableVertexAttribArray</code> 和 <code>glDisableVertexAttribArray</code> 确实是全局状态。这意味着在不使用 VAO 的情况下，启用或禁用特定的顶点属性数组会影响所有后续的绘制调用，直到该状态被改变。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 启用顶点属性数组索引 0</span></span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行绘制调用，使用索引 0 的顶点属性数组</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 禁用顶点属性数组索引 0</span></span><br><span class=\"line\">glDisableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再次进行绘制调用，此时索引 0 的顶点属性数组将不会被使用</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"顶点数组对象（VAO）\"><a href=\"#顶点数组对象（VAO）\" class=\"headerlink\" title=\"顶点数组对象（VAO）\"></a>顶点数组对象（VAO）</h3><p>当使用 VAO 时，<code>glEnableVertexAttribArray</code> 和 <code>glVertexAttribPointer</code> 等顶点属性相关的状态是存储在 VAO 中的。这意味着当你绑定一个 VAO 时，它会恢复之前存储的所有顶点属性状态，包括哪些属性数组是启用的。这样，每个 VAO 可以拥有自己独立的顶点属性配置。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建并绑定第一个 VAO</span></span><br><span class=\"line\">GLuint vao1;</span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;vao1);</span><br><span class=\"line\">glBindVertexArray(vao1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置顶点属性指针和启用顶点属性数组</span></span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解绑 VAO</span></span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并绑定第二个 VAO</span></span><br><span class=\"line\">GLuint vao2;</span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;vao2);</span><br><span class=\"line\">glBindVertexArray(vao2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置不同的顶点属性指针和启用顶点属性数组</span></span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">2</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">2</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解绑 VAO</span></span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用第一个 VAO 进行绘制</span></span><br><span class=\"line\">glBindVertexArray(vao1);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用第二个 VAO 进行绘制</span></span><br><span class=\"line\">glBindVertexArray(vao2);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中：</p>\n<ul>\n<li><code>vao1</code> 存储了顶点属性索引 0 的配置和使能状态。</li>\n<li><code>vao2</code> 存储了顶点属性索引 1 的配置和使能状态。</li>\n</ul>\n<p>绑定 <code>vao1</code> 会恢复其配置和状态，绑定 <code>vao2</code> 则会恢复其自身的配置和状态。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>全局顶点属性数组使能状态</strong>：在不使用 VAO 时，<code>glEnableVertexAttribArray</code> 和 <code>glDisableVertexAttribArray</code> 对所有后续绘制调用生效，直到状态被改变。</li>\n<li><strong>顶点数组对象（VAO）</strong>：存储了顶点属性相关的所有状态，包括使能状态。当绑定 VAO 时，会恢复之前存储的顶点属性配置和使能状态，使得每个 VAO 拥有独立的顶点属性配置。</li>\n</ul>\n<p>使用 VAO 是管理复杂场景和多个对象的最佳实践，因为它简化了状态管理，并且可以提高渲染性能。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"全局顶点属性数组使能状态\"><a href=\"#全局顶点属性数组使能状态\" class=\"headerlink\" title=\"全局顶点属性数组使能状态\"></a>全局顶点属性数组使能状态</h3>","more":"<p><code>glEnableVertexAttribArray</code> 和 <code>glDisableVertexAttribArray</code> 确实是全局状态。这意味着在不使用 VAO 的情况下，启用或禁用特定的顶点属性数组会影响所有后续的绘制调用，直到该状态被改变。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 启用顶点属性数组索引 0</span></span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行绘制调用，使用索引 0 的顶点属性数组</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 禁用顶点属性数组索引 0</span></span><br><span class=\"line\">glDisableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再次进行绘制调用，此时索引 0 的顶点属性数组将不会被使用</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"顶点数组对象（VAO）\"><a href=\"#顶点数组对象（VAO）\" class=\"headerlink\" title=\"顶点数组对象（VAO）\"></a>顶点数组对象（VAO）</h3><p>当使用 VAO 时，<code>glEnableVertexAttribArray</code> 和 <code>glVertexAttribPointer</code> 等顶点属性相关的状态是存储在 VAO 中的。这意味着当你绑定一个 VAO 时，它会恢复之前存储的所有顶点属性状态，包括哪些属性数组是启用的。这样，每个 VAO 可以拥有自己独立的顶点属性配置。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建并绑定第一个 VAO</span></span><br><span class=\"line\">GLuint vao1;</span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;vao1);</span><br><span class=\"line\">glBindVertexArray(vao1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置顶点属性指针和启用顶点属性数组</span></span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解绑 VAO</span></span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并绑定第二个 VAO</span></span><br><span class=\"line\">GLuint vao2;</span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;vao2);</span><br><span class=\"line\">glBindVertexArray(vao2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置不同的顶点属性指针和启用顶点属性数组</span></span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">2</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">2</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解绑 VAO</span></span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用第一个 VAO 进行绘制</span></span><br><span class=\"line\">glBindVertexArray(vao1);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用第二个 VAO 进行绘制</span></span><br><span class=\"line\">glBindVertexArray(vao2);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中：</p>\n<ul>\n<li><code>vao1</code> 存储了顶点属性索引 0 的配置和使能状态。</li>\n<li><code>vao2</code> 存储了顶点属性索引 1 的配置和使能状态。</li>\n</ul>\n<p>绑定 <code>vao1</code> 会恢复其配置和状态，绑定 <code>vao2</code> 则会恢复其自身的配置和状态。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>全局顶点属性数组使能状态</strong>：在不使用 VAO 时，<code>glEnableVertexAttribArray</code> 和 <code>glDisableVertexAttribArray</code> 对所有后续绘制调用生效，直到状态被改变。</li>\n<li><strong>顶点数组对象（VAO）</strong>：存储了顶点属性相关的所有状态，包括使能状态。当绑定 VAO 时，会恢复之前存储的顶点属性配置和使能状态，使得每个 VAO 拥有独立的顶点属性配置。</li>\n</ul>\n<p>使用 VAO 是管理复杂场景和多个对象的最佳实践，因为它简化了状态管理，并且可以提高渲染性能。</p>"},{"title":"OpenGLES设置顶点属性的默认值","date":"2024-07-28T08:53:57.000Z","_content":"\n在 OpenGL ES 中，设置顶点属性的默认值和通过顶点缓冲对象（VBO）上传顶点属性是两种不同的处理顶点属性的方法。以下是详细的解释：\n\n### 设置顶点属性默认值\n\n在 OpenGL ES 中，可以使用 `glVertexAttrib4f`（或其他类似的函数）来设置顶点属性的默认值。这些函数允许您为指定的顶点属性索引设置一个常量值，而不必为每个顶点提供一个值。例如：\n\n```c\n// 设置索引为 0 的顶点属性的默认值为 (1.0, 0.0, 0.0, 1.0)\nglVertexAttrib4f(0, 1.0f, 0.0f, 0.0f, 1.0f);\n```\n\n请注意，这种方法直接在顶点着色器中使用常量值，因此适用于需要相同属性值的所有顶点的情况。\n\n### 通过 VBO 上传顶点属性\n\nVBO 是一种在图形硬件上存储顶点数据的高效方式。使用 VBO 可以提高渲染性能，因为数据存储在 GPU 内存中，而不是通过每次绘制调用从 CPU 内存传输数据。以下是使用 VBO 上传顶点属性的步骤：\n\n1. **生成和绑定 VBO**：\n   ```c\n   GLuint vbo;\n   glGenBuffers(1, &vbo);\n   glBindBuffer(GL_ARRAY_BUFFER, vbo);\n   ```\n\n2. **上传顶点数据**：\n   ```c\n   GLfloat vertices[] = {\n       // 顶点数据，假设每个顶点包含 3 个浮点数 (x, y, z)\n       0.0f, 0.0f, 0.0f,\n       1.0f, 0.0f, 0.0f,\n       0.0f, 1.0f, 0.0f,\n   };\n   glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n   ```\n\n3. **设置顶点属性指针**：\n   ```c\n   glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (void*)0);\n   glEnableVertexAttribArray(0);\n   ```\n\n4. **绘制**：\n   ```c\n   glDrawArrays(GL_TRIANGLES, 0, 3);\n   ```\n\n### 性能差别\n\n- **设置顶点属性默认值**：这种方法适用于所有顶点共享相同属性值的情况。其优点是简单直接，不需要额外的内存传输。然而，它缺乏灵活性，只能应用于特定的简单场景。\n\n- **通过 VBO 上传顶点属性**：这种方法更为灵活，可以为每个顶点设置不同的属性值。因为数据存储在 GPU 内存中，所以渲染性能通常更高，特别是在处理大量顶点数据时。这种方法适用于大多数复杂的渲染任务。\n\n总结来说，如果您的应用场景中所有顶点都共享相同的属性值，可以使用设置默认值的方法。如果不同顶点有不同的属性值，并且您希望获得更好的性能，应使用 VBO。\n","source":"_posts/OpenGLES设置顶点属性的默认值.md","raw":"---\ntitle: OpenGLES设置顶点属性的默认值\ndate: 2024-07-28 16:53:57\ntags:\n---\n\n在 OpenGL ES 中，设置顶点属性的默认值和通过顶点缓冲对象（VBO）上传顶点属性是两种不同的处理顶点属性的方法。以下是详细的解释：\n\n### 设置顶点属性默认值\n\n在 OpenGL ES 中，可以使用 `glVertexAttrib4f`（或其他类似的函数）来设置顶点属性的默认值。这些函数允许您为指定的顶点属性索引设置一个常量值，而不必为每个顶点提供一个值。例如：\n\n```c\n// 设置索引为 0 的顶点属性的默认值为 (1.0, 0.0, 0.0, 1.0)\nglVertexAttrib4f(0, 1.0f, 0.0f, 0.0f, 1.0f);\n```\n\n请注意，这种方法直接在顶点着色器中使用常量值，因此适用于需要相同属性值的所有顶点的情况。\n\n### 通过 VBO 上传顶点属性\n\nVBO 是一种在图形硬件上存储顶点数据的高效方式。使用 VBO 可以提高渲染性能，因为数据存储在 GPU 内存中，而不是通过每次绘制调用从 CPU 内存传输数据。以下是使用 VBO 上传顶点属性的步骤：\n\n1. **生成和绑定 VBO**：\n   ```c\n   GLuint vbo;\n   glGenBuffers(1, &vbo);\n   glBindBuffer(GL_ARRAY_BUFFER, vbo);\n   ```\n\n2. **上传顶点数据**：\n   ```c\n   GLfloat vertices[] = {\n       // 顶点数据，假设每个顶点包含 3 个浮点数 (x, y, z)\n       0.0f, 0.0f, 0.0f,\n       1.0f, 0.0f, 0.0f,\n       0.0f, 1.0f, 0.0f,\n   };\n   glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n   ```\n\n3. **设置顶点属性指针**：\n   ```c\n   glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (void*)0);\n   glEnableVertexAttribArray(0);\n   ```\n\n4. **绘制**：\n   ```c\n   glDrawArrays(GL_TRIANGLES, 0, 3);\n   ```\n\n### 性能差别\n\n- **设置顶点属性默认值**：这种方法适用于所有顶点共享相同属性值的情况。其优点是简单直接，不需要额外的内存传输。然而，它缺乏灵活性，只能应用于特定的简单场景。\n\n- **通过 VBO 上传顶点属性**：这种方法更为灵活，可以为每个顶点设置不同的属性值。因为数据存储在 GPU 内存中，所以渲染性能通常更高，特别是在处理大量顶点数据时。这种方法适用于大多数复杂的渲染任务。\n\n总结来说，如果您的应用场景中所有顶点都共享相同的属性值，可以使用设置默认值的方法。如果不同顶点有不同的属性值，并且您希望获得更好的性能，应使用 VBO。\n","slug":"OpenGLES设置顶点属性的默认值","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8e00121xcod1kr81j1","content":"<p>在 OpenGL ES 中，设置顶点属性的默认值和通过顶点缓冲对象（VBO）上传顶点属性是两种不同的处理顶点属性的方法。以下是详细的解释：</p>\n<h3 id=\"设置顶点属性默认值\"><a href=\"#设置顶点属性默认值\" class=\"headerlink\" title=\"设置顶点属性默认值\"></a>设置顶点属性默认值</h3><span id=\"more\"></span>\n\n<p>在 OpenGL ES 中，可以使用 <code>glVertexAttrib4f</code>（或其他类似的函数）来设置顶点属性的默认值。这些函数允许您为指定的顶点属性索引设置一个常量值，而不必为每个顶点提供一个值。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置索引为 0 的顶点属性的默认值为 (1.0, 0.0, 0.0, 1.0)</span></span><br><span class=\"line\">glVertexAttrib4f(<span class=\"number\">0</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>);</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这种方法直接在顶点着色器中使用常量值，因此适用于需要相同属性值的所有顶点的情况。</p>\n<h3 id=\"通过-VBO-上传顶点属性\"><a href=\"#通过-VBO-上传顶点属性\" class=\"headerlink\" title=\"通过 VBO 上传顶点属性\"></a>通过 VBO 上传顶点属性</h3><p>VBO 是一种在图形硬件上存储顶点数据的高效方式。使用 VBO 可以提高渲染性能，因为数据存储在 GPU 内存中，而不是通过每次绘制调用从 CPU 内存传输数据。以下是使用 VBO 上传顶点属性的步骤：</p>\n<ol>\n<li><p><strong>生成和绑定 VBO</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint vbo;</span><br><span class=\"line\">glGenBuffers(<span class=\"number\">1</span>, &amp;vbo);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbo);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>上传顶点数据</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 顶点数据，假设每个顶点包含 3 个浮点数 (x, y, z)</span></span><br><span class=\"line\">    <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,</span><br><span class=\"line\">    <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,</span><br><span class=\"line\">    <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>设置顶点属性指针</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>绘制</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"性能差别\"><a href=\"#性能差别\" class=\"headerlink\" title=\"性能差别\"></a>性能差别</h3><ul>\n<li><p><strong>设置顶点属性默认值</strong>：这种方法适用于所有顶点共享相同属性值的情况。其优点是简单直接，不需要额外的内存传输。然而，它缺乏灵活性，只能应用于特定的简单场景。</p>\n</li>\n<li><p><strong>通过 VBO 上传顶点属性</strong>：这种方法更为灵活，可以为每个顶点设置不同的属性值。因为数据存储在 GPU 内存中，所以渲染性能通常更高，特别是在处理大量顶点数据时。这种方法适用于大多数复杂的渲染任务。</p>\n</li>\n</ul>\n<p>总结来说，如果您的应用场景中所有顶点都共享相同的属性值，可以使用设置默认值的方法。如果不同顶点有不同的属性值，并且您希望获得更好的性能，应使用 VBO。</p>\n","site":{"data":{}},"excerpt":"<p>在 OpenGL ES 中，设置顶点属性的默认值和通过顶点缓冲对象（VBO）上传顶点属性是两种不同的处理顶点属性的方法。以下是详细的解释：</p>\n<h3 id=\"设置顶点属性默认值\"><a href=\"#设置顶点属性默认值\" class=\"headerlink\" title=\"设置顶点属性默认值\"></a>设置顶点属性默认值</h3>","more":"<p>在 OpenGL ES 中，可以使用 <code>glVertexAttrib4f</code>（或其他类似的函数）来设置顶点属性的默认值。这些函数允许您为指定的顶点属性索引设置一个常量值，而不必为每个顶点提供一个值。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置索引为 0 的顶点属性的默认值为 (1.0, 0.0, 0.0, 1.0)</span></span><br><span class=\"line\">glVertexAttrib4f(<span class=\"number\">0</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>);</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这种方法直接在顶点着色器中使用常量值，因此适用于需要相同属性值的所有顶点的情况。</p>\n<h3 id=\"通过-VBO-上传顶点属性\"><a href=\"#通过-VBO-上传顶点属性\" class=\"headerlink\" title=\"通过 VBO 上传顶点属性\"></a>通过 VBO 上传顶点属性</h3><p>VBO 是一种在图形硬件上存储顶点数据的高效方式。使用 VBO 可以提高渲染性能，因为数据存储在 GPU 内存中，而不是通过每次绘制调用从 CPU 内存传输数据。以下是使用 VBO 上传顶点属性的步骤：</p>\n<ol>\n<li><p><strong>生成和绑定 VBO</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint vbo;</span><br><span class=\"line\">glGenBuffers(<span class=\"number\">1</span>, &amp;vbo);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, vbo);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>上传顶点数据</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 顶点数据，假设每个顶点包含 3 个浮点数 (x, y, z)</span></span><br><span class=\"line\">    <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,</span><br><span class=\"line\">    <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,</span><br><span class=\"line\">    <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>设置顶点属性指针</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>绘制</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"性能差别\"><a href=\"#性能差别\" class=\"headerlink\" title=\"性能差别\"></a>性能差别</h3><ul>\n<li><p><strong>设置顶点属性默认值</strong>：这种方法适用于所有顶点共享相同属性值的情况。其优点是简单直接，不需要额外的内存传输。然而，它缺乏灵活性，只能应用于特定的简单场景。</p>\n</li>\n<li><p><strong>通过 VBO 上传顶点属性</strong>：这种方法更为灵活，可以为每个顶点设置不同的属性值。因为数据存储在 GPU 内存中，所以渲染性能通常更高，特别是在处理大量顶点数据时。这种方法适用于大多数复杂的渲染任务。</p>\n</li>\n</ul>\n<p>总结来说，如果您的应用场景中所有顶点都共享相同的属性值，可以使用设置默认值的方法。如果不同顶点有不同的属性值，并且您希望获得更好的性能，应使用 VBO。</p>"},{"title":"OpenGL模板测试流程","date":"2022-11-08T03:51:27.000Z","_content":"\n\n### 模板测试流程\n\n不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试\n\n#### 模板测试一般使用流程：\n\t1. 启用模板缓冲写入\n\t2. 渲染物体，更新模板缓冲\n\t3. 禁用模板缓冲写入\n\t4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段\n\n\n##### 使用模板测试绘制物体轮廓的例子\n\n\t```\n\tglStencilMask();\n\tglStencilFunc(GLenum func, GLint ref, GLuint mask);\n\tglStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);\n\t```\n\n\t1. 开启模板测试和深度测试\n\t2. 第一次render pass，主要是绘制，并写入模板\n\t\t1. 开启模板测试和深度测试\n\t\t2. glStencilMask(0xFF);\n\t\t3. glStencilOp(keep, keep, replace);\n\t\t4. glStencilFunc(always, 1, 0xFF);\n\t\t5. 绘制物体\n\t3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素\n\t\t1. 将物体缩放变大\n\t\t2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系\n\t\t3. 关闭模板写入glStencilMask(0x00);\n\t\t4. glStencilFunc(not_equal, 1, 0xFF);\n\t\t5. 绘制物体\n\n\n### 关于OpenGL里面的Mask\n\t1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&运算后写入\n\t2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入\n\t3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入\n","source":"_posts/OpenGL模板测试流程.md","raw":"---\ntitle: OpenGL模板测试流程\ndate: 2022-11-08 11:51:27\ntags: openGL\n---\n\n\n### 模板测试流程\n\n不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试\n\n#### 模板测试一般使用流程：\n\t1. 启用模板缓冲写入\n\t2. 渲染物体，更新模板缓冲\n\t3. 禁用模板缓冲写入\n\t4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段\n\n\n##### 使用模板测试绘制物体轮廓的例子\n\n\t```\n\tglStencilMask();\n\tglStencilFunc(GLenum func, GLint ref, GLuint mask);\n\tglStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);\n\t```\n\n\t1. 开启模板测试和深度测试\n\t2. 第一次render pass，主要是绘制，并写入模板\n\t\t1. 开启模板测试和深度测试\n\t\t2. glStencilMask(0xFF);\n\t\t3. glStencilOp(keep, keep, replace);\n\t\t4. glStencilFunc(always, 1, 0xFF);\n\t\t5. 绘制物体\n\t3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素\n\t\t1. 将物体缩放变大\n\t\t2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系\n\t\t3. 关闭模板写入glStencilMask(0x00);\n\t\t4. glStencilFunc(not_equal, 1, 0xFF);\n\t\t5. 绘制物体\n\n\n### 关于OpenGL里面的Mask\n\t1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&运算后写入\n\t2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入\n\t3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入\n","slug":"OpenGL模板测试流程","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8f00151xco9c94b8pe","content":"<h3 id=\"模板测试流程\"><a href=\"#模板测试流程\" class=\"headerlink\" title=\"模板测试流程\"></a>模板测试流程</h3><span id=\"more\"></span>\n\n<p>不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试</p>\n<h4 id=\"模板测试一般使用流程：\"><a href=\"#模板测试一般使用流程：\" class=\"headerlink\" title=\"模板测试一般使用流程：\"></a>模板测试一般使用流程：</h4><pre><code>1. 启用模板缓冲写入\n2. 渲染物体，更新模板缓冲\n3. 禁用模板缓冲写入\n4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段\n</code></pre>\n<h5 id=\"使用模板测试绘制物体轮廓的例子\"><a href=\"#使用模板测试绘制物体轮廓的例子\" class=\"headerlink\" title=\"使用模板测试绘制物体轮廓的例子\"></a>使用模板测试绘制物体轮廓的例子</h5><pre><code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glStencilMask();</span><br><span class=\"line\">glStencilFunc(GLenum func, GLint ref, GLuint mask);</span><br><span class=\"line\">glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);</span><br></pre></td></tr></table></figure>\n\n1. 开启模板测试和深度测试\n2. 第一次render pass，主要是绘制，并写入模板\n    1. 开启模板测试和深度测试\n    2. glStencilMask(0xFF);\n    3. glStencilOp(keep, keep, replace);\n    4. glStencilFunc(always, 1, 0xFF);\n    5. 绘制物体\n3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素\n    1. 将物体缩放变大\n    2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系\n    3. 关闭模板写入glStencilMask(0x00);\n    4. glStencilFunc(not_equal, 1, 0xFF);\n    5. 绘制物体\n</code></pre>\n<h3 id=\"关于OpenGL里面的Mask\"><a href=\"#关于OpenGL里面的Mask\" class=\"headerlink\" title=\"关于OpenGL里面的Mask\"></a>关于OpenGL里面的Mask</h3><pre><code>1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&amp;运算后写入\n2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入\n3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入\n</code></pre>\n","site":{"data":{}},"excerpt":"<h3 id=\"模板测试流程\"><a href=\"#模板测试流程\" class=\"headerlink\" title=\"模板测试流程\"></a>模板测试流程</h3>","more":"<p>不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试</p>\n<h4 id=\"模板测试一般使用流程：\"><a href=\"#模板测试一般使用流程：\" class=\"headerlink\" title=\"模板测试一般使用流程：\"></a>模板测试一般使用流程：</h4><pre><code>1. 启用模板缓冲写入\n2. 渲染物体，更新模板缓冲\n3. 禁用模板缓冲写入\n4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段\n</code></pre>\n<h5 id=\"使用模板测试绘制物体轮廓的例子\"><a href=\"#使用模板测试绘制物体轮廓的例子\" class=\"headerlink\" title=\"使用模板测试绘制物体轮廓的例子\"></a>使用模板测试绘制物体轮廓的例子</h5><pre><code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glStencilMask();</span><br><span class=\"line\">glStencilFunc(GLenum func, GLint ref, GLuint mask);</span><br><span class=\"line\">glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);</span><br></pre></td></tr></table></figure>\n\n1. 开启模板测试和深度测试\n2. 第一次render pass，主要是绘制，并写入模板\n    1. 开启模板测试和深度测试\n    2. glStencilMask(0xFF);\n    3. glStencilOp(keep, keep, replace);\n    4. glStencilFunc(always, 1, 0xFF);\n    5. 绘制物体\n3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素\n    1. 将物体缩放变大\n    2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系\n    3. 关闭模板写入glStencilMask(0x00);\n    4. glStencilFunc(not_equal, 1, 0xFF);\n    5. 绘制物体\n</code></pre>\n<h3 id=\"关于OpenGL里面的Mask\"><a href=\"#关于OpenGL里面的Mask\" class=\"headerlink\" title=\"关于OpenGL里面的Mask\"></a>关于OpenGL里面的Mask</h3><pre><code>1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&amp;运算后写入\n2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入\n3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入\n</code></pre>"},{"title":"SDF实现CornerRadius","date":"2023-12-28T10:45:16.000Z","draft":true,"_content":"\n本文将介绍如何使用SDF（Signed Distance Field）实现圆角效果。\n\n<!-- 内容待补充 -->\n","source":"_posts/SDF实现CornerRadius.md","raw":"---\ntitle: SDF实现CornerRadius\ndate: 2023-12-28 18:45:16\ntags:\ndraft: true\n---\n\n本文将介绍如何使用SDF（Signed Distance Field）实现圆角效果。\n\n<!-- 内容待补充 -->\n","slug":"SDF实现CornerRadius","published":1,"updated":"2025-06-07T09:22:13.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8f00171xco1w9ybc1q","content":"<p>本文将介绍如何使用SDF（Signed Distance Field）实现圆角效果。</p>\n<!-- 内容待补充 -->\n","site":{"data":{}},"excerpt":"","more":"<p>本文将介绍如何使用SDF（Signed Distance Field）实现圆角效果。</p>\n<!-- 内容待补充 -->\n"},{"title":"UTF编码内存角度比较.md","date":"2024-07-11T07:36:56.000Z","_content":"\nUTF-8、UTF-16 和 UTF-32 是三种不同的 Unicode 编码方式，它们在表示字符时占用的字节数各不相同。具体如下：\n\n1. **UTF-8**：\n   - UTF-8 是一种可变长度的编码方式，每个字符占用 1 到 4 个字节。\n   - 具体字节数取决于字符的 Unicode 码点：\n     - U+0000 至 U+007F（基本拉丁字母）占 1 个字节。\n     - U+0080 至 U+07FF 占 2 个字节。\n     - U+0800 至 U+FFFF 占 3 个字节。\n     - U+10000 至 U+10FFFF 占 4 个字节。\n\n2. **UTF-16**：\n   - UTF-16 也是一种可变长度的编码方式，每个字符占用 2 或 4 个字节。\n   - 具体字节数取决于字符的 Unicode 码点：\n     - U+0000 至 U+FFFF（基本多语言平面，BMP）占 2 个字节。\n     - U+10000 至 U+10FFFF（辅助平面）占 4 个字节（使用一对代理项，即高位代理项和低位代理项，每个占 2 个字节）。\n\n3. **UTF-32**：\n   - UTF-32 是一种固定长度的编码方式，每个字符占用 4 个字节。\n   - 无论字符的 Unicode 码点是多少，每个字符始终占用 4 个字节。\n\n总结：\n\n- **UTF-8**：1 到 4 个字节，具体取决于字符。\n- **UTF-16**：2 或 4 个字节，具体取决于字符。\n- **UTF-32**：固定 4 个字节。\n\n这三种编码方式各有优缺点。UTF-8 是最常用的编码方式，因其对 ASCII 字符的高效编码（仅占 1 个字节），节省空间且向后兼容 ASCII。UTF-16 在处理基本多语言平面字符时相对高效，但对于包括大量辅助平面字符的文本，可能会占用更多空间。UTF-32 最简单，但由于每个字符固定占用 4 个字节，通常会占用更多的存储空间。\n","source":"_posts/UTF编码内存角度比较-md.md","raw":"---\ntitle: UTF编码内存角度比较.md\ndate: 2024-07-11 15:36:56\ntags:\n---\n\nUTF-8、UTF-16 和 UTF-32 是三种不同的 Unicode 编码方式，它们在表示字符时占用的字节数各不相同。具体如下：\n\n1. **UTF-8**：\n   - UTF-8 是一种可变长度的编码方式，每个字符占用 1 到 4 个字节。\n   - 具体字节数取决于字符的 Unicode 码点：\n     - U+0000 至 U+007F（基本拉丁字母）占 1 个字节。\n     - U+0080 至 U+07FF 占 2 个字节。\n     - U+0800 至 U+FFFF 占 3 个字节。\n     - U+10000 至 U+10FFFF 占 4 个字节。\n\n2. **UTF-16**：\n   - UTF-16 也是一种可变长度的编码方式，每个字符占用 2 或 4 个字节。\n   - 具体字节数取决于字符的 Unicode 码点：\n     - U+0000 至 U+FFFF（基本多语言平面，BMP）占 2 个字节。\n     - U+10000 至 U+10FFFF（辅助平面）占 4 个字节（使用一对代理项，即高位代理项和低位代理项，每个占 2 个字节）。\n\n3. **UTF-32**：\n   - UTF-32 是一种固定长度的编码方式，每个字符占用 4 个字节。\n   - 无论字符的 Unicode 码点是多少，每个字符始终占用 4 个字节。\n\n总结：\n\n- **UTF-8**：1 到 4 个字节，具体取决于字符。\n- **UTF-16**：2 或 4 个字节，具体取决于字符。\n- **UTF-32**：固定 4 个字节。\n\n这三种编码方式各有优缺点。UTF-8 是最常用的编码方式，因其对 ASCII 字符的高效编码（仅占 1 个字节），节省空间且向后兼容 ASCII。UTF-16 在处理基本多语言平面字符时相对高效，但对于包括大量辅助平面字符的文本，可能会占用更多空间。UTF-32 最简单，但由于每个字符固定占用 4 个字节，通常会占用更多的存储空间。\n","slug":"UTF编码内存角度比较-md","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8f001a1xco7605glpg","content":"<p>UTF-8、UTF-16 和 UTF-32 是三种不同的 Unicode 编码方式，它们在表示字符时占用的字节数各不相同。具体如下：</p>\n<ol>\n<li><strong>UTF-8</strong>：<ul>\n<li>UTF-8 是一种可变长度的编码方式，每个字符占用 1 到 4 个字节。</li>\n<li>具体字节数取决于字符的 Unicode 码点：<ul>\n<li>U+0000 至 U+007F（基本拉丁字母）占 1 个字节。</li>\n<li>U+0080 至 U+07FF 占 2 个字节。</li>\n<li>U+0800 至 U+FFFF 占 3 个字节。</li>\n<li>U+10000 至 U+10FFFF 占 4 个字节。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<span id=\"more\"></span>\n\n<ol start=\"2\">\n<li><p><strong>UTF-16</strong>：</p>\n<ul>\n<li>UTF-16 也是一种可变长度的编码方式，每个字符占用 2 或 4 个字节。</li>\n<li>具体字节数取决于字符的 Unicode 码点：<ul>\n<li>U+0000 至 U+FFFF（基本多语言平面，BMP）占 2 个字节。</li>\n<li>U+10000 至 U+10FFFF（辅助平面）占 4 个字节（使用一对代理项，即高位代理项和低位代理项，每个占 2 个字节）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>UTF-32</strong>：</p>\n<ul>\n<li>UTF-32 是一种固定长度的编码方式，每个字符占用 4 个字节。</li>\n<li>无论字符的 Unicode 码点是多少，每个字符始终占用 4 个字节。</li>\n</ul>\n</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li><strong>UTF-8</strong>：1 到 4 个字节，具体取决于字符。</li>\n<li><strong>UTF-16</strong>：2 或 4 个字节，具体取决于字符。</li>\n<li><strong>UTF-32</strong>：固定 4 个字节。</li>\n</ul>\n<p>这三种编码方式各有优缺点。UTF-8 是最常用的编码方式，因其对 ASCII 字符的高效编码（仅占 1 个字节），节省空间且向后兼容 ASCII。UTF-16 在处理基本多语言平面字符时相对高效，但对于包括大量辅助平面字符的文本，可能会占用更多空间。UTF-32 最简单，但由于每个字符固定占用 4 个字节，通常会占用更多的存储空间。</p>\n","site":{"data":{}},"excerpt":"<p>UTF-8、UTF-16 和 UTF-32 是三种不同的 Unicode 编码方式，它们在表示字符时占用的字节数各不相同。具体如下：</p>\n<ol>\n<li><strong>UTF-8</strong>：<ul>\n<li>UTF-8 是一种可变长度的编码方式，每个字符占用 1 到 4 个字节。</li>\n<li>具体字节数取决于字符的 Unicode 码点：<ul>\n<li>U+0000 至 U+007F（基本拉丁字母）占 1 个字节。</li>\n<li>U+0080 至 U+07FF 占 2 个字节。</li>\n<li>U+0800 至 U+FFFF 占 3 个字节。</li>\n<li>U+10000 至 U+10FFFF 占 4 个字节。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>","more":"<ol start=\"2\">\n<li><p><strong>UTF-16</strong>：</p>\n<ul>\n<li>UTF-16 也是一种可变长度的编码方式，每个字符占用 2 或 4 个字节。</li>\n<li>具体字节数取决于字符的 Unicode 码点：<ul>\n<li>U+0000 至 U+FFFF（基本多语言平面，BMP）占 2 个字节。</li>\n<li>U+10000 至 U+10FFFF（辅助平面）占 4 个字节（使用一对代理项，即高位代理项和低位代理项，每个占 2 个字节）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>UTF-32</strong>：</p>\n<ul>\n<li>UTF-32 是一种固定长度的编码方式，每个字符占用 4 个字节。</li>\n<li>无论字符的 Unicode 码点是多少，每个字符始终占用 4 个字节。</li>\n</ul>\n</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li><strong>UTF-8</strong>：1 到 4 个字节，具体取决于字符。</li>\n<li><strong>UTF-16</strong>：2 或 4 个字节，具体取决于字符。</li>\n<li><strong>UTF-32</strong>：固定 4 个字节。</li>\n</ul>\n<p>这三种编码方式各有优缺点。UTF-8 是最常用的编码方式，因其对 ASCII 字符的高效编码（仅占 1 个字节），节省空间且向后兼容 ASCII。UTF-16 在处理基本多语言平面字符时相对高效，但对于包括大量辅助平面字符的文本，可能会占用更多空间。UTF-32 最简单，但由于每个字符固定占用 4 个字节，通常会占用更多的存储空间。</p>"},{"title":"add Image","date":"2022-09-25T12:26:19.000Z","_content":"\n\n###测试插入一张图片\n\n\n![](../add-Image/sharedptr1.png)\n\n\ntest end\n\n\n\n","source":"_posts/add-Image.md","raw":"---\ntitle: add Image\ndate: 2022-09-25 20:26:19\ntags: test\n---\n\n\n###测试插入一张图片\n\n\n![](../add-Image/sharedptr1.png)\n\n\ntest end\n\n\n\n","slug":"add-Image","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8f001c1xcobj6ldrrw","content":"<p>###测试插入一张图片</p>\n<p><img src=\"/2022/09/25/add-Image/sharedptr1.png\"></p>\n<p>test end</p>\n","site":{"data":{}},"excerpt":"","more":"<p>###测试插入一张图片</p>\n<p><img src=\"/2022/09/25/add-Image/sharedptr1.png\"></p>\n<p>test end</p>\n"},{"title":"c++ 可变参数模板","date":"2022-12-11T06:50:04.000Z","_content":"\n\n\n### 可变模版参数(variadic templates)\n可以对参数进行高度泛化，标识0到任意个数参数\n\n#### 两种展开形式\n1. 使用特化的终止函数结合递归\n\n```\n#include <iostream>\nusing namespace std;\n\n//终止函数\nint multiply()\n{\n    return 1;\n}\n\n//递归展开\ntemplate <typename T, typename ...Args>\nint multiply(T&& t, Args&& ...arg)\n{\n    return t * multiply(arg...);\n}\n\nint main(int argc, const char * argv[]) {\n    \n    cout << multiply(3, 4, 5) << endl;\n    \n    cout << multiply() << endl;\n    \n    return 0;\n}\n```\n\n2. 使用逗号表达式\n初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)...}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc... )，最终会创建一个元素值都为0的数组int arr[sizeof...(Args)]\n\n\n```\ntemplate<class F, class... Args>void expand(const F& f, Args&&...args)\n{\n  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》\n  initializer_list<int>{(f(std::forward< Args>(args)),0)...};\n}\n\nint main(int argc, const char * argv[]) {\n    \n    expand([](int i) {\n        cout<<i<<endl;\n    }, 1,2,3);\n    return 0;\n}\n\n```\n\n### initializer_list\n为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板\n\n```\nstruct myclass {\n    myclass(int,int)\n    {\n        cout << \"myclass constructor\" << endl;\n    }\n    myclass(initializer_list<int>)\n    {\n        cout << \"myclass initializer_list constructor\" << endl;\n    }\n};\n\n\nint main(int argc, const char * argv[]) {\n    \n    auto il = {10, 20, 30};\n    \n    myclass foo {10,20};  // calls initializer_list constructor\n    myclass bar (10,20);  // calls first constructo\n    \n    return 0;\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/c-可变参数模板.md","raw":"---\ntitle: c++ 可变参数模板\ndate: 2022-12-11 14:50:04\ntags: c++11\n---\n\n\n\n### 可变模版参数(variadic templates)\n可以对参数进行高度泛化，标识0到任意个数参数\n\n#### 两种展开形式\n1. 使用特化的终止函数结合递归\n\n```\n#include <iostream>\nusing namespace std;\n\n//终止函数\nint multiply()\n{\n    return 1;\n}\n\n//递归展开\ntemplate <typename T, typename ...Args>\nint multiply(T&& t, Args&& ...arg)\n{\n    return t * multiply(arg...);\n}\n\nint main(int argc, const char * argv[]) {\n    \n    cout << multiply(3, 4, 5) << endl;\n    \n    cout << multiply() << endl;\n    \n    return 0;\n}\n```\n\n2. 使用逗号表达式\n初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)...}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc... )，最终会创建一个元素值都为0的数组int arr[sizeof...(Args)]\n\n\n```\ntemplate<class F, class... Args>void expand(const F& f, Args&&...args)\n{\n  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》\n  initializer_list<int>{(f(std::forward< Args>(args)),0)...};\n}\n\nint main(int argc, const char * argv[]) {\n    \n    expand([](int i) {\n        cout<<i<<endl;\n    }, 1,2,3);\n    return 0;\n}\n\n```\n\n### initializer_list\n为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板\n\n```\nstruct myclass {\n    myclass(int,int)\n    {\n        cout << \"myclass constructor\" << endl;\n    }\n    myclass(initializer_list<int>)\n    {\n        cout << \"myclass initializer_list constructor\" << endl;\n    }\n};\n\n\nint main(int argc, const char * argv[]) {\n    \n    auto il = {10, 20, 30};\n    \n    myclass foo {10,20};  // calls initializer_list constructor\n    myclass bar (10,20);  // calls first constructo\n    \n    return 0;\n}\n```\n\n\n\n\n\n\n\n","slug":"c-可变参数模板","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8f001f1xco36cqfgp1","content":"<h3 id=\"可变模版参数-variadic-templates\"><a href=\"#可变模版参数-variadic-templates\" class=\"headerlink\" title=\"可变模版参数(variadic templates)\"></a>可变模版参数(variadic templates)</h3><p>可以对参数进行高度泛化，标识0到任意个数参数</p>\n<span id=\"more\"></span>\n\n<h4 id=\"两种展开形式\"><a href=\"#两种展开形式\" class=\"headerlink\" title=\"两种展开形式\"></a>两种展开形式</h4><ol>\n<li>使用特化的终止函数结合递归</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">//终止函数</span><br><span class=\"line\">int multiply()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//递归展开</span><br><span class=\"line\">template &lt;typename T, typename ...Args&gt;</span><br><span class=\"line\">int multiply(T&amp;&amp; t, Args&amp;&amp; ...arg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return t * multiply(arg...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; multiply(3, 4, 5) &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; multiply() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用逗号表达式<br>初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc… )，最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class F, class... Args&gt;void expand(const F&amp; f, Args&amp;&amp;...args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》</span><br><span class=\"line\">  initializer_list&lt;int&gt;&#123;(f(std::forward&lt; Args&gt;(args)),0)...&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    expand([](int i) &#123;</span><br><span class=\"line\">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class=\"line\">    &#125;, 1,2,3);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"initializer-list\"><a href=\"#initializer-list\" class=\"headerlink\" title=\"initializer_list\"></a>initializer_list</h3><p>为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct myclass &#123;</span><br><span class=\"line\">    myclass(int,int)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;myclass constructor&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    myclass(initializer_list&lt;int&gt;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;myclass initializer_list constructor&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    auto il = &#123;10, 20, 30&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    myclass foo &#123;10,20&#125;;  // calls initializer_list constructor</span><br><span class=\"line\">    myclass bar (10,20);  // calls first constructo</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<h3 id=\"可变模版参数-variadic-templates\"><a href=\"#可变模版参数-variadic-templates\" class=\"headerlink\" title=\"可变模版参数(variadic templates)\"></a>可变模版参数(variadic templates)</h3><p>可以对参数进行高度泛化，标识0到任意个数参数</p>","more":"<h4 id=\"两种展开形式\"><a href=\"#两种展开形式\" class=\"headerlink\" title=\"两种展开形式\"></a>两种展开形式</h4><ol>\n<li>使用特化的终止函数结合递归</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">//终止函数</span><br><span class=\"line\">int multiply()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//递归展开</span><br><span class=\"line\">template &lt;typename T, typename ...Args&gt;</span><br><span class=\"line\">int multiply(T&amp;&amp; t, Args&amp;&amp; ...arg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return t * multiply(arg...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; multiply(3, 4, 5) &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; multiply() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用逗号表达式<br>初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc… )，最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class F, class... Args&gt;void expand(const F&amp; f, Args&amp;&amp;...args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》</span><br><span class=\"line\">  initializer_list&lt;int&gt;&#123;(f(std::forward&lt; Args&gt;(args)),0)...&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    expand([](int i) &#123;</span><br><span class=\"line\">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class=\"line\">    &#125;, 1,2,3);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"initializer-list\"><a href=\"#initializer-list\" class=\"headerlink\" title=\"initializer_list\"></a>initializer_list</h3><p>为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct myclass &#123;</span><br><span class=\"line\">    myclass(int,int)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;myclass constructor&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    myclass(initializer_list&lt;int&gt;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;myclass initializer_list constructor&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    auto il = &#123;10, 20, 30&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    myclass foo &#123;10,20&#125;;  // calls initializer_list constructor</span><br><span class=\"line\">    myclass bar (10,20);  // calls first constructo</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"c++模版函数delete防止隐士类型转换.md","date":"2024-09-26T06:29:27.000Z","_content":"\n本文展示如何使用C++模板函数的`delete`关键字来防止不必要的隐式类型转换。\n\n<!-- more -->\n\n```c++\nstruct Person {\n    int a = 0;\n    operator int&() { return a; }\n    operator const int&() const { return a; }\n};\n\ntemplate <typename T>\nvoid testFunc(T arg) = delete;\n\nvoid testFunc(int arg)\n{\n    printf(\"called testFunc int\\n\");\n}\n\nint main() {\n    \n    Person a;\n    testFunc(a); //报错\n    return 0;\n}\n```\n","source":"_posts/c-模版函数delete防止隐士类型转换-md.md","raw":"---\ntitle: c++模版函数delete防止隐士类型转换.md\ndate: 2024-09-26 14:29:27\ntags:\n---\n\n本文展示如何使用C++模板函数的`delete`关键字来防止不必要的隐式类型转换。\n\n<!-- more -->\n\n```c++\nstruct Person {\n    int a = 0;\n    operator int&() { return a; }\n    operator const int&() const { return a; }\n};\n\ntemplate <typename T>\nvoid testFunc(T arg) = delete;\n\nvoid testFunc(int arg)\n{\n    printf(\"called testFunc int\\n\");\n}\n\nint main() {\n    \n    Person a;\n    testFunc(a); //报错\n    return 0;\n}\n```\n","slug":"c-模版函数delete防止隐士类型转换-md","published":1,"updated":"2025-06-07T09:19:58.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8f001g1xco5cif3fzs","content":"<p>本文展示如何使用C++模板函数的<code>delete</code>关键字来防止不必要的隐式类型转换。</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"type\">int</span>&amp;() &#123; <span class=\"keyword\">return</span> a; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"type\">const</span> <span class=\"type\">int</span>&amp;() <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> a; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">testFunc</span><span class=\"params\">(T arg)</span> </span>= <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">testFunc</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;called testFunc int\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person a;</span><br><span class=\"line\">    <span class=\"built_in\">testFunc</span>(a); <span class=\"comment\">//报错</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>本文展示如何使用C++模板函数的<code>delete</code>关键字来防止不必要的隐式类型转换。</p>","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"type\">int</span>&amp;() &#123; <span class=\"keyword\">return</span> a; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"type\">const</span> <span class=\"type\">int</span>&amp;() <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> a; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">testFunc</span><span class=\"params\">(T arg)</span> </span>= <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">testFunc</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;called testFunc int\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Person a;</span><br><span class=\"line\">    <span class=\"built_in\">testFunc</span>(a); <span class=\"comment\">//报错</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"c++继承权限","date":"2022-12-04T14:52:54.000Z","_content":"\n1. 继承有三种权限，public，proteced，private，默认不写是private\n\n2. 权限的最低是public，其次是protected，最高private\n\n3. 继承方式代表是父类属性在当前类中的最低呈现\n\n4. 父类中的privated属性在子类中不可访问\n\n","source":"_posts/c-继承权限.md","raw":"---\ntitle: c++继承权限\ndate: 2022-12-04 22:52:54\ntags:\n---\n\n1. 继承有三种权限，public，proteced，private，默认不写是private\n\n2. 权限的最低是public，其次是protected，最高private\n\n3. 继承方式代表是父类属性在当前类中的最低呈现\n\n4. 父类中的privated属性在子类中不可访问\n\n","slug":"c-继承权限","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8g001i1xco73r00eye","content":"<ol>\n<li><p>继承有三种权限，public，proteced，private，默认不写是private</p>\n</li>\n<li><p>权限的最低是public，其次是protected，最高private</p>\n</li>\n<li><p>继承方式代表是父类属性在当前类中的最低呈现</p>\n</li>\n<li><p>父类中的privated属性在子类中不可访问</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>继承有三种权限，public，proteced，private，默认不写是private</p>\n</li>\n<li><p>权限的最低是public，其次是protected，最高private</p>\n</li>\n<li><p>继承方式代表是父类属性在当前类中的最低呈现</p>\n</li>\n<li><p>父类中的privated属性在子类中不可访问</p>\n</li>\n</ol>\n"},{"layout":"post","title":"iOS运行时消息转发","subtitle":"iOS Runtime","date":"2017-12-13T16:00:00.000Z","_content":"\n\n> 最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解\n\n\n\n### iOS 方法调用探讨\n\n这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, ...)方法这种方式\n\n在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding\n\n如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：\n\n![image.png](https://oh144b0ji.qnssl.com/OC%20runTime.jpg)\n\n\n\n主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程\n\n1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法\n\n```\n+ (BOOL)resolveInstanceMethod:(SEL)aSEL{\n  \n    if (aSEL == @selector(notFoundFunctiion)) {\n        \n        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, \"v@:\");\n        return YES;\n    }\n    \n    return [super resolveInstanceMethod:aSEL];\n}\n```\n\n​\t需要注意的是，不仅[self notFoundFunctiion]会触发这里，在\n\n```\n[self respondsToSelector:@selector(notFoundFunctiion)]\n```\n\n​\t这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。\n\n\n\n2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程\n\n可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO\n\n\n\n#### 参考文章：\n\n[Objective-C Runtime Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html)\n\n\n\n\n","source":"_posts/iOS-MessageForwarding.md","raw":"---\nlayout:     post\ntitle:      iOS运行时消息转发\nsubtitle:   iOS Runtime\ndate:       2017-12-14\ntags:\n    - iOS\n---\n\n\n> 最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解\n\n\n\n### iOS 方法调用探讨\n\n这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, ...)方法这种方式\n\n在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding\n\n如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：\n\n![image.png](https://oh144b0ji.qnssl.com/OC%20runTime.jpg)\n\n\n\n主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程\n\n1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法\n\n```\n+ (BOOL)resolveInstanceMethod:(SEL)aSEL{\n  \n    if (aSEL == @selector(notFoundFunctiion)) {\n        \n        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, \"v@:\");\n        return YES;\n    }\n    \n    return [super resolveInstanceMethod:aSEL];\n}\n```\n\n​\t需要注意的是，不仅[self notFoundFunctiion]会触发这里，在\n\n```\n[self respondsToSelector:@selector(notFoundFunctiion)]\n```\n\n​\t这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。\n\n\n\n2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程\n\n可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO\n\n\n\n#### 参考文章：\n\n[Objective-C Runtime Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html)\n\n\n\n\n","slug":"iOS-MessageForwarding","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8g001k1xcoeunp5srb","content":"<blockquote>\n<p>最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解</p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"iOS-方法调用探讨\"><a href=\"#iOS-方法调用探讨\" class=\"headerlink\" title=\"iOS 方法调用探讨\"></a>iOS 方法调用探讨</h3><p>这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, …)方法这种方式</p>\n<p>在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding</p>\n<p>如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：</p>\n<p><img src=\"https://oh144b0ji.qnssl.com/OC%20runTime.jpg\" alt=\"image.png\"></p>\n<p>主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程</p>\n<p>1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    if (aSEL == @selector(notFoundFunctiion)) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return [super resolveInstanceMethod:aSEL];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    需要注意的是，不仅[self notFoundFunctiion]会触发这里，在</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self respondsToSelector:@selector(notFoundFunctiion)]</span><br></pre></td></tr></table></figure>\n\n<p>​    这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。</p>\n<p>2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程</p>\n<p>可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO</p>\n<h4 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h4><p><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html\">Objective-C Runtime Programming Guide</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解</p>\n</blockquote>","more":"<h3 id=\"iOS-方法调用探讨\"><a href=\"#iOS-方法调用探讨\" class=\"headerlink\" title=\"iOS 方法调用探讨\"></a>iOS 方法调用探讨</h3><p>这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, …)方法这种方式</p>\n<p>在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding</p>\n<p>如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：</p>\n<p><img src=\"https://oh144b0ji.qnssl.com/OC%20runTime.jpg\" alt=\"image.png\"></p>\n<p>主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程</p>\n<p>1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    if (aSEL == @selector(notFoundFunctiion)) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return [super resolveInstanceMethod:aSEL];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    需要注意的是，不仅[self notFoundFunctiion]会触发这里，在</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self respondsToSelector:@selector(notFoundFunctiion)]</span><br></pre></td></tr></table></figure>\n\n<p>​    这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。</p>\n<p>2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程</p>\n<p>可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO</p>\n<h4 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h4><p><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html\">Objective-C Runtime Programming Guide</a></p>"},{"layout":"post","title":"iOS11模拟器运行OpenGL相关程序卡顿","subtitle":"Xcode9.0 problem","date":"2017-09-18T16:00:00.000Z","author":"jack","header-img":"img/post-bg-ios9-web.jpg","catalog":true,"_content":"\n\n> 最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug\n\n\n\n### 具体的解决方案是\n替换此路径下的文件用附件文件，替换此路径下文件即可\n\n*/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib*  \n\n[libCoreVMClient.dylib下载链接](http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib)\n\n\n\n### 参考文献\n\n[苹果开发者论坛](https://forums.developer.apple.com/thread/83570)","source":"_posts/iOS11 Simulator OpenGL Slowly.md","raw":"---\nlayout:     post\ntitle:      iOS11模拟器运行OpenGL相关程序卡顿\nsubtitle:   Xcode9.0 problem\ndate:       2017-09-19\nauthor:     jack\nheader-img: img/post-bg-ios9-web.jpg\ncatalog: true\ntags:\n    - iOS\n---\n\n\n> 最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug\n\n\n\n### 具体的解决方案是\n替换此路径下的文件用附件文件，替换此路径下文件即可\n\n*/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib*  \n\n[libCoreVMClient.dylib下载链接](http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib)\n\n\n\n### 参考文献\n\n[苹果开发者论坛](https://forums.developer.apple.com/thread/83570)","slug":"iOS11 Simulator OpenGL Slowly","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8g001n1xcoc8sbamxg","content":"<blockquote>\n<p>最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug</p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"具体的解决方案是\"><a href=\"#具体的解决方案是\" class=\"headerlink\" title=\"具体的解决方案是\"></a>具体的解决方案是</h3><p>替换此路径下的文件用附件文件，替换此路径下文件即可</p>\n<p><em>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib</em>  </p>\n<p><a href=\"http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib\">libCoreVMClient.dylib下载链接</a></p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://forums.developer.apple.com/thread/83570\">苹果开发者论坛</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug</p>\n</blockquote>","more":"<h3 id=\"具体的解决方案是\"><a href=\"#具体的解决方案是\" class=\"headerlink\" title=\"具体的解决方案是\"></a>具体的解决方案是</h3><p>替换此路径下的文件用附件文件，替换此路径下文件即可</p>\n<p><em>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib</em>  </p>\n<p><a href=\"http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib\">libCoreVMClient.dylib下载链接</a></p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://forums.developer.apple.com/thread/83570\">苹果开发者论坛</a></p>"},{"layout":"post","title":"iOS不受用户手动修改时间的影响的计时技术","subtitle":"一种不受系统时钟影响的实现","date":"2017-09-16T16:00:00.000Z","author":"jack","header-img":"img/post-bg-ios9-web.jpg","catalog":true,"_content":"\n### iOS不受用户手动修改时间的影响的计时技术\n\n### 前言\n\n这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案\n\n\n\n### 解决问题\n\n直接说最终方案\n\n`[[NSProcessInfo processInfo] systemUptime];`\n\n这个函数返回的是开机到当前的时间，秒数为单位，并且**不受系统时钟的影响**，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.\n\n\n\n### 参考文献\n\n[苹果接口文档](https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc)","source":"_posts/iOS准确计时.md","raw":"---\nlayout:     post\ntitle:      iOS不受用户手动修改时间的影响的计时技术\nsubtitle:   一种不受系统时钟影响的实现\ndate:       2017-09-17\nauthor:     jack\nheader-img: img/post-bg-ios9-web.jpg\ncatalog: true\ntags:\n    - iOS\n---\n\n### iOS不受用户手动修改时间的影响的计时技术\n\n### 前言\n\n这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案\n\n\n\n### 解决问题\n\n直接说最终方案\n\n`[[NSProcessInfo processInfo] systemUptime];`\n\n这个函数返回的是开机到当前的时间，秒数为单位，并且**不受系统时钟的影响**，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.\n\n\n\n### 参考文献\n\n[苹果接口文档](https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc)","slug":"iOS准确计时","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8g001p1xco1aux70vz","content":"<h3 id=\"iOS不受用户手动修改时间的影响的计时技术\"><a href=\"#iOS不受用户手动修改时间的影响的计时技术\" class=\"headerlink\" title=\"iOS不受用户手动修改时间的影响的计时技术\"></a>iOS不受用户手动修改时间的影响的计时技术</h3><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><span id=\"more\"></span>\n\n<p>这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案</p>\n<h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>直接说最终方案</p>\n<p><code>[[NSProcessInfo processInfo] systemUptime];</code></p>\n<p>这个函数返回的是开机到当前的时间，秒数为单位，并且<strong>不受系统时钟的影响</strong>，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc\">苹果接口文档</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"iOS不受用户手动修改时间的影响的计时技术\"><a href=\"#iOS不受用户手动修改时间的影响的计时技术\" class=\"headerlink\" title=\"iOS不受用户手动修改时间的影响的计时技术\"></a>iOS不受用户手动修改时间的影响的计时技术</h3><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3>","more":"<p>这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案</p>\n<h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>直接说最终方案</p>\n<p><code>[[NSProcessInfo processInfo] systemUptime];</code></p>\n<p>这个函数返回的是开机到当前的时间，秒数为单位，并且<strong>不受系统时钟的影响</strong>，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc\">苹果接口文档</a></p>"},{"title":"lamda 初始化捕获用法","date":"2023-12-27T06:16:08.000Z","draft":true,"_content":"\n本文将介绍C++ Lambda表达式的初始化捕获用法。\n\n<!-- 内容待补充 -->\n","source":"_posts/lamda-初始化捕获用法.md","raw":"---\ntitle: lamda 初始化捕获用法\ndate: 2023-12-27 14:16:08\ntags:\ndraft: true\n---\n\n本文将介绍C++ Lambda表达式的初始化捕获用法。\n\n<!-- 内容待补充 -->\n","slug":"lamda-初始化捕获用法","published":1,"updated":"2025-06-07T09:22:21.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8g001s1xco5tcv4t6k","content":"<p>本文将介绍C++ Lambda表达式的初始化捕获用法。</p>\n<!-- 内容待补充 -->\n","site":{"data":{}},"excerpt":"","more":"<p>本文将介绍C++ Lambda表达式的初始化捕获用法。</p>\n<!-- 内容待补充 -->\n"},{"layout":"post","title":"iOS手势事件分发原理","subtitle":"iOSHitTest和PointInSide实现探究","date":"2017-06-30T16:00:00.000Z","author":"jack","header-img":"img/post-bg-ios9-web.jpg","catalog":true,"_content":"\nHitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理\n\n```\n- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event{\n    \n    //apple文档描述，不接受事件的情况\n    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha < 0.01) {\n        return nil;\n    }\n    \n    //如果当前View包含此Point\n    if ([self pointInside:point withEvent:event]) {\n        \n        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的\n        for (NSInteger i=self.subviews.count-1; i>=0; i--) {\n            \n            UIView* subView = [self.subviews objectAtIndex:i];\n            \n            //将父View的Point转换成子View坐标系的Point\n            CGPoint pointInSubView = [subView convertPoint:point fromView:self];\n            \n            //递归子View调用HitTest:\n            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];\n            \n            //找到了子View可以响应\n            if (resultView) {\n                return resultView;\n            }\n            \n        }\n        \n        //没有找到可以响应的子View，返回自己\n        return self;\n    }\n    \n    //返回nil，告诉上一级自己无法响应此事件\n    return nil;\n}\n```\n\n流程图总结\n\n![image.png](http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","source":"_posts/iOS手势事件分发原理.md","raw":"---\nlayout:     post\ntitle:      iOS手势事件分发原理\nsubtitle:   iOSHitTest和PointInSide实现探究\ndate:       2017-07-01\nauthor:     jack\nheader-img: img/post-bg-ios9-web.jpg\ncatalog: true\ntags:\n    - iOS\n---\n\nHitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理\n\n```\n- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event{\n    \n    //apple文档描述，不接受事件的情况\n    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha < 0.01) {\n        return nil;\n    }\n    \n    //如果当前View包含此Point\n    if ([self pointInside:point withEvent:event]) {\n        \n        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的\n        for (NSInteger i=self.subviews.count-1; i>=0; i--) {\n            \n            UIView* subView = [self.subviews objectAtIndex:i];\n            \n            //将父View的Point转换成子View坐标系的Point\n            CGPoint pointInSubView = [subView convertPoint:point fromView:self];\n            \n            //递归子View调用HitTest:\n            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];\n            \n            //找到了子View可以响应\n            if (resultView) {\n                return resultView;\n            }\n            \n        }\n        \n        //没有找到可以响应的子View，返回自己\n        return self;\n    }\n    \n    //返回nil，告诉上一级自己无法响应此事件\n    return nil;\n}\n```\n\n流程图总结\n\n![image.png](http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","slug":"iOS手势事件分发原理","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8g001u1xcocjvp0lls","content":"<p>HitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //apple文档描述，不接受事件的情况</span><br><span class=\"line\">    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha &lt; 0.01) &#123;</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //如果当前View包含此Point</span><br><span class=\"line\">    if ([self pointInside:point withEvent:event]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的</span><br><span class=\"line\">        for (NSInteger i=self.subviews.count-1; i&gt;=0; i--) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            UIView* subView = [self.subviews objectAtIndex:i];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //将父View的Point转换成子View坐标系的Point</span><br><span class=\"line\">            CGPoint pointInSubView = [subView convertPoint:point fromView:self];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //递归子View调用HitTest:</span><br><span class=\"line\">            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //找到了子View可以响应</span><br><span class=\"line\">            if (resultView) &#123;</span><br><span class=\"line\">                return resultView;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //没有找到可以响应的子View，返回自己</span><br><span class=\"line\">        return self;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //返回nil，告诉上一级自己无法响应此事件</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<span id=\"more\"></span>\n\n<p>流程图总结</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"<p>HitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //apple文档描述，不接受事件的情况</span><br><span class=\"line\">    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha &lt; 0.01) &#123;</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //如果当前View包含此Point</span><br><span class=\"line\">    if ([self pointInside:point withEvent:event]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的</span><br><span class=\"line\">        for (NSInteger i=self.subviews.count-1; i&gt;=0; i--) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            UIView* subView = [self.subviews objectAtIndex:i];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //将父View的Point转换成子View坐标系的Point</span><br><span class=\"line\">            CGPoint pointInSubView = [subView convertPoint:point fromView:self];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //递归子View调用HitTest:</span><br><span class=\"line\">            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];</span><br><span class=\"line\">            </span><br><span class=\"line\">            //找到了子View可以响应</span><br><span class=\"line\">            if (resultView) &#123;</span><br><span class=\"line\">                return resultView;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //没有找到可以响应的子View，返回自己</span><br><span class=\"line\">        return self;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //返回nil，告诉上一级自己无法响应此事件</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<p>流程图总结</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>"},{"title":"pthread_create设置栈size","date":"2024-07-28T02:44:09.000Z","_content":"\n本文演示如何在使用 `pthread_create` 创建线程时设置自定义的栈大小。通过 `pthread_attr_setstacksize` 函数可以控制线程的栈空间大小，这在需要大量栈空间或者优化内存使用时非常有用。\n\n<!-- more -->\n\n```cpp\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid* threadFunction(void* arg) {\n    // 线程的执行代码\n    printf(\"Thread is running\\n\");\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    pthread_attr_t attr;\n    size_t stackSize = 2 * 1024 * 1024; // 设置栈大小为2 MiB\n\n    // 初始化线程属性\n    if (pthread_attr_init(&attr) != 0) {\n        perror(\"pthread_attr_init\");\n        return EXIT_FAILURE;\n    }\n\n    // 设置线程栈大小\n    if (pthread_attr_setstacksize(&attr, stackSize) != 0) {\n        perror(\"pthread_attr_setstacksize\");\n        return EXIT_FAILURE;\n    }\n\n    // 创建线程\n    if (pthread_create(&thread, &attr, threadFunction, NULL) != 0) {\n        perror(\"pthread_create\");\n        return EXIT_FAILURE;\n    }\n\n    // 等待线程结束\n    if (pthread_join(thread, NULL) != 0) {\n        perror(\"pthread_join\");\n        return EXIT_FAILURE;\n    }\n\n    // 销毁线程属性\n    if (pthread_attr_destroy(&attr) != 0) {\n        perror(\"pthread_attr_destroy\");\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n```","source":"_posts/pthread-create设置栈size.md","raw":"---\ntitle: pthread_create设置栈size\ndate: 2024-07-28 10:44:09\ntags:\n---\n\n本文演示如何在使用 `pthread_create` 创建线程时设置自定义的栈大小。通过 `pthread_attr_setstacksize` 函数可以控制线程的栈空间大小，这在需要大量栈空间或者优化内存使用时非常有用。\n\n<!-- more -->\n\n```cpp\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid* threadFunction(void* arg) {\n    // 线程的执行代码\n    printf(\"Thread is running\\n\");\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    pthread_attr_t attr;\n    size_t stackSize = 2 * 1024 * 1024; // 设置栈大小为2 MiB\n\n    // 初始化线程属性\n    if (pthread_attr_init(&attr) != 0) {\n        perror(\"pthread_attr_init\");\n        return EXIT_FAILURE;\n    }\n\n    // 设置线程栈大小\n    if (pthread_attr_setstacksize(&attr, stackSize) != 0) {\n        perror(\"pthread_attr_setstacksize\");\n        return EXIT_FAILURE;\n    }\n\n    // 创建线程\n    if (pthread_create(&thread, &attr, threadFunction, NULL) != 0) {\n        perror(\"pthread_create\");\n        return EXIT_FAILURE;\n    }\n\n    // 等待线程结束\n    if (pthread_join(thread, NULL) != 0) {\n        perror(\"pthread_join\");\n        return EXIT_FAILURE;\n    }\n\n    // 销毁线程属性\n    if (pthread_attr_destroy(&attr) != 0) {\n        perror(\"pthread_attr_destroy\");\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n```","slug":"pthread-create设置栈size","published":1,"updated":"2025-06-07T09:24:45.445Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8i001x1xco9vr4f7om","content":"<p>本文演示如何在使用 <code>pthread_create</code> 创建线程时设置自定义的栈大小。通过 <code>pthread_attr_setstacksize</code> 函数可以控制线程的栈空间大小，这在需要大量栈空间或者优化内存使用时非常有用。</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span>* <span class=\"title\">threadFunction</span><span class=\"params\">(<span class=\"type\">void</span>* arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 线程的执行代码</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Thread is running\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> thread;</span><br><span class=\"line\">    <span class=\"type\">pthread_attr_t</span> attr;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> stackSize = <span class=\"number\">2</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>; <span class=\"comment\">// 设置栈大小为2 MiB</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化线程属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_attr_init</span>(&amp;attr) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_attr_init&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置线程栈大小</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_attr_setstacksize</span>(&amp;attr, stackSize) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_attr_setstacksize&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_create</span>(&amp;thread, &amp;attr, threadFunction, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_create&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待线程结束</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_join</span>(thread, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_join&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 销毁线程属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_attr_destroy</span>(&amp;attr) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_attr_destroy&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>本文演示如何在使用 <code>pthread_create</code> 创建线程时设置自定义的栈大小。通过 <code>pthread_attr_setstacksize</code> 函数可以控制线程的栈空间大小，这在需要大量栈空间或者优化内存使用时非常有用。</p>","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span>* <span class=\"title\">threadFunction</span><span class=\"params\">(<span class=\"type\">void</span>* arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 线程的执行代码</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Thread is running\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> thread;</span><br><span class=\"line\">    <span class=\"type\">pthread_attr_t</span> attr;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> stackSize = <span class=\"number\">2</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>; <span class=\"comment\">// 设置栈大小为2 MiB</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化线程属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_attr_init</span>(&amp;attr) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_attr_init&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置线程栈大小</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_attr_setstacksize</span>(&amp;attr, stackSize) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_attr_setstacksize&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_create</span>(&amp;thread, &amp;attr, threadFunction, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_create&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待线程结束</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_join</span>(thread, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_join&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 销毁线程属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pthread_attr_destroy</span>(&amp;attr) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;pthread_attr_destroy&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"shell和子shell环境变量","date":"2024-09-29T06:12:02.000Z","_content":"\n在 Shell 脚本中，命令替换（command substitution）是指将命令的输出作为字符串插入到另一个命令中。命令替换通常使用反引号（`` `command` ``）或 `$()` 语法来实现。命令替换会在一个子 Shell 中执行指定的命令，这意味着在子 Shell 中定义的变量不会影响父 Shell 中的变量。\n\n### 1. 子 Shell 的概念\n\n- **子 Shell**: 当你在 Shell 中执行一个命令替换时，Shell 会创建一个新的子 Shell 来执行该命令。子 Shell 是父 Shell 的一个独立实例，具有自己的环境和变量。\n\n### 2. 变量作用域\n\n- 在子 Shell 中定义的变量不会影响父 Shell 中的变量。相反，父 Shell 中的变量也无法在子 Shell 中被访问。\n\n### 3. 示例\n\n以下是一个示例，展示了命令替换如何在子 Shell 中运行命令，并且如何影响变量的作用域。\n\n```bash\n#!/bin/bash\n\n# 定义一个变量\nvar=\"Hello from parent shell\"\n\n# 使用命令替换\nresult=$(echo $var)\n\n# 输出结果\necho \"Result from command substitution: $result\"\n\n# 在子 Shell 中修改变量\nresult=$(echo \"Hello from child shell\"; var=\"Hello from child shell\")\n\n# 输出结果\necho \"Result after child shell: $result\"\necho \"Variable in parent shell: $var\"\n```\n\n### 4. 运行结果\n\n如果你运行上述脚本，输出将是：\n\n```\nResult from command substitution: Hello from parent shell\nResult after child shell: Hello from child shell\nVariable in parent shell: Hello from parent shell\n```\n\n### 5. 解释\n\n- **第一部分**: \n  - `var=\"Hello from parent shell\"` 定义了一个变量 `var` 在父 Shell 中。\n  - `result=$(echo $var)` 使用命令替换，将 `var` 的值传递给 `result`。此时，`result` 的值为 `Hello from parent shell`。\n\n- **第二部分**:\n  - `result=$(echo \"Hello from child shell\"; var=\"Hello from child shell\")` 在子 Shell 中执行。虽然在子 Shell 中修改了 `var` 的值，但这个修改不会影响父 Shell 中的 `var` 变量。\n  - `result` 的值被设置为 `Hello from child shell`，但父 Shell 中的 `var` 仍然保持为 `Hello from parent shell`。\n\n### 6. 总结\n\n命令替换会在子 Shell 中执行命令，因此在子 Shell 中定义的变量不会影响父 Shell 中的变量。这种行为是 Shell 的一个重要特性，理解这一点对于编写有效的 Shell 脚本非常重要。","source":"_posts/shell和子shell环境变量.md","raw":"---\ntitle: shell和子shell环境变量\ndate: 2024-09-29 14:12:02\ntags:\n---\n\n在 Shell 脚本中，命令替换（command substitution）是指将命令的输出作为字符串插入到另一个命令中。命令替换通常使用反引号（`` `command` ``）或 `$()` 语法来实现。命令替换会在一个子 Shell 中执行指定的命令，这意味着在子 Shell 中定义的变量不会影响父 Shell 中的变量。\n\n### 1. 子 Shell 的概念\n\n- **子 Shell**: 当你在 Shell 中执行一个命令替换时，Shell 会创建一个新的子 Shell 来执行该命令。子 Shell 是父 Shell 的一个独立实例，具有自己的环境和变量。\n\n### 2. 变量作用域\n\n- 在子 Shell 中定义的变量不会影响父 Shell 中的变量。相反，父 Shell 中的变量也无法在子 Shell 中被访问。\n\n### 3. 示例\n\n以下是一个示例，展示了命令替换如何在子 Shell 中运行命令，并且如何影响变量的作用域。\n\n```bash\n#!/bin/bash\n\n# 定义一个变量\nvar=\"Hello from parent shell\"\n\n# 使用命令替换\nresult=$(echo $var)\n\n# 输出结果\necho \"Result from command substitution: $result\"\n\n# 在子 Shell 中修改变量\nresult=$(echo \"Hello from child shell\"; var=\"Hello from child shell\")\n\n# 输出结果\necho \"Result after child shell: $result\"\necho \"Variable in parent shell: $var\"\n```\n\n### 4. 运行结果\n\n如果你运行上述脚本，输出将是：\n\n```\nResult from command substitution: Hello from parent shell\nResult after child shell: Hello from child shell\nVariable in parent shell: Hello from parent shell\n```\n\n### 5. 解释\n\n- **第一部分**: \n  - `var=\"Hello from parent shell\"` 定义了一个变量 `var` 在父 Shell 中。\n  - `result=$(echo $var)` 使用命令替换，将 `var` 的值传递给 `result`。此时，`result` 的值为 `Hello from parent shell`。\n\n- **第二部分**:\n  - `result=$(echo \"Hello from child shell\"; var=\"Hello from child shell\")` 在子 Shell 中执行。虽然在子 Shell 中修改了 `var` 的值，但这个修改不会影响父 Shell 中的 `var` 变量。\n  - `result` 的值被设置为 `Hello from child shell`，但父 Shell 中的 `var` 仍然保持为 `Hello from parent shell`。\n\n### 6. 总结\n\n命令替换会在子 Shell 中执行命令，因此在子 Shell 中定义的变量不会影响父 Shell 中的变量。这种行为是 Shell 的一个重要特性，理解这一点对于编写有效的 Shell 脚本非常重要。","slug":"shell和子shell环境变量","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8j001z1xco363vef7e","content":"<p>在 Shell 脚本中，命令替换（command substitution）是指将命令的输出作为字符串插入到另一个命令中。命令替换通常使用反引号（<code>`command`</code>）或 <code>$()</code> 语法来实现。命令替换会在一个子 Shell 中执行指定的命令，这意味着在子 Shell 中定义的变量不会影响父 Shell 中的变量。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"1-子-Shell-的概念\"><a href=\"#1-子-Shell-的概念\" class=\"headerlink\" title=\"1. 子 Shell 的概念\"></a>1. 子 Shell 的概念</h3><ul>\n<li><strong>子 Shell</strong>: 当你在 Shell 中执行一个命令替换时，Shell 会创建一个新的子 Shell 来执行该命令。子 Shell 是父 Shell 的一个独立实例，具有自己的环境和变量。</li>\n</ul>\n<h3 id=\"2-变量作用域\"><a href=\"#2-变量作用域\" class=\"headerlink\" title=\"2. 变量作用域\"></a>2. 变量作用域</h3><ul>\n<li>在子 Shell 中定义的变量不会影响父 Shell 中的变量。相反，父 Shell 中的变量也无法在子 Shell 中被访问。</li>\n</ul>\n<h3 id=\"3-示例\"><a href=\"#3-示例\" class=\"headerlink\" title=\"3. 示例\"></a>3. 示例</h3><p>以下是一个示例，展示了命令替换如何在子 Shell 中运行命令，并且如何影响变量的作用域。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义一个变量</span></span><br><span class=\"line\">var=<span class=\"string\">&quot;Hello from parent shell&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用命令替换</span></span><br><span class=\"line\">result=$(<span class=\"built_in\">echo</span> <span class=\"variable\">$var</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Result from command substitution: <span class=\"variable\">$result</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在子 Shell 中修改变量</span></span><br><span class=\"line\">result=$(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello from child shell&quot;</span>; var=<span class=\"string\">&quot;Hello from child shell&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Result after child shell: <span class=\"variable\">$result</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Variable in parent shell: <span class=\"variable\">$var</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-运行结果\"><a href=\"#4-运行结果\" class=\"headerlink\" title=\"4. 运行结果\"></a>4. 运行结果</h3><p>如果你运行上述脚本，输出将是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result from command substitution: Hello from parent shell</span><br><span class=\"line\">Result after child shell: Hello from child shell</span><br><span class=\"line\">Variable in parent shell: Hello from parent shell</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-解释\"><a href=\"#5-解释\" class=\"headerlink\" title=\"5. 解释\"></a>5. 解释</h3><ul>\n<li><p><strong>第一部分</strong>: </p>\n<ul>\n<li><code>var=&quot;Hello from parent shell&quot;</code> 定义了一个变量 <code>var</code> 在父 Shell 中。</li>\n<li><code>result=$(echo $var)</code> 使用命令替换，将 <code>var</code> 的值传递给 <code>result</code>。此时，<code>result</code> 的值为 <code>Hello from parent shell</code>。</li>\n</ul>\n</li>\n<li><p><strong>第二部分</strong>:</p>\n<ul>\n<li><code>result=$(echo &quot;Hello from child shell&quot;; var=&quot;Hello from child shell&quot;)</code> 在子 Shell 中执行。虽然在子 Shell 中修改了 <code>var</code> 的值，但这个修改不会影响父 Shell 中的 <code>var</code> 变量。</li>\n<li><code>result</code> 的值被设置为 <code>Hello from child shell</code>，但父 Shell 中的 <code>var</code> 仍然保持为 <code>Hello from parent shell</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><p>命令替换会在子 Shell 中执行命令，因此在子 Shell 中定义的变量不会影响父 Shell 中的变量。这种行为是 Shell 的一个重要特性，理解这一点对于编写有效的 Shell 脚本非常重要。</p>\n","site":{"data":{}},"excerpt":"<p>在 Shell 脚本中，命令替换（command substitution）是指将命令的输出作为字符串插入到另一个命令中。命令替换通常使用反引号（<code>`command`</code>）或 <code>$()</code> 语法来实现。命令替换会在一个子 Shell 中执行指定的命令，这意味着在子 Shell 中定义的变量不会影响父 Shell 中的变量。</p>","more":"<h3 id=\"1-子-Shell-的概念\"><a href=\"#1-子-Shell-的概念\" class=\"headerlink\" title=\"1. 子 Shell 的概念\"></a>1. 子 Shell 的概念</h3><ul>\n<li><strong>子 Shell</strong>: 当你在 Shell 中执行一个命令替换时，Shell 会创建一个新的子 Shell 来执行该命令。子 Shell 是父 Shell 的一个独立实例，具有自己的环境和变量。</li>\n</ul>\n<h3 id=\"2-变量作用域\"><a href=\"#2-变量作用域\" class=\"headerlink\" title=\"2. 变量作用域\"></a>2. 变量作用域</h3><ul>\n<li>在子 Shell 中定义的变量不会影响父 Shell 中的变量。相反，父 Shell 中的变量也无法在子 Shell 中被访问。</li>\n</ul>\n<h3 id=\"3-示例\"><a href=\"#3-示例\" class=\"headerlink\" title=\"3. 示例\"></a>3. 示例</h3><p>以下是一个示例，展示了命令替换如何在子 Shell 中运行命令，并且如何影响变量的作用域。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义一个变量</span></span><br><span class=\"line\">var=<span class=\"string\">&quot;Hello from parent shell&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用命令替换</span></span><br><span class=\"line\">result=$(<span class=\"built_in\">echo</span> <span class=\"variable\">$var</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Result from command substitution: <span class=\"variable\">$result</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在子 Shell 中修改变量</span></span><br><span class=\"line\">result=$(<span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello from child shell&quot;</span>; var=<span class=\"string\">&quot;Hello from child shell&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Result after child shell: <span class=\"variable\">$result</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Variable in parent shell: <span class=\"variable\">$var</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-运行结果\"><a href=\"#4-运行结果\" class=\"headerlink\" title=\"4. 运行结果\"></a>4. 运行结果</h3><p>如果你运行上述脚本，输出将是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result from command substitution: Hello from parent shell</span><br><span class=\"line\">Result after child shell: Hello from child shell</span><br><span class=\"line\">Variable in parent shell: Hello from parent shell</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-解释\"><a href=\"#5-解释\" class=\"headerlink\" title=\"5. 解释\"></a>5. 解释</h3><ul>\n<li><p><strong>第一部分</strong>: </p>\n<ul>\n<li><code>var=&quot;Hello from parent shell&quot;</code> 定义了一个变量 <code>var</code> 在父 Shell 中。</li>\n<li><code>result=$(echo $var)</code> 使用命令替换，将 <code>var</code> 的值传递给 <code>result</code>。此时，<code>result</code> 的值为 <code>Hello from parent shell</code>。</li>\n</ul>\n</li>\n<li><p><strong>第二部分</strong>:</p>\n<ul>\n<li><code>result=$(echo &quot;Hello from child shell&quot;; var=&quot;Hello from child shell&quot;)</code> 在子 Shell 中执行。虽然在子 Shell 中修改了 <code>var</code> 的值，但这个修改不会影响父 Shell 中的 <code>var</code> 变量。</li>\n<li><code>result</code> 的值被设置为 <code>Hello from child shell</code>，但父 Shell 中的 <code>var</code> 仍然保持为 <code>Hello from parent shell</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h3><p>命令替换会在子 Shell 中执行命令，因此在子 Shell 中定义的变量不会影响父 Shell 中的变量。这种行为是 Shell 的一个重要特性，理解这一点对于编写有效的 Shell 脚本非常重要。</p>"},{"title":"smoothStep实现","date":"2023-12-22T11:51:30.000Z","draft":true,"_content":"\n本文将介绍smoothStep函数的实现原理和应用。\n\n<!-- 内容待补充 -->\n","source":"_posts/smoothStep实现.md","raw":"---\ntitle: smoothStep实现\ndate: 2023-12-22 19:51:30\ntags:\ndraft: true\n---\n\n本文将介绍smoothStep函数的实现原理和应用。\n\n<!-- 内容待补充 -->\n","slug":"smoothStep实现","published":1,"updated":"2025-06-07T09:39:06.409Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8j00221xco9zxw27gu","content":"<p>本文将介绍smoothStep函数的实现原理和应用。</p>\n<!-- 内容待补充 -->\n","site":{"data":{}},"excerpt":"","more":"<p>本文将介绍smoothStep函数的实现原理和应用。</p>\n<!-- 内容待补充 -->\n"},{"title":"tag dispatch","date":"2023-12-24T06:44:19.000Z","_content":"\n#### 对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\n\n```cpp\nnamespace TagDispatch {\n\ntemplate <typename T>\nvoid fun(T&& params) {\n    std::vector<std::string> temp;\n    temp.emplace_back(std::forward<T>(params));\n    std::cout << \"called fun(T&& params)\" << std::endl;\n}\n\nvoid fun(int a) {\n    std::cout << \"called fun(int a)\" << std::endl;\n}\n\ntemplate <typename T>\nvoid fwd(T&& params) {\n    fun(std::forward<T>(params));\n}\n\nvoid test()\n{\n    fwd(\"abc\"); //suc\n    int a = 0;\n    fwd(a);     //suc\n    \n    short b = 10;\n    //fwd(b);     //failed, 匹配到了通用引用函数\n    \n}\n\nint main(int argc, const char * argv[]) {    \n    TagDispatch::test();\n\n    return 0;\n}\n\n}\n```\n\n\n#### 使用TagDispath，来解决匹配的问题\n\n```cpp\nnamespace TagDispatch {\n\ntemplate <typename T>\nvoid fun2(T&& params, std::false_type) {\n    std::vector<std::string> temp;\n    temp.emplace_back(std::forward<T>(params));\n    std::cout << \"called fun(T&& params)\" << std::endl;\n}\n\nvoid fun2(int a, std::true_type) {\n    std::cout << \"called fun(int a)\" << std::endl;\n}\n\ntemplate <typename T>\nvoid fwd(T&& params) {\n    fun2(std::forward<T>(params), std::is_integral<typename std::remove_reference<T>::type>());\n}\n\nvoid test()\n{\n    fwd(\"abc\"); //suc\n    int a = 0;\n    fwd(a);     //suc\n    \n    short b = 10;\n    fwd(b);     //succeed, 匹配到了通用引用函数\n}\n\n}\n\n```\n\n#### 针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配\n\n```cpp\nclass Person\n{\npublic:\n    template <\n        typename T,\n        typename = std::enable_if_t<\n            !std::is_base_of<Person, std::decay_t<T>>::value    // 防止调用拷贝和移动构造函数，并且考虑了子类\n            &&                                                  // decay,移除指针引用和cv修饰符\n            !std::is_integral<std::remove_reference_t<T>>::value\n        >\n    >\n    explicit Person(T&& params) {\n        std::vector<std::string> temp;\n        temp.emplace_back(std::forward<T>(params));\n        std::cout << \"Person(T&& params)\" << std::endl;\n    }\n    \n    explicit Person(int a) {\n        std::cout << \"Person(int a)\" << std::endl;\n    }\n};\n\nvoid testCtrOverload() {\n\n    short b = 10;\n    Person person(b);\n    \n}\n\n}\n```","source":"_posts/tag-dispatch.md","raw":"---\ntitle: tag dispatch\ndate: 2023-12-24 14:44:19\ntags:\n---\n\n#### 对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\n\n```cpp\nnamespace TagDispatch {\n\ntemplate <typename T>\nvoid fun(T&& params) {\n    std::vector<std::string> temp;\n    temp.emplace_back(std::forward<T>(params));\n    std::cout << \"called fun(T&& params)\" << std::endl;\n}\n\nvoid fun(int a) {\n    std::cout << \"called fun(int a)\" << std::endl;\n}\n\ntemplate <typename T>\nvoid fwd(T&& params) {\n    fun(std::forward<T>(params));\n}\n\nvoid test()\n{\n    fwd(\"abc\"); //suc\n    int a = 0;\n    fwd(a);     //suc\n    \n    short b = 10;\n    //fwd(b);     //failed, 匹配到了通用引用函数\n    \n}\n\nint main(int argc, const char * argv[]) {    \n    TagDispatch::test();\n\n    return 0;\n}\n\n}\n```\n\n\n#### 使用TagDispath，来解决匹配的问题\n\n```cpp\nnamespace TagDispatch {\n\ntemplate <typename T>\nvoid fun2(T&& params, std::false_type) {\n    std::vector<std::string> temp;\n    temp.emplace_back(std::forward<T>(params));\n    std::cout << \"called fun(T&& params)\" << std::endl;\n}\n\nvoid fun2(int a, std::true_type) {\n    std::cout << \"called fun(int a)\" << std::endl;\n}\n\ntemplate <typename T>\nvoid fwd(T&& params) {\n    fun2(std::forward<T>(params), std::is_integral<typename std::remove_reference<T>::type>());\n}\n\nvoid test()\n{\n    fwd(\"abc\"); //suc\n    int a = 0;\n    fwd(a);     //suc\n    \n    short b = 10;\n    fwd(b);     //succeed, 匹配到了通用引用函数\n}\n\n}\n\n```\n\n#### 针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配\n\n```cpp\nclass Person\n{\npublic:\n    template <\n        typename T,\n        typename = std::enable_if_t<\n            !std::is_base_of<Person, std::decay_t<T>>::value    // 防止调用拷贝和移动构造函数，并且考虑了子类\n            &&                                                  // decay,移除指针引用和cv修饰符\n            !std::is_integral<std::remove_reference_t<T>>::value\n        >\n    >\n    explicit Person(T&& params) {\n        std::vector<std::string> temp;\n        temp.emplace_back(std::forward<T>(params));\n        std::cout << \"Person(T&& params)\" << std::endl;\n    }\n    \n    explicit Person(int a) {\n        std::cout << \"Person(int a)\" << std::endl;\n    }\n};\n\nvoid testCtrOverload() {\n\n    short b = 10;\n    Person person(b);\n    \n}\n\n}\n```","slug":"tag-dispatch","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8j00241xcoe3e137mh","content":"<h4 id=\"对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\"><a href=\"#对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\" class=\"headerlink\" title=\"对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\"></a>对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> TagDispatch &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; temp;</span><br><span class=\"line\">    temp.<span class=\"built_in\">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fwd</span><span class=\"params\">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fun</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(<span class=\"string\">&quot;abc&quot;</span>); <span class=\"comment\">//suc</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(a);     <span class=\"comment\">//suc</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">short</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">//fwd(b);     //failed, 匹配到了通用引用函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> * argv[])</span> </span>&#123;    </span><br><span class=\"line\">    TagDispatch::<span class=\"built_in\">test</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<span id=\"more\"></span>\n\n\n<h4 id=\"使用TagDispath，来解决匹配的问题\"><a href=\"#使用TagDispath，来解决匹配的问题\" class=\"headerlink\" title=\"使用TagDispath，来解决匹配的问题\"></a>使用TagDispath，来解决匹配的问题</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> TagDispatch &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun2</span><span class=\"params\">(T&amp;&amp; params, std::false_type)</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; temp;</span><br><span class=\"line\">    temp.<span class=\"built_in\">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun2</span><span class=\"params\">(<span class=\"type\">int</span> a, std::true_type)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fwd</span><span class=\"params\">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fun2</span>(std::forward&lt;T&gt;(params), std::is_integral&lt;<span class=\"keyword\">typename</span> std::remove_reference&lt;T&gt;::type&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(<span class=\"string\">&quot;abc&quot;</span>); <span class=\"comment\">//suc</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(a);     <span class=\"comment\">//suc</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">short</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(b);     <span class=\"comment\">//succeed, 匹配到了通用引用函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable-if来限制模板的匹配\"><a href=\"#针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable-if来限制模板的匹配\" class=\"headerlink\" title=\"针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配\"></a>针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;</span><br><span class=\"line\">        <span class=\"keyword\">typename</span> T,</span><br><span class=\"line\">        <span class=\"keyword\">typename</span> = std::<span class=\"type\">enable_if_t</span>&lt;</span><br><span class=\"line\">            !std::is_base_of&lt;Person, std::<span class=\"type\">decay_t</span>&lt;T&gt;&gt;::value    <span class=\"comment\">// 防止调用拷贝和移动构造函数，并且考虑了子类</span></span><br><span class=\"line\">            &amp;&amp;                                                  <span class=\"comment\">// decay,移除指针引用和cv修饰符</span></span><br><span class=\"line\">            !std::is_integral&lt;std::<span class=\"type\">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">    <span class=\"keyword\">explicit</span> <span class=\"built_in\">Person</span>(T&amp;&amp; params) &#123;</span><br><span class=\"line\">        std::vector&lt;std::string&gt; temp;</span><br><span class=\"line\">        temp.<span class=\"built_in\">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Person(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Person</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Person(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">testCtrOverload</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">short</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">person</span><span class=\"params\">(b)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h4 id=\"对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\"><a href=\"#对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\" class=\"headerlink\" title=\"对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string\"></a>对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> TagDispatch &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; temp;</span><br><span class=\"line\">    temp.<span class=\"built_in\">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fwd</span><span class=\"params\">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fun</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(<span class=\"string\">&quot;abc&quot;</span>); <span class=\"comment\">//suc</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(a);     <span class=\"comment\">//suc</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">short</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">//fwd(b);     //failed, 匹配到了通用引用函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> * argv[])</span> </span>&#123;    </span><br><span class=\"line\">    TagDispatch::<span class=\"built_in\">test</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"使用TagDispath，来解决匹配的问题\"><a href=\"#使用TagDispath，来解决匹配的问题\" class=\"headerlink\" title=\"使用TagDispath，来解决匹配的问题\"></a>使用TagDispath，来解决匹配的问题</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> TagDispatch &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun2</span><span class=\"params\">(T&amp;&amp; params, std::false_type)</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; temp;</span><br><span class=\"line\">    temp.<span class=\"built_in\">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun2</span><span class=\"params\">(<span class=\"type\">int</span> a, std::true_type)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;called fun(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fwd</span><span class=\"params\">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fun2</span>(std::forward&lt;T&gt;(params), std::is_integral&lt;<span class=\"keyword\">typename</span> std::remove_reference&lt;T&gt;::type&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(<span class=\"string\">&quot;abc&quot;</span>); <span class=\"comment\">//suc</span></span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(a);     <span class=\"comment\">//suc</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">short</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fwd</span>(b);     <span class=\"comment\">//succeed, 匹配到了通用引用函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable-if来限制模板的匹配\"><a href=\"#针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable-if来限制模板的匹配\" class=\"headerlink\" title=\"针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配\"></a>针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;</span><br><span class=\"line\">        <span class=\"keyword\">typename</span> T,</span><br><span class=\"line\">        <span class=\"keyword\">typename</span> = std::<span class=\"type\">enable_if_t</span>&lt;</span><br><span class=\"line\">            !std::is_base_of&lt;Person, std::<span class=\"type\">decay_t</span>&lt;T&gt;&gt;::value    <span class=\"comment\">// 防止调用拷贝和移动构造函数，并且考虑了子类</span></span><br><span class=\"line\">            &amp;&amp;                                                  <span class=\"comment\">// decay,移除指针引用和cv修饰符</span></span><br><span class=\"line\">            !std::is_integral&lt;std::<span class=\"type\">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">    <span class=\"keyword\">explicit</span> <span class=\"built_in\">Person</span>(T&amp;&amp; params) &#123;</span><br><span class=\"line\">        std::vector&lt;std::string&gt; temp;</span><br><span class=\"line\">        temp.<span class=\"built_in\">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Person(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Person</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Person(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">testCtrOverload</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">short</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">person</span><span class=\"params\">(b)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"std::nth_element实现","date":"2024-10-08T09:37:18.000Z","_content":"\n`std::nth_element` 是 C++ 标准库中的一个算法，用于在一个范围内重新排列元素，使得第 `n` 个元素位于其最终位置，并且该元素左侧的所有元素都小于或等于它，右侧的所有元素都大于或等于它。这个算法的时间复杂度为 O(n) 平均情况下，最坏情况下为 O(n^2)。\n\n### 实现原理\n\n`std::nth_element` 的实现通常基于快速选择算法（Quickselect），这是一个选择算法，类似于快速排序。其基本思路如下：\n\n1. **选择一个基准元素**: 从数组中选择一个基准元素（pivot）。\n2. **分区**: 将数组分为两部分：小于基准元素的部分和大于基准元素的部分。\n3. **递归选择**: 根据基准元素的位置与 `n` 的关系，决定在左侧还是右侧继续查找。\n\n### 代码实现\n\n以下是一个简单的 `std::nth_element` 的实现示例：\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib> // for std::rand\n\n// Partition function for Quickselect\ntemplate <typename RandomIt>\nRandomIt partition(RandomIt first, RandomIt last, RandomIt pivot) {\n    std::iter_swap(pivot, last - 1); // Move pivot to end\n    RandomIt storeIndex = first;\n\n    for (RandomIt it = first; it < last - 1; ++it) {\n        if (*it < *(last - 1)) {\n            std::iter_swap(it, storeIndex);\n            ++storeIndex;\n        }\n    }\n    std::iter_swap(storeIndex, last - 1); // Move pivot to its final place\n    return storeIndex;\n}\n\n// Quickselect function\ntemplate <typename RandomIt>\nvoid quickselect(RandomIt first, RandomIt last, size_t n) {\n    if (first < last) {\n        RandomIt pivot = first + std::rand() % (last - first); // Random pivot\n        pivot = partition(first, last, pivot);\n\n        if (pivot - first == n) {\n            return; // Found the nth element\n        } else if (pivot - first > n) {\n            quickselect(first, pivot, n); // Search in the left part\n        } else {\n            quickselect(pivot + 1, last, n - (pivot - first + 1)); // Search in the right part\n        }\n    }\n}\n\n// nth_element implementation\ntemplate <typename RandomIt>\nvoid my_nth_element(RandomIt first, RandomIt nth, RandomIt last) {\n    size_t n = nth - first;\n    quickselect(first, last, n);\n}\n\nint main() {\n    std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};\n    size_t n = 5; // We want the 5th element (0-based index)\n\n    my_nth_element(vec.begin(), vec.begin() + n, vec.end());\n\n    std::cout << \"The \" << n << \"th element is: \" << vec[n] << std::endl;\n\n    return 0;\n}\n```\n\n### 代码解释\n\n1. **Partition Function**: \n   - `partition` 函数将数组分为两部分，返回基准元素的最终位置。\n   - 它将基准元素移动到数组的末尾，然后遍历数组，将小于基准的元素移动到左侧。\n\n2. **Quickselect Function**:\n   - `quickselect` 函数递归地选择基准元素并进行分区，直到找到第 `n` 个元素。\n\n3. **My Nth Element Function**:\n   - `my_nth_element` 是用户定义的函数，调用 `quickselect` 来找到第 `n` 个元素。\n\n4. **Main Function**:\n   - 在 `main` 函数中，创建一个整数向量，调用 `my_nth_element`，并输出第 `n` 个元素。\n\n### 总结\n\n`std::nth_element` 的实现基于快速选择算法，能够高效地找到数组中第 `n` 个元素。上述代码展示了如何实现这一算法，并提供了一个简单的示例来演示其用法。","source":"_posts/std-nth-element实现.md","raw":"---\ntitle: 'std::nth_element实现'\ndate: 2024-10-08 17:37:18\ntags:\n---\n\n`std::nth_element` 是 C++ 标准库中的一个算法，用于在一个范围内重新排列元素，使得第 `n` 个元素位于其最终位置，并且该元素左侧的所有元素都小于或等于它，右侧的所有元素都大于或等于它。这个算法的时间复杂度为 O(n) 平均情况下，最坏情况下为 O(n^2)。\n\n### 实现原理\n\n`std::nth_element` 的实现通常基于快速选择算法（Quickselect），这是一个选择算法，类似于快速排序。其基本思路如下：\n\n1. **选择一个基准元素**: 从数组中选择一个基准元素（pivot）。\n2. **分区**: 将数组分为两部分：小于基准元素的部分和大于基准元素的部分。\n3. **递归选择**: 根据基准元素的位置与 `n` 的关系，决定在左侧还是右侧继续查找。\n\n### 代码实现\n\n以下是一个简单的 `std::nth_element` 的实现示例：\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib> // for std::rand\n\n// Partition function for Quickselect\ntemplate <typename RandomIt>\nRandomIt partition(RandomIt first, RandomIt last, RandomIt pivot) {\n    std::iter_swap(pivot, last - 1); // Move pivot to end\n    RandomIt storeIndex = first;\n\n    for (RandomIt it = first; it < last - 1; ++it) {\n        if (*it < *(last - 1)) {\n            std::iter_swap(it, storeIndex);\n            ++storeIndex;\n        }\n    }\n    std::iter_swap(storeIndex, last - 1); // Move pivot to its final place\n    return storeIndex;\n}\n\n// Quickselect function\ntemplate <typename RandomIt>\nvoid quickselect(RandomIt first, RandomIt last, size_t n) {\n    if (first < last) {\n        RandomIt pivot = first + std::rand() % (last - first); // Random pivot\n        pivot = partition(first, last, pivot);\n\n        if (pivot - first == n) {\n            return; // Found the nth element\n        } else if (pivot - first > n) {\n            quickselect(first, pivot, n); // Search in the left part\n        } else {\n            quickselect(pivot + 1, last, n - (pivot - first + 1)); // Search in the right part\n        }\n    }\n}\n\n// nth_element implementation\ntemplate <typename RandomIt>\nvoid my_nth_element(RandomIt first, RandomIt nth, RandomIt last) {\n    size_t n = nth - first;\n    quickselect(first, last, n);\n}\n\nint main() {\n    std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};\n    size_t n = 5; // We want the 5th element (0-based index)\n\n    my_nth_element(vec.begin(), vec.begin() + n, vec.end());\n\n    std::cout << \"The \" << n << \"th element is: \" << vec[n] << std::endl;\n\n    return 0;\n}\n```\n\n### 代码解释\n\n1. **Partition Function**: \n   - `partition` 函数将数组分为两部分，返回基准元素的最终位置。\n   - 它将基准元素移动到数组的末尾，然后遍历数组，将小于基准的元素移动到左侧。\n\n2. **Quickselect Function**:\n   - `quickselect` 函数递归地选择基准元素并进行分区，直到找到第 `n` 个元素。\n\n3. **My Nth Element Function**:\n   - `my_nth_element` 是用户定义的函数，调用 `quickselect` 来找到第 `n` 个元素。\n\n4. **Main Function**:\n   - 在 `main` 函数中，创建一个整数向量，调用 `my_nth_element`，并输出第 `n` 个元素。\n\n### 总结\n\n`std::nth_element` 的实现基于快速选择算法，能够高效地找到数组中第 `n` 个元素。上述代码展示了如何实现这一算法，并提供了一个简单的示例来演示其用法。","slug":"std-nth-element实现","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8j00271xco1mtm89ee","content":"<p><code>std::nth_element</code> 是 C++ 标准库中的一个算法，用于在一个范围内重新排列元素，使得第 <code>n</code> 个元素位于其最终位置，并且该元素左侧的所有元素都小于或等于它，右侧的所有元素都大于或等于它。这个算法的时间复杂度为 O(n) 平均情况下，最坏情况下为 O(n^2)。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p><code>std::nth_element</code> 的实现通常基于快速选择算法（Quickselect），这是一个选择算法，类似于快速排序。其基本思路如下：</p>\n<ol>\n<li><strong>选择一个基准元素</strong>: 从数组中选择一个基准元素（pivot）。</li>\n<li><strong>分区</strong>: 将数组分为两部分：小于基准元素的部分和大于基准元素的部分。</li>\n<li><strong>递归选择</strong>: 根据基准元素的位置与 <code>n</code> 的关系，决定在左侧还是右侧继续查找。</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>以下是一个简单的 <code>std::nth_element</code> 的实现示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span> <span class=\"comment\">// for std::rand</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Partition function for Quickselect</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> RandomIt&gt;</span><br><span class=\"line\"><span class=\"function\">RandomIt <span class=\"title\">partition</span><span class=\"params\">(RandomIt first, RandomIt last, RandomIt pivot)</span> </span>&#123;</span><br><span class=\"line\">    std::<span class=\"built_in\">iter_swap</span>(pivot, last - <span class=\"number\">1</span>); <span class=\"comment\">// Move pivot to end</span></span><br><span class=\"line\">    RandomIt storeIndex = first;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RandomIt it = first; it &lt; last - <span class=\"number\">1</span>; ++it) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*it &lt; *(last - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            std::<span class=\"built_in\">iter_swap</span>(it, storeIndex);</span><br><span class=\"line\">            ++storeIndex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::<span class=\"built_in\">iter_swap</span>(storeIndex, last - <span class=\"number\">1</span>); <span class=\"comment\">// Move pivot to its final place</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> storeIndex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Quickselect function</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> RandomIt&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickselect</span><span class=\"params\">(RandomIt first, RandomIt last, <span class=\"type\">size_t</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first &lt; last) &#123;</span><br><span class=\"line\">        RandomIt pivot = first + std::<span class=\"built_in\">rand</span>() % (last - first); <span class=\"comment\">// Random pivot</span></span><br><span class=\"line\">        pivot = <span class=\"built_in\">partition</span>(first, last, pivot);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pivot - first == n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// Found the nth element</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pivot - first &gt; n) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">quickselect</span>(first, pivot, n); <span class=\"comment\">// Search in the left part</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">quickselect</span>(pivot + <span class=\"number\">1</span>, last, n - (pivot - first + <span class=\"number\">1</span>)); <span class=\"comment\">// Search in the right part</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// nth_element implementation</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> RandomIt&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">my_nth_element</span><span class=\"params\">(RandomIt first, RandomIt nth, RandomIt last)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = nth - first;</span><br><span class=\"line\">    <span class=\"built_in\">quickselect</span>(first, last, n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; vec = &#123;<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = <span class=\"number\">5</span>; <span class=\"comment\">// We want the 5th element (0-based index)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">my_nth_element</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">begin</span>() + n, vec.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;The &quot;</span> &lt;&lt; n &lt;&lt; <span class=\"string\">&quot;th element is: &quot;</span> &lt;&lt; vec[n] &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码解释\"><a href=\"#代码解释\" class=\"headerlink\" title=\"代码解释\"></a>代码解释</h3><ol>\n<li><p><strong>Partition Function</strong>: </p>\n<ul>\n<li><code>partition</code> 函数将数组分为两部分，返回基准元素的最终位置。</li>\n<li>它将基准元素移动到数组的末尾，然后遍历数组，将小于基准的元素移动到左侧。</li>\n</ul>\n</li>\n<li><p><strong>Quickselect Function</strong>:</p>\n<ul>\n<li><code>quickselect</code> 函数递归地选择基准元素并进行分区，直到找到第 <code>n</code> 个元素。</li>\n</ul>\n</li>\n<li><p><strong>My Nth Element Function</strong>:</p>\n<ul>\n<li><code>my_nth_element</code> 是用户定义的函数，调用 <code>quickselect</code> 来找到第 <code>n</code> 个元素。</li>\n</ul>\n</li>\n<li><p><strong>Main Function</strong>:</p>\n<ul>\n<li>在 <code>main</code> 函数中，创建一个整数向量，调用 <code>my_nth_element</code>，并输出第 <code>n</code> 个元素。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>std::nth_element</code> 的实现基于快速选择算法，能够高效地找到数组中第 <code>n</code> 个元素。上述代码展示了如何实现这一算法，并提供了一个简单的示例来演示其用法。</p>\n","site":{"data":{}},"excerpt":"<p><code>std::nth_element</code> 是 C++ 标准库中的一个算法，用于在一个范围内重新排列元素，使得第 <code>n</code> 个元素位于其最终位置，并且该元素左侧的所有元素都小于或等于它，右侧的所有元素都大于或等于它。这个算法的时间复杂度为 O(n) 平均情况下，最坏情况下为 O(n^2)。</p>","more":"<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p><code>std::nth_element</code> 的实现通常基于快速选择算法（Quickselect），这是一个选择算法，类似于快速排序。其基本思路如下：</p>\n<ol>\n<li><strong>选择一个基准元素</strong>: 从数组中选择一个基准元素（pivot）。</li>\n<li><strong>分区</strong>: 将数组分为两部分：小于基准元素的部分和大于基准元素的部分。</li>\n<li><strong>递归选择</strong>: 根据基准元素的位置与 <code>n</code> 的关系，决定在左侧还是右侧继续查找。</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>以下是一个简单的 <code>std::nth_element</code> 的实现示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span> <span class=\"comment\">// for std::rand</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Partition function for Quickselect</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> RandomIt&gt;</span><br><span class=\"line\"><span class=\"function\">RandomIt <span class=\"title\">partition</span><span class=\"params\">(RandomIt first, RandomIt last, RandomIt pivot)</span> </span>&#123;</span><br><span class=\"line\">    std::<span class=\"built_in\">iter_swap</span>(pivot, last - <span class=\"number\">1</span>); <span class=\"comment\">// Move pivot to end</span></span><br><span class=\"line\">    RandomIt storeIndex = first;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RandomIt it = first; it &lt; last - <span class=\"number\">1</span>; ++it) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*it &lt; *(last - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            std::<span class=\"built_in\">iter_swap</span>(it, storeIndex);</span><br><span class=\"line\">            ++storeIndex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::<span class=\"built_in\">iter_swap</span>(storeIndex, last - <span class=\"number\">1</span>); <span class=\"comment\">// Move pivot to its final place</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> storeIndex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Quickselect function</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> RandomIt&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickselect</span><span class=\"params\">(RandomIt first, RandomIt last, <span class=\"type\">size_t</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first &lt; last) &#123;</span><br><span class=\"line\">        RandomIt pivot = first + std::<span class=\"built_in\">rand</span>() % (last - first); <span class=\"comment\">// Random pivot</span></span><br><span class=\"line\">        pivot = <span class=\"built_in\">partition</span>(first, last, pivot);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pivot - first == n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// Found the nth element</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pivot - first &gt; n) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">quickselect</span>(first, pivot, n); <span class=\"comment\">// Search in the left part</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">quickselect</span>(pivot + <span class=\"number\">1</span>, last, n - (pivot - first + <span class=\"number\">1</span>)); <span class=\"comment\">// Search in the right part</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// nth_element implementation</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> RandomIt&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">my_nth_element</span><span class=\"params\">(RandomIt first, RandomIt nth, RandomIt last)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = nth - first;</span><br><span class=\"line\">    <span class=\"built_in\">quickselect</span>(first, last, n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; vec = &#123;<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> n = <span class=\"number\">5</span>; <span class=\"comment\">// We want the 5th element (0-based index)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">my_nth_element</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">begin</span>() + n, vec.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;The &quot;</span> &lt;&lt; n &lt;&lt; <span class=\"string\">&quot;th element is: &quot;</span> &lt;&lt; vec[n] &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码解释\"><a href=\"#代码解释\" class=\"headerlink\" title=\"代码解释\"></a>代码解释</h3><ol>\n<li><p><strong>Partition Function</strong>: </p>\n<ul>\n<li><code>partition</code> 函数将数组分为两部分，返回基准元素的最终位置。</li>\n<li>它将基准元素移动到数组的末尾，然后遍历数组，将小于基准的元素移动到左侧。</li>\n</ul>\n</li>\n<li><p><strong>Quickselect Function</strong>:</p>\n<ul>\n<li><code>quickselect</code> 函数递归地选择基准元素并进行分区，直到找到第 <code>n</code> 个元素。</li>\n</ul>\n</li>\n<li><p><strong>My Nth Element Function</strong>:</p>\n<ul>\n<li><code>my_nth_element</code> 是用户定义的函数，调用 <code>quickselect</code> 来找到第 <code>n</code> 个元素。</li>\n</ul>\n</li>\n<li><p><strong>Main Function</strong>:</p>\n<ul>\n<li>在 <code>main</code> 函数中，创建一个整数向量，调用 <code>my_nth_element</code>，并输出第 <code>n</code> 个元素。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>std::nth_element</code> 的实现基于快速选择算法，能够高效地找到数组中第 <code>n</code> 个元素。上述代码展示了如何实现这一算法，并提供了一个简单的示例来演示其用法。</p>"},{"title":"traits设计和用法","date":"2024-09-29T09:25:47.000Z","_content":"\n在 C++ 中，**Traits**（特性）是一种设计模式，通常用于提供类型信息或行为的模板类。Traits 允许在编译时获取类型的特性，从而实现更灵活和可扩展的代码。Traits 模式广泛应用于标准库和现代 C++ 编程中，尤其是在模板编程和泛型编程中。\n\n### 1. Traits 的设计\n\nTraits 通常是一个模板类，专门用于提供与类型相关的信息。它们可以用于：\n\n- **类型特性**: 提供类型的属性（如是否是指针、是否是类等）。\n- **类型转换**: 提供类型的转换信息（如获取类型的基类、去除引用等）。\n- **类型操作**: 提供与类型相关的操作（如获取类型的大小、默认构造函数等）。\n\n### 2. Traits 的基本用法\n\n以下是一些常见的 Traits 用法示例：\n\n#### a. 类型特性\n\n使用 `std::is_integral` 来检查一个类型是否是整数类型：\n\n```cpp\n#include <iostream>\n#include <type_traits>\n\ntemplate<typename T>\nvoid checkType() {\n    if (std::is_integral<T>::value) {\n        std::cout << \"T is an integral type.\" << std::endl;\n    } else {\n        std::cout << \"T is not an integral type.\" << std::endl;\n    }\n}\n\nint main() {\n    checkType<int>();    // 输出: T is an integral type.\n    checkType<double>(); // 输出: T is not an integral type.\n    return 0;\n}\n```\n\n#### b. 自定义 Traits\n\n你可以定义自己的 Traits 类来提供特定类型的信息。例如，定义一个 Traits 类来获取类型的大小：\n\n```cpp\n#include <iostream>\n\ntemplate<typename T>\nstruct TypeTraits {\n    static const size_t size = sizeof(T);\n};\n\nint main() {\n    std::cout << \"Size of int: \" << TypeTraits<int>::size << std::endl; // 输出: Size of int: 4\n    std::cout << \"Size of double: \" << TypeTraits<double>::size << std::endl; // 输出: Size of double: 8\n    return 0;\n}\n```\n\n#### c. 结合 SFINAE\n\nTraits 可以与 SFINAE（Substitution Failure Is Not An Error）结合使用，以实现更复杂的模板特化。例如，选择性地启用某些函数：\n\n```cpp\n#include <iostream>\n#include <type_traits>\n\ntemplate<typename T>\ntypename std::enable_if<std::is_integral<T>::value>::type\nprocess(T value) {\n    std::cout << \"Processing integral type: \" << value << std::endl;\n}\n\ntemplate<typename T>\ntypename std::enable_if<!std::is_integral<T>::value>::type\nprocess(T value) {\n    std::cout << \"Processing non-integral type: \" << value << std::endl;\n}\n\nint main() {\n    process(42);        // 输出: Processing integral type: 42\n    process(3.14);     // 输出: Processing non-integral type: 3.14\n    return 0;\n}\n```\n\n### 3. Traits 的应用\n\nTraits 在 C++ 标准库中有广泛的应用，以下是一些常见的例子：\n\n- **`std::iterator_traits`**: 提供迭代器的类型信息，如值类型、指针类型等。\n- **`std::numeric_limits`**: 提供数值类型的特性，如最小值、最大值等。\n- **`std::enable_if`**: 用于条件性地启用模板特化。\n\n### 4. 总结\n\n- **Traits** 是一种强大的设计模式，允许在编译时获取类型信息和行为。\n- 它们可以用于类型特性、类型转换和类型操作，提供灵活性和可扩展性。\n- Traits 在 C++ 标准库中有广泛的应用，尤其是在模板编程和泛型编程中。\n\n通过使用 Traits，开发者可以编写更通用和可重用的代码，同时提高类型安全性和性能。","source":"_posts/traits设计和用法.md","raw":"---\ntitle: traits设计和用法\ndate: 2024-09-29 17:25:47\ntags:\n---\n\n在 C++ 中，**Traits**（特性）是一种设计模式，通常用于提供类型信息或行为的模板类。Traits 允许在编译时获取类型的特性，从而实现更灵活和可扩展的代码。Traits 模式广泛应用于标准库和现代 C++ 编程中，尤其是在模板编程和泛型编程中。\n\n### 1. Traits 的设计\n\nTraits 通常是一个模板类，专门用于提供与类型相关的信息。它们可以用于：\n\n- **类型特性**: 提供类型的属性（如是否是指针、是否是类等）。\n- **类型转换**: 提供类型的转换信息（如获取类型的基类、去除引用等）。\n- **类型操作**: 提供与类型相关的操作（如获取类型的大小、默认构造函数等）。\n\n### 2. Traits 的基本用法\n\n以下是一些常见的 Traits 用法示例：\n\n#### a. 类型特性\n\n使用 `std::is_integral` 来检查一个类型是否是整数类型：\n\n```cpp\n#include <iostream>\n#include <type_traits>\n\ntemplate<typename T>\nvoid checkType() {\n    if (std::is_integral<T>::value) {\n        std::cout << \"T is an integral type.\" << std::endl;\n    } else {\n        std::cout << \"T is not an integral type.\" << std::endl;\n    }\n}\n\nint main() {\n    checkType<int>();    // 输出: T is an integral type.\n    checkType<double>(); // 输出: T is not an integral type.\n    return 0;\n}\n```\n\n#### b. 自定义 Traits\n\n你可以定义自己的 Traits 类来提供特定类型的信息。例如，定义一个 Traits 类来获取类型的大小：\n\n```cpp\n#include <iostream>\n\ntemplate<typename T>\nstruct TypeTraits {\n    static const size_t size = sizeof(T);\n};\n\nint main() {\n    std::cout << \"Size of int: \" << TypeTraits<int>::size << std::endl; // 输出: Size of int: 4\n    std::cout << \"Size of double: \" << TypeTraits<double>::size << std::endl; // 输出: Size of double: 8\n    return 0;\n}\n```\n\n#### c. 结合 SFINAE\n\nTraits 可以与 SFINAE（Substitution Failure Is Not An Error）结合使用，以实现更复杂的模板特化。例如，选择性地启用某些函数：\n\n```cpp\n#include <iostream>\n#include <type_traits>\n\ntemplate<typename T>\ntypename std::enable_if<std::is_integral<T>::value>::type\nprocess(T value) {\n    std::cout << \"Processing integral type: \" << value << std::endl;\n}\n\ntemplate<typename T>\ntypename std::enable_if<!std::is_integral<T>::value>::type\nprocess(T value) {\n    std::cout << \"Processing non-integral type: \" << value << std::endl;\n}\n\nint main() {\n    process(42);        // 输出: Processing integral type: 42\n    process(3.14);     // 输出: Processing non-integral type: 3.14\n    return 0;\n}\n```\n\n### 3. Traits 的应用\n\nTraits 在 C++ 标准库中有广泛的应用，以下是一些常见的例子：\n\n- **`std::iterator_traits`**: 提供迭代器的类型信息，如值类型、指针类型等。\n- **`std::numeric_limits`**: 提供数值类型的特性，如最小值、最大值等。\n- **`std::enable_if`**: 用于条件性地启用模板特化。\n\n### 4. 总结\n\n- **Traits** 是一种强大的设计模式，允许在编译时获取类型信息和行为。\n- 它们可以用于类型特性、类型转换和类型操作，提供灵活性和可扩展性。\n- Traits 在 C++ 标准库中有广泛的应用，尤其是在模板编程和泛型编程中。\n\n通过使用 Traits，开发者可以编写更通用和可重用的代码，同时提高类型安全性和性能。","slug":"traits设计和用法","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8j00291xcodiurcr97","content":"<p>在 C++ 中，<strong>Traits</strong>（特性）是一种设计模式，通常用于提供类型信息或行为的模板类。Traits 允许在编译时获取类型的特性，从而实现更灵活和可扩展的代码。Traits 模式广泛应用于标准库和现代 C++ 编程中，尤其是在模板编程和泛型编程中。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"1-Traits-的设计\"><a href=\"#1-Traits-的设计\" class=\"headerlink\" title=\"1. Traits 的设计\"></a>1. Traits 的设计</h3><p>Traits 通常是一个模板类，专门用于提供与类型相关的信息。它们可以用于：</p>\n<ul>\n<li><strong>类型特性</strong>: 提供类型的属性（如是否是指针、是否是类等）。</li>\n<li><strong>类型转换</strong>: 提供类型的转换信息（如获取类型的基类、去除引用等）。</li>\n<li><strong>类型操作</strong>: 提供与类型相关的操作（如获取类型的大小、默认构造函数等）。</li>\n</ul>\n<h3 id=\"2-Traits-的基本用法\"><a href=\"#2-Traits-的基本用法\" class=\"headerlink\" title=\"2. Traits 的基本用法\"></a>2. Traits 的基本用法</h3><p>以下是一些常见的 Traits 用法示例：</p>\n<h4 id=\"a-类型特性\"><a href=\"#a-类型特性\" class=\"headerlink\" title=\"a. 类型特性\"></a>a. 类型特性</h4><p>使用 <code>std::is_integral</code> 来检查一个类型是否是整数类型：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checkType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::is_integral&lt;T&gt;::value) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;T is an integral type.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;T is not an integral type.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkType</span>&lt;<span class=\"type\">int</span>&gt;();    <span class=\"comment\">// 输出: T is an integral type.</span></span><br><span class=\"line\">    <span class=\"built_in\">checkType</span>&lt;<span class=\"type\">double</span>&gt;(); <span class=\"comment\">// 输出: T is not an integral type.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"b-自定义-Traits\"><a href=\"#b-自定义-Traits\" class=\"headerlink\" title=\"b. 自定义 Traits\"></a>b. 自定义 Traits</h4><p>你可以定义自己的 Traits 类来提供特定类型的信息。例如，定义一个 Traits 类来获取类型的大小：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TypeTraits</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> size = <span class=\"built_in\">sizeof</span>(T);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Size of int: &quot;</span> &lt;&lt; TypeTraits&lt;<span class=\"type\">int</span>&gt;::size &lt;&lt; std::endl; <span class=\"comment\">// 输出: Size of int: 4</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Size of double: &quot;</span> &lt;&lt; TypeTraits&lt;<span class=\"type\">double</span>&gt;::size &lt;&lt; std::endl; <span class=\"comment\">// 输出: Size of double: 8</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"c-结合-SFINAE\"><a href=\"#c-结合-SFINAE\" class=\"headerlink\" title=\"c. 结合 SFINAE\"></a>c. 结合 SFINAE</h4><p>Traits 可以与 SFINAE（Substitution Failure Is Not An Error）结合使用，以实现更复杂的模板特化。例如，选择性地启用某些函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::<span class=\"function\">type</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">process</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Processing integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">typename</span> std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::<span class=\"function\">type</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">process</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Processing non-integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">process</span>(<span class=\"number\">42</span>);        <span class=\"comment\">// 输出: Processing integral type: 42</span></span><br><span class=\"line\">    <span class=\"built_in\">process</span>(<span class=\"number\">3.14</span>);     <span class=\"comment\">// 输出: Processing non-integral type: 3.14</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-Traits-的应用\"><a href=\"#3-Traits-的应用\" class=\"headerlink\" title=\"3. Traits 的应用\"></a>3. Traits 的应用</h3><p>Traits 在 C++ 标准库中有广泛的应用，以下是一些常见的例子：</p>\n<ul>\n<li><strong><code>std::iterator_traits</code></strong>: 提供迭代器的类型信息，如值类型、指针类型等。</li>\n<li><strong><code>std::numeric_limits</code></strong>: 提供数值类型的特性，如最小值、最大值等。</li>\n<li><strong><code>std::enable_if</code></strong>: 用于条件性地启用模板特化。</li>\n</ul>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><ul>\n<li><strong>Traits</strong> 是一种强大的设计模式，允许在编译时获取类型信息和行为。</li>\n<li>它们可以用于类型特性、类型转换和类型操作，提供灵活性和可扩展性。</li>\n<li>Traits 在 C++ 标准库中有广泛的应用，尤其是在模板编程和泛型编程中。</li>\n</ul>\n<p>通过使用 Traits，开发者可以编写更通用和可重用的代码，同时提高类型安全性和性能。</p>\n","site":{"data":{}},"excerpt":"<p>在 C++ 中，<strong>Traits</strong>（特性）是一种设计模式，通常用于提供类型信息或行为的模板类。Traits 允许在编译时获取类型的特性，从而实现更灵活和可扩展的代码。Traits 模式广泛应用于标准库和现代 C++ 编程中，尤其是在模板编程和泛型编程中。</p>","more":"<h3 id=\"1-Traits-的设计\"><a href=\"#1-Traits-的设计\" class=\"headerlink\" title=\"1. Traits 的设计\"></a>1. Traits 的设计</h3><p>Traits 通常是一个模板类，专门用于提供与类型相关的信息。它们可以用于：</p>\n<ul>\n<li><strong>类型特性</strong>: 提供类型的属性（如是否是指针、是否是类等）。</li>\n<li><strong>类型转换</strong>: 提供类型的转换信息（如获取类型的基类、去除引用等）。</li>\n<li><strong>类型操作</strong>: 提供与类型相关的操作（如获取类型的大小、默认构造函数等）。</li>\n</ul>\n<h3 id=\"2-Traits-的基本用法\"><a href=\"#2-Traits-的基本用法\" class=\"headerlink\" title=\"2. Traits 的基本用法\"></a>2. Traits 的基本用法</h3><p>以下是一些常见的 Traits 用法示例：</p>\n<h4 id=\"a-类型特性\"><a href=\"#a-类型特性\" class=\"headerlink\" title=\"a. 类型特性\"></a>a. 类型特性</h4><p>使用 <code>std::is_integral</code> 来检查一个类型是否是整数类型：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checkType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (std::is_integral&lt;T&gt;::value) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;T is an integral type.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;T is not an integral type.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">checkType</span>&lt;<span class=\"type\">int</span>&gt;();    <span class=\"comment\">// 输出: T is an integral type.</span></span><br><span class=\"line\">    <span class=\"built_in\">checkType</span>&lt;<span class=\"type\">double</span>&gt;(); <span class=\"comment\">// 输出: T is not an integral type.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"b-自定义-Traits\"><a href=\"#b-自定义-Traits\" class=\"headerlink\" title=\"b. 自定义 Traits\"></a>b. 自定义 Traits</h4><p>你可以定义自己的 Traits 类来提供特定类型的信息。例如，定义一个 Traits 类来获取类型的大小：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TypeTraits</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> size = <span class=\"built_in\">sizeof</span>(T);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Size of int: &quot;</span> &lt;&lt; TypeTraits&lt;<span class=\"type\">int</span>&gt;::size &lt;&lt; std::endl; <span class=\"comment\">// 输出: Size of int: 4</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Size of double: &quot;</span> &lt;&lt; TypeTraits&lt;<span class=\"type\">double</span>&gt;::size &lt;&lt; std::endl; <span class=\"comment\">// 输出: Size of double: 8</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"c-结合-SFINAE\"><a href=\"#c-结合-SFINAE\" class=\"headerlink\" title=\"c. 结合 SFINAE\"></a>c. 结合 SFINAE</h4><p>Traits 可以与 SFINAE（Substitution Failure Is Not An Error）结合使用，以实现更复杂的模板特化。例如，选择性地启用某些函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::<span class=\"function\">type</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">process</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Processing integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">typename</span> std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::<span class=\"function\">type</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">process</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Processing non-integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">process</span>(<span class=\"number\">42</span>);        <span class=\"comment\">// 输出: Processing integral type: 42</span></span><br><span class=\"line\">    <span class=\"built_in\">process</span>(<span class=\"number\">3.14</span>);     <span class=\"comment\">// 输出: Processing non-integral type: 3.14</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-Traits-的应用\"><a href=\"#3-Traits-的应用\" class=\"headerlink\" title=\"3. Traits 的应用\"></a>3. Traits 的应用</h3><p>Traits 在 C++ 标准库中有广泛的应用，以下是一些常见的例子：</p>\n<ul>\n<li><strong><code>std::iterator_traits</code></strong>: 提供迭代器的类型信息，如值类型、指针类型等。</li>\n<li><strong><code>std::numeric_limits</code></strong>: 提供数值类型的特性，如最小值、最大值等。</li>\n<li><strong><code>std::enable_if</code></strong>: 用于条件性地启用模板特化。</li>\n</ul>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><ul>\n<li><strong>Traits</strong> 是一种强大的设计模式，允许在编译时获取类型信息和行为。</li>\n<li>它们可以用于类型特性、类型转换和类型操作，提供灵活性和可扩展性。</li>\n<li>Traits 在 C++ 标准库中有广泛的应用，尤其是在模板编程和泛型编程中。</li>\n</ul>\n<p>通过使用 Traits，开发者可以编写更通用和可重用的代码，同时提高类型安全性和性能。</p>"},{"title":"texelFetch","date":"2024-10-06T10:16:59.000Z","_content":"\n`texelFetch` 是一个在着色器编程中用于从纹理中获取特定纹素（texel）的函数。与常规的纹理采样不同，`texelFetch` 使用整数纹理坐标来直接访问纹理数据，不进行过滤或插值。\n\n在 OpenGL 的 GLSL（OpenGL Shading Language）中，`texelFetch` 的用法如下：\n\n```glsl\nvec4 texelFetch(sampler2D sampler, ivec2 coord, int lod);\n```\n\n- `sampler`：纹理采样器。\n- `coord`：整数形式的纹理坐标。\n- `lod`：细节层次（level of detail），通常为 0。\n\n`texelFetch` 适用于需要精确访问纹理像素的场合，比如在一些计算或图像处理效果中。","source":"_posts/texelFetch.md","raw":"---\ntitle: texelFetch\ndate: 2024-10-06 18:16:59\ntags:\n---\n\n`texelFetch` 是一个在着色器编程中用于从纹理中获取特定纹素（texel）的函数。与常规的纹理采样不同，`texelFetch` 使用整数纹理坐标来直接访问纹理数据，不进行过滤或插值。\n\n在 OpenGL 的 GLSL（OpenGL Shading Language）中，`texelFetch` 的用法如下：\n\n```glsl\nvec4 texelFetch(sampler2D sampler, ivec2 coord, int lod);\n```\n\n- `sampler`：纹理采样器。\n- `coord`：整数形式的纹理坐标。\n- `lod`：细节层次（level of detail），通常为 0。\n\n`texelFetch` 适用于需要精确访问纹理像素的场合，比如在一些计算或图像处理效果中。","slug":"texelFetch","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8k002c1xco3mmd51aa","content":"<p><code>texelFetch</code> 是一个在着色器编程中用于从纹理中获取特定纹素（texel）的函数。与常规的纹理采样不同，<code>texelFetch</code> 使用整数纹理坐标来直接访问纹理数据，不进行过滤或插值。</p>\n<p>在 OpenGL 的 GLSL（OpenGL Shading Language）中，<code>texelFetch</code> 的用法如下：</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec4</span> <span class=\"built_in\">texelFetch</span>(<span class=\"type\">sampler2D</span> sampler, <span class=\"type\">ivec2</span> coord, <span class=\"type\">int</span> lod);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>sampler</code>：纹理采样器。</li>\n<li><code>coord</code>：整数形式的纹理坐标。</li>\n<li><code>lod</code>：细节层次（level of detail），通常为 0。</li>\n</ul>\n<p><code>texelFetch</code> 适用于需要精确访问纹理像素的场合，比如在一些计算或图像处理效果中。</p>\n","site":{"data":{}},"excerpt":"<p><code>texelFetch</code> 是一个在着色器编程中用于从纹理中获取特定纹素（texel）的函数。与常规的纹理采样不同，<code>texelFetch</code> 使用整数纹理坐标来直接访问纹理数据，不进行过滤或插值。</p>\n<p>在 OpenGL 的 GLSL（OpenGL Shading Language）中，<code>texelFetch</code> 的用法如下：</p>","more":"<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec4</span> <span class=\"built_in\">texelFetch</span>(<span class=\"type\">sampler2D</span> sampler, <span class=\"type\">ivec2</span> coord, <span class=\"type\">int</span> lod);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>sampler</code>：纹理采样器。</li>\n<li><code>coord</code>：整数形式的纹理坐标。</li>\n<li><code>lod</code>：细节层次（level of detail），通常为 0。</li>\n</ul>\n<p><code>texelFetch</code> 适用于需要精确访问纹理像素的场合，比如在一些计算或图像处理效果中。</p>"},{"title":"trivially copyable 拷贝不变","date":"2022-10-25T06:29:27.000Z","draft":true,"_content":"\n本文将介绍C++中trivially copyable概念及其应用。\n\n<!-- 内容待补充 -->\n","source":"_posts/trivially-copyable-拷贝不变.md","raw":"---\ntitle: trivially copyable 拷贝不变\ndate: 2022-10-25 14:29:27\ntags:\ndraft: true\n---\n\n本文将介绍C++中trivially copyable概念及其应用。\n\n<!-- 内容待补充 -->\n","slug":"trivially-copyable-拷贝不变","published":1,"updated":"2025-06-07T09:22:34.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8k002e1xcodiqeflgl","content":"<p>本文将介绍C++中trivially copyable概念及其应用。</p>\n<!-- 内容待补充 -->\n","site":{"data":{}},"excerpt":"","more":"<p>本文将介绍C++中trivially copyable概念及其应用。</p>\n<!-- 内容待补充 -->\n"},{"layout":"post","title":"tweak环境搭建","date":"2017-03-07T00:43:58.000Z","_content":"\n### 0 设置环境变量 export THEOS=/opt/theos\n\n可以设置~/.zshrc中添加，修改后用source命令重新加载\n\n### 1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下\n\n### 2 下载ldid，放到/opt/theos/bin下\n\nsudo chmod 777 /opt/theos/bin/ldid\n\n### 3 配置CydiaSubstrate\n\n在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib\n\n并将头文件substrate.h也scp 到/opt/theos/include下\n\nsudo /opt/theos/bin/bootstrap.sh substrate\n\n### 4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/\n\nsuodo chmod 777 /opt/bin/dpkg-deb\n\n基本就搭建完成，可以练习创建工程\n\n/opt/theos/bin/nic.pl\n\n然后进行make package \n\nmake package install\n\n","source":"_posts/tweak环境搭建.md","raw":"---\nlayout: post\ntitle: tweak环境搭建\ndate: 2017-03-07 08:43:58\ntags: iOS\n---\n\n### 0 设置环境变量 export THEOS=/opt/theos\n\n可以设置~/.zshrc中添加，修改后用source命令重新加载\n\n### 1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下\n\n### 2 下载ldid，放到/opt/theos/bin下\n\nsudo chmod 777 /opt/theos/bin/ldid\n\n### 3 配置CydiaSubstrate\n\n在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib\n\n并将头文件substrate.h也scp 到/opt/theos/include下\n\nsudo /opt/theos/bin/bootstrap.sh substrate\n\n### 4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/\n\nsuodo chmod 777 /opt/bin/dpkg-deb\n\n基本就搭建完成，可以练习创建工程\n\n/opt/theos/bin/nic.pl\n\n然后进行make package \n\nmake package install\n\n","slug":"tweak环境搭建","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8k002g1xco5p3ef87q","content":"<h3 id=\"0-设置环境变量-export-THEOS-opt-theos\"><a href=\"#0-设置环境变量-export-THEOS-opt-theos\" class=\"headerlink\" title=\"0 设置环境变量 export THEOS=/opt/theos\"></a>0 设置环境变量 export THEOS=/opt/theos</h3><p>可以设置~/.zshrc中添加，修改后用source命令重新加载</p>\n<span id=\"more\"></span>\n\n<h3 id=\"1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下\"><a href=\"#1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下\" class=\"headerlink\" title=\"1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下\"></a>1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下</h3><h3 id=\"2-下载ldid，放到-opt-theos-bin下\"><a href=\"#2-下载ldid，放到-opt-theos-bin下\" class=\"headerlink\" title=\"2 下载ldid，放到/opt/theos/bin下\"></a>2 下载ldid，放到/opt/theos/bin下</h3><p>sudo chmod 777 /opt/theos/bin/ldid</p>\n<h3 id=\"3-配置CydiaSubstrate\"><a href=\"#3-配置CydiaSubstrate\" class=\"headerlink\" title=\"3 配置CydiaSubstrate\"></a>3 配置CydiaSubstrate</h3><p>在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib</p>\n<p>并将头文件substrate.h也scp 到/opt/theos/include下</p>\n<p>sudo /opt/theos/bin/bootstrap.sh substrate</p>\n<h3 id=\"4-将dm-pl重命名为dpkg-deb，cp到-opt-bin\"><a href=\"#4-将dm-pl重命名为dpkg-deb，cp到-opt-bin\" class=\"headerlink\" title=\"4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/\"></a>4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/</h3><p>suodo chmod 777 /opt/bin/dpkg-deb</p>\n<p>基本就搭建完成，可以练习创建工程</p>\n<p>/opt/theos/bin/nic.pl</p>\n<p>然后进行make package </p>\n<p>make package install</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"0-设置环境变量-export-THEOS-opt-theos\"><a href=\"#0-设置环境变量-export-THEOS-opt-theos\" class=\"headerlink\" title=\"0 设置环境变量 export THEOS=/opt/theos\"></a>0 设置环境变量 export THEOS=/opt/theos</h3><p>可以设置~/.zshrc中添加，修改后用source命令重新加载</p>","more":"<h3 id=\"1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下\"><a href=\"#1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下\" class=\"headerlink\" title=\"1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下\"></a>1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下</h3><h3 id=\"2-下载ldid，放到-opt-theos-bin下\"><a href=\"#2-下载ldid，放到-opt-theos-bin下\" class=\"headerlink\" title=\"2 下载ldid，放到/opt/theos/bin下\"></a>2 下载ldid，放到/opt/theos/bin下</h3><p>sudo chmod 777 /opt/theos/bin/ldid</p>\n<h3 id=\"3-配置CydiaSubstrate\"><a href=\"#3-配置CydiaSubstrate\" class=\"headerlink\" title=\"3 配置CydiaSubstrate\"></a>3 配置CydiaSubstrate</h3><p>在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib</p>\n<p>并将头文件substrate.h也scp 到/opt/theos/include下</p>\n<p>sudo /opt/theos/bin/bootstrap.sh substrate</p>\n<h3 id=\"4-将dm-pl重命名为dpkg-deb，cp到-opt-bin\"><a href=\"#4-将dm-pl重命名为dpkg-deb，cp到-opt-bin\" class=\"headerlink\" title=\"4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/\"></a>4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/</h3><p>suodo chmod 777 /opt/bin/dpkg-deb</p>\n<p>基本就搭建完成，可以练习创建工程</p>\n<p>/opt/theos/bin/nic.pl</p>\n<p>然后进行make package </p>\n<p>make package install</p>"},{"layout":"post","title":"tweak心得","date":"2017-03-07T01:20:39.000Z","_content":"\n### 1 关于ssh\n\n一般形式 ssh root@192.168.2.17或者ssh mobile@192.168.2.17\n\nroot和mobile分别为iOS上默认用户，alpine是默认密码\n\n可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码\n\n### 2 scp source dest\n\n一般为\n\nscp ~/123.txt mobile@192.168.2.17:/usr/bin\n\n### 3 Makefile\n\n可以配置手机的IP，framework，arch等参数\n\nTHEOS_DEVICE_IP = 192.168.31.202\nARCHS = armv7 arm64\nTARGET = iphone:latest:8.0\n\niOSREGreetings_FRAMEWORKS = UIKit \n\n### 4 关于bundleID\n\n.plist中的bundle就是你想hook的程序的bundleID\n","source":"_posts/tweak使用说明.md","raw":"---\nlayout: post\ntitle: tweak心得\ndate: 2017-03-07 09:20:39\ntags: iOS\n---\n\n### 1 关于ssh\n\n一般形式 ssh root@192.168.2.17或者ssh mobile@192.168.2.17\n\nroot和mobile分别为iOS上默认用户，alpine是默认密码\n\n可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码\n\n### 2 scp source dest\n\n一般为\n\nscp ~/123.txt mobile@192.168.2.17:/usr/bin\n\n### 3 Makefile\n\n可以配置手机的IP，framework，arch等参数\n\nTHEOS_DEVICE_IP = 192.168.31.202\nARCHS = armv7 arm64\nTARGET = iphone:latest:8.0\n\niOSREGreetings_FRAMEWORKS = UIKit \n\n### 4 关于bundleID\n\n.plist中的bundle就是你想hook的程序的bundleID\n","slug":"tweak使用说明","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"photos":[],"link":"","_id":"cmbt3hg8k002i1xco7bla199r","content":"<h3 id=\"1-关于ssh\"><a href=\"#1-关于ssh\" class=\"headerlink\" title=\"1 关于ssh\"></a>1 关于ssh</h3><p>一般形式 ssh <a href=\"mailto:&#x72;&#111;&#111;&#x74;&#64;&#49;&#x39;&#50;&#x2e;&#x31;&#x36;&#56;&#46;&#50;&#46;&#x31;&#x37;\">&#x72;&#111;&#111;&#x74;&#64;&#49;&#x39;&#50;&#x2e;&#x31;&#x36;&#56;&#46;&#50;&#46;&#x31;&#x37;</a>或者ssh <a href=\"mailto:&#x6d;&#x6f;&#98;&#105;&#x6c;&#101;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#x32;&#46;&#49;&#x37;\">&#x6d;&#x6f;&#98;&#105;&#x6c;&#101;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#x32;&#46;&#49;&#x37;</a></p>\n<span id=\"more\"></span>\n\n<p>root和mobile分别为iOS上默认用户，alpine是默认密码</p>\n<p>可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码</p>\n<h3 id=\"2-scp-source-dest\"><a href=\"#2-scp-source-dest\" class=\"headerlink\" title=\"2 scp source dest\"></a>2 scp source dest</h3><p>一般为</p>\n<p>scp ~/123.txt <a href=\"mailto:&#x6d;&#x6f;&#98;&#105;&#x6c;&#x65;&#64;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#50;&#x2e;&#x31;&#x37;\">&#x6d;&#x6f;&#98;&#105;&#x6c;&#x65;&#64;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#50;&#x2e;&#x31;&#x37;</a>:/usr/bin</p>\n<h3 id=\"3-Makefile\"><a href=\"#3-Makefile\" class=\"headerlink\" title=\"3 Makefile\"></a>3 Makefile</h3><p>可以配置手机的IP，framework，arch等参数</p>\n<p>THEOS_DEVICE_IP = 192.168.31.202<br>ARCHS = armv7 arm64<br>TARGET = iphone:latest:8.0</p>\n<p>iOSREGreetings_FRAMEWORKS = UIKit </p>\n<h3 id=\"4-关于bundleID\"><a href=\"#4-关于bundleID\" class=\"headerlink\" title=\"4 关于bundleID\"></a>4 关于bundleID</h3><p>.plist中的bundle就是你想hook的程序的bundleID</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-关于ssh\"><a href=\"#1-关于ssh\" class=\"headerlink\" title=\"1 关于ssh\"></a>1 关于ssh</h3><p>一般形式 ssh <a href=\"mailto:&#x72;&#111;&#111;&#x74;&#64;&#49;&#x39;&#50;&#x2e;&#x31;&#x36;&#56;&#46;&#50;&#46;&#x31;&#x37;\">&#x72;&#111;&#111;&#x74;&#64;&#49;&#x39;&#50;&#x2e;&#x31;&#x36;&#56;&#46;&#50;&#46;&#x31;&#x37;</a>或者ssh <a href=\"mailto:&#x6d;&#x6f;&#98;&#105;&#x6c;&#101;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#x32;&#46;&#49;&#x37;\">&#x6d;&#x6f;&#98;&#105;&#x6c;&#101;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#x32;&#46;&#49;&#x37;</a></p>","more":"<p>root和mobile分别为iOS上默认用户，alpine是默认密码</p>\n<p>可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码</p>\n<h3 id=\"2-scp-source-dest\"><a href=\"#2-scp-source-dest\" class=\"headerlink\" title=\"2 scp source dest\"></a>2 scp source dest</h3><p>一般为</p>\n<p>scp ~/123.txt <a href=\"mailto:&#x6d;&#x6f;&#98;&#105;&#x6c;&#x65;&#64;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#50;&#x2e;&#x31;&#x37;\">&#x6d;&#x6f;&#98;&#105;&#x6c;&#x65;&#64;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#50;&#x2e;&#x31;&#x37;</a>:/usr/bin</p>\n<h3 id=\"3-Makefile\"><a href=\"#3-Makefile\" class=\"headerlink\" title=\"3 Makefile\"></a>3 Makefile</h3><p>可以配置手机的IP，framework，arch等参数</p>\n<p>THEOS_DEVICE_IP = 192.168.31.202<br>ARCHS = armv7 arm64<br>TARGET = iphone:latest:8.0</p>\n<p>iOSREGreetings_FRAMEWORKS = UIKit </p>\n<h3 id=\"4-关于bundleID\"><a href=\"#4-关于bundleID\" class=\"headerlink\" title=\"4 关于bundleID\"></a>4 关于bundleID</h3><p>.plist中的bundle就是你想hook的程序的bundleID</p>"},{"title":"type script","date":"2025-03-15T15:23:39.000Z","_content":"TypeScript 是一种由 **Microsoft** 开发的开源编程语言，它是 **JavaScript 的超集**，为 JavaScript 添加了可选的静态类型系统和现代语言特性。TypeScript 的目标是提高 JavaScript 代码的可维护性、可读性和开发效率，同时保持与 JavaScript 的完全兼容。\n\n---\n\n### **1. TypeScript 的核心特性**\n#### **(1) 静态类型检查**\n- **类型注解**：  \n  允许开发者为变量、函数参数和返回值等添加类型注解，例如：\n  ```typescript\n  let count: number = 10;\n  function add(a: number, b: number): number {\n      return a + b;\n  }\n  ```\n- **类型推断**：  \n  即使没有显式注解，TypeScript 也能根据上下文推断类型。\n\n#### **(2) 面向对象编程**\n- **类与接口**：  \n  支持类、继承、接口等面向对象特性：\n  ```typescript\n  interface Animal {\n      name: string;\n      makeSound(): void;\n  }\n\n  class Dog implements Animal {\n      name: string;\n      constructor(name: string) {\n          this.name = name;\n      }\n      makeSound() {\n          console.log(\"Woof!\");\n      }\n  }\n  ```\n\n#### **(3) 现代 JavaScript 特性**\n- **ES6+ 支持**：  \n  TypeScript 支持最新的 JavaScript 特性（如箭头函数、解构赋值、模块化等），并将其编译为兼容性更好的 ES5 或更低版本。\n- **装饰器**：  \n  支持实验性装饰器语法，常用于 Angular 等框架。\n\n#### **(4) 工具支持**\n- **强大的 IDE 支持**：  \n  TypeScript 提供了丰富的工具支持，如代码补全、类型检查、重构等，主流 IDE（如 VS Code）对 TypeScript 有原生支持。\n- **编译时错误检查**：  \n  在编译阶段捕获类型错误，减少运行时错误。\n\n---\n\n### **2. TypeScript 的优势**\n#### **(1) 提高代码质量**\n- **类型安全**：  \n  静态类型检查可以在编译阶段发现潜在的错误，减少运行时错误。\n- **代码可读性**：  \n  类型注解使代码更易于理解和维护。\n\n#### **(2) 提高开发效率**\n- **智能提示**：  \n  IDE 可以根据类型信息提供更准确的代码补全和提示。\n- **重构支持**：  \n  类型信息使得重构代码更加安全和高效。\n\n#### **(3) 兼容性**\n- **与 JavaScript 兼容**：  \n  TypeScript 是 JavaScript 的超集，任何合法的 JavaScript 代码都是合法的 TypeScript 代码。\n- **渐进式采用**：  \n  可以在现有 JavaScript 项目中逐步引入 TypeScript。\n\n---\n\n### **3. TypeScript 的基本语法**\n#### **(1) 类型注解**\n```typescript\nlet isDone: boolean = false;\nlet count: number = 42;\nlet name: string = \"TypeScript\";\n```\n\n#### **(2) 接口**\n```typescript\ninterface User {\n    id: number;\n    name: string;\n    email?: string;  // 可选属性\n}\n\nlet user: User = {\n    id: 1,\n    name: \"Alice\"\n};\n```\n\n#### **(3) 类**\n```typescript\nclass Person {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    greet() {\n        console.log(`Hello, ${this.name}`);\n    }\n}\n\nlet person = new Person(\"Bob\");\nperson.greet();\n```\n\n#### **(4) 泛型**\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet output = identity<string>(\"Hello\");\n```\n\n#### **(5) 模块化**\n```typescript\n// math.ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\n// main.ts\nimport { add } from './math';\nconsole.log(add(1, 2));\n```\n\n---\n\n### **4. TypeScript 的工作流程**\n1. **编写 TypeScript 代码**：  \n   使用 `.ts` 或 `.tsx` 文件编写代码。\n2. **编译 TypeScript**：  \n   使用 TypeScript 编译器（`tsc`）将代码编译为 JavaScript：\n   ```bash\n   tsc main.ts\n   ```\n3. **运行 JavaScript**：  \n   执行生成的 `.js` 文件。\n\n---\n\n### **5. TypeScript 的适用场景**\n- **大型项目**：  \n  类型系统有助于管理复杂的代码库。\n- **团队协作**：  \n  类型注解和接口定义可以提高团队协作效率。\n- **框架开发**：  \n  许多现代前端框架（如 Angular、Vue 3、React）都支持 TypeScript。\n- **渐进式迁移**：  \n  可以在现有 JavaScript 项目中逐步引入 TypeScript。\n\n---\n\n### **6. TypeScript 与 JavaScript 的区别**\n| 特性                | TypeScript                     | JavaScript                 |\n|---------------------|--------------------------------|----------------------------|\n| **类型系统**         | 静态类型                       | 动态类型                   |\n| **编译**             | 需要编译为 JavaScript          | 直接运行                   |\n| **工具支持**         | 强大的 IDE 支持                | 有限的工具支持             |\n| **学习曲线**         | 较高（需要学习类型系统）       | 较低                       |\n| **适用场景**         | 大型项目、团队协作             | 小型项目、快速原型开发     |\n\n---\n\n### **7. 如何开始学习 TypeScript**\n1. **安装 TypeScript**：\n   ```bash\n   npm install -g typescript\n   ```\n2. **编写第一个 TypeScript 程序**：\n   ```typescript\n   // hello.ts\n   function greet(name: string): string {\n       return `Hello, ${name}!`;\n   }\n   console.log(greet(\"TypeScript\"));\n   ```\n3. **编译并运行**：\n   ```bash\n   tsc hello.ts\n   node hello.js\n   ```\n\n---\n\n### **总结**\nTypeScript 是一种强大的编程语言，通过静态类型检查和现代语言特性，显著提升了 JavaScript 的开发效率和代码质量。它特别适合大型项目、团队协作以及对代码质量要求较高的场景。如果你已经熟悉 JavaScript，学习 TypeScript 将是一个自然且有益的进阶选择。\n","source":"_posts/type-script.md","raw":"---\ntitle: type script\ndate: 2025-03-15 23:23:39\ntags:\n---\nTypeScript 是一种由 **Microsoft** 开发的开源编程语言，它是 **JavaScript 的超集**，为 JavaScript 添加了可选的静态类型系统和现代语言特性。TypeScript 的目标是提高 JavaScript 代码的可维护性、可读性和开发效率，同时保持与 JavaScript 的完全兼容。\n\n---\n\n### **1. TypeScript 的核心特性**\n#### **(1) 静态类型检查**\n- **类型注解**：  \n  允许开发者为变量、函数参数和返回值等添加类型注解，例如：\n  ```typescript\n  let count: number = 10;\n  function add(a: number, b: number): number {\n      return a + b;\n  }\n  ```\n- **类型推断**：  \n  即使没有显式注解，TypeScript 也能根据上下文推断类型。\n\n#### **(2) 面向对象编程**\n- **类与接口**：  \n  支持类、继承、接口等面向对象特性：\n  ```typescript\n  interface Animal {\n      name: string;\n      makeSound(): void;\n  }\n\n  class Dog implements Animal {\n      name: string;\n      constructor(name: string) {\n          this.name = name;\n      }\n      makeSound() {\n          console.log(\"Woof!\");\n      }\n  }\n  ```\n\n#### **(3) 现代 JavaScript 特性**\n- **ES6+ 支持**：  \n  TypeScript 支持最新的 JavaScript 特性（如箭头函数、解构赋值、模块化等），并将其编译为兼容性更好的 ES5 或更低版本。\n- **装饰器**：  \n  支持实验性装饰器语法，常用于 Angular 等框架。\n\n#### **(4) 工具支持**\n- **强大的 IDE 支持**：  \n  TypeScript 提供了丰富的工具支持，如代码补全、类型检查、重构等，主流 IDE（如 VS Code）对 TypeScript 有原生支持。\n- **编译时错误检查**：  \n  在编译阶段捕获类型错误，减少运行时错误。\n\n---\n\n### **2. TypeScript 的优势**\n#### **(1) 提高代码质量**\n- **类型安全**：  \n  静态类型检查可以在编译阶段发现潜在的错误，减少运行时错误。\n- **代码可读性**：  \n  类型注解使代码更易于理解和维护。\n\n#### **(2) 提高开发效率**\n- **智能提示**：  \n  IDE 可以根据类型信息提供更准确的代码补全和提示。\n- **重构支持**：  \n  类型信息使得重构代码更加安全和高效。\n\n#### **(3) 兼容性**\n- **与 JavaScript 兼容**：  \n  TypeScript 是 JavaScript 的超集，任何合法的 JavaScript 代码都是合法的 TypeScript 代码。\n- **渐进式采用**：  \n  可以在现有 JavaScript 项目中逐步引入 TypeScript。\n\n---\n\n### **3. TypeScript 的基本语法**\n#### **(1) 类型注解**\n```typescript\nlet isDone: boolean = false;\nlet count: number = 42;\nlet name: string = \"TypeScript\";\n```\n\n#### **(2) 接口**\n```typescript\ninterface User {\n    id: number;\n    name: string;\n    email?: string;  // 可选属性\n}\n\nlet user: User = {\n    id: 1,\n    name: \"Alice\"\n};\n```\n\n#### **(3) 类**\n```typescript\nclass Person {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    greet() {\n        console.log(`Hello, ${this.name}`);\n    }\n}\n\nlet person = new Person(\"Bob\");\nperson.greet();\n```\n\n#### **(4) 泛型**\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet output = identity<string>(\"Hello\");\n```\n\n#### **(5) 模块化**\n```typescript\n// math.ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\n// main.ts\nimport { add } from './math';\nconsole.log(add(1, 2));\n```\n\n---\n\n### **4. TypeScript 的工作流程**\n1. **编写 TypeScript 代码**：  \n   使用 `.ts` 或 `.tsx` 文件编写代码。\n2. **编译 TypeScript**：  \n   使用 TypeScript 编译器（`tsc`）将代码编译为 JavaScript：\n   ```bash\n   tsc main.ts\n   ```\n3. **运行 JavaScript**：  \n   执行生成的 `.js` 文件。\n\n---\n\n### **5. TypeScript 的适用场景**\n- **大型项目**：  \n  类型系统有助于管理复杂的代码库。\n- **团队协作**：  \n  类型注解和接口定义可以提高团队协作效率。\n- **框架开发**：  \n  许多现代前端框架（如 Angular、Vue 3、React）都支持 TypeScript。\n- **渐进式迁移**：  \n  可以在现有 JavaScript 项目中逐步引入 TypeScript。\n\n---\n\n### **6. TypeScript 与 JavaScript 的区别**\n| 特性                | TypeScript                     | JavaScript                 |\n|---------------------|--------------------------------|----------------------------|\n| **类型系统**         | 静态类型                       | 动态类型                   |\n| **编译**             | 需要编译为 JavaScript          | 直接运行                   |\n| **工具支持**         | 强大的 IDE 支持                | 有限的工具支持             |\n| **学习曲线**         | 较高（需要学习类型系统）       | 较低                       |\n| **适用场景**         | 大型项目、团队协作             | 小型项目、快速原型开发     |\n\n---\n\n### **7. 如何开始学习 TypeScript**\n1. **安装 TypeScript**：\n   ```bash\n   npm install -g typescript\n   ```\n2. **编写第一个 TypeScript 程序**：\n   ```typescript\n   // hello.ts\n   function greet(name: string): string {\n       return `Hello, ${name}!`;\n   }\n   console.log(greet(\"TypeScript\"));\n   ```\n3. **编译并运行**：\n   ```bash\n   tsc hello.ts\n   node hello.js\n   ```\n\n---\n\n### **总结**\nTypeScript 是一种强大的编程语言，通过静态类型检查和现代语言特性，显著提升了 JavaScript 的开发效率和代码质量。它特别适合大型项目、团队协作以及对代码质量要求较高的场景。如果你已经熟悉 JavaScript，学习 TypeScript 将是一个自然且有益的进阶选择。\n","slug":"type-script","published":1,"updated":"2025-03-15T15:26:08.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8k002k1xcogmulchz6","content":"<p>TypeScript 是一种由 <strong>Microsoft</strong> 开发的开源编程语言，它是 <strong>JavaScript 的超集</strong>，为 JavaScript 添加了可选的静态类型系统和现代语言特性。TypeScript 的目标是提高 JavaScript 代码的可维护性、可读性和开发效率，同时保持与 JavaScript 的完全兼容。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"1-TypeScript-的核心特性\"><a href=\"#1-TypeScript-的核心特性\" class=\"headerlink\" title=\"1. TypeScript 的核心特性\"></a><strong>1. TypeScript 的核心特性</strong></h3><h4 id=\"1-静态类型检查\"><a href=\"#1-静态类型检查\" class=\"headerlink\" title=\"(1) 静态类型检查\"></a><strong>(1) 静态类型检查</strong></h4><ul>\n<li><strong>类型注解</strong>：<br>允许开发者为变量、函数参数和返回值等添加类型注解，例如：<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">count</span>: <span class=\"built_in\">number</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a: <span class=\"built_in\">number</span>, b: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>类型推断</strong>：<br>即使没有显式注解，TypeScript 也能根据上下文推断类型。</li>\n</ul>\n<h4 id=\"2-面向对象编程\"><a href=\"#2-面向对象编程\" class=\"headerlink\" title=\"(2) 面向对象编程\"></a><strong>(2) 面向对象编程</strong></h4><ul>\n<li><strong>类与接口</strong>：<br>支持类、继承、接口等面向对象特性：<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"title function_\">makeSound</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">makeSound</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Woof!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"3-现代-JavaScript-特性\"><a href=\"#3-现代-JavaScript-特性\" class=\"headerlink\" title=\"(3) 现代 JavaScript 特性\"></a><strong>(3) 现代 JavaScript 特性</strong></h4><ul>\n<li><strong>ES6+ 支持</strong>：<br>TypeScript 支持最新的 JavaScript 特性（如箭头函数、解构赋值、模块化等），并将其编译为兼容性更好的 ES5 或更低版本。</li>\n<li><strong>装饰器</strong>：<br>支持实验性装饰器语法，常用于 Angular 等框架。</li>\n</ul>\n<h4 id=\"4-工具支持\"><a href=\"#4-工具支持\" class=\"headerlink\" title=\"(4) 工具支持\"></a><strong>(4) 工具支持</strong></h4><ul>\n<li><strong>强大的 IDE 支持</strong>：<br>TypeScript 提供了丰富的工具支持，如代码补全、类型检查、重构等，主流 IDE（如 VS Code）对 TypeScript 有原生支持。</li>\n<li><strong>编译时错误检查</strong>：<br>在编译阶段捕获类型错误，减少运行时错误。</li>\n</ul>\n<hr>\n<h3 id=\"2-TypeScript-的优势\"><a href=\"#2-TypeScript-的优势\" class=\"headerlink\" title=\"2. TypeScript 的优势\"></a><strong>2. TypeScript 的优势</strong></h3><h4 id=\"1-提高代码质量\"><a href=\"#1-提高代码质量\" class=\"headerlink\" title=\"(1) 提高代码质量\"></a><strong>(1) 提高代码质量</strong></h4><ul>\n<li><strong>类型安全</strong>：<br>静态类型检查可以在编译阶段发现潜在的错误，减少运行时错误。</li>\n<li><strong>代码可读性</strong>：<br>类型注解使代码更易于理解和维护。</li>\n</ul>\n<h4 id=\"2-提高开发效率\"><a href=\"#2-提高开发效率\" class=\"headerlink\" title=\"(2) 提高开发效率\"></a><strong>(2) 提高开发效率</strong></h4><ul>\n<li><strong>智能提示</strong>：<br>IDE 可以根据类型信息提供更准确的代码补全和提示。</li>\n<li><strong>重构支持</strong>：<br>类型信息使得重构代码更加安全和高效。</li>\n</ul>\n<h4 id=\"3-兼容性\"><a href=\"#3-兼容性\" class=\"headerlink\" title=\"(3) 兼容性\"></a><strong>(3) 兼容性</strong></h4><ul>\n<li><strong>与 JavaScript 兼容</strong>：<br>TypeScript 是 JavaScript 的超集，任何合法的 JavaScript 代码都是合法的 TypeScript 代码。</li>\n<li><strong>渐进式采用</strong>：<br>可以在现有 JavaScript 项目中逐步引入 TypeScript。</li>\n</ul>\n<hr>\n<h3 id=\"3-TypeScript-的基本语法\"><a href=\"#3-TypeScript-的基本语法\" class=\"headerlink\" title=\"3. TypeScript 的基本语法\"></a><strong>3. TypeScript 的基本语法</strong></h3><h4 id=\"1-类型注解\"><a href=\"#1-类型注解\" class=\"headerlink\" title=\"(1) 类型注解\"></a><strong>(1) 类型注解</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">isDone</span>: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">count</span>: <span class=\"built_in\">number</span> = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;TypeScript&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-接口\"><a href=\"#2-接口\" class=\"headerlink\" title=\"(2) 接口\"></a><strong>(2) 接口</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    email?: <span class=\"built_in\">string</span>;  <span class=\"comment\">// 可选属性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">user</span>: <span class=\"title class_\">User</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-类\"><a href=\"#3-类\" class=\"headerlink\" title=\"(3) 类\"></a><strong>(3) 类</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">person.<span class=\"title function_\">greet</span>();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-泛型\"><a href=\"#4-泛型\" class=\"headerlink\" title=\"(4) 泛型\"></a><strong>(4) 泛型</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;T&gt;(<span class=\"attr\">arg</span>: T): T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> output = identity&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-模块化\"><a href=\"#5-模块化\" class=\"headerlink\" title=\"(5) 模块化\"></a><strong>(5) 模块化</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// math.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a: <span class=\"built_in\">number</span>, b: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; add &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./math&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">add</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"4-TypeScript-的工作流程\"><a href=\"#4-TypeScript-的工作流程\" class=\"headerlink\" title=\"4. TypeScript 的工作流程\"></a><strong>4. TypeScript 的工作流程</strong></h3><ol>\n<li><strong>编写 TypeScript 代码</strong>：<br>使用 <code>.ts</code> 或 <code>.tsx</code> 文件编写代码。</li>\n<li><strong>编译 TypeScript</strong>：<br>使用 TypeScript 编译器（<code>tsc</code>）将代码编译为 JavaScript：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc main.ts</span><br></pre></td></tr></table></figure></li>\n<li><strong>运行 JavaScript</strong>：<br>执行生成的 <code>.js</code> 文件。</li>\n</ol>\n<hr>\n<h3 id=\"5-TypeScript-的适用场景\"><a href=\"#5-TypeScript-的适用场景\" class=\"headerlink\" title=\"5. TypeScript 的适用场景\"></a><strong>5. TypeScript 的适用场景</strong></h3><ul>\n<li><strong>大型项目</strong>：<br>类型系统有助于管理复杂的代码库。</li>\n<li><strong>团队协作</strong>：<br>类型注解和接口定义可以提高团队协作效率。</li>\n<li><strong>框架开发</strong>：<br>许多现代前端框架（如 Angular、Vue 3、React）都支持 TypeScript。</li>\n<li><strong>渐进式迁移</strong>：<br>可以在现有 JavaScript 项目中逐步引入 TypeScript。</li>\n</ul>\n<hr>\n<h3 id=\"6-TypeScript-与-JavaScript-的区别\"><a href=\"#6-TypeScript-与-JavaScript-的区别\" class=\"headerlink\" title=\"6. TypeScript 与 JavaScript 的区别\"></a><strong>6. TypeScript 与 JavaScript 的区别</strong></h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>TypeScript</th>\n<th>JavaScript</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>类型系统</strong></td>\n<td>静态类型</td>\n<td>动态类型</td>\n</tr>\n<tr>\n<td><strong>编译</strong></td>\n<td>需要编译为 JavaScript</td>\n<td>直接运行</td>\n</tr>\n<tr>\n<td><strong>工具支持</strong></td>\n<td>强大的 IDE 支持</td>\n<td>有限的工具支持</td>\n</tr>\n<tr>\n<td><strong>学习曲线</strong></td>\n<td>较高（需要学习类型系统）</td>\n<td>较低</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>大型项目、团队协作</td>\n<td>小型项目、快速原型开发</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"7-如何开始学习-TypeScript\"><a href=\"#7-如何开始学习-TypeScript\" class=\"headerlink\" title=\"7. 如何开始学习 TypeScript\"></a><strong>7. 如何开始学习 TypeScript</strong></h3><ol>\n<li><strong>安装 TypeScript</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure></li>\n<li><strong>编写第一个 TypeScript 程序</strong>：<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hello.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, <span class=\"subst\">$&#123;name&#125;</span>!`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">greet</span>(<span class=\"string\">&quot;TypeScript&quot;</span>));</span><br></pre></td></tr></table></figure></li>\n<li><strong>编译并运行</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc hello.ts</span><br><span class=\"line\">node hello.js</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>TypeScript 是一种强大的编程语言，通过静态类型检查和现代语言特性，显著提升了 JavaScript 的开发效率和代码质量。它特别适合大型项目、团队协作以及对代码质量要求较高的场景。如果你已经熟悉 JavaScript，学习 TypeScript 将是一个自然且有益的进阶选择。</p>\n","site":{"data":{}},"excerpt":"<p>TypeScript 是一种由 <strong>Microsoft</strong> 开发的开源编程语言，它是 <strong>JavaScript 的超集</strong>，为 JavaScript 添加了可选的静态类型系统和现代语言特性。TypeScript 的目标是提高 JavaScript 代码的可维护性、可读性和开发效率，同时保持与 JavaScript 的完全兼容。</p>","more":"<hr>\n<h3 id=\"1-TypeScript-的核心特性\"><a href=\"#1-TypeScript-的核心特性\" class=\"headerlink\" title=\"1. TypeScript 的核心特性\"></a><strong>1. TypeScript 的核心特性</strong></h3><h4 id=\"1-静态类型检查\"><a href=\"#1-静态类型检查\" class=\"headerlink\" title=\"(1) 静态类型检查\"></a><strong>(1) 静态类型检查</strong></h4><ul>\n<li><strong>类型注解</strong>：<br>允许开发者为变量、函数参数和返回值等添加类型注解，例如：<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">count</span>: <span class=\"built_in\">number</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a: <span class=\"built_in\">number</span>, b: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>类型推断</strong>：<br>即使没有显式注解，TypeScript 也能根据上下文推断类型。</li>\n</ul>\n<h4 id=\"2-面向对象编程\"><a href=\"#2-面向对象编程\" class=\"headerlink\" title=\"(2) 面向对象编程\"></a><strong>(2) 面向对象编程</strong></h4><ul>\n<li><strong>类与接口</strong>：<br>支持类、继承、接口等面向对象特性：<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"title function_\">makeSound</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">makeSound</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Woof!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"3-现代-JavaScript-特性\"><a href=\"#3-现代-JavaScript-特性\" class=\"headerlink\" title=\"(3) 现代 JavaScript 特性\"></a><strong>(3) 现代 JavaScript 特性</strong></h4><ul>\n<li><strong>ES6+ 支持</strong>：<br>TypeScript 支持最新的 JavaScript 特性（如箭头函数、解构赋值、模块化等），并将其编译为兼容性更好的 ES5 或更低版本。</li>\n<li><strong>装饰器</strong>：<br>支持实验性装饰器语法，常用于 Angular 等框架。</li>\n</ul>\n<h4 id=\"4-工具支持\"><a href=\"#4-工具支持\" class=\"headerlink\" title=\"(4) 工具支持\"></a><strong>(4) 工具支持</strong></h4><ul>\n<li><strong>强大的 IDE 支持</strong>：<br>TypeScript 提供了丰富的工具支持，如代码补全、类型检查、重构等，主流 IDE（如 VS Code）对 TypeScript 有原生支持。</li>\n<li><strong>编译时错误检查</strong>：<br>在编译阶段捕获类型错误，减少运行时错误。</li>\n</ul>\n<hr>\n<h3 id=\"2-TypeScript-的优势\"><a href=\"#2-TypeScript-的优势\" class=\"headerlink\" title=\"2. TypeScript 的优势\"></a><strong>2. TypeScript 的优势</strong></h3><h4 id=\"1-提高代码质量\"><a href=\"#1-提高代码质量\" class=\"headerlink\" title=\"(1) 提高代码质量\"></a><strong>(1) 提高代码质量</strong></h4><ul>\n<li><strong>类型安全</strong>：<br>静态类型检查可以在编译阶段发现潜在的错误，减少运行时错误。</li>\n<li><strong>代码可读性</strong>：<br>类型注解使代码更易于理解和维护。</li>\n</ul>\n<h4 id=\"2-提高开发效率\"><a href=\"#2-提高开发效率\" class=\"headerlink\" title=\"(2) 提高开发效率\"></a><strong>(2) 提高开发效率</strong></h4><ul>\n<li><strong>智能提示</strong>：<br>IDE 可以根据类型信息提供更准确的代码补全和提示。</li>\n<li><strong>重构支持</strong>：<br>类型信息使得重构代码更加安全和高效。</li>\n</ul>\n<h4 id=\"3-兼容性\"><a href=\"#3-兼容性\" class=\"headerlink\" title=\"(3) 兼容性\"></a><strong>(3) 兼容性</strong></h4><ul>\n<li><strong>与 JavaScript 兼容</strong>：<br>TypeScript 是 JavaScript 的超集，任何合法的 JavaScript 代码都是合法的 TypeScript 代码。</li>\n<li><strong>渐进式采用</strong>：<br>可以在现有 JavaScript 项目中逐步引入 TypeScript。</li>\n</ul>\n<hr>\n<h3 id=\"3-TypeScript-的基本语法\"><a href=\"#3-TypeScript-的基本语法\" class=\"headerlink\" title=\"3. TypeScript 的基本语法\"></a><strong>3. TypeScript 的基本语法</strong></h3><h4 id=\"1-类型注解\"><a href=\"#1-类型注解\" class=\"headerlink\" title=\"(1) 类型注解\"></a><strong>(1) 类型注解</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">isDone</span>: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">count</span>: <span class=\"built_in\">number</span> = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;TypeScript&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-接口\"><a href=\"#2-接口\" class=\"headerlink\" title=\"(2) 接口\"></a><strong>(2) 接口</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    email?: <span class=\"built_in\">string</span>;  <span class=\"comment\">// 可选属性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">user</span>: <span class=\"title class_\">User</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-类\"><a href=\"#3-类\" class=\"headerlink\" title=\"(3) 类\"></a><strong>(3) 类</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">person.<span class=\"title function_\">greet</span>();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-泛型\"><a href=\"#4-泛型\" class=\"headerlink\" title=\"(4) 泛型\"></a><strong>(4) 泛型</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;T&gt;(<span class=\"attr\">arg</span>: T): T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> output = identity&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-模块化\"><a href=\"#5-模块化\" class=\"headerlink\" title=\"(5) 模块化\"></a><strong>(5) 模块化</strong></h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// math.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a: <span class=\"built_in\">number</span>, b: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; add &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./math&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">add</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"4-TypeScript-的工作流程\"><a href=\"#4-TypeScript-的工作流程\" class=\"headerlink\" title=\"4. TypeScript 的工作流程\"></a><strong>4. TypeScript 的工作流程</strong></h3><ol>\n<li><strong>编写 TypeScript 代码</strong>：<br>使用 <code>.ts</code> 或 <code>.tsx</code> 文件编写代码。</li>\n<li><strong>编译 TypeScript</strong>：<br>使用 TypeScript 编译器（<code>tsc</code>）将代码编译为 JavaScript：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc main.ts</span><br></pre></td></tr></table></figure></li>\n<li><strong>运行 JavaScript</strong>：<br>执行生成的 <code>.js</code> 文件。</li>\n</ol>\n<hr>\n<h3 id=\"5-TypeScript-的适用场景\"><a href=\"#5-TypeScript-的适用场景\" class=\"headerlink\" title=\"5. TypeScript 的适用场景\"></a><strong>5. TypeScript 的适用场景</strong></h3><ul>\n<li><strong>大型项目</strong>：<br>类型系统有助于管理复杂的代码库。</li>\n<li><strong>团队协作</strong>：<br>类型注解和接口定义可以提高团队协作效率。</li>\n<li><strong>框架开发</strong>：<br>许多现代前端框架（如 Angular、Vue 3、React）都支持 TypeScript。</li>\n<li><strong>渐进式迁移</strong>：<br>可以在现有 JavaScript 项目中逐步引入 TypeScript。</li>\n</ul>\n<hr>\n<h3 id=\"6-TypeScript-与-JavaScript-的区别\"><a href=\"#6-TypeScript-与-JavaScript-的区别\" class=\"headerlink\" title=\"6. TypeScript 与 JavaScript 的区别\"></a><strong>6. TypeScript 与 JavaScript 的区别</strong></h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>TypeScript</th>\n<th>JavaScript</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>类型系统</strong></td>\n<td>静态类型</td>\n<td>动态类型</td>\n</tr>\n<tr>\n<td><strong>编译</strong></td>\n<td>需要编译为 JavaScript</td>\n<td>直接运行</td>\n</tr>\n<tr>\n<td><strong>工具支持</strong></td>\n<td>强大的 IDE 支持</td>\n<td>有限的工具支持</td>\n</tr>\n<tr>\n<td><strong>学习曲线</strong></td>\n<td>较高（需要学习类型系统）</td>\n<td>较低</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>大型项目、团队协作</td>\n<td>小型项目、快速原型开发</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"7-如何开始学习-TypeScript\"><a href=\"#7-如何开始学习-TypeScript\" class=\"headerlink\" title=\"7. 如何开始学习 TypeScript\"></a><strong>7. 如何开始学习 TypeScript</strong></h3><ol>\n<li><strong>安装 TypeScript</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure></li>\n<li><strong>编写第一个 TypeScript 程序</strong>：<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hello.ts</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, <span class=\"subst\">$&#123;name&#125;</span>!`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">greet</span>(<span class=\"string\">&quot;TypeScript&quot;</span>));</span><br></pre></td></tr></table></figure></li>\n<li><strong>编译并运行</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc hello.ts</span><br><span class=\"line\">node hello.js</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>TypeScript 是一种强大的编程语言，通过静态类型检查和现代语言特性，显著提升了 JavaScript 的开发效率和代码质量。它特别适合大型项目、团队协作以及对代码质量要求较高的场景。如果你已经熟悉 JavaScript，学习 TypeScript 将是一个自然且有益的进阶选择。</p>"},{"title":"what is mpx","date":"2025-03-15T15:04:48.000Z","_content":"MPX 是一个 **面向小程序开发的前端框架**，由滴滴出行团队开源，专为提升小程序开发效率和性能而设计。它基于 Vue.js 的语法和特性，同时针对小程序的特点进行了深度优化和扩展。以下是 MPX 的核心特性和详细介绍：\n\n---\n\n### **1. MPX 的核心特性**\n#### **(1) 基于 Vue.js 语法**\n- **语法兼容**：  \n  MPX 支持 Vue.js 的模板语法、计算属性、侦听器、生命周期钩子等，开发者可以快速上手。\n- **响应式数据**：  \n  支持 Vue 风格的响应式数据绑定，简化状态管理。\n\n#### **(2) 多平台支持**\n- **跨平台开发**：  \n  MPX 支持将同一套代码编译到微信小程序、支付宝小程序、百度小程序、字节跳动小程序等多个平台。\n- **平台差异化处理**：  \n  提供平台特定的 API 和配置，方便处理不同平台的兼容性问题。\n\n#### **(3) 性能优化**\n- **运行时优化**：  \n  通过减少不必要的 setData 调用和优化数据更新机制，提升小程序的运行性能。\n- **体积优化**：  \n  支持按需加载和代码分割，减小小程序包体积。\n\n#### **(4) 增强的开发体验**\n- **单文件组件**：  \n  支持 `.mpx` 单文件组件，将模板、脚本、样式封装在一个文件中，提升开发效率。\n- **TypeScript 支持**：  \n  提供完整的 TypeScript 支持，增强代码的可维护性和类型安全。\n- **插件系统**：  \n  支持丰富的插件生态，方便扩展功能（如状态管理、请求封装等）。\n\n#### **(5) 状态管理**\n- **Vuex 支持**：  \n  内置 Vuex 支持，方便管理全局状态。\n- **轻量级状态管理**：  \n  提供更轻量的状态管理方案，适合小型项目。\n\n---\n\n### **2. MPX 的核心架构**\n#### **(1) 编译时**\n- **模板编译**：  \n  将 `.mpx` 文件中的模板编译为小程序支持的 WXML。\n- **样式编译**：  \n  支持 Sass、Less 等预处理器，并将样式编译为小程序的 WXSS。\n- **脚本编译**：  \n  将 Vue.js 语法转换为小程序支持的 JS 代码。\n\n#### **(2) 运行时**\n- **响应式系统**：  \n  基于 Vue.js 的响应式系统，实现数据与视图的绑定。\n- **生命周期适配**：  \n  将 Vue.js 的生命周期钩子映射到小程序的生命周期中。\n\n#### **(3) 多平台适配**\n- **平台差异抹平**：  \n  通过统一的 API 和配置，抹平不同小程序平台的差异。\n- **条件编译**：  \n  支持条件编译，针对不同平台编写特定的代码逻辑。\n\n---\n\n### **3. MPX 的使用场景**\n- **多平台小程序开发**：  \n  适合需要同时发布到多个小程序平台的项目。\n- **复杂业务逻辑**：  \n  适合需要复杂状态管理和组件化开发的场景。\n- **性能敏感项目**：  \n  适合对性能要求较高的小程序项目。\n\n---\n\n### **4. MPX 的优缺点**\n#### **优点**\n- **开发效率高**：  \n  基于 Vue.js 语法，学习成本低，开发效率高。\n- **跨平台支持**：  \n  一套代码多端运行，减少重复开发。\n- **性能优化**：  \n  针对小程序性能做了深度优化。\n- **生态丰富**：  \n  支持 TypeScript、Vuex 等现代前端工具。\n\n#### **缺点**\n- **社区规模较小**：  \n  相比 Taro 和 uni-app，MPX 的社区和生态相对较小。\n- **平台兼容性**：  \n  虽然支持多平台，但在某些特定平台的兼容性上可能需要额外处理。\n\n---\n\n### **5. MPX 与其他小程序框架对比**\n| 特性                | MPX                     | Taro                   | uni-app                |\n|---------------------|-------------------------|------------------------|------------------------|\n| **语法基础**         | Vue.js                  | React                  | Vue.js                 |\n| **跨平台支持**       | 微信、支付宝、百度等     | 微信、支付宝、H5 等     | 微信、支付宝、H5、App 等 |\n| **性能优化**         | 深度优化                | 一般优化                | 一般优化                |\n| **生态丰富度**       | 中等                    | 丰富                    | 丰富                    |\n| **学习成本**         | 低（Vue.js 开发者）      | 中（React 开发者）      | 低（Vue.js 开发者）     |\n\n---\n\n### **6. 快速上手 MPX**\n#### **(1) 安装**\n```bash\nnpm install @mpxjs/cli -g\n```\n\n#### **(2) 创建项目**\n```bash\nmpx init my-project\n```\n\n#### **(3) 开发与构建**\n- 开发模式：\n  ```bash\n  npm run watch\n  ```\n- 生产构建：\n  ```bash\n  npm run build\n  ```\n\n#### **(4) 示例代码**\n```html\n<template>\n  <view class=\"container\">\n    <text>{{ message }}</text>\n    <button @tap=\"changeMessage\">点击我</button>\n  </view>\n</template>\n\n<script>\nimport { createComponent } from '@mpxjs/core'\n\ncreateComponent({\n  data: {\n    message: 'Hello MPX!'\n  },\n  methods: {\n    changeMessage() {\n      this.message = '你好，MPX！'\n    }\n  }\n})\n</script>\n\n<style lang=\"stylus\">\n.container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n}\n</style>\n```\n\n---\n\n### **总结**\nMPX 是一个专注于小程序开发的 Vue.js 风格框架，具有跨平台支持、性能优化和开发效率高等特点。它适合需要多平台发布、复杂业务逻辑和性能敏感的小程序项目。如果你已经是 Vue.js 开发者，MPX 将是一个快速上手且高效的选择。\n","source":"_posts/what-is-mpx.md","raw":"---\ntitle: what is mpx\ndate: 2025-03-15 23:04:48\ntags:\n---\nMPX 是一个 **面向小程序开发的前端框架**，由滴滴出行团队开源，专为提升小程序开发效率和性能而设计。它基于 Vue.js 的语法和特性，同时针对小程序的特点进行了深度优化和扩展。以下是 MPX 的核心特性和详细介绍：\n\n---\n\n### **1. MPX 的核心特性**\n#### **(1) 基于 Vue.js 语法**\n- **语法兼容**：  \n  MPX 支持 Vue.js 的模板语法、计算属性、侦听器、生命周期钩子等，开发者可以快速上手。\n- **响应式数据**：  \n  支持 Vue 风格的响应式数据绑定，简化状态管理。\n\n#### **(2) 多平台支持**\n- **跨平台开发**：  \n  MPX 支持将同一套代码编译到微信小程序、支付宝小程序、百度小程序、字节跳动小程序等多个平台。\n- **平台差异化处理**：  \n  提供平台特定的 API 和配置，方便处理不同平台的兼容性问题。\n\n#### **(3) 性能优化**\n- **运行时优化**：  \n  通过减少不必要的 setData 调用和优化数据更新机制，提升小程序的运行性能。\n- **体积优化**：  \n  支持按需加载和代码分割，减小小程序包体积。\n\n#### **(4) 增强的开发体验**\n- **单文件组件**：  \n  支持 `.mpx` 单文件组件，将模板、脚本、样式封装在一个文件中，提升开发效率。\n- **TypeScript 支持**：  \n  提供完整的 TypeScript 支持，增强代码的可维护性和类型安全。\n- **插件系统**：  \n  支持丰富的插件生态，方便扩展功能（如状态管理、请求封装等）。\n\n#### **(5) 状态管理**\n- **Vuex 支持**：  \n  内置 Vuex 支持，方便管理全局状态。\n- **轻量级状态管理**：  \n  提供更轻量的状态管理方案，适合小型项目。\n\n---\n\n### **2. MPX 的核心架构**\n#### **(1) 编译时**\n- **模板编译**：  \n  将 `.mpx` 文件中的模板编译为小程序支持的 WXML。\n- **样式编译**：  \n  支持 Sass、Less 等预处理器，并将样式编译为小程序的 WXSS。\n- **脚本编译**：  \n  将 Vue.js 语法转换为小程序支持的 JS 代码。\n\n#### **(2) 运行时**\n- **响应式系统**：  \n  基于 Vue.js 的响应式系统，实现数据与视图的绑定。\n- **生命周期适配**：  \n  将 Vue.js 的生命周期钩子映射到小程序的生命周期中。\n\n#### **(3) 多平台适配**\n- **平台差异抹平**：  \n  通过统一的 API 和配置，抹平不同小程序平台的差异。\n- **条件编译**：  \n  支持条件编译，针对不同平台编写特定的代码逻辑。\n\n---\n\n### **3. MPX 的使用场景**\n- **多平台小程序开发**：  \n  适合需要同时发布到多个小程序平台的项目。\n- **复杂业务逻辑**：  \n  适合需要复杂状态管理和组件化开发的场景。\n- **性能敏感项目**：  \n  适合对性能要求较高的小程序项目。\n\n---\n\n### **4. MPX 的优缺点**\n#### **优点**\n- **开发效率高**：  \n  基于 Vue.js 语法，学习成本低，开发效率高。\n- **跨平台支持**：  \n  一套代码多端运行，减少重复开发。\n- **性能优化**：  \n  针对小程序性能做了深度优化。\n- **生态丰富**：  \n  支持 TypeScript、Vuex 等现代前端工具。\n\n#### **缺点**\n- **社区规模较小**：  \n  相比 Taro 和 uni-app，MPX 的社区和生态相对较小。\n- **平台兼容性**：  \n  虽然支持多平台，但在某些特定平台的兼容性上可能需要额外处理。\n\n---\n\n### **5. MPX 与其他小程序框架对比**\n| 特性                | MPX                     | Taro                   | uni-app                |\n|---------------------|-------------------------|------------------------|------------------------|\n| **语法基础**         | Vue.js                  | React                  | Vue.js                 |\n| **跨平台支持**       | 微信、支付宝、百度等     | 微信、支付宝、H5 等     | 微信、支付宝、H5、App 等 |\n| **性能优化**         | 深度优化                | 一般优化                | 一般优化                |\n| **生态丰富度**       | 中等                    | 丰富                    | 丰富                    |\n| **学习成本**         | 低（Vue.js 开发者）      | 中（React 开发者）      | 低（Vue.js 开发者）     |\n\n---\n\n### **6. 快速上手 MPX**\n#### **(1) 安装**\n```bash\nnpm install @mpxjs/cli -g\n```\n\n#### **(2) 创建项目**\n```bash\nmpx init my-project\n```\n\n#### **(3) 开发与构建**\n- 开发模式：\n  ```bash\n  npm run watch\n  ```\n- 生产构建：\n  ```bash\n  npm run build\n  ```\n\n#### **(4) 示例代码**\n```html\n<template>\n  <view class=\"container\">\n    <text>{{ message }}</text>\n    <button @tap=\"changeMessage\">点击我</button>\n  </view>\n</template>\n\n<script>\nimport { createComponent } from '@mpxjs/core'\n\ncreateComponent({\n  data: {\n    message: 'Hello MPX!'\n  },\n  methods: {\n    changeMessage() {\n      this.message = '你好，MPX！'\n    }\n  }\n})\n</script>\n\n<style lang=\"stylus\">\n.container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n}\n</style>\n```\n\n---\n\n### **总结**\nMPX 是一个专注于小程序开发的 Vue.js 风格框架，具有跨平台支持、性能优化和开发效率高等特点。它适合需要多平台发布、复杂业务逻辑和性能敏感的小程序项目。如果你已经是 Vue.js 开发者，MPX 将是一个快速上手且高效的选择。\n","slug":"what-is-mpx","published":1,"updated":"2025-03-15T15:09:28.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8k002m1xcodojdeyjj","content":"<p>MPX 是一个 <strong>面向小程序开发的前端框架</strong>，由滴滴出行团队开源，专为提升小程序开发效率和性能而设计。它基于 Vue.js 的语法和特性，同时针对小程序的特点进行了深度优化和扩展。以下是 MPX 的核心特性和详细介绍：</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"1-MPX-的核心特性\"><a href=\"#1-MPX-的核心特性\" class=\"headerlink\" title=\"1. MPX 的核心特性\"></a><strong>1. MPX 的核心特性</strong></h3><h4 id=\"1-基于-Vue-js-语法\"><a href=\"#1-基于-Vue-js-语法\" class=\"headerlink\" title=\"(1) 基于 Vue.js 语法\"></a><strong>(1) 基于 Vue.js 语法</strong></h4><ul>\n<li><strong>语法兼容</strong>：<br>MPX 支持 Vue.js 的模板语法、计算属性、侦听器、生命周期钩子等，开发者可以快速上手。</li>\n<li><strong>响应式数据</strong>：<br>支持 Vue 风格的响应式数据绑定，简化状态管理。</li>\n</ul>\n<h4 id=\"2-多平台支持\"><a href=\"#2-多平台支持\" class=\"headerlink\" title=\"(2) 多平台支持\"></a><strong>(2) 多平台支持</strong></h4><ul>\n<li><strong>跨平台开发</strong>：<br>MPX 支持将同一套代码编译到微信小程序、支付宝小程序、百度小程序、字节跳动小程序等多个平台。</li>\n<li><strong>平台差异化处理</strong>：<br>提供平台特定的 API 和配置，方便处理不同平台的兼容性问题。</li>\n</ul>\n<h4 id=\"3-性能优化\"><a href=\"#3-性能优化\" class=\"headerlink\" title=\"(3) 性能优化\"></a><strong>(3) 性能优化</strong></h4><ul>\n<li><strong>运行时优化</strong>：<br>通过减少不必要的 setData 调用和优化数据更新机制，提升小程序的运行性能。</li>\n<li><strong>体积优化</strong>：<br>支持按需加载和代码分割，减小小程序包体积。</li>\n</ul>\n<h4 id=\"4-增强的开发体验\"><a href=\"#4-增强的开发体验\" class=\"headerlink\" title=\"(4) 增强的开发体验\"></a><strong>(4) 增强的开发体验</strong></h4><ul>\n<li><strong>单文件组件</strong>：<br>支持 <code>.mpx</code> 单文件组件，将模板、脚本、样式封装在一个文件中，提升开发效率。</li>\n<li><strong>TypeScript 支持</strong>：<br>提供完整的 TypeScript 支持，增强代码的可维护性和类型安全。</li>\n<li><strong>插件系统</strong>：<br>支持丰富的插件生态，方便扩展功能（如状态管理、请求封装等）。</li>\n</ul>\n<h4 id=\"5-状态管理\"><a href=\"#5-状态管理\" class=\"headerlink\" title=\"(5) 状态管理\"></a><strong>(5) 状态管理</strong></h4><ul>\n<li><strong>Vuex 支持</strong>：<br>内置 Vuex 支持，方便管理全局状态。</li>\n<li><strong>轻量级状态管理</strong>：<br>提供更轻量的状态管理方案，适合小型项目。</li>\n</ul>\n<hr>\n<h3 id=\"2-MPX-的核心架构\"><a href=\"#2-MPX-的核心架构\" class=\"headerlink\" title=\"2. MPX 的核心架构\"></a><strong>2. MPX 的核心架构</strong></h3><h4 id=\"1-编译时\"><a href=\"#1-编译时\" class=\"headerlink\" title=\"(1) 编译时\"></a><strong>(1) 编译时</strong></h4><ul>\n<li><strong>模板编译</strong>：<br>将 <code>.mpx</code> 文件中的模板编译为小程序支持的 WXML。</li>\n<li><strong>样式编译</strong>：<br>支持 Sass、Less 等预处理器，并将样式编译为小程序的 WXSS。</li>\n<li><strong>脚本编译</strong>：<br>将 Vue.js 语法转换为小程序支持的 JS 代码。</li>\n</ul>\n<h4 id=\"2-运行时\"><a href=\"#2-运行时\" class=\"headerlink\" title=\"(2) 运行时\"></a><strong>(2) 运行时</strong></h4><ul>\n<li><strong>响应式系统</strong>：<br>基于 Vue.js 的响应式系统，实现数据与视图的绑定。</li>\n<li><strong>生命周期适配</strong>：<br>将 Vue.js 的生命周期钩子映射到小程序的生命周期中。</li>\n</ul>\n<h4 id=\"3-多平台适配\"><a href=\"#3-多平台适配\" class=\"headerlink\" title=\"(3) 多平台适配\"></a><strong>(3) 多平台适配</strong></h4><ul>\n<li><strong>平台差异抹平</strong>：<br>通过统一的 API 和配置，抹平不同小程序平台的差异。</li>\n<li><strong>条件编译</strong>：<br>支持条件编译，针对不同平台编写特定的代码逻辑。</li>\n</ul>\n<hr>\n<h3 id=\"3-MPX-的使用场景\"><a href=\"#3-MPX-的使用场景\" class=\"headerlink\" title=\"3. MPX 的使用场景\"></a><strong>3. MPX 的使用场景</strong></h3><ul>\n<li><strong>多平台小程序开发</strong>：<br>适合需要同时发布到多个小程序平台的项目。</li>\n<li><strong>复杂业务逻辑</strong>：<br>适合需要复杂状态管理和组件化开发的场景。</li>\n<li><strong>性能敏感项目</strong>：<br>适合对性能要求较高的小程序项目。</li>\n</ul>\n<hr>\n<h3 id=\"4-MPX-的优缺点\"><a href=\"#4-MPX-的优缺点\" class=\"headerlink\" title=\"4. MPX 的优缺点\"></a><strong>4. MPX 的优缺点</strong></h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a><strong>优点</strong></h4><ul>\n<li><strong>开发效率高</strong>：<br>基于 Vue.js 语法，学习成本低，开发效率高。</li>\n<li><strong>跨平台支持</strong>：<br>一套代码多端运行，减少重复开发。</li>\n<li><strong>性能优化</strong>：<br>针对小程序性能做了深度优化。</li>\n<li><strong>生态丰富</strong>：<br>支持 TypeScript、Vuex 等现代前端工具。</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a><strong>缺点</strong></h4><ul>\n<li><strong>社区规模较小</strong>：<br>相比 Taro 和 uni-app，MPX 的社区和生态相对较小。</li>\n<li><strong>平台兼容性</strong>：<br>虽然支持多平台，但在某些特定平台的兼容性上可能需要额外处理。</li>\n</ul>\n<hr>\n<h3 id=\"5-MPX-与其他小程序框架对比\"><a href=\"#5-MPX-与其他小程序框架对比\" class=\"headerlink\" title=\"5. MPX 与其他小程序框架对比\"></a><strong>5. MPX 与其他小程序框架对比</strong></h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>MPX</th>\n<th>Taro</th>\n<th>uni-app</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>语法基础</strong></td>\n<td>Vue.js</td>\n<td>React</td>\n<td>Vue.js</td>\n</tr>\n<tr>\n<td><strong>跨平台支持</strong></td>\n<td>微信、支付宝、百度等</td>\n<td>微信、支付宝、H5 等</td>\n<td>微信、支付宝、H5、App 等</td>\n</tr>\n<tr>\n<td><strong>性能优化</strong></td>\n<td>深度优化</td>\n<td>一般优化</td>\n<td>一般优化</td>\n</tr>\n<tr>\n<td><strong>生态丰富度</strong></td>\n<td>中等</td>\n<td>丰富</td>\n<td>丰富</td>\n</tr>\n<tr>\n<td><strong>学习成本</strong></td>\n<td>低（Vue.js 开发者）</td>\n<td>中（React 开发者）</td>\n<td>低（Vue.js 开发者）</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"6-快速上手-MPX\"><a href=\"#6-快速上手-MPX\" class=\"headerlink\" title=\"6. 快速上手 MPX\"></a><strong>6. 快速上手 MPX</strong></h3><h4 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"(1) 安装\"></a><strong>(1) 安装</strong></h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @mpxjs/cli -g</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-创建项目\"><a href=\"#2-创建项目\" class=\"headerlink\" title=\"(2) 创建项目\"></a><strong>(2) 创建项目</strong></h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mpx init my-project</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-开发与构建\"><a href=\"#3-开发与构建\" class=\"headerlink\" title=\"(3) 开发与构建\"></a><strong>(3) 开发与构建</strong></h4><ul>\n<li>开发模式：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run watch</span><br></pre></td></tr></table></figure></li>\n<li>生产构建：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"4-示例代码\"><a href=\"#4-示例代码\" class=\"headerlink\" title=\"(4) 示例代码\"></a><strong>(4) 示例代码</strong></h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">tap</span>=<span class=\"string\">&quot;changeMessage&quot;</span>&gt;</span>点击我<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; createComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@mpxjs/core&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"title function_\">createComponent</span>(&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">data</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello MPX!&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">methods</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">changeMessage</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"variable language_\">this</span>.<span class=\"property\">message</span> = <span class=\"string\">&#x27;你好，MPX！&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;)</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;stylus&quot;</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-class\">.container</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">display</span>: flex;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">justify-content</span>: center;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">align-items</span>: center;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">&#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>MPX 是一个专注于小程序开发的 Vue.js 风格框架，具有跨平台支持、性能优化和开发效率高等特点。它适合需要多平台发布、复杂业务逻辑和性能敏感的小程序项目。如果你已经是 Vue.js 开发者，MPX 将是一个快速上手且高效的选择。</p>\n","site":{"data":{}},"excerpt":"<p>MPX 是一个 <strong>面向小程序开发的前端框架</strong>，由滴滴出行团队开源，专为提升小程序开发效率和性能而设计。它基于 Vue.js 的语法和特性，同时针对小程序的特点进行了深度优化和扩展。以下是 MPX 的核心特性和详细介绍：</p>","more":"<hr>\n<h3 id=\"1-MPX-的核心特性\"><a href=\"#1-MPX-的核心特性\" class=\"headerlink\" title=\"1. MPX 的核心特性\"></a><strong>1. MPX 的核心特性</strong></h3><h4 id=\"1-基于-Vue-js-语法\"><a href=\"#1-基于-Vue-js-语法\" class=\"headerlink\" title=\"(1) 基于 Vue.js 语法\"></a><strong>(1) 基于 Vue.js 语法</strong></h4><ul>\n<li><strong>语法兼容</strong>：<br>MPX 支持 Vue.js 的模板语法、计算属性、侦听器、生命周期钩子等，开发者可以快速上手。</li>\n<li><strong>响应式数据</strong>：<br>支持 Vue 风格的响应式数据绑定，简化状态管理。</li>\n</ul>\n<h4 id=\"2-多平台支持\"><a href=\"#2-多平台支持\" class=\"headerlink\" title=\"(2) 多平台支持\"></a><strong>(2) 多平台支持</strong></h4><ul>\n<li><strong>跨平台开发</strong>：<br>MPX 支持将同一套代码编译到微信小程序、支付宝小程序、百度小程序、字节跳动小程序等多个平台。</li>\n<li><strong>平台差异化处理</strong>：<br>提供平台特定的 API 和配置，方便处理不同平台的兼容性问题。</li>\n</ul>\n<h4 id=\"3-性能优化\"><a href=\"#3-性能优化\" class=\"headerlink\" title=\"(3) 性能优化\"></a><strong>(3) 性能优化</strong></h4><ul>\n<li><strong>运行时优化</strong>：<br>通过减少不必要的 setData 调用和优化数据更新机制，提升小程序的运行性能。</li>\n<li><strong>体积优化</strong>：<br>支持按需加载和代码分割，减小小程序包体积。</li>\n</ul>\n<h4 id=\"4-增强的开发体验\"><a href=\"#4-增强的开发体验\" class=\"headerlink\" title=\"(4) 增强的开发体验\"></a><strong>(4) 增强的开发体验</strong></h4><ul>\n<li><strong>单文件组件</strong>：<br>支持 <code>.mpx</code> 单文件组件，将模板、脚本、样式封装在一个文件中，提升开发效率。</li>\n<li><strong>TypeScript 支持</strong>：<br>提供完整的 TypeScript 支持，增强代码的可维护性和类型安全。</li>\n<li><strong>插件系统</strong>：<br>支持丰富的插件生态，方便扩展功能（如状态管理、请求封装等）。</li>\n</ul>\n<h4 id=\"5-状态管理\"><a href=\"#5-状态管理\" class=\"headerlink\" title=\"(5) 状态管理\"></a><strong>(5) 状态管理</strong></h4><ul>\n<li><strong>Vuex 支持</strong>：<br>内置 Vuex 支持，方便管理全局状态。</li>\n<li><strong>轻量级状态管理</strong>：<br>提供更轻量的状态管理方案，适合小型项目。</li>\n</ul>\n<hr>\n<h3 id=\"2-MPX-的核心架构\"><a href=\"#2-MPX-的核心架构\" class=\"headerlink\" title=\"2. MPX 的核心架构\"></a><strong>2. MPX 的核心架构</strong></h3><h4 id=\"1-编译时\"><a href=\"#1-编译时\" class=\"headerlink\" title=\"(1) 编译时\"></a><strong>(1) 编译时</strong></h4><ul>\n<li><strong>模板编译</strong>：<br>将 <code>.mpx</code> 文件中的模板编译为小程序支持的 WXML。</li>\n<li><strong>样式编译</strong>：<br>支持 Sass、Less 等预处理器，并将样式编译为小程序的 WXSS。</li>\n<li><strong>脚本编译</strong>：<br>将 Vue.js 语法转换为小程序支持的 JS 代码。</li>\n</ul>\n<h4 id=\"2-运行时\"><a href=\"#2-运行时\" class=\"headerlink\" title=\"(2) 运行时\"></a><strong>(2) 运行时</strong></h4><ul>\n<li><strong>响应式系统</strong>：<br>基于 Vue.js 的响应式系统，实现数据与视图的绑定。</li>\n<li><strong>生命周期适配</strong>：<br>将 Vue.js 的生命周期钩子映射到小程序的生命周期中。</li>\n</ul>\n<h4 id=\"3-多平台适配\"><a href=\"#3-多平台适配\" class=\"headerlink\" title=\"(3) 多平台适配\"></a><strong>(3) 多平台适配</strong></h4><ul>\n<li><strong>平台差异抹平</strong>：<br>通过统一的 API 和配置，抹平不同小程序平台的差异。</li>\n<li><strong>条件编译</strong>：<br>支持条件编译，针对不同平台编写特定的代码逻辑。</li>\n</ul>\n<hr>\n<h3 id=\"3-MPX-的使用场景\"><a href=\"#3-MPX-的使用场景\" class=\"headerlink\" title=\"3. MPX 的使用场景\"></a><strong>3. MPX 的使用场景</strong></h3><ul>\n<li><strong>多平台小程序开发</strong>：<br>适合需要同时发布到多个小程序平台的项目。</li>\n<li><strong>复杂业务逻辑</strong>：<br>适合需要复杂状态管理和组件化开发的场景。</li>\n<li><strong>性能敏感项目</strong>：<br>适合对性能要求较高的小程序项目。</li>\n</ul>\n<hr>\n<h3 id=\"4-MPX-的优缺点\"><a href=\"#4-MPX-的优缺点\" class=\"headerlink\" title=\"4. MPX 的优缺点\"></a><strong>4. MPX 的优缺点</strong></h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a><strong>优点</strong></h4><ul>\n<li><strong>开发效率高</strong>：<br>基于 Vue.js 语法，学习成本低，开发效率高。</li>\n<li><strong>跨平台支持</strong>：<br>一套代码多端运行，减少重复开发。</li>\n<li><strong>性能优化</strong>：<br>针对小程序性能做了深度优化。</li>\n<li><strong>生态丰富</strong>：<br>支持 TypeScript、Vuex 等现代前端工具。</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a><strong>缺点</strong></h4><ul>\n<li><strong>社区规模较小</strong>：<br>相比 Taro 和 uni-app，MPX 的社区和生态相对较小。</li>\n<li><strong>平台兼容性</strong>：<br>虽然支持多平台，但在某些特定平台的兼容性上可能需要额外处理。</li>\n</ul>\n<hr>\n<h3 id=\"5-MPX-与其他小程序框架对比\"><a href=\"#5-MPX-与其他小程序框架对比\" class=\"headerlink\" title=\"5. MPX 与其他小程序框架对比\"></a><strong>5. MPX 与其他小程序框架对比</strong></h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>MPX</th>\n<th>Taro</th>\n<th>uni-app</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>语法基础</strong></td>\n<td>Vue.js</td>\n<td>React</td>\n<td>Vue.js</td>\n</tr>\n<tr>\n<td><strong>跨平台支持</strong></td>\n<td>微信、支付宝、百度等</td>\n<td>微信、支付宝、H5 等</td>\n<td>微信、支付宝、H5、App 等</td>\n</tr>\n<tr>\n<td><strong>性能优化</strong></td>\n<td>深度优化</td>\n<td>一般优化</td>\n<td>一般优化</td>\n</tr>\n<tr>\n<td><strong>生态丰富度</strong></td>\n<td>中等</td>\n<td>丰富</td>\n<td>丰富</td>\n</tr>\n<tr>\n<td><strong>学习成本</strong></td>\n<td>低（Vue.js 开发者）</td>\n<td>中（React 开发者）</td>\n<td>低（Vue.js 开发者）</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"6-快速上手-MPX\"><a href=\"#6-快速上手-MPX\" class=\"headerlink\" title=\"6. 快速上手 MPX\"></a><strong>6. 快速上手 MPX</strong></h3><h4 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"(1) 安装\"></a><strong>(1) 安装</strong></h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @mpxjs/cli -g</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-创建项目\"><a href=\"#2-创建项目\" class=\"headerlink\" title=\"(2) 创建项目\"></a><strong>(2) 创建项目</strong></h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mpx init my-project</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-开发与构建\"><a href=\"#3-开发与构建\" class=\"headerlink\" title=\"(3) 开发与构建\"></a><strong>(3) 开发与构建</strong></h4><ul>\n<li>开发模式：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run watch</span><br></pre></td></tr></table></figure></li>\n<li>生产构建：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"4-示例代码\"><a href=\"#4-示例代码\" class=\"headerlink\" title=\"(4) 示例代码\"></a><strong>(4) 示例代码</strong></h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">tap</span>=<span class=\"string\">&quot;changeMessage&quot;</span>&gt;</span>点击我<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">import</span> &#123; createComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@mpxjs/core&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"title function_\">createComponent</span>(&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">data</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello MPX!&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"attr\">methods</span>: &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">changeMessage</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"variable language_\">this</span>.<span class=\"property\">message</span> = <span class=\"string\">&#x27;你好，MPX！&#x27;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;)</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;stylus&quot;</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-class\">.container</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">display</span>: flex;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">justify-content</span>: center;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">align-items</span>: center;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">&#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>MPX 是一个专注于小程序开发的 Vue.js 风格框架，具有跨平台支持、性能优化和开发效率高等特点。它适合需要多平台发布、复杂业务逻辑和性能敏感的小程序项目。如果你已经是 Vue.js 开发者，MPX 将是一个快速上手且高效的选择。</p>"},{"title":"使用__asan_unpoison_memory_region屏蔽某处内存检查","date":"2024-07-22T00:45:16.000Z","_content":"\n`__asan_unpoison_memory_region` 是 AddressSanitizer (ASan) 库中的一个函数。ASan 是一个用于检测内存错误的工具，主要用于 C 和 C++ 程序开发者。`__asan_unpoison_memory_region` 的作用是标记一段内存区域为“未污染”状态，这意味着这段内存可以被访问且不会触发 ASan 的错误报告。\n\n具体来说，这个函数通常用于以下场景：\n1. 在内存被分配后但未初始化之前，标记该区域为未污染，以便在初始化期间可以安全访问。\n2. 当程序知道某段内存区域将被合法访问时，预先标记该区域为未污染，以避免误报。\n\n函数原型通常如下：\n```c\nvoid __asan_unpoison_memory_region(void *addr, size_t size);\n```\n\n参数解释：\n- `addr`：内存区域的起始地址。\n- `size`：内存区域的大小（以字节为单位）。\n\n通过调用这个函数，开发者可以更精细地控制 ASan 的内存监控行为，减少误报，提高调试效率。","source":"_posts/使用-asan-unpoison-memory-region屏蔽某处内存检查.md","raw":"---\ntitle: 使用__asan_unpoison_memory_region屏蔽某处内存检查\ndate: 2024-07-22 08:45:16\ntags:\n---\n\n`__asan_unpoison_memory_region` 是 AddressSanitizer (ASan) 库中的一个函数。ASan 是一个用于检测内存错误的工具，主要用于 C 和 C++ 程序开发者。`__asan_unpoison_memory_region` 的作用是标记一段内存区域为“未污染”状态，这意味着这段内存可以被访问且不会触发 ASan 的错误报告。\n\n具体来说，这个函数通常用于以下场景：\n1. 在内存被分配后但未初始化之前，标记该区域为未污染，以便在初始化期间可以安全访问。\n2. 当程序知道某段内存区域将被合法访问时，预先标记该区域为未污染，以避免误报。\n\n函数原型通常如下：\n```c\nvoid __asan_unpoison_memory_region(void *addr, size_t size);\n```\n\n参数解释：\n- `addr`：内存区域的起始地址。\n- `size`：内存区域的大小（以字节为单位）。\n\n通过调用这个函数，开发者可以更精细地控制 ASan 的内存监控行为，减少误报，提高调试效率。","slug":"使用-asan-unpoison-memory-region屏蔽某处内存检查","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8k002o1xco76q0exyf","content":"<p><code>__asan_unpoison_memory_region</code> 是 AddressSanitizer (ASan) 库中的一个函数。ASan 是一个用于检测内存错误的工具，主要用于 C 和 C++ 程序开发者。<code>__asan_unpoison_memory_region</code> 的作用是标记一段内存区域为“未污染”状态，这意味着这段内存可以被访问且不会触发 ASan 的错误报告。</p>\n<span id=\"more\"></span>\n\n<p>具体来说，这个函数通常用于以下场景：</p>\n<ol>\n<li>在内存被分配后但未初始化之前，标记该区域为未污染，以便在初始化期间可以安全访问。</li>\n<li>当程序知道某段内存区域将被合法访问时，预先标记该区域为未污染，以避免误报。</li>\n</ol>\n<p>函数原型通常如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __asan_unpoison_memory_region(<span class=\"type\">void</span> *addr, <span class=\"type\">size_t</span> size);</span><br></pre></td></tr></table></figure>\n\n<p>参数解释：</p>\n<ul>\n<li><code>addr</code>：内存区域的起始地址。</li>\n<li><code>size</code>：内存区域的大小（以字节为单位）。</li>\n</ul>\n<p>通过调用这个函数，开发者可以更精细地控制 ASan 的内存监控行为，减少误报，提高调试效率。</p>\n","site":{"data":{}},"excerpt":"<p><code>__asan_unpoison_memory_region</code> 是 AddressSanitizer (ASan) 库中的一个函数。ASan 是一个用于检测内存错误的工具，主要用于 C 和 C++ 程序开发者。<code>__asan_unpoison_memory_region</code> 的作用是标记一段内存区域为“未污染”状态，这意味着这段内存可以被访问且不会触发 ASan 的错误报告。</p>","more":"<p>具体来说，这个函数通常用于以下场景：</p>\n<ol>\n<li>在内存被分配后但未初始化之前，标记该区域为未污染，以便在初始化期间可以安全访问。</li>\n<li>当程序知道某段内存区域将被合法访问时，预先标记该区域为未污染，以避免误报。</li>\n</ol>\n<p>函数原型通常如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __asan_unpoison_memory_region(<span class=\"type\">void</span> *addr, <span class=\"type\">size_t</span> size);</span><br></pre></td></tr></table></figure>\n\n<p>参数解释：</p>\n<ul>\n<li><code>addr</code>：内存区域的起始地址。</li>\n<li><code>size</code>：内存区域的大小（以字节为单位）。</li>\n</ul>\n<p>通过调用这个函数，开发者可以更精细地控制 ASan 的内存监控行为，减少误报，提高调试效率。</p>"},{"title":"从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵","date":"2024-07-30T04:26:12.000Z","_content":"\n要从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵，您需要对原矩阵进行一些操作。原矩阵通常是一个3x3或4x4的矩阵。\n\n### 对于3x3矩阵：\n原3x3矩阵的形式如下：\n```\n| a  b  tx |\n| c  d  ty |\n| 0  0  1  |\n```\n\n步骤：\n1. 提取旋转部分（左上2x2子矩阵）：\n```\n| a  b |\n| c  d |\n```\n\n2. 计算缩放因子（可以使用行向量的范数或列向量的范数）：\n```\ns = sqrt(a^2 + c^2) = sqrt(b^2 + d^2)\n```\n\n3. 将旋转部分归一化：\n```\n| a/s  b/s |\n| c/s  d/s |\n```\n\n4. 构建新的3x3矩阵，包含平移分量：\n```\n| a/s  b/s  tx |\n| c/s  d/s  ty |\n|  0    0    1 |\n```\n\n### 对于4x4矩阵：\n原4x4矩阵的形式如下：\n```\n| a  b  c  tx |\n| d  e  f  ty |\n| g  h  i  tz |\n| 0  0  0   1 |\n```\n\n步骤：\n1. 提取旋转部分（左上3x3子矩阵）：\n```\n| a  b  c |\n| d  e  f |\n| g  h  i |\n```\n\n2. 计算缩放因子（可以使用行向量的范数或列向量的范数）：\n```\nsx = sqrt(a^2 + d^2 + g^2)\nsy = sqrt(b^2 + e^2 + h^2)\nsz = sqrt(c^2 + f^2 + i^2)\n```\n\n3. 将旋转部分归一化：\n```\n| a/sx  b/sy  c/sz |\n| d/sx  e/sy  f/sz |\n| g/sx  h/sy  i/sz |\n```\n\n4. 构建新的4x4矩阵，包含平移分量：\n```\n| a/sx  b/sy  c/sz  tx |\n| d/sx  e/sy  f/sz  ty |\n| g/sx  h/sy  i/sz  tz |\n|  0     0     0    1  |\n```\n\n这些步骤可以帮助您从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵。\n","source":"_posts/从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵.md","raw":"---\ntitle: 从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵\ndate: 2024-07-30 12:26:12\ntags:\n---\n\n要从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵，您需要对原矩阵进行一些操作。原矩阵通常是一个3x3或4x4的矩阵。\n\n### 对于3x3矩阵：\n原3x3矩阵的形式如下：\n```\n| a  b  tx |\n| c  d  ty |\n| 0  0  1  |\n```\n\n步骤：\n1. 提取旋转部分（左上2x2子矩阵）：\n```\n| a  b |\n| c  d |\n```\n\n2. 计算缩放因子（可以使用行向量的范数或列向量的范数）：\n```\ns = sqrt(a^2 + c^2) = sqrt(b^2 + d^2)\n```\n\n3. 将旋转部分归一化：\n```\n| a/s  b/s |\n| c/s  d/s |\n```\n\n4. 构建新的3x3矩阵，包含平移分量：\n```\n| a/s  b/s  tx |\n| c/s  d/s  ty |\n|  0    0    1 |\n```\n\n### 对于4x4矩阵：\n原4x4矩阵的形式如下：\n```\n| a  b  c  tx |\n| d  e  f  ty |\n| g  h  i  tz |\n| 0  0  0   1 |\n```\n\n步骤：\n1. 提取旋转部分（左上3x3子矩阵）：\n```\n| a  b  c |\n| d  e  f |\n| g  h  i |\n```\n\n2. 计算缩放因子（可以使用行向量的范数或列向量的范数）：\n```\nsx = sqrt(a^2 + d^2 + g^2)\nsy = sqrt(b^2 + e^2 + h^2)\nsz = sqrt(c^2 + f^2 + i^2)\n```\n\n3. 将旋转部分归一化：\n```\n| a/sx  b/sy  c/sz |\n| d/sx  e/sy  f/sz |\n| g/sx  h/sy  i/sz |\n```\n\n4. 构建新的4x4矩阵，包含平移分量：\n```\n| a/sx  b/sy  c/sz  tx |\n| d/sx  e/sy  f/sz  ty |\n| g/sx  h/sy  i/sz  tz |\n|  0     0     0    1  |\n```\n\n这些步骤可以帮助您从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵。\n","slug":"从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8k002p1xco1htk66zl","content":"<p>要从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵，您需要对原矩阵进行一些操作。原矩阵通常是一个3x3或4x4的矩阵。</p>\n<h3 id=\"对于3x3矩阵：\"><a href=\"#对于3x3矩阵：\" class=\"headerlink\" title=\"对于3x3矩阵：\"></a>对于3x3矩阵：</h3><p>原3x3矩阵的形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b  tx |</span><br><span class=\"line\">| c  d  ty |</span><br><span class=\"line\">| 0  0  1  |</span><br></pre></td></tr></table></figure>\n\n\n\n<span id=\"more\"></span>\n\n<p>步骤：</p>\n<ol>\n<li><p>提取旋转部分（左上2x2子矩阵）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b |</span><br><span class=\"line\">| c  d |</span><br></pre></td></tr></table></figure></li>\n<li><p>计算缩放因子（可以使用行向量的范数或列向量的范数）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = sqrt(a^2 + c^2) = sqrt(b^2 + d^2)</span><br></pre></td></tr></table></figure></li>\n<li><p>将旋转部分归一化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/s  b/s |</span><br><span class=\"line\">| c/s  d/s |</span><br></pre></td></tr></table></figure></li>\n<li><p>构建新的3x3矩阵，包含平移分量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/s  b/s  tx |</span><br><span class=\"line\">| c/s  d/s  ty |</span><br><span class=\"line\">|  0    0    1 |</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"对于4x4矩阵：\"><a href=\"#对于4x4矩阵：\" class=\"headerlink\" title=\"对于4x4矩阵：\"></a>对于4x4矩阵：</h3><p>原4x4矩阵的形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b  c  tx |</span><br><span class=\"line\">| d  e  f  ty |</span><br><span class=\"line\">| g  h  i  tz |</span><br><span class=\"line\">| 0  0  0   1 |</span><br></pre></td></tr></table></figure>\n\n<p>步骤：</p>\n<ol>\n<li><p>提取旋转部分（左上3x3子矩阵）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b  c |</span><br><span class=\"line\">| d  e  f |</span><br><span class=\"line\">| g  h  i |</span><br></pre></td></tr></table></figure></li>\n<li><p>计算缩放因子（可以使用行向量的范数或列向量的范数）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sx = sqrt(a^2 + d^2 + g^2)</span><br><span class=\"line\">sy = sqrt(b^2 + e^2 + h^2)</span><br><span class=\"line\">sz = sqrt(c^2 + f^2 + i^2)</span><br></pre></td></tr></table></figure></li>\n<li><p>将旋转部分归一化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/sx  b/sy  c/sz |</span><br><span class=\"line\">| d/sx  e/sy  f/sz |</span><br><span class=\"line\">| g/sx  h/sy  i/sz |</span><br></pre></td></tr></table></figure></li>\n<li><p>构建新的4x4矩阵，包含平移分量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/sx  b/sy  c/sz  tx |</span><br><span class=\"line\">| d/sx  e/sy  f/sz  ty |</span><br><span class=\"line\">| g/sx  h/sy  i/sz  tz |</span><br><span class=\"line\">|  0     0     0    1  |</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>这些步骤可以帮助您从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵。</p>\n","site":{"data":{}},"excerpt":"<p>要从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵，您需要对原矩阵进行一些操作。原矩阵通常是一个3x3或4x4的矩阵。</p>\n<h3 id=\"对于3x3矩阵：\"><a href=\"#对于3x3矩阵：\" class=\"headerlink\" title=\"对于3x3矩阵：\"></a>对于3x3矩阵：</h3><p>原3x3矩阵的形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b  tx |</span><br><span class=\"line\">| c  d  ty |</span><br><span class=\"line\">| 0  0  1  |</span><br></pre></td></tr></table></figure>","more":"<p>步骤：</p>\n<ol>\n<li><p>提取旋转部分（左上2x2子矩阵）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b |</span><br><span class=\"line\">| c  d |</span><br></pre></td></tr></table></figure></li>\n<li><p>计算缩放因子（可以使用行向量的范数或列向量的范数）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = sqrt(a^2 + c^2) = sqrt(b^2 + d^2)</span><br></pre></td></tr></table></figure></li>\n<li><p>将旋转部分归一化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/s  b/s |</span><br><span class=\"line\">| c/s  d/s |</span><br></pre></td></tr></table></figure></li>\n<li><p>构建新的3x3矩阵，包含平移分量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/s  b/s  tx |</span><br><span class=\"line\">| c/s  d/s  ty |</span><br><span class=\"line\">|  0    0    1 |</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"对于4x4矩阵：\"><a href=\"#对于4x4矩阵：\" class=\"headerlink\" title=\"对于4x4矩阵：\"></a>对于4x4矩阵：</h3><p>原4x4矩阵的形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b  c  tx |</span><br><span class=\"line\">| d  e  f  ty |</span><br><span class=\"line\">| g  h  i  tz |</span><br><span class=\"line\">| 0  0  0   1 |</span><br></pre></td></tr></table></figure>\n\n<p>步骤：</p>\n<ol>\n<li><p>提取旋转部分（左上3x3子矩阵）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a  b  c |</span><br><span class=\"line\">| d  e  f |</span><br><span class=\"line\">| g  h  i |</span><br></pre></td></tr></table></figure></li>\n<li><p>计算缩放因子（可以使用行向量的范数或列向量的范数）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sx = sqrt(a^2 + d^2 + g^2)</span><br><span class=\"line\">sy = sqrt(b^2 + e^2 + h^2)</span><br><span class=\"line\">sz = sqrt(c^2 + f^2 + i^2)</span><br></pre></td></tr></table></figure></li>\n<li><p>将旋转部分归一化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/sx  b/sy  c/sz |</span><br><span class=\"line\">| d/sx  e/sy  f/sz |</span><br><span class=\"line\">| g/sx  h/sy  i/sz |</span><br></pre></td></tr></table></figure></li>\n<li><p>构建新的4x4矩阵，包含平移分量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| a/sx  b/sy  c/sz  tx |</span><br><span class=\"line\">| d/sx  e/sy  f/sz  ty |</span><br><span class=\"line\">| g/sx  h/sy  i/sz  tz |</span><br><span class=\"line\">|  0     0     0    1  |</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>这些步骤可以帮助您从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵。</p>"},{"title":"分支预测","date":"2024-09-27T01:25:37.000Z","_content":"\n1. 宏定义解释\n```cpp\n#define likely(x) __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n```\n\n* likely(x):\n这个宏用于表示某个条件 x 是“可能为真”的。它的作用是告诉编译器，x 很可能为真（即返回值为 1）。\n__builtin_expect(!!(x), 1) 的作用是将 x 的值转换为布尔值（0 或 1），并告诉编译器这个值很可能是 1。\n* unlikely(x):\n这个宏用于表示某个条件 x 是“可能为假”的。它的作用是告诉编译器，x 很可能为假（即返回值为 0）。\n__builtin_expect(!!(x), 0) 的作用是将 x 的值转换为布尔值，并告诉编译器这个值很可能是 0。\n\n2. 使用场景\n这些宏通常用于条件语句中，以优化分支预测。例如：\n\n```cpp\nif (likely(condition)) {\n    // 处理条件为真的情况\n} else {\n    // 处理条件为假的情况\n}\n```\n\n在这个例子中，使用 likely 可以帮助编译器优化代码生成，使得在条件为真的情况下，相关的代码路径更快。\n\n3. 优化原理\n分支预测：现代 CPU 通常具有分支预测机制，能够根据历史执行路径预测条件语句的结果。通过使用 likely 和 unlikely，开发者可以显式地告诉编译器和 CPU 哪个分支更可能被执行，从而提高预测的准确性。\n性能提升：在性能敏感的代码中，减少错误的分支预测可以显著提高执行效率，尤其是在循环和频繁调用的函数中。\n\n4. 注意事项\n可读性：虽然使用这些宏可以提高性能，但过度使用可能会影响代码的可读性。应在性能关键的部分使用，而不是在所有条件判断中使用。\n编译器支持：__builtin_expect 是 GCC 和 Clang 的扩展，其他编译器可能不支持此功能。在使用时需要确保代码的可移植性。\n总结\nlikely 和 unlikely 宏通过利用 __builtin_expect 提供了对条件分支的预测信息，帮助编译器生成更高效的代码。它们在性能敏感的应用中非常有用，尤其是在需要优化分支预测的场景中","source":"_posts/分支预测.md","raw":"---\ntitle: 分支预测\ndate: 2024-09-27 09:25:37\ntags:\n---\n\n1. 宏定义解释\n```cpp\n#define likely(x) __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n```\n\n* likely(x):\n这个宏用于表示某个条件 x 是“可能为真”的。它的作用是告诉编译器，x 很可能为真（即返回值为 1）。\n__builtin_expect(!!(x), 1) 的作用是将 x 的值转换为布尔值（0 或 1），并告诉编译器这个值很可能是 1。\n* unlikely(x):\n这个宏用于表示某个条件 x 是“可能为假”的。它的作用是告诉编译器，x 很可能为假（即返回值为 0）。\n__builtin_expect(!!(x), 0) 的作用是将 x 的值转换为布尔值，并告诉编译器这个值很可能是 0。\n\n2. 使用场景\n这些宏通常用于条件语句中，以优化分支预测。例如：\n\n```cpp\nif (likely(condition)) {\n    // 处理条件为真的情况\n} else {\n    // 处理条件为假的情况\n}\n```\n\n在这个例子中，使用 likely 可以帮助编译器优化代码生成，使得在条件为真的情况下，相关的代码路径更快。\n\n3. 优化原理\n分支预测：现代 CPU 通常具有分支预测机制，能够根据历史执行路径预测条件语句的结果。通过使用 likely 和 unlikely，开发者可以显式地告诉编译器和 CPU 哪个分支更可能被执行，从而提高预测的准确性。\n性能提升：在性能敏感的代码中，减少错误的分支预测可以显著提高执行效率，尤其是在循环和频繁调用的函数中。\n\n4. 注意事项\n可读性：虽然使用这些宏可以提高性能，但过度使用可能会影响代码的可读性。应在性能关键的部分使用，而不是在所有条件判断中使用。\n编译器支持：__builtin_expect 是 GCC 和 Clang 的扩展，其他编译器可能不支持此功能。在使用时需要确保代码的可移植性。\n总结\nlikely 和 unlikely 宏通过利用 __builtin_expect 提供了对条件分支的预测信息，帮助编译器生成更高效的代码。它们在性能敏感的应用中非常有用，尤其是在需要优化分支预测的场景中","slug":"分支预测","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8k002q1xcohzeo6kyq","content":"<ol>\n<li>宏定义解释<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<span id=\"more\"></span>\n\n<ul>\n<li>likely(x):<br>这个宏用于表示某个条件 x 是“可能为真”的。它的作用是告诉编译器，x 很可能为真（即返回值为 1）。<br>__builtin_expect(!!(x), 1) 的作用是将 x 的值转换为布尔值（0 或 1），并告诉编译器这个值很可能是 1。</li>\n<li>unlikely(x):<br>这个宏用于表示某个条件 x 是“可能为假”的。它的作用是告诉编译器，x 很可能为假（即返回值为 0）。<br>__builtin_expect(!!(x), 0) 的作用是将 x 的值转换为布尔值，并告诉编译器这个值很可能是 0。</li>\n</ul>\n<ol start=\"2\">\n<li>使用场景<br>这些宏通常用于条件语句中，以优化分支预测。例如：</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">likely</span>(condition)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理条件为真的情况</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理条件为假的情况</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，使用 likely 可以帮助编译器优化代码生成，使得在条件为真的情况下，相关的代码路径更快。</p>\n<ol start=\"3\">\n<li><p>优化原理<br>分支预测：现代 CPU 通常具有分支预测机制，能够根据历史执行路径预测条件语句的结果。通过使用 likely 和 unlikely，开发者可以显式地告诉编译器和 CPU 哪个分支更可能被执行，从而提高预测的准确性。<br>性能提升：在性能敏感的代码中，减少错误的分支预测可以显著提高执行效率，尤其是在循环和频繁调用的函数中。</p>\n</li>\n<li><p>注意事项<br>可读性：虽然使用这些宏可以提高性能，但过度使用可能会影响代码的可读性。应在性能关键的部分使用，而不是在所有条件判断中使用。<br>编译器支持：__builtin_expect 是 GCC 和 Clang 的扩展，其他编译器可能不支持此功能。在使用时需要确保代码的可移植性。<br>总结<br>likely 和 unlikely 宏通过利用 __builtin_expect 提供了对条件分支的预测信息，帮助编译器生成更高效的代码。它们在性能敏感的应用中非常有用，尤其是在需要优化分支预测的场景中</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ol>\n<li>宏定义解释<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure></li>\n</ol>","more":"<ul>\n<li>likely(x):<br>这个宏用于表示某个条件 x 是“可能为真”的。它的作用是告诉编译器，x 很可能为真（即返回值为 1）。<br>__builtin_expect(!!(x), 1) 的作用是将 x 的值转换为布尔值（0 或 1），并告诉编译器这个值很可能是 1。</li>\n<li>unlikely(x):<br>这个宏用于表示某个条件 x 是“可能为假”的。它的作用是告诉编译器，x 很可能为假（即返回值为 0）。<br>__builtin_expect(!!(x), 0) 的作用是将 x 的值转换为布尔值，并告诉编译器这个值很可能是 0。</li>\n</ul>\n<ol start=\"2\">\n<li>使用场景<br>这些宏通常用于条件语句中，以优化分支预测。例如：</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">likely</span>(condition)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理条件为真的情况</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理条件为假的情况</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，使用 likely 可以帮助编译器优化代码生成，使得在条件为真的情况下，相关的代码路径更快。</p>\n<ol start=\"3\">\n<li><p>优化原理<br>分支预测：现代 CPU 通常具有分支预测机制，能够根据历史执行路径预测条件语句的结果。通过使用 likely 和 unlikely，开发者可以显式地告诉编译器和 CPU 哪个分支更可能被执行，从而提高预测的准确性。<br>性能提升：在性能敏感的代码中，减少错误的分支预测可以显著提高执行效率，尤其是在循环和频繁调用的函数中。</p>\n</li>\n<li><p>注意事项<br>可读性：虽然使用这些宏可以提高性能，但过度使用可能会影响代码的可读性。应在性能关键的部分使用，而不是在所有条件判断中使用。<br>编译器支持：__builtin_expect 是 GCC 和 Clang 的扩展，其他编译器可能不支持此功能。在使用时需要确保代码的可移植性。<br>总结<br>likely 和 unlikely 宏通过利用 __builtin_expect 提供了对条件分支的预测信息，帮助编译器生成更高效的代码。它们在性能敏感的应用中非常有用，尤其是在需要优化分支预测的场景中</p>\n</li>\n</ol>"},{"title":"命令行通配符","date":"2024-11-04T09:14:07.000Z","_content":"\n### 这是因为 shell 中的通配符（`*`）展开行为不同：\n\n1. `unzip *.zip`：\n- shell 会先展开 `*.zip`，如果当前目录有多个 zip 文件\n- 命令会变成 `unzip file1.zip file2.zip file3.zip`\n- 这可能导致 unzip 命令收到多个参数而报错\n\n<!-- more -->\n\n2. `unzip \"*.zip\"`：\n- 引号阻止了 shell 展开通配符\n- 通配符会直接传递给 unzip 命令\n- unzip 命令自己处理通配符匹配\n\n### 正确的写法有几种：\n\n```bash\n# 方法1：使用引号\nunzip \"*.zip\"\n\n# 方法2：使用转义\nunzip \\*.zip\n\n# 方法3：使用循环处理多个文件\nfor zip in *.zip; do\n    unzip \"$zip\"\ndone\n\n# 方法4：使用find命令\nfind . -name \"*.zip\" -exec unzip {} \\;\n```\n\n如果需要更健壮的处理：\n\n```bash\n#!/bin/bash\n\n# 解压所有zip文件\nunzip_all() {\n    local zip_files=( *.zip )\n    \n    # 检查是否存在zip文件\n    if [ ! -e \"${zip_files[0]}\" ]; then\n        echo \"没有找到zip文件\"\n        return 1\n    }\n    \n    # 逐个解压\n    for zip in \"${zip_files[@]}\"; do\n        echo \"解压: $zip\"\n        if ! unzip \"$zip\"; then\n            echo \"解压失败: $zip\"\n            return 1\n        fi\n    done\n}\n```","source":"_posts/命令行通配符.md","raw":"---\ntitle: 命令行通配符\ndate: 2024-11-04 17:14:07\ntags:\n---\n\n### 这是因为 shell 中的通配符（`*`）展开行为不同：\n\n1. `unzip *.zip`：\n- shell 会先展开 `*.zip`，如果当前目录有多个 zip 文件\n- 命令会变成 `unzip file1.zip file2.zip file3.zip`\n- 这可能导致 unzip 命令收到多个参数而报错\n\n<!-- more -->\n\n2. `unzip \"*.zip\"`：\n- 引号阻止了 shell 展开通配符\n- 通配符会直接传递给 unzip 命令\n- unzip 命令自己处理通配符匹配\n\n### 正确的写法有几种：\n\n```bash\n# 方法1：使用引号\nunzip \"*.zip\"\n\n# 方法2：使用转义\nunzip \\*.zip\n\n# 方法3：使用循环处理多个文件\nfor zip in *.zip; do\n    unzip \"$zip\"\ndone\n\n# 方法4：使用find命令\nfind . -name \"*.zip\" -exec unzip {} \\;\n```\n\n如果需要更健壮的处理：\n\n```bash\n#!/bin/bash\n\n# 解压所有zip文件\nunzip_all() {\n    local zip_files=( *.zip )\n    \n    # 检查是否存在zip文件\n    if [ ! -e \"${zip_files[0]}\" ]; then\n        echo \"没有找到zip文件\"\n        return 1\n    }\n    \n    # 逐个解压\n    for zip in \"${zip_files[@]}\"; do\n        echo \"解压: $zip\"\n        if ! unzip \"$zip\"; then\n            echo \"解压失败: $zip\"\n            return 1\n        fi\n    done\n}\n```","slug":"命令行通配符","published":1,"updated":"2025-06-07T09:16:19.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8l002r1xco5t8lan0x","content":"<h3 id=\"这是因为-shell-中的通配符（-）展开行为不同：\"><a href=\"#这是因为-shell-中的通配符（-）展开行为不同：\" class=\"headerlink\" title=\"这是因为 shell 中的通配符（*）展开行为不同：\"></a>这是因为 shell 中的通配符（<code>*</code>）展开行为不同：</h3><ol>\n<li><code>unzip *.zip</code>：</li>\n</ol>\n<ul>\n<li>shell 会先展开 <code>*.zip</code>，如果当前目录有多个 zip 文件</li>\n<li>命令会变成 <code>unzip file1.zip file2.zip file3.zip</code></li>\n<li>这可能导致 unzip 命令收到多个参数而报错</li>\n</ul>\n<span id=\"more\"></span>\n\n<ol start=\"2\">\n<li><code>unzip &quot;*.zip&quot;</code>：</li>\n</ol>\n<ul>\n<li>引号阻止了 shell 展开通配符</li>\n<li>通配符会直接传递给 unzip 命令</li>\n<li>unzip 命令自己处理通配符匹配</li>\n</ul>\n<h3 id=\"正确的写法有几种：\"><a href=\"#正确的写法有几种：\" class=\"headerlink\" title=\"正确的写法有几种：\"></a>正确的写法有几种：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方法1：使用引号</span></span><br><span class=\"line\">unzip <span class=\"string\">&quot;*.zip&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法2：使用转义</span></span><br><span class=\"line\">unzip \\*.zip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法3：使用循环处理多个文件</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> zip <span class=\"keyword\">in</span> *.zip; <span class=\"keyword\">do</span></span><br><span class=\"line\">    unzip <span class=\"string\">&quot;<span class=\"variable\">$zip</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法4：使用find命令</span></span><br><span class=\"line\">find . -name <span class=\"string\">&quot;*.zip&quot;</span> -<span class=\"built_in\">exec</span> unzip &#123;&#125; \\;</span><br></pre></td></tr></table></figure>\n\n<p>如果需要更健壮的处理：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压所有zip文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip_all</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">local</span> zip_files=( *.zip )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 检查是否存在zip文件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ ! -e <span class=\"string\">&quot;<span class=\"variable\">$&#123;zip_files[0]&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;没有找到zip文件&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">return</span> 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 逐个解压</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> zip <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;zip_files[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;解压: <span class=\"variable\">$zip</span>&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ! unzip <span class=\"string\">&quot;<span class=\"variable\">$zip</span>&quot;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;解压失败: <span class=\"variable\">$zip</span>&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> 1</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"这是因为-shell-中的通配符（-）展开行为不同：\"><a href=\"#这是因为-shell-中的通配符（-）展开行为不同：\" class=\"headerlink\" title=\"这是因为 shell 中的通配符（*）展开行为不同：\"></a>这是因为 shell 中的通配符（<code>*</code>）展开行为不同：</h3><ol>\n<li><code>unzip *.zip</code>：</li>\n</ol>\n<ul>\n<li>shell 会先展开 <code>*.zip</code>，如果当前目录有多个 zip 文件</li>\n<li>命令会变成 <code>unzip file1.zip file2.zip file3.zip</code></li>\n<li>这可能导致 unzip 命令收到多个参数而报错</li>\n</ul>","more":"<ol start=\"2\">\n<li><code>unzip &quot;*.zip&quot;</code>：</li>\n</ol>\n<ul>\n<li>引号阻止了 shell 展开通配符</li>\n<li>通配符会直接传递给 unzip 命令</li>\n<li>unzip 命令自己处理通配符匹配</li>\n</ul>\n<h3 id=\"正确的写法有几种：\"><a href=\"#正确的写法有几种：\" class=\"headerlink\" title=\"正确的写法有几种：\"></a>正确的写法有几种：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方法1：使用引号</span></span><br><span class=\"line\">unzip <span class=\"string\">&quot;*.zip&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法2：使用转义</span></span><br><span class=\"line\">unzip \\*.zip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法3：使用循环处理多个文件</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> zip <span class=\"keyword\">in</span> *.zip; <span class=\"keyword\">do</span></span><br><span class=\"line\">    unzip <span class=\"string\">&quot;<span class=\"variable\">$zip</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法4：使用find命令</span></span><br><span class=\"line\">find . -name <span class=\"string\">&quot;*.zip&quot;</span> -<span class=\"built_in\">exec</span> unzip &#123;&#125; \\;</span><br></pre></td></tr></table></figure>\n\n<p>如果需要更健壮的处理：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压所有zip文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip_all</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">local</span> zip_files=( *.zip )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 检查是否存在zip文件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ ! -e <span class=\"string\">&quot;<span class=\"variable\">$&#123;zip_files[0]&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;没有找到zip文件&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">return</span> 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 逐个解压</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> zip <span class=\"keyword\">in</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;zip_files[@]&#125;</span>&quot;</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;解压: <span class=\"variable\">$zip</span>&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ! unzip <span class=\"string\">&quot;<span class=\"variable\">$zip</span>&quot;</span>; <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;解压失败: <span class=\"variable\">$zip</span>&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> 1</span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">done</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"模板规则推导","date":"2023-12-21T05:56:09.000Z","_content":"\n### 模板推导规则\n\n```\ntemplate<typename T>\nvoid passByRefFun(T& val) { }\n\ntemplate<typename T>\nvoid passByUniRefFun(T&& val) { }\n\ntemplate<typename T>\nvoid passByValueFun(T val) { }\n\nvoid fun3(int& a) { }\nvoid fun3(int&& a) { }\n\nvoid test()\n{\n    int a = 0;          //a int\n    const int b = a;    //b const int\n    const int& c = a;   //c const int&\n    \n    passByRefFun(a);    // int&\n    passByRefFun(b);    // const int&\n    passByRefFun(c);    // const int&\n    //passByRefFun(27);   // 报错\n    \n    passByUniRefFun(a); // int&\n    passByUniRefFun(b); // const int&\n    passByUniRefFun(c); // const int&\n    passByUniRefFun(27); // int&&\n    \n    passByValueFun(a);  // int\n    passByValueFun(b);  // int\n    passByValueFun(c);  // int\n    passByValueFun(27); // int\n    \n    {\n        int&& a = 10;\n        fun3(a);            // called void fun3(int& a)\n        fun3(std::move(a)); // called void fun3(int&& a)\n        \n    }\n}\n```\n\n\n### SFINAE\nSFINAE（Substitution Failure Is Not An Error）是 C++ 中的一个重要概念，主要用于模板编程。它的意思是，当模板参数替换导致错误时，编译器不会将其视为错误，而是会继续查找其他可能的匹配。这使得我们可以在模板中进行条件编译，选择合适的重载或特化\n\nSFINAE 的优势\n条件编译：可以根据类型特征选择不同的实现，增强代码的灵活性和可重用性。\n避免编译错误：当模板参数替换导致错误时，编译器不会将其视为错误，而是继续查找其他匹配的模板。\n类型安全：通过类型特征，可以确保只有符合条件的类型才能使用特定的模板实现。\n\n\nSFINAE 是 C++ 模板编程中的一个强大工具，允许开发者根据类型特征选择合适的模板特化或重载。通过结合 std::enable_if 和类型特征，开发者可以编写更灵活和安全的代码。","source":"_posts/模板规则推导.md","raw":"---\ntitle: 模板规则推导\ndate: 2023-12-21 13:56:09\ntags:\n---\n\n### 模板推导规则\n\n```\ntemplate<typename T>\nvoid passByRefFun(T& val) { }\n\ntemplate<typename T>\nvoid passByUniRefFun(T&& val) { }\n\ntemplate<typename T>\nvoid passByValueFun(T val) { }\n\nvoid fun3(int& a) { }\nvoid fun3(int&& a) { }\n\nvoid test()\n{\n    int a = 0;          //a int\n    const int b = a;    //b const int\n    const int& c = a;   //c const int&\n    \n    passByRefFun(a);    // int&\n    passByRefFun(b);    // const int&\n    passByRefFun(c);    // const int&\n    //passByRefFun(27);   // 报错\n    \n    passByUniRefFun(a); // int&\n    passByUniRefFun(b); // const int&\n    passByUniRefFun(c); // const int&\n    passByUniRefFun(27); // int&&\n    \n    passByValueFun(a);  // int\n    passByValueFun(b);  // int\n    passByValueFun(c);  // int\n    passByValueFun(27); // int\n    \n    {\n        int&& a = 10;\n        fun3(a);            // called void fun3(int& a)\n        fun3(std::move(a)); // called void fun3(int&& a)\n        \n    }\n}\n```\n\n\n### SFINAE\nSFINAE（Substitution Failure Is Not An Error）是 C++ 中的一个重要概念，主要用于模板编程。它的意思是，当模板参数替换导致错误时，编译器不会将其视为错误，而是会继续查找其他可能的匹配。这使得我们可以在模板中进行条件编译，选择合适的重载或特化\n\nSFINAE 的优势\n条件编译：可以根据类型特征选择不同的实现，增强代码的灵活性和可重用性。\n避免编译错误：当模板参数替换导致错误时，编译器不会将其视为错误，而是继续查找其他匹配的模板。\n类型安全：通过类型特征，可以确保只有符合条件的类型才能使用特定的模板实现。\n\n\nSFINAE 是 C++ 模板编程中的一个强大工具，允许开发者根据类型特征选择合适的模板特化或重载。通过结合 std::enable_if 和类型特征，开发者可以编写更灵活和安全的代码。","slug":"模板规则推导","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8l002s1xcoew3gd4ti","content":"<h3 id=\"模板推导规则\"><a href=\"#模板推导规则\" class=\"headerlink\" title=\"模板推导规则\"></a>模板推导规则</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void passByRefFun(T&amp; val) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void passByUniRefFun(T&amp;&amp; val) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void passByValueFun(T val) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void fun3(int&amp; a) &#123; &#125;</span><br><span class=\"line\">void fun3(int&amp;&amp; a) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void test()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a = 0;          //a int</span><br><span class=\"line\">    const int b = a;    //b const int</span><br><span class=\"line\">    const int&amp; c = a;   //c const int&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    passByRefFun(a);    // int&amp;</span><br><span class=\"line\">    passByRefFun(b);    // const int&amp;</span><br><span class=\"line\">    passByRefFun(c);    // const int&amp;</span><br><span class=\"line\">    //passByRefFun(27);   // 报错</span><br><span class=\"line\">    </span><br><span class=\"line\">    passByUniRefFun(a); // int&amp;</span><br><span class=\"line\">    passByUniRefFun(b); // const int&amp;</span><br><span class=\"line\">    passByUniRefFun(c); // const int&amp;</span><br><span class=\"line\">    passByUniRefFun(27); // int&amp;&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    passByValueFun(a);  // int</span><br><span class=\"line\">    passByValueFun(b);  // int</span><br><span class=\"line\">    passByValueFun(c);  // int</span><br><span class=\"line\">    passByValueFun(27); // int</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int&amp;&amp; a = 10;</span><br><span class=\"line\">        fun3(a);            // called void fun3(int&amp; a)</span><br><span class=\"line\">        fun3(std::move(a)); // called void fun3(int&amp;&amp; a)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<span id=\"more\"></span>\n\n\n<h3 id=\"SFINAE\"><a href=\"#SFINAE\" class=\"headerlink\" title=\"SFINAE\"></a>SFINAE</h3><p>SFINAE（Substitution Failure Is Not An Error）是 C++ 中的一个重要概念，主要用于模板编程。它的意思是，当模板参数替换导致错误时，编译器不会将其视为错误，而是会继续查找其他可能的匹配。这使得我们可以在模板中进行条件编译，选择合适的重载或特化</p>\n<p>SFINAE 的优势<br>条件编译：可以根据类型特征选择不同的实现，增强代码的灵活性和可重用性。<br>避免编译错误：当模板参数替换导致错误时，编译器不会将其视为错误，而是继续查找其他匹配的模板。<br>类型安全：通过类型特征，可以确保只有符合条件的类型才能使用特定的模板实现。</p>\n<p>SFINAE 是 C++ 模板编程中的一个强大工具，允许开发者根据类型特征选择合适的模板特化或重载。通过结合 std::enable_if 和类型特征，开发者可以编写更灵活和安全的代码。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"模板推导规则\"><a href=\"#模板推导规则\" class=\"headerlink\" title=\"模板推导规则\"></a>模板推导规则</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void passByRefFun(T&amp; val) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void passByUniRefFun(T&amp;&amp; val) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">void passByValueFun(T val) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void fun3(int&amp; a) &#123; &#125;</span><br><span class=\"line\">void fun3(int&amp;&amp; a) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void test()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a = 0;          //a int</span><br><span class=\"line\">    const int b = a;    //b const int</span><br><span class=\"line\">    const int&amp; c = a;   //c const int&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    passByRefFun(a);    // int&amp;</span><br><span class=\"line\">    passByRefFun(b);    // const int&amp;</span><br><span class=\"line\">    passByRefFun(c);    // const int&amp;</span><br><span class=\"line\">    //passByRefFun(27);   // 报错</span><br><span class=\"line\">    </span><br><span class=\"line\">    passByUniRefFun(a); // int&amp;</span><br><span class=\"line\">    passByUniRefFun(b); // const int&amp;</span><br><span class=\"line\">    passByUniRefFun(c); // const int&amp;</span><br><span class=\"line\">    passByUniRefFun(27); // int&amp;&amp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    passByValueFun(a);  // int</span><br><span class=\"line\">    passByValueFun(b);  // int</span><br><span class=\"line\">    passByValueFun(c);  // int</span><br><span class=\"line\">    passByValueFun(27); // int</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int&amp;&amp; a = 10;</span><br><span class=\"line\">        fun3(a);            // called void fun3(int&amp; a)</span><br><span class=\"line\">        fun3(std::move(a)); // called void fun3(int&amp;&amp; a)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"SFINAE\"><a href=\"#SFINAE\" class=\"headerlink\" title=\"SFINAE\"></a>SFINAE</h3><p>SFINAE（Substitution Failure Is Not An Error）是 C++ 中的一个重要概念，主要用于模板编程。它的意思是，当模板参数替换导致错误时，编译器不会将其视为错误，而是会继续查找其他可能的匹配。这使得我们可以在模板中进行条件编译，选择合适的重载或特化</p>\n<p>SFINAE 的优势<br>条件编译：可以根据类型特征选择不同的实现，增强代码的灵活性和可重用性。<br>避免编译错误：当模板参数替换导致错误时，编译器不会将其视为错误，而是继续查找其他匹配的模板。<br>类型安全：通过类型特征，可以确保只有符合条件的类型才能使用特定的模板实现。</p>\n<p>SFINAE 是 C++ 模板编程中的一个强大工具，允许开发者根据类型特征选择合适的模板特化或重载。通过结合 std::enable_if 和类型特征，开发者可以编写更灵活和安全的代码。</p>"},{"title":"如何让孩子戒掉手机爱上阅读：实用策略指南","date":"2025-06-07T10:00:00.000Z","_content":"\n在数字化时代，如何引导孩子从手机屏幕转向书本页面，是每个家长都关心的话题。本文将分享一些经过实践验证的策略，帮助您的孩子逐步减少对手机的依赖，培养良好的阅读习惯。\n\n<!-- more -->\n\n## 为什么孩子容易沉迷手机？\n\n### 心理层面的原因\n- **即时满足感**：手机游戏和短视频提供即时的快乐反馈\n- **社交需求**：通过社交媒体与同龄人保持联系\n- **逃避现实**：面对学习压力时的一种逃避方式\n- **好奇心驱动**：对新奇内容的天然渴望\n\n### 技术设计的\"陷阱\"\n现代应用程序采用了大量心理学技巧来吸引用户：\n- 无限下拉的信息流\n- 随机奖励机制\n- 推送通知的及时性\n- 个性化推荐算法\n\n## 循序渐进的戒手机策略\n\n### 第一阶段：建立规则和界限\n\n**1. 制定家庭数字使用协议**\n```\n- 用餐时间禁用电子设备\n- 睡前1小时收起所有设备\n- 作业时间手机放在指定位置\n- 周末可适当放宽，但需要计时\n```\n\n**2. 创建\"无手机区域\"**\n- 餐厅：促进家庭交流\n- 卧室：保证睡眠质量\n- 学习桌：提高专注力\n\n### 第二阶段：寻找替代活动\n\n**优质替代活动清单：**\n- 户外运动（骑车、跑步、球类）\n- 手工制作（绘画、折纸、乐高）\n- 音乐学习（乐器演奏、唱歌）\n- 社交活动（与朋友面对面交流）\n\n## 培养阅读兴趣的具体方法\n\n### 1. 营造良好的阅读环境\n\n**物理环境优化：**\n- 设置专门的阅读角落\n- 确保充足的自然光照\n- 准备舒适的座椅和靠垫\n- 减少干扰因素\n\n**家庭阅读氛围：**\n- 父母以身作则，经常阅读\n- 定期进行家庭阅读时间\n- 在家中显眼位置摆放书籍\n- 限制电视和其他电子设备的使用时间\n\n### 2. 选择合适的书籍\n\n**年龄段推荐：**\n\n**3-6岁：**\n- 图画书和绘本\n- 互动式翻翻书\n- 简单的故事书\n\n**7-10岁：**\n- 桥梁书（介于绘本和文字书之间）\n- 科普类读物\n- 冒险故事\n\n**11-14岁：**\n- 青少年小说\n- 科幻和奇幻作品\n- 传记和历史故事\n\n**15岁以上：**\n- 经典文学作品\n- 哲学和思辨类书籍\n- 专业兴趣相关书籍\n\n### 3. 创新的阅读方法\n\n**亲子共读技巧：**\n- 轮流朗读，增加参与感\n- 讨论情节，培养思辨能力\n- 角色扮演，增强理解\n- 绘制思维导图，梳理内容\n\n**阅读游戏化：**\n- 设立阅读积分制度\n- 创建家庭读书俱乐部\n- 举办\"家庭读书分享会\"\n- 制作读书笔记和书评\n\n## 应对常见挑战\n\n### 孩子说\"书太无聊\"\n- 从孩子感兴趣的主题开始\n- 选择有视觉冲击力的书籍\n- 尝试有声书作为过渡\n- 与孩子一起选书，给予选择权\n\n### 注意力不集中\n- 从短篇开始，逐步增加长度\n- 设定小目标，如\"每天读10分钟\"\n- 使用番茄工作法进行阅读\n- 在安静的环境中阅读\n\n### 阅读理解困难\n- 选择适合当前水平的书籍\n- 鼓励孩子问问题\n- 一起查阅不懂的词汇\n- 用图片和实物帮助理解\n\n## 长期坚持的秘诀\n\n### 建立正向反馈循环\n1. **设定合理目标**：从小目标开始，逐步提高\n2. **及时鼓励**：认可孩子的每一次进步\n3. **记录成长**：建立阅读档案，记录阅读历程\n4. **适时调整**：根据孩子的反馈调整策略\n\n### 社区支持的力量\n- 加入其他家长的阅读群体\n- 参加图书馆的活动\n- 与学校老师保持沟通\n- 寻找有相同目标的家庭一起努力\n\n## 成功案例分享\n\n**案例一：张家的\"21天阅读挑战\"**\n张妈妈发现10岁的儿子每天花3小时玩手机后，实施了\"21天阅读挑战\"：\n- 前7天：每天阅读15分钟，手机时间减少30分钟\n- 中间7天：阅读时间增加到30分钟，手机时间再减少30分钟\n- 最后7天：阅读45分钟，手机仅在周末使用\n\n结果：21天后，孩子主动要求继续阅读计划。\n\n## 总结\n\n让孩子戒掉手机爱上阅读不是一蹴而就的过程，需要家长的耐心、坚持和智慧。记住以下几个关键点：\n\n1. **循序渐进**：不要试图一夜之间改变所有习惯\n2. **以身作则**：父母的行为是最好的教育\n3. **保持耐心**：允许孩子有反复，给予时间适应\n4. **个性化策略**：根据孩子的特点调整方法\n5. **创造乐趣**：让阅读成为一种享受，而不是负担\n\n只要坚持正确的方法，相信每个孩子都能够在书籍的世界中找到属于自己的快乐，并逐步减少对电子设备的过度依赖。阅读不仅能够提升孩子的学习能力，更能够培养他们的思维能力、想象力和专注力，为未来的成长打下坚实的基础。 ","source":"_posts/如何让孩子戒掉手机爱上阅读-实用策略指南.md","raw":"---\ntitle: 如何让孩子戒掉手机爱上阅读：实用策略指南\ndate: 2025-06-07 18:00:00\ntags: [教育, 亲子, 阅读, 手机成瘾]\ncategories: [家庭教育]\n---\n\n在数字化时代，如何引导孩子从手机屏幕转向书本页面，是每个家长都关心的话题。本文将分享一些经过实践验证的策略，帮助您的孩子逐步减少对手机的依赖，培养良好的阅读习惯。\n\n<!-- more -->\n\n## 为什么孩子容易沉迷手机？\n\n### 心理层面的原因\n- **即时满足感**：手机游戏和短视频提供即时的快乐反馈\n- **社交需求**：通过社交媒体与同龄人保持联系\n- **逃避现实**：面对学习压力时的一种逃避方式\n- **好奇心驱动**：对新奇内容的天然渴望\n\n### 技术设计的\"陷阱\"\n现代应用程序采用了大量心理学技巧来吸引用户：\n- 无限下拉的信息流\n- 随机奖励机制\n- 推送通知的及时性\n- 个性化推荐算法\n\n## 循序渐进的戒手机策略\n\n### 第一阶段：建立规则和界限\n\n**1. 制定家庭数字使用协议**\n```\n- 用餐时间禁用电子设备\n- 睡前1小时收起所有设备\n- 作业时间手机放在指定位置\n- 周末可适当放宽，但需要计时\n```\n\n**2. 创建\"无手机区域\"**\n- 餐厅：促进家庭交流\n- 卧室：保证睡眠质量\n- 学习桌：提高专注力\n\n### 第二阶段：寻找替代活动\n\n**优质替代活动清单：**\n- 户外运动（骑车、跑步、球类）\n- 手工制作（绘画、折纸、乐高）\n- 音乐学习（乐器演奏、唱歌）\n- 社交活动（与朋友面对面交流）\n\n## 培养阅读兴趣的具体方法\n\n### 1. 营造良好的阅读环境\n\n**物理环境优化：**\n- 设置专门的阅读角落\n- 确保充足的自然光照\n- 准备舒适的座椅和靠垫\n- 减少干扰因素\n\n**家庭阅读氛围：**\n- 父母以身作则，经常阅读\n- 定期进行家庭阅读时间\n- 在家中显眼位置摆放书籍\n- 限制电视和其他电子设备的使用时间\n\n### 2. 选择合适的书籍\n\n**年龄段推荐：**\n\n**3-6岁：**\n- 图画书和绘本\n- 互动式翻翻书\n- 简单的故事书\n\n**7-10岁：**\n- 桥梁书（介于绘本和文字书之间）\n- 科普类读物\n- 冒险故事\n\n**11-14岁：**\n- 青少年小说\n- 科幻和奇幻作品\n- 传记和历史故事\n\n**15岁以上：**\n- 经典文学作品\n- 哲学和思辨类书籍\n- 专业兴趣相关书籍\n\n### 3. 创新的阅读方法\n\n**亲子共读技巧：**\n- 轮流朗读，增加参与感\n- 讨论情节，培养思辨能力\n- 角色扮演，增强理解\n- 绘制思维导图，梳理内容\n\n**阅读游戏化：**\n- 设立阅读积分制度\n- 创建家庭读书俱乐部\n- 举办\"家庭读书分享会\"\n- 制作读书笔记和书评\n\n## 应对常见挑战\n\n### 孩子说\"书太无聊\"\n- 从孩子感兴趣的主题开始\n- 选择有视觉冲击力的书籍\n- 尝试有声书作为过渡\n- 与孩子一起选书，给予选择权\n\n### 注意力不集中\n- 从短篇开始，逐步增加长度\n- 设定小目标，如\"每天读10分钟\"\n- 使用番茄工作法进行阅读\n- 在安静的环境中阅读\n\n### 阅读理解困难\n- 选择适合当前水平的书籍\n- 鼓励孩子问问题\n- 一起查阅不懂的词汇\n- 用图片和实物帮助理解\n\n## 长期坚持的秘诀\n\n### 建立正向反馈循环\n1. **设定合理目标**：从小目标开始，逐步提高\n2. **及时鼓励**：认可孩子的每一次进步\n3. **记录成长**：建立阅读档案，记录阅读历程\n4. **适时调整**：根据孩子的反馈调整策略\n\n### 社区支持的力量\n- 加入其他家长的阅读群体\n- 参加图书馆的活动\n- 与学校老师保持沟通\n- 寻找有相同目标的家庭一起努力\n\n## 成功案例分享\n\n**案例一：张家的\"21天阅读挑战\"**\n张妈妈发现10岁的儿子每天花3小时玩手机后，实施了\"21天阅读挑战\"：\n- 前7天：每天阅读15分钟，手机时间减少30分钟\n- 中间7天：阅读时间增加到30分钟，手机时间再减少30分钟\n- 最后7天：阅读45分钟，手机仅在周末使用\n\n结果：21天后，孩子主动要求继续阅读计划。\n\n## 总结\n\n让孩子戒掉手机爱上阅读不是一蹴而就的过程，需要家长的耐心、坚持和智慧。记住以下几个关键点：\n\n1. **循序渐进**：不要试图一夜之间改变所有习惯\n2. **以身作则**：父母的行为是最好的教育\n3. **保持耐心**：允许孩子有反复，给予时间适应\n4. **个性化策略**：根据孩子的特点调整方法\n5. **创造乐趣**：让阅读成为一种享受，而不是负担\n\n只要坚持正确的方法，相信每个孩子都能够在书籍的世界中找到属于自己的快乐，并逐步减少对电子设备的过度依赖。阅读不仅能够提升孩子的学习能力，更能够培养他们的思维能力、想象力和专注力，为未来的成长打下坚实的基础。 ","slug":"如何让孩子戒掉手机爱上阅读-实用策略指南","published":1,"updated":"2025-06-07T09:40:37.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8l002t1xco5mc5h917","content":"<p>在数字化时代，如何引导孩子从手机屏幕转向书本页面，是每个家长都关心的话题。本文将分享一些经过实践验证的策略，帮助您的孩子逐步减少对手机的依赖，培养良好的阅读习惯。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"为什么孩子容易沉迷手机？\"><a href=\"#为什么孩子容易沉迷手机？\" class=\"headerlink\" title=\"为什么孩子容易沉迷手机？\"></a>为什么孩子容易沉迷手机？</h2><h3 id=\"心理层面的原因\"><a href=\"#心理层面的原因\" class=\"headerlink\" title=\"心理层面的原因\"></a>心理层面的原因</h3><ul>\n<li><strong>即时满足感</strong>：手机游戏和短视频提供即时的快乐反馈</li>\n<li><strong>社交需求</strong>：通过社交媒体与同龄人保持联系</li>\n<li><strong>逃避现实</strong>：面对学习压力时的一种逃避方式</li>\n<li><strong>好奇心驱动</strong>：对新奇内容的天然渴望</li>\n</ul>\n<h3 id=\"技术设计的”陷阱”\"><a href=\"#技术设计的”陷阱”\" class=\"headerlink\" title=\"技术设计的”陷阱”\"></a>技术设计的”陷阱”</h3><p>现代应用程序采用了大量心理学技巧来吸引用户：</p>\n<ul>\n<li>无限下拉的信息流</li>\n<li>随机奖励机制</li>\n<li>推送通知的及时性</li>\n<li>个性化推荐算法</li>\n</ul>\n<h2 id=\"循序渐进的戒手机策略\"><a href=\"#循序渐进的戒手机策略\" class=\"headerlink\" title=\"循序渐进的戒手机策略\"></a>循序渐进的戒手机策略</h2><h3 id=\"第一阶段：建立规则和界限\"><a href=\"#第一阶段：建立规则和界限\" class=\"headerlink\" title=\"第一阶段：建立规则和界限\"></a>第一阶段：建立规则和界限</h3><p><strong>1. 制定家庭数字使用协议</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 用餐时间禁用电子设备</span><br><span class=\"line\">- 睡前1小时收起所有设备</span><br><span class=\"line\">- 作业时间手机放在指定位置</span><br><span class=\"line\">- 周末可适当放宽，但需要计时</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. 创建”无手机区域”</strong></p>\n<ul>\n<li>餐厅：促进家庭交流</li>\n<li>卧室：保证睡眠质量</li>\n<li>学习桌：提高专注力</li>\n</ul>\n<h3 id=\"第二阶段：寻找替代活动\"><a href=\"#第二阶段：寻找替代活动\" class=\"headerlink\" title=\"第二阶段：寻找替代活动\"></a>第二阶段：寻找替代活动</h3><p><strong>优质替代活动清单：</strong></p>\n<ul>\n<li>户外运动（骑车、跑步、球类）</li>\n<li>手工制作（绘画、折纸、乐高）</li>\n<li>音乐学习（乐器演奏、唱歌）</li>\n<li>社交活动（与朋友面对面交流）</li>\n</ul>\n<h2 id=\"培养阅读兴趣的具体方法\"><a href=\"#培养阅读兴趣的具体方法\" class=\"headerlink\" title=\"培养阅读兴趣的具体方法\"></a>培养阅读兴趣的具体方法</h2><h3 id=\"1-营造良好的阅读环境\"><a href=\"#1-营造良好的阅读环境\" class=\"headerlink\" title=\"1. 营造良好的阅读环境\"></a>1. 营造良好的阅读环境</h3><p><strong>物理环境优化：</strong></p>\n<ul>\n<li>设置专门的阅读角落</li>\n<li>确保充足的自然光照</li>\n<li>准备舒适的座椅和靠垫</li>\n<li>减少干扰因素</li>\n</ul>\n<p><strong>家庭阅读氛围：</strong></p>\n<ul>\n<li>父母以身作则，经常阅读</li>\n<li>定期进行家庭阅读时间</li>\n<li>在家中显眼位置摆放书籍</li>\n<li>限制电视和其他电子设备的使用时间</li>\n</ul>\n<h3 id=\"2-选择合适的书籍\"><a href=\"#2-选择合适的书籍\" class=\"headerlink\" title=\"2. 选择合适的书籍\"></a>2. 选择合适的书籍</h3><p><strong>年龄段推荐：</strong></p>\n<p><strong>3-6岁：</strong></p>\n<ul>\n<li>图画书和绘本</li>\n<li>互动式翻翻书</li>\n<li>简单的故事书</li>\n</ul>\n<p><strong>7-10岁：</strong></p>\n<ul>\n<li>桥梁书（介于绘本和文字书之间）</li>\n<li>科普类读物</li>\n<li>冒险故事</li>\n</ul>\n<p><strong>11-14岁：</strong></p>\n<ul>\n<li>青少年小说</li>\n<li>科幻和奇幻作品</li>\n<li>传记和历史故事</li>\n</ul>\n<p><strong>15岁以上：</strong></p>\n<ul>\n<li>经典文学作品</li>\n<li>哲学和思辨类书籍</li>\n<li>专业兴趣相关书籍</li>\n</ul>\n<h3 id=\"3-创新的阅读方法\"><a href=\"#3-创新的阅读方法\" class=\"headerlink\" title=\"3. 创新的阅读方法\"></a>3. 创新的阅读方法</h3><p><strong>亲子共读技巧：</strong></p>\n<ul>\n<li>轮流朗读，增加参与感</li>\n<li>讨论情节，培养思辨能力</li>\n<li>角色扮演，增强理解</li>\n<li>绘制思维导图，梳理内容</li>\n</ul>\n<p><strong>阅读游戏化：</strong></p>\n<ul>\n<li>设立阅读积分制度</li>\n<li>创建家庭读书俱乐部</li>\n<li>举办”家庭读书分享会”</li>\n<li>制作读书笔记和书评</li>\n</ul>\n<h2 id=\"应对常见挑战\"><a href=\"#应对常见挑战\" class=\"headerlink\" title=\"应对常见挑战\"></a>应对常见挑战</h2><h3 id=\"孩子说”书太无聊”\"><a href=\"#孩子说”书太无聊”\" class=\"headerlink\" title=\"孩子说”书太无聊”\"></a>孩子说”书太无聊”</h3><ul>\n<li>从孩子感兴趣的主题开始</li>\n<li>选择有视觉冲击力的书籍</li>\n<li>尝试有声书作为过渡</li>\n<li>与孩子一起选书，给予选择权</li>\n</ul>\n<h3 id=\"注意力不集中\"><a href=\"#注意力不集中\" class=\"headerlink\" title=\"注意力不集中\"></a>注意力不集中</h3><ul>\n<li>从短篇开始，逐步增加长度</li>\n<li>设定小目标，如”每天读10分钟”</li>\n<li>使用番茄工作法进行阅读</li>\n<li>在安静的环境中阅读</li>\n</ul>\n<h3 id=\"阅读理解困难\"><a href=\"#阅读理解困难\" class=\"headerlink\" title=\"阅读理解困难\"></a>阅读理解困难</h3><ul>\n<li>选择适合当前水平的书籍</li>\n<li>鼓励孩子问问题</li>\n<li>一起查阅不懂的词汇</li>\n<li>用图片和实物帮助理解</li>\n</ul>\n<h2 id=\"长期坚持的秘诀\"><a href=\"#长期坚持的秘诀\" class=\"headerlink\" title=\"长期坚持的秘诀\"></a>长期坚持的秘诀</h2><h3 id=\"建立正向反馈循环\"><a href=\"#建立正向反馈循环\" class=\"headerlink\" title=\"建立正向反馈循环\"></a>建立正向反馈循环</h3><ol>\n<li><strong>设定合理目标</strong>：从小目标开始，逐步提高</li>\n<li><strong>及时鼓励</strong>：认可孩子的每一次进步</li>\n<li><strong>记录成长</strong>：建立阅读档案，记录阅读历程</li>\n<li><strong>适时调整</strong>：根据孩子的反馈调整策略</li>\n</ol>\n<h3 id=\"社区支持的力量\"><a href=\"#社区支持的力量\" class=\"headerlink\" title=\"社区支持的力量\"></a>社区支持的力量</h3><ul>\n<li>加入其他家长的阅读群体</li>\n<li>参加图书馆的活动</li>\n<li>与学校老师保持沟通</li>\n<li>寻找有相同目标的家庭一起努力</li>\n</ul>\n<h2 id=\"成功案例分享\"><a href=\"#成功案例分享\" class=\"headerlink\" title=\"成功案例分享\"></a>成功案例分享</h2><p><strong>案例一：张家的”21天阅读挑战”</strong><br>张妈妈发现10岁的儿子每天花3小时玩手机后，实施了”21天阅读挑战”：</p>\n<ul>\n<li>前7天：每天阅读15分钟，手机时间减少30分钟</li>\n<li>中间7天：阅读时间增加到30分钟，手机时间再减少30分钟</li>\n<li>最后7天：阅读45分钟，手机仅在周末使用</li>\n</ul>\n<p>结果：21天后，孩子主动要求继续阅读计划。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>让孩子戒掉手机爱上阅读不是一蹴而就的过程，需要家长的耐心、坚持和智慧。记住以下几个关键点：</p>\n<ol>\n<li><strong>循序渐进</strong>：不要试图一夜之间改变所有习惯</li>\n<li><strong>以身作则</strong>：父母的行为是最好的教育</li>\n<li><strong>保持耐心</strong>：允许孩子有反复，给予时间适应</li>\n<li><strong>个性化策略</strong>：根据孩子的特点调整方法</li>\n<li><strong>创造乐趣</strong>：让阅读成为一种享受，而不是负担</li>\n</ol>\n<p>只要坚持正确的方法，相信每个孩子都能够在书籍的世界中找到属于自己的快乐，并逐步减少对电子设备的过度依赖。阅读不仅能够提升孩子的学习能力，更能够培养他们的思维能力、想象力和专注力，为未来的成长打下坚实的基础。 </p>\n","site":{"data":{}},"excerpt":"<p>在数字化时代，如何引导孩子从手机屏幕转向书本页面，是每个家长都关心的话题。本文将分享一些经过实践验证的策略，帮助您的孩子逐步减少对手机的依赖，培养良好的阅读习惯。</p>","more":"<h2 id=\"为什么孩子容易沉迷手机？\"><a href=\"#为什么孩子容易沉迷手机？\" class=\"headerlink\" title=\"为什么孩子容易沉迷手机？\"></a>为什么孩子容易沉迷手机？</h2><h3 id=\"心理层面的原因\"><a href=\"#心理层面的原因\" class=\"headerlink\" title=\"心理层面的原因\"></a>心理层面的原因</h3><ul>\n<li><strong>即时满足感</strong>：手机游戏和短视频提供即时的快乐反馈</li>\n<li><strong>社交需求</strong>：通过社交媒体与同龄人保持联系</li>\n<li><strong>逃避现实</strong>：面对学习压力时的一种逃避方式</li>\n<li><strong>好奇心驱动</strong>：对新奇内容的天然渴望</li>\n</ul>\n<h3 id=\"技术设计的”陷阱”\"><a href=\"#技术设计的”陷阱”\" class=\"headerlink\" title=\"技术设计的”陷阱”\"></a>技术设计的”陷阱”</h3><p>现代应用程序采用了大量心理学技巧来吸引用户：</p>\n<ul>\n<li>无限下拉的信息流</li>\n<li>随机奖励机制</li>\n<li>推送通知的及时性</li>\n<li>个性化推荐算法</li>\n</ul>\n<h2 id=\"循序渐进的戒手机策略\"><a href=\"#循序渐进的戒手机策略\" class=\"headerlink\" title=\"循序渐进的戒手机策略\"></a>循序渐进的戒手机策略</h2><h3 id=\"第一阶段：建立规则和界限\"><a href=\"#第一阶段：建立规则和界限\" class=\"headerlink\" title=\"第一阶段：建立规则和界限\"></a>第一阶段：建立规则和界限</h3><p><strong>1. 制定家庭数字使用协议</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 用餐时间禁用电子设备</span><br><span class=\"line\">- 睡前1小时收起所有设备</span><br><span class=\"line\">- 作业时间手机放在指定位置</span><br><span class=\"line\">- 周末可适当放宽，但需要计时</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. 创建”无手机区域”</strong></p>\n<ul>\n<li>餐厅：促进家庭交流</li>\n<li>卧室：保证睡眠质量</li>\n<li>学习桌：提高专注力</li>\n</ul>\n<h3 id=\"第二阶段：寻找替代活动\"><a href=\"#第二阶段：寻找替代活动\" class=\"headerlink\" title=\"第二阶段：寻找替代活动\"></a>第二阶段：寻找替代活动</h3><p><strong>优质替代活动清单：</strong></p>\n<ul>\n<li>户外运动（骑车、跑步、球类）</li>\n<li>手工制作（绘画、折纸、乐高）</li>\n<li>音乐学习（乐器演奏、唱歌）</li>\n<li>社交活动（与朋友面对面交流）</li>\n</ul>\n<h2 id=\"培养阅读兴趣的具体方法\"><a href=\"#培养阅读兴趣的具体方法\" class=\"headerlink\" title=\"培养阅读兴趣的具体方法\"></a>培养阅读兴趣的具体方法</h2><h3 id=\"1-营造良好的阅读环境\"><a href=\"#1-营造良好的阅读环境\" class=\"headerlink\" title=\"1. 营造良好的阅读环境\"></a>1. 营造良好的阅读环境</h3><p><strong>物理环境优化：</strong></p>\n<ul>\n<li>设置专门的阅读角落</li>\n<li>确保充足的自然光照</li>\n<li>准备舒适的座椅和靠垫</li>\n<li>减少干扰因素</li>\n</ul>\n<p><strong>家庭阅读氛围：</strong></p>\n<ul>\n<li>父母以身作则，经常阅读</li>\n<li>定期进行家庭阅读时间</li>\n<li>在家中显眼位置摆放书籍</li>\n<li>限制电视和其他电子设备的使用时间</li>\n</ul>\n<h3 id=\"2-选择合适的书籍\"><a href=\"#2-选择合适的书籍\" class=\"headerlink\" title=\"2. 选择合适的书籍\"></a>2. 选择合适的书籍</h3><p><strong>年龄段推荐：</strong></p>\n<p><strong>3-6岁：</strong></p>\n<ul>\n<li>图画书和绘本</li>\n<li>互动式翻翻书</li>\n<li>简单的故事书</li>\n</ul>\n<p><strong>7-10岁：</strong></p>\n<ul>\n<li>桥梁书（介于绘本和文字书之间）</li>\n<li>科普类读物</li>\n<li>冒险故事</li>\n</ul>\n<p><strong>11-14岁：</strong></p>\n<ul>\n<li>青少年小说</li>\n<li>科幻和奇幻作品</li>\n<li>传记和历史故事</li>\n</ul>\n<p><strong>15岁以上：</strong></p>\n<ul>\n<li>经典文学作品</li>\n<li>哲学和思辨类书籍</li>\n<li>专业兴趣相关书籍</li>\n</ul>\n<h3 id=\"3-创新的阅读方法\"><a href=\"#3-创新的阅读方法\" class=\"headerlink\" title=\"3. 创新的阅读方法\"></a>3. 创新的阅读方法</h3><p><strong>亲子共读技巧：</strong></p>\n<ul>\n<li>轮流朗读，增加参与感</li>\n<li>讨论情节，培养思辨能力</li>\n<li>角色扮演，增强理解</li>\n<li>绘制思维导图，梳理内容</li>\n</ul>\n<p><strong>阅读游戏化：</strong></p>\n<ul>\n<li>设立阅读积分制度</li>\n<li>创建家庭读书俱乐部</li>\n<li>举办”家庭读书分享会”</li>\n<li>制作读书笔记和书评</li>\n</ul>\n<h2 id=\"应对常见挑战\"><a href=\"#应对常见挑战\" class=\"headerlink\" title=\"应对常见挑战\"></a>应对常见挑战</h2><h3 id=\"孩子说”书太无聊”\"><a href=\"#孩子说”书太无聊”\" class=\"headerlink\" title=\"孩子说”书太无聊”\"></a>孩子说”书太无聊”</h3><ul>\n<li>从孩子感兴趣的主题开始</li>\n<li>选择有视觉冲击力的书籍</li>\n<li>尝试有声书作为过渡</li>\n<li>与孩子一起选书，给予选择权</li>\n</ul>\n<h3 id=\"注意力不集中\"><a href=\"#注意力不集中\" class=\"headerlink\" title=\"注意力不集中\"></a>注意力不集中</h3><ul>\n<li>从短篇开始，逐步增加长度</li>\n<li>设定小目标，如”每天读10分钟”</li>\n<li>使用番茄工作法进行阅读</li>\n<li>在安静的环境中阅读</li>\n</ul>\n<h3 id=\"阅读理解困难\"><a href=\"#阅读理解困难\" class=\"headerlink\" title=\"阅读理解困难\"></a>阅读理解困难</h3><ul>\n<li>选择适合当前水平的书籍</li>\n<li>鼓励孩子问问题</li>\n<li>一起查阅不懂的词汇</li>\n<li>用图片和实物帮助理解</li>\n</ul>\n<h2 id=\"长期坚持的秘诀\"><a href=\"#长期坚持的秘诀\" class=\"headerlink\" title=\"长期坚持的秘诀\"></a>长期坚持的秘诀</h2><h3 id=\"建立正向反馈循环\"><a href=\"#建立正向反馈循环\" class=\"headerlink\" title=\"建立正向反馈循环\"></a>建立正向反馈循环</h3><ol>\n<li><strong>设定合理目标</strong>：从小目标开始，逐步提高</li>\n<li><strong>及时鼓励</strong>：认可孩子的每一次进步</li>\n<li><strong>记录成长</strong>：建立阅读档案，记录阅读历程</li>\n<li><strong>适时调整</strong>：根据孩子的反馈调整策略</li>\n</ol>\n<h3 id=\"社区支持的力量\"><a href=\"#社区支持的力量\" class=\"headerlink\" title=\"社区支持的力量\"></a>社区支持的力量</h3><ul>\n<li>加入其他家长的阅读群体</li>\n<li>参加图书馆的活动</li>\n<li>与学校老师保持沟通</li>\n<li>寻找有相同目标的家庭一起努力</li>\n</ul>\n<h2 id=\"成功案例分享\"><a href=\"#成功案例分享\" class=\"headerlink\" title=\"成功案例分享\"></a>成功案例分享</h2><p><strong>案例一：张家的”21天阅读挑战”</strong><br>张妈妈发现10岁的儿子每天花3小时玩手机后，实施了”21天阅读挑战”：</p>\n<ul>\n<li>前7天：每天阅读15分钟，手机时间减少30分钟</li>\n<li>中间7天：阅读时间增加到30分钟，手机时间再减少30分钟</li>\n<li>最后7天：阅读45分钟，手机仅在周末使用</li>\n</ul>\n<p>结果：21天后，孩子主动要求继续阅读计划。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>让孩子戒掉手机爱上阅读不是一蹴而就的过程，需要家长的耐心、坚持和智慧。记住以下几个关键点：</p>\n<ol>\n<li><strong>循序渐进</strong>：不要试图一夜之间改变所有习惯</li>\n<li><strong>以身作则</strong>：父母的行为是最好的教育</li>\n<li><strong>保持耐心</strong>：允许孩子有反复，给予时间适应</li>\n<li><strong>个性化策略</strong>：根据孩子的特点调整方法</li>\n<li><strong>创造乐趣</strong>：让阅读成为一种享受，而不是负担</li>\n</ol>\n<p>只要坚持正确的方法，相信每个孩子都能够在书籍的世界中找到属于自己的快乐，并逐步减少对电子设备的过度依赖。阅读不仅能够提升孩子的学习能力，更能够培养他们的思维能力、想象力和专注力，为未来的成长打下坚实的基础。 </p>"},{"title":"培养孩子阅读习惯的优质书单推荐","date":"2025-06-07T10:30:00.000Z","_content":"\n选择合适的书籍是培养孩子阅读兴趣的关键第一步。本文根据不同年龄段孩子的认知特点和兴趣偏好，精心整理了一份优质书单，帮助家长为孩子挑选最适合的读物。\n\n<!-- more -->\n\n## 3-6岁：启蒙阶段书单\n\n### 经典绘本系列\n\n**《好饿的毛毛虫》- 艾瑞克·卡尔**\n- **推荐理由**：色彩鲜艳，故事简单有趣，教授数字和星期概念\n- **阅读技巧**：可以让孩子用手指跟着毛毛虫\"吃\"东西\n- **延伸活动**：制作毛毛虫手工，观察真实的蝴蝶变化过程\n\n**《猜猜我有多爱你》- 山姆·麦克布雷尼**\n- **推荐理由**：温馨的亲情故事，培养表达爱的能力\n- **阅读技巧**：鼓励孩子模仿书中动作，增强互动性\n- **延伸活动**：和孩子一起比较\"谁爱谁更多\"\n\n**《逃家小兔》- 玛格丽特·怀兹·布朗**\n- **推荐理由**：经典的母爱主题，给孩子安全感\n- **阅读技巧**：可以和孩子角色扮演，一个当小兔，一个当妈妈\n- **延伸活动**：讨论\"如果你要逃跑，妈妈会怎么找到你\"\n\n### 中文原创绘本\n\n**《小熊和最好的爸爸》系列 - 阿兰德·丹姆**\n- **推荐理由**：父子情深，适合爸爸和孩子一起阅读\n- **特色**：7本书涵盖不同主题，从游戏到成长\n\n**《不一样的卡梅拉》系列**\n- **推荐理由**：想象力丰富，鼓励孩子勇于尝试\n- **特色**：每本都有不同的冒险故事\n\n## 7-10岁：桥梁书阶段\n\n### 冒险故事类\n\n**《神奇树屋》系列 - 玛丽·波·奥斯本**\n- **推荐理由**：结合历史知识和冒险故事，寓教于乐\n- **阅读建议**：可以按照历史时间线阅读，增强历史感\n- **延伸学习**：查阅相关历史资料，制作时间轴\n\n**《内德的秘密花园》- 琳达·苏·帕克**\n- **推荐理由**：环保主题，培养孩子的责任感\n- **特色**：插图精美，文字适中\n\n### 科普启蒙类\n\n**《可怕的科学》系列**\n- **推荐理由**：用幽默的方式讲解科学知识\n- **特色**：图文并茂，实验性强\n- **阅读建议**：可以和孩子一起做书中的小实验\n\n**《DK儿童百科全书》**\n- **推荐理由**：知识全面，图片精美\n- **使用方法**：不需要从头读到尾，可以按兴趣查阅\n\n### 成长励志类\n\n**《小屁孩日记》系列**\n- **推荐理由**：贴近孩子生活，幽默风趣\n- **特色**：日记体形式，容易引起共鸣\n\n**《窗边的小豆豆》- 黑柳彻子**\n- **推荐理由**：真实的成长故事，培养同理心\n- **教育价值**：让孩子理解不同的教育方式\n\n## 11-14岁：深度阅读阶段\n\n### 经典文学入门\n\n**《哈利·波特》系列 - J.K.罗琳**\n- **推荐理由**：想象力丰富，情节引人入胜\n- **阅读建议**：可以先看前三部，适应后再读后续\n- **延伸活动**：制作魔法道具，讨论友谊和勇气\n\n**《纳尼亚传奇》系列 - C.S.路易斯**\n- **推荐理由**：奇幻冒险，蕴含深刻哲理\n- **特色**：每本都是独立故事，可以单独阅读\n\n**《小王子》- 安托万·德·圣-埃克苏佩里**\n- **推荐理由**：哲理深刻，适合反复阅读\n- **阅读建议**：可以和孩子讨论每个星球的寓意\n\n### 科幻探索类\n\n**《三体》青少年版 - 刘慈欣**\n- **推荐理由**：中国科幻经典，培养科学思维\n- **注意事项**：内容较深，建议有一定阅读基础后再读\n\n**《时间机器》- H.G.威尔斯**\n- **推荐理由**：科幻经典，引发对时间的思考\n- **延伸讨论**：时间旅行的可能性和后果\n\n### 历史传记类\n\n**《上下五千年》**\n- **推荐理由**：了解中国历史，培养文化自信\n- **阅读建议**：可以选择感兴趣的历史人物重点阅读\n\n**《居里夫人传》**\n- **推荐理由**：科学家传记，特别适合女孩阅读\n- **教育价值**：坚持和奉献精神的典范\n\n## 15岁以上：经典文学阶段\n\n### 中外经典名著\n\n**《红楼梦》（青少年版）**\n- **推荐理由**：中国古典文学巅峰之作\n- **阅读建议**：可以先读简化版，培养兴趣后再读原著\n\n**《傲慢与偏见》- 简·奥斯汀**\n- **推荐理由**：经典爱情小说，文笔优美\n- **教育价值**：理解人性的复杂和成长的意义\n\n**《1984》- 乔治·奥威尔**\n- **推荐理由**：反乌托邦经典，培养批判思维\n- **注意事项**：内容较为深刻，需要引导讨论\n\n### 哲学思辨类\n\n**《苏菲的世界》- 乔斯坦·贾德**\n- **推荐理由**：哲学启蒙读物，深入浅出\n- **阅读建议**：可以分章节讨论，不急于一次读完\n\n**《瓦尔登湖》- 梭罗**\n- **推荐理由**：自然哲学，培养独立思考\n- **延伸活动**：尝试简单生活，体验自然\n\n## 选书的实用技巧\n\n### 根据孩子兴趣选择\n\n**观察孩子的偏好：**\n- 喜欢动物的孩子：选择动物主题的故事\n- 喜欢冒险的孩子：选择探险类小说\n- 喜欢科学的孩子：选择科普类读物\n- 喜欢历史的孩子：选择历史故事和传记\n\n### 循序渐进的原则\n\n**难度递增：**\n1. 从图多字少开始\n2. 逐步增加文字比例\n3. 最终过渡到纯文字书籍\n\n**兴趣引导：**\n1. 先选择孩子感兴趣的主题\n2. 在同一主题下选择不同难度的书\n3. 适时引入新的主题和类型\n\n### 质量判断标准\n\n**好书的特征：**\n- 语言优美，适合年龄段\n- 内容积极正面，传递正确价值观\n- 情节引人入胜，能够吸引孩子\n- 插图精美（对于低年龄段）\n- 获得过权威奖项或专家推荐\n\n## 亲子阅读的实施建议\n\n### 创建阅读计划\n\n**每日阅读时间安排：**\n- 3-6岁：15-20分钟\n- 7-10岁：30-45分钟\n- 11-14岁：45-60分钟\n- 15岁以上：60分钟以上\n\n**阅读方式多样化：**\n- 亲子共读\n- 独立阅读\n- 有声书辅助\n- 电子书补充\n\n### 阅读后的互动\n\n**讨论要点：**\n- 最喜欢的角色是谁？为什么？\n- 如果你是主人公，会怎么做？\n- 这个故事告诉我们什么道理？\n- 你想推荐给其他小朋友吗？\n\n**创意活动：**\n- 画出故事中的场景\n- 续写故事结尾\n- 表演故事片段\n- 制作读书笔记\n\n## 建立家庭图书馆\n\n### 购书建议\n\n**预算分配：**\n- 经典必读书籍：60%\n- 孩子兴趣书籍：30%\n- 尝试性新书：10%\n\n**购买渠道：**\n- 实体书店：可以现场翻阅\n- 网上书店：价格优惠，选择丰富\n- 二手书市场：经济实惠\n- 图书馆借阅：先试读再决定是否购买\n\n### 图书管理\n\n**分类整理：**\n- 按年龄段分类\n- 按主题分类\n- 按阅读状态分类（已读/未读/正在读）\n\n**阅读记录：**\n- 建立读书清单\n- 记录阅读日期\n- 写下简单感想\n- 评分推荐指数\n\n## 总结\n\n培养孩子的阅读习惯是一个长期的过程，选择合适的书籍只是第一步。更重要的是要：\n\n1. **尊重孩子的选择**：在推荐的基础上，让孩子有自主选择权\n2. **保持耐心**：不要急于求成，允许孩子有自己的阅读节奏\n3. **以身作则**：家长的阅读习惯是最好的榜样\n4. **创造氛围**：营造良好的家庭阅读环境\n5. **适时引导**：在孩子遇到困难时给予帮助和鼓励\n\n记住，每个孩子都是独特的，最适合的书单是根据自己孩子的特点量身定制的。希望这份书单能够为您提供参考，帮助您的孩子在书籍的海洋中找到属于自己的宝藏，从而逐步减少对手机的依赖，爱上阅读的美好世界。 ","source":"_posts/培养孩子阅读习惯的优质书单推荐.md","raw":"---\ntitle: 培养孩子阅读习惯的优质书单推荐\ndate: 2025-06-07 18:30:00\ntags: [阅读, 书单, 儿童教育, 亲子]\ncategories: [家庭教育]\n---\n\n选择合适的书籍是培养孩子阅读兴趣的关键第一步。本文根据不同年龄段孩子的认知特点和兴趣偏好，精心整理了一份优质书单，帮助家长为孩子挑选最适合的读物。\n\n<!-- more -->\n\n## 3-6岁：启蒙阶段书单\n\n### 经典绘本系列\n\n**《好饿的毛毛虫》- 艾瑞克·卡尔**\n- **推荐理由**：色彩鲜艳，故事简单有趣，教授数字和星期概念\n- **阅读技巧**：可以让孩子用手指跟着毛毛虫\"吃\"东西\n- **延伸活动**：制作毛毛虫手工，观察真实的蝴蝶变化过程\n\n**《猜猜我有多爱你》- 山姆·麦克布雷尼**\n- **推荐理由**：温馨的亲情故事，培养表达爱的能力\n- **阅读技巧**：鼓励孩子模仿书中动作，增强互动性\n- **延伸活动**：和孩子一起比较\"谁爱谁更多\"\n\n**《逃家小兔》- 玛格丽特·怀兹·布朗**\n- **推荐理由**：经典的母爱主题，给孩子安全感\n- **阅读技巧**：可以和孩子角色扮演，一个当小兔，一个当妈妈\n- **延伸活动**：讨论\"如果你要逃跑，妈妈会怎么找到你\"\n\n### 中文原创绘本\n\n**《小熊和最好的爸爸》系列 - 阿兰德·丹姆**\n- **推荐理由**：父子情深，适合爸爸和孩子一起阅读\n- **特色**：7本书涵盖不同主题，从游戏到成长\n\n**《不一样的卡梅拉》系列**\n- **推荐理由**：想象力丰富，鼓励孩子勇于尝试\n- **特色**：每本都有不同的冒险故事\n\n## 7-10岁：桥梁书阶段\n\n### 冒险故事类\n\n**《神奇树屋》系列 - 玛丽·波·奥斯本**\n- **推荐理由**：结合历史知识和冒险故事，寓教于乐\n- **阅读建议**：可以按照历史时间线阅读，增强历史感\n- **延伸学习**：查阅相关历史资料，制作时间轴\n\n**《内德的秘密花园》- 琳达·苏·帕克**\n- **推荐理由**：环保主题，培养孩子的责任感\n- **特色**：插图精美，文字适中\n\n### 科普启蒙类\n\n**《可怕的科学》系列**\n- **推荐理由**：用幽默的方式讲解科学知识\n- **特色**：图文并茂，实验性强\n- **阅读建议**：可以和孩子一起做书中的小实验\n\n**《DK儿童百科全书》**\n- **推荐理由**：知识全面，图片精美\n- **使用方法**：不需要从头读到尾，可以按兴趣查阅\n\n### 成长励志类\n\n**《小屁孩日记》系列**\n- **推荐理由**：贴近孩子生活，幽默风趣\n- **特色**：日记体形式，容易引起共鸣\n\n**《窗边的小豆豆》- 黑柳彻子**\n- **推荐理由**：真实的成长故事，培养同理心\n- **教育价值**：让孩子理解不同的教育方式\n\n## 11-14岁：深度阅读阶段\n\n### 经典文学入门\n\n**《哈利·波特》系列 - J.K.罗琳**\n- **推荐理由**：想象力丰富，情节引人入胜\n- **阅读建议**：可以先看前三部，适应后再读后续\n- **延伸活动**：制作魔法道具，讨论友谊和勇气\n\n**《纳尼亚传奇》系列 - C.S.路易斯**\n- **推荐理由**：奇幻冒险，蕴含深刻哲理\n- **特色**：每本都是独立故事，可以单独阅读\n\n**《小王子》- 安托万·德·圣-埃克苏佩里**\n- **推荐理由**：哲理深刻，适合反复阅读\n- **阅读建议**：可以和孩子讨论每个星球的寓意\n\n### 科幻探索类\n\n**《三体》青少年版 - 刘慈欣**\n- **推荐理由**：中国科幻经典，培养科学思维\n- **注意事项**：内容较深，建议有一定阅读基础后再读\n\n**《时间机器》- H.G.威尔斯**\n- **推荐理由**：科幻经典，引发对时间的思考\n- **延伸讨论**：时间旅行的可能性和后果\n\n### 历史传记类\n\n**《上下五千年》**\n- **推荐理由**：了解中国历史，培养文化自信\n- **阅读建议**：可以选择感兴趣的历史人物重点阅读\n\n**《居里夫人传》**\n- **推荐理由**：科学家传记，特别适合女孩阅读\n- **教育价值**：坚持和奉献精神的典范\n\n## 15岁以上：经典文学阶段\n\n### 中外经典名著\n\n**《红楼梦》（青少年版）**\n- **推荐理由**：中国古典文学巅峰之作\n- **阅读建议**：可以先读简化版，培养兴趣后再读原著\n\n**《傲慢与偏见》- 简·奥斯汀**\n- **推荐理由**：经典爱情小说，文笔优美\n- **教育价值**：理解人性的复杂和成长的意义\n\n**《1984》- 乔治·奥威尔**\n- **推荐理由**：反乌托邦经典，培养批判思维\n- **注意事项**：内容较为深刻，需要引导讨论\n\n### 哲学思辨类\n\n**《苏菲的世界》- 乔斯坦·贾德**\n- **推荐理由**：哲学启蒙读物，深入浅出\n- **阅读建议**：可以分章节讨论，不急于一次读完\n\n**《瓦尔登湖》- 梭罗**\n- **推荐理由**：自然哲学，培养独立思考\n- **延伸活动**：尝试简单生活，体验自然\n\n## 选书的实用技巧\n\n### 根据孩子兴趣选择\n\n**观察孩子的偏好：**\n- 喜欢动物的孩子：选择动物主题的故事\n- 喜欢冒险的孩子：选择探险类小说\n- 喜欢科学的孩子：选择科普类读物\n- 喜欢历史的孩子：选择历史故事和传记\n\n### 循序渐进的原则\n\n**难度递增：**\n1. 从图多字少开始\n2. 逐步增加文字比例\n3. 最终过渡到纯文字书籍\n\n**兴趣引导：**\n1. 先选择孩子感兴趣的主题\n2. 在同一主题下选择不同难度的书\n3. 适时引入新的主题和类型\n\n### 质量判断标准\n\n**好书的特征：**\n- 语言优美，适合年龄段\n- 内容积极正面，传递正确价值观\n- 情节引人入胜，能够吸引孩子\n- 插图精美（对于低年龄段）\n- 获得过权威奖项或专家推荐\n\n## 亲子阅读的实施建议\n\n### 创建阅读计划\n\n**每日阅读时间安排：**\n- 3-6岁：15-20分钟\n- 7-10岁：30-45分钟\n- 11-14岁：45-60分钟\n- 15岁以上：60分钟以上\n\n**阅读方式多样化：**\n- 亲子共读\n- 独立阅读\n- 有声书辅助\n- 电子书补充\n\n### 阅读后的互动\n\n**讨论要点：**\n- 最喜欢的角色是谁？为什么？\n- 如果你是主人公，会怎么做？\n- 这个故事告诉我们什么道理？\n- 你想推荐给其他小朋友吗？\n\n**创意活动：**\n- 画出故事中的场景\n- 续写故事结尾\n- 表演故事片段\n- 制作读书笔记\n\n## 建立家庭图书馆\n\n### 购书建议\n\n**预算分配：**\n- 经典必读书籍：60%\n- 孩子兴趣书籍：30%\n- 尝试性新书：10%\n\n**购买渠道：**\n- 实体书店：可以现场翻阅\n- 网上书店：价格优惠，选择丰富\n- 二手书市场：经济实惠\n- 图书馆借阅：先试读再决定是否购买\n\n### 图书管理\n\n**分类整理：**\n- 按年龄段分类\n- 按主题分类\n- 按阅读状态分类（已读/未读/正在读）\n\n**阅读记录：**\n- 建立读书清单\n- 记录阅读日期\n- 写下简单感想\n- 评分推荐指数\n\n## 总结\n\n培养孩子的阅读习惯是一个长期的过程，选择合适的书籍只是第一步。更重要的是要：\n\n1. **尊重孩子的选择**：在推荐的基础上，让孩子有自主选择权\n2. **保持耐心**：不要急于求成，允许孩子有自己的阅读节奏\n3. **以身作则**：家长的阅读习惯是最好的榜样\n4. **创造氛围**：营造良好的家庭阅读环境\n5. **适时引导**：在孩子遇到困难时给予帮助和鼓励\n\n记住，每个孩子都是独特的，最适合的书单是根据自己孩子的特点量身定制的。希望这份书单能够为您提供参考，帮助您的孩子在书籍的海洋中找到属于自己的宝藏，从而逐步减少对手机的依赖，爱上阅读的美好世界。 ","slug":"培养孩子阅读习惯的优质书单推荐","published":1,"updated":"2025-06-07T09:51:05.668Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8l002u1xco9as712um","content":"<p>选择合适的书籍是培养孩子阅读兴趣的关键第一步。本文根据不同年龄段孩子的认知特点和兴趣偏好，精心整理了一份优质书单，帮助家长为孩子挑选最适合的读物。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"3-6岁：启蒙阶段书单\"><a href=\"#3-6岁：启蒙阶段书单\" class=\"headerlink\" title=\"3-6岁：启蒙阶段书单\"></a>3-6岁：启蒙阶段书单</h2><h3 id=\"经典绘本系列\"><a href=\"#经典绘本系列\" class=\"headerlink\" title=\"经典绘本系列\"></a>经典绘本系列</h3><p><strong>《好饿的毛毛虫》- 艾瑞克·卡尔</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：色彩鲜艳，故事简单有趣，教授数字和星期概念</li>\n<li><strong>阅读技巧</strong>：可以让孩子用手指跟着毛毛虫”吃”东西</li>\n<li><strong>延伸活动</strong>：制作毛毛虫手工，观察真实的蝴蝶变化过程</li>\n</ul>\n<p><strong>《猜猜我有多爱你》- 山姆·麦克布雷尼</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：温馨的亲情故事，培养表达爱的能力</li>\n<li><strong>阅读技巧</strong>：鼓励孩子模仿书中动作，增强互动性</li>\n<li><strong>延伸活动</strong>：和孩子一起比较”谁爱谁更多”</li>\n</ul>\n<p><strong>《逃家小兔》- 玛格丽特·怀兹·布朗</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：经典的母爱主题，给孩子安全感</li>\n<li><strong>阅读技巧</strong>：可以和孩子角色扮演，一个当小兔，一个当妈妈</li>\n<li><strong>延伸活动</strong>：讨论”如果你要逃跑，妈妈会怎么找到你”</li>\n</ul>\n<h3 id=\"中文原创绘本\"><a href=\"#中文原创绘本\" class=\"headerlink\" title=\"中文原创绘本\"></a>中文原创绘本</h3><p><strong>《小熊和最好的爸爸》系列 - 阿兰德·丹姆</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：父子情深，适合爸爸和孩子一起阅读</li>\n<li><strong>特色</strong>：7本书涵盖不同主题，从游戏到成长</li>\n</ul>\n<p><strong>《不一样的卡梅拉》系列</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：想象力丰富，鼓励孩子勇于尝试</li>\n<li><strong>特色</strong>：每本都有不同的冒险故事</li>\n</ul>\n<h2 id=\"7-10岁：桥梁书阶段\"><a href=\"#7-10岁：桥梁书阶段\" class=\"headerlink\" title=\"7-10岁：桥梁书阶段\"></a>7-10岁：桥梁书阶段</h2><h3 id=\"冒险故事类\"><a href=\"#冒险故事类\" class=\"headerlink\" title=\"冒险故事类\"></a>冒险故事类</h3><p><strong>《神奇树屋》系列 - 玛丽·波·奥斯本</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：结合历史知识和冒险故事，寓教于乐</li>\n<li><strong>阅读建议</strong>：可以按照历史时间线阅读，增强历史感</li>\n<li><strong>延伸学习</strong>：查阅相关历史资料，制作时间轴</li>\n</ul>\n<p><strong>《内德的秘密花园》- 琳达·苏·帕克</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：环保主题，培养孩子的责任感</li>\n<li><strong>特色</strong>：插图精美，文字适中</li>\n</ul>\n<h3 id=\"科普启蒙类\"><a href=\"#科普启蒙类\" class=\"headerlink\" title=\"科普启蒙类\"></a>科普启蒙类</h3><p><strong>《可怕的科学》系列</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：用幽默的方式讲解科学知识</li>\n<li><strong>特色</strong>：图文并茂，实验性强</li>\n<li><strong>阅读建议</strong>：可以和孩子一起做书中的小实验</li>\n</ul>\n<p><strong>《DK儿童百科全书》</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：知识全面，图片精美</li>\n<li><strong>使用方法</strong>：不需要从头读到尾，可以按兴趣查阅</li>\n</ul>\n<h3 id=\"成长励志类\"><a href=\"#成长励志类\" class=\"headerlink\" title=\"成长励志类\"></a>成长励志类</h3><p><strong>《小屁孩日记》系列</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：贴近孩子生活，幽默风趣</li>\n<li><strong>特色</strong>：日记体形式，容易引起共鸣</li>\n</ul>\n<p><strong>《窗边的小豆豆》- 黑柳彻子</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：真实的成长故事，培养同理心</li>\n<li><strong>教育价值</strong>：让孩子理解不同的教育方式</li>\n</ul>\n<h2 id=\"11-14岁：深度阅读阶段\"><a href=\"#11-14岁：深度阅读阶段\" class=\"headerlink\" title=\"11-14岁：深度阅读阶段\"></a>11-14岁：深度阅读阶段</h2><h3 id=\"经典文学入门\"><a href=\"#经典文学入门\" class=\"headerlink\" title=\"经典文学入门\"></a>经典文学入门</h3><p><strong>《哈利·波特》系列 - J.K.罗琳</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：想象力丰富，情节引人入胜</li>\n<li><strong>阅读建议</strong>：可以先看前三部，适应后再读后续</li>\n<li><strong>延伸活动</strong>：制作魔法道具，讨论友谊和勇气</li>\n</ul>\n<p><strong>《纳尼亚传奇》系列 - C.S.路易斯</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：奇幻冒险，蕴含深刻哲理</li>\n<li><strong>特色</strong>：每本都是独立故事，可以单独阅读</li>\n</ul>\n<p><strong>《小王子》- 安托万·德·圣-埃克苏佩里</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：哲理深刻，适合反复阅读</li>\n<li><strong>阅读建议</strong>：可以和孩子讨论每个星球的寓意</li>\n</ul>\n<h3 id=\"科幻探索类\"><a href=\"#科幻探索类\" class=\"headerlink\" title=\"科幻探索类\"></a>科幻探索类</h3><p><strong>《三体》青少年版 - 刘慈欣</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：中国科幻经典，培养科学思维</li>\n<li><strong>注意事项</strong>：内容较深，建议有一定阅读基础后再读</li>\n</ul>\n<p><strong>《时间机器》- H.G.威尔斯</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：科幻经典，引发对时间的思考</li>\n<li><strong>延伸讨论</strong>：时间旅行的可能性和后果</li>\n</ul>\n<h3 id=\"历史传记类\"><a href=\"#历史传记类\" class=\"headerlink\" title=\"历史传记类\"></a>历史传记类</h3><p><strong>《上下五千年》</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：了解中国历史，培养文化自信</li>\n<li><strong>阅读建议</strong>：可以选择感兴趣的历史人物重点阅读</li>\n</ul>\n<p><strong>《居里夫人传》</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：科学家传记，特别适合女孩阅读</li>\n<li><strong>教育价值</strong>：坚持和奉献精神的典范</li>\n</ul>\n<h2 id=\"15岁以上：经典文学阶段\"><a href=\"#15岁以上：经典文学阶段\" class=\"headerlink\" title=\"15岁以上：经典文学阶段\"></a>15岁以上：经典文学阶段</h2><h3 id=\"中外经典名著\"><a href=\"#中外经典名著\" class=\"headerlink\" title=\"中外经典名著\"></a>中外经典名著</h3><p><strong>《红楼梦》（青少年版）</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：中国古典文学巅峰之作</li>\n<li><strong>阅读建议</strong>：可以先读简化版，培养兴趣后再读原著</li>\n</ul>\n<p><strong>《傲慢与偏见》- 简·奥斯汀</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：经典爱情小说，文笔优美</li>\n<li><strong>教育价值</strong>：理解人性的复杂和成长的意义</li>\n</ul>\n<p><strong>《1984》- 乔治·奥威尔</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：反乌托邦经典，培养批判思维</li>\n<li><strong>注意事项</strong>：内容较为深刻，需要引导讨论</li>\n</ul>\n<h3 id=\"哲学思辨类\"><a href=\"#哲学思辨类\" class=\"headerlink\" title=\"哲学思辨类\"></a>哲学思辨类</h3><p><strong>《苏菲的世界》- 乔斯坦·贾德</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：哲学启蒙读物，深入浅出</li>\n<li><strong>阅读建议</strong>：可以分章节讨论，不急于一次读完</li>\n</ul>\n<p><strong>《瓦尔登湖》- 梭罗</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：自然哲学，培养独立思考</li>\n<li><strong>延伸活动</strong>：尝试简单生活，体验自然</li>\n</ul>\n<h2 id=\"选书的实用技巧\"><a href=\"#选书的实用技巧\" class=\"headerlink\" title=\"选书的实用技巧\"></a>选书的实用技巧</h2><h3 id=\"根据孩子兴趣选择\"><a href=\"#根据孩子兴趣选择\" class=\"headerlink\" title=\"根据孩子兴趣选择\"></a>根据孩子兴趣选择</h3><p><strong>观察孩子的偏好：</strong></p>\n<ul>\n<li>喜欢动物的孩子：选择动物主题的故事</li>\n<li>喜欢冒险的孩子：选择探险类小说</li>\n<li>喜欢科学的孩子：选择科普类读物</li>\n<li>喜欢历史的孩子：选择历史故事和传记</li>\n</ul>\n<h3 id=\"循序渐进的原则\"><a href=\"#循序渐进的原则\" class=\"headerlink\" title=\"循序渐进的原则\"></a>循序渐进的原则</h3><p><strong>难度递增：</strong></p>\n<ol>\n<li>从图多字少开始</li>\n<li>逐步增加文字比例</li>\n<li>最终过渡到纯文字书籍</li>\n</ol>\n<p><strong>兴趣引导：</strong></p>\n<ol>\n<li>先选择孩子感兴趣的主题</li>\n<li>在同一主题下选择不同难度的书</li>\n<li>适时引入新的主题和类型</li>\n</ol>\n<h3 id=\"质量判断标准\"><a href=\"#质量判断标准\" class=\"headerlink\" title=\"质量判断标准\"></a>质量判断标准</h3><p><strong>好书的特征：</strong></p>\n<ul>\n<li>语言优美，适合年龄段</li>\n<li>内容积极正面，传递正确价值观</li>\n<li>情节引人入胜，能够吸引孩子</li>\n<li>插图精美（对于低年龄段）</li>\n<li>获得过权威奖项或专家推荐</li>\n</ul>\n<h2 id=\"亲子阅读的实施建议\"><a href=\"#亲子阅读的实施建议\" class=\"headerlink\" title=\"亲子阅读的实施建议\"></a>亲子阅读的实施建议</h2><h3 id=\"创建阅读计划\"><a href=\"#创建阅读计划\" class=\"headerlink\" title=\"创建阅读计划\"></a>创建阅读计划</h3><p><strong>每日阅读时间安排：</strong></p>\n<ul>\n<li>3-6岁：15-20分钟</li>\n<li>7-10岁：30-45分钟</li>\n<li>11-14岁：45-60分钟</li>\n<li>15岁以上：60分钟以上</li>\n</ul>\n<p><strong>阅读方式多样化：</strong></p>\n<ul>\n<li>亲子共读</li>\n<li>独立阅读</li>\n<li>有声书辅助</li>\n<li>电子书补充</li>\n</ul>\n<h3 id=\"阅读后的互动\"><a href=\"#阅读后的互动\" class=\"headerlink\" title=\"阅读后的互动\"></a>阅读后的互动</h3><p><strong>讨论要点：</strong></p>\n<ul>\n<li>最喜欢的角色是谁？为什么？</li>\n<li>如果你是主人公，会怎么做？</li>\n<li>这个故事告诉我们什么道理？</li>\n<li>你想推荐给其他小朋友吗？</li>\n</ul>\n<p><strong>创意活动：</strong></p>\n<ul>\n<li>画出故事中的场景</li>\n<li>续写故事结尾</li>\n<li>表演故事片段</li>\n<li>制作读书笔记</li>\n</ul>\n<h2 id=\"建立家庭图书馆\"><a href=\"#建立家庭图书馆\" class=\"headerlink\" title=\"建立家庭图书馆\"></a>建立家庭图书馆</h2><h3 id=\"购书建议\"><a href=\"#购书建议\" class=\"headerlink\" title=\"购书建议\"></a>购书建议</h3><p><strong>预算分配：</strong></p>\n<ul>\n<li>经典必读书籍：60%</li>\n<li>孩子兴趣书籍：30%</li>\n<li>尝试性新书：10%</li>\n</ul>\n<p><strong>购买渠道：</strong></p>\n<ul>\n<li>实体书店：可以现场翻阅</li>\n<li>网上书店：价格优惠，选择丰富</li>\n<li>二手书市场：经济实惠</li>\n<li>图书馆借阅：先试读再决定是否购买</li>\n</ul>\n<h3 id=\"图书管理\"><a href=\"#图书管理\" class=\"headerlink\" title=\"图书管理\"></a>图书管理</h3><p><strong>分类整理：</strong></p>\n<ul>\n<li>按年龄段分类</li>\n<li>按主题分类</li>\n<li>按阅读状态分类（已读/未读/正在读）</li>\n</ul>\n<p><strong>阅读记录：</strong></p>\n<ul>\n<li>建立读书清单</li>\n<li>记录阅读日期</li>\n<li>写下简单感想</li>\n<li>评分推荐指数</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>培养孩子的阅读习惯是一个长期的过程，选择合适的书籍只是第一步。更重要的是要：</p>\n<ol>\n<li><strong>尊重孩子的选择</strong>：在推荐的基础上，让孩子有自主选择权</li>\n<li><strong>保持耐心</strong>：不要急于求成，允许孩子有自己的阅读节奏</li>\n<li><strong>以身作则</strong>：家长的阅读习惯是最好的榜样</li>\n<li><strong>创造氛围</strong>：营造良好的家庭阅读环境</li>\n<li><strong>适时引导</strong>：在孩子遇到困难时给予帮助和鼓励</li>\n</ol>\n<p>记住，每个孩子都是独特的，最适合的书单是根据自己孩子的特点量身定制的。希望这份书单能够为您提供参考，帮助您的孩子在书籍的海洋中找到属于自己的宝藏，从而逐步减少对手机的依赖，爱上阅读的美好世界。 </p>\n","site":{"data":{}},"excerpt":"<p>选择合适的书籍是培养孩子阅读兴趣的关键第一步。本文根据不同年龄段孩子的认知特点和兴趣偏好，精心整理了一份优质书单，帮助家长为孩子挑选最适合的读物。</p>","more":"<h2 id=\"3-6岁：启蒙阶段书单\"><a href=\"#3-6岁：启蒙阶段书单\" class=\"headerlink\" title=\"3-6岁：启蒙阶段书单\"></a>3-6岁：启蒙阶段书单</h2><h3 id=\"经典绘本系列\"><a href=\"#经典绘本系列\" class=\"headerlink\" title=\"经典绘本系列\"></a>经典绘本系列</h3><p><strong>《好饿的毛毛虫》- 艾瑞克·卡尔</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：色彩鲜艳，故事简单有趣，教授数字和星期概念</li>\n<li><strong>阅读技巧</strong>：可以让孩子用手指跟着毛毛虫”吃”东西</li>\n<li><strong>延伸活动</strong>：制作毛毛虫手工，观察真实的蝴蝶变化过程</li>\n</ul>\n<p><strong>《猜猜我有多爱你》- 山姆·麦克布雷尼</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：温馨的亲情故事，培养表达爱的能力</li>\n<li><strong>阅读技巧</strong>：鼓励孩子模仿书中动作，增强互动性</li>\n<li><strong>延伸活动</strong>：和孩子一起比较”谁爱谁更多”</li>\n</ul>\n<p><strong>《逃家小兔》- 玛格丽特·怀兹·布朗</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：经典的母爱主题，给孩子安全感</li>\n<li><strong>阅读技巧</strong>：可以和孩子角色扮演，一个当小兔，一个当妈妈</li>\n<li><strong>延伸活动</strong>：讨论”如果你要逃跑，妈妈会怎么找到你”</li>\n</ul>\n<h3 id=\"中文原创绘本\"><a href=\"#中文原创绘本\" class=\"headerlink\" title=\"中文原创绘本\"></a>中文原创绘本</h3><p><strong>《小熊和最好的爸爸》系列 - 阿兰德·丹姆</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：父子情深，适合爸爸和孩子一起阅读</li>\n<li><strong>特色</strong>：7本书涵盖不同主题，从游戏到成长</li>\n</ul>\n<p><strong>《不一样的卡梅拉》系列</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：想象力丰富，鼓励孩子勇于尝试</li>\n<li><strong>特色</strong>：每本都有不同的冒险故事</li>\n</ul>\n<h2 id=\"7-10岁：桥梁书阶段\"><a href=\"#7-10岁：桥梁书阶段\" class=\"headerlink\" title=\"7-10岁：桥梁书阶段\"></a>7-10岁：桥梁书阶段</h2><h3 id=\"冒险故事类\"><a href=\"#冒险故事类\" class=\"headerlink\" title=\"冒险故事类\"></a>冒险故事类</h3><p><strong>《神奇树屋》系列 - 玛丽·波·奥斯本</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：结合历史知识和冒险故事，寓教于乐</li>\n<li><strong>阅读建议</strong>：可以按照历史时间线阅读，增强历史感</li>\n<li><strong>延伸学习</strong>：查阅相关历史资料，制作时间轴</li>\n</ul>\n<p><strong>《内德的秘密花园》- 琳达·苏·帕克</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：环保主题，培养孩子的责任感</li>\n<li><strong>特色</strong>：插图精美，文字适中</li>\n</ul>\n<h3 id=\"科普启蒙类\"><a href=\"#科普启蒙类\" class=\"headerlink\" title=\"科普启蒙类\"></a>科普启蒙类</h3><p><strong>《可怕的科学》系列</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：用幽默的方式讲解科学知识</li>\n<li><strong>特色</strong>：图文并茂，实验性强</li>\n<li><strong>阅读建议</strong>：可以和孩子一起做书中的小实验</li>\n</ul>\n<p><strong>《DK儿童百科全书》</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：知识全面，图片精美</li>\n<li><strong>使用方法</strong>：不需要从头读到尾，可以按兴趣查阅</li>\n</ul>\n<h3 id=\"成长励志类\"><a href=\"#成长励志类\" class=\"headerlink\" title=\"成长励志类\"></a>成长励志类</h3><p><strong>《小屁孩日记》系列</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：贴近孩子生活，幽默风趣</li>\n<li><strong>特色</strong>：日记体形式，容易引起共鸣</li>\n</ul>\n<p><strong>《窗边的小豆豆》- 黑柳彻子</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：真实的成长故事，培养同理心</li>\n<li><strong>教育价值</strong>：让孩子理解不同的教育方式</li>\n</ul>\n<h2 id=\"11-14岁：深度阅读阶段\"><a href=\"#11-14岁：深度阅读阶段\" class=\"headerlink\" title=\"11-14岁：深度阅读阶段\"></a>11-14岁：深度阅读阶段</h2><h3 id=\"经典文学入门\"><a href=\"#经典文学入门\" class=\"headerlink\" title=\"经典文学入门\"></a>经典文学入门</h3><p><strong>《哈利·波特》系列 - J.K.罗琳</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：想象力丰富，情节引人入胜</li>\n<li><strong>阅读建议</strong>：可以先看前三部，适应后再读后续</li>\n<li><strong>延伸活动</strong>：制作魔法道具，讨论友谊和勇气</li>\n</ul>\n<p><strong>《纳尼亚传奇》系列 - C.S.路易斯</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：奇幻冒险，蕴含深刻哲理</li>\n<li><strong>特色</strong>：每本都是独立故事，可以单独阅读</li>\n</ul>\n<p><strong>《小王子》- 安托万·德·圣-埃克苏佩里</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：哲理深刻，适合反复阅读</li>\n<li><strong>阅读建议</strong>：可以和孩子讨论每个星球的寓意</li>\n</ul>\n<h3 id=\"科幻探索类\"><a href=\"#科幻探索类\" class=\"headerlink\" title=\"科幻探索类\"></a>科幻探索类</h3><p><strong>《三体》青少年版 - 刘慈欣</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：中国科幻经典，培养科学思维</li>\n<li><strong>注意事项</strong>：内容较深，建议有一定阅读基础后再读</li>\n</ul>\n<p><strong>《时间机器》- H.G.威尔斯</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：科幻经典，引发对时间的思考</li>\n<li><strong>延伸讨论</strong>：时间旅行的可能性和后果</li>\n</ul>\n<h3 id=\"历史传记类\"><a href=\"#历史传记类\" class=\"headerlink\" title=\"历史传记类\"></a>历史传记类</h3><p><strong>《上下五千年》</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：了解中国历史，培养文化自信</li>\n<li><strong>阅读建议</strong>：可以选择感兴趣的历史人物重点阅读</li>\n</ul>\n<p><strong>《居里夫人传》</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：科学家传记，特别适合女孩阅读</li>\n<li><strong>教育价值</strong>：坚持和奉献精神的典范</li>\n</ul>\n<h2 id=\"15岁以上：经典文学阶段\"><a href=\"#15岁以上：经典文学阶段\" class=\"headerlink\" title=\"15岁以上：经典文学阶段\"></a>15岁以上：经典文学阶段</h2><h3 id=\"中外经典名著\"><a href=\"#中外经典名著\" class=\"headerlink\" title=\"中外经典名著\"></a>中外经典名著</h3><p><strong>《红楼梦》（青少年版）</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：中国古典文学巅峰之作</li>\n<li><strong>阅读建议</strong>：可以先读简化版，培养兴趣后再读原著</li>\n</ul>\n<p><strong>《傲慢与偏见》- 简·奥斯汀</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：经典爱情小说，文笔优美</li>\n<li><strong>教育价值</strong>：理解人性的复杂和成长的意义</li>\n</ul>\n<p><strong>《1984》- 乔治·奥威尔</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：反乌托邦经典，培养批判思维</li>\n<li><strong>注意事项</strong>：内容较为深刻，需要引导讨论</li>\n</ul>\n<h3 id=\"哲学思辨类\"><a href=\"#哲学思辨类\" class=\"headerlink\" title=\"哲学思辨类\"></a>哲学思辨类</h3><p><strong>《苏菲的世界》- 乔斯坦·贾德</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：哲学启蒙读物，深入浅出</li>\n<li><strong>阅读建议</strong>：可以分章节讨论，不急于一次读完</li>\n</ul>\n<p><strong>《瓦尔登湖》- 梭罗</strong></p>\n<ul>\n<li><strong>推荐理由</strong>：自然哲学，培养独立思考</li>\n<li><strong>延伸活动</strong>：尝试简单生活，体验自然</li>\n</ul>\n<h2 id=\"选书的实用技巧\"><a href=\"#选书的实用技巧\" class=\"headerlink\" title=\"选书的实用技巧\"></a>选书的实用技巧</h2><h3 id=\"根据孩子兴趣选择\"><a href=\"#根据孩子兴趣选择\" class=\"headerlink\" title=\"根据孩子兴趣选择\"></a>根据孩子兴趣选择</h3><p><strong>观察孩子的偏好：</strong></p>\n<ul>\n<li>喜欢动物的孩子：选择动物主题的故事</li>\n<li>喜欢冒险的孩子：选择探险类小说</li>\n<li>喜欢科学的孩子：选择科普类读物</li>\n<li>喜欢历史的孩子：选择历史故事和传记</li>\n</ul>\n<h3 id=\"循序渐进的原则\"><a href=\"#循序渐进的原则\" class=\"headerlink\" title=\"循序渐进的原则\"></a>循序渐进的原则</h3><p><strong>难度递增：</strong></p>\n<ol>\n<li>从图多字少开始</li>\n<li>逐步增加文字比例</li>\n<li>最终过渡到纯文字书籍</li>\n</ol>\n<p><strong>兴趣引导：</strong></p>\n<ol>\n<li>先选择孩子感兴趣的主题</li>\n<li>在同一主题下选择不同难度的书</li>\n<li>适时引入新的主题和类型</li>\n</ol>\n<h3 id=\"质量判断标准\"><a href=\"#质量判断标准\" class=\"headerlink\" title=\"质量判断标准\"></a>质量判断标准</h3><p><strong>好书的特征：</strong></p>\n<ul>\n<li>语言优美，适合年龄段</li>\n<li>内容积极正面，传递正确价值观</li>\n<li>情节引人入胜，能够吸引孩子</li>\n<li>插图精美（对于低年龄段）</li>\n<li>获得过权威奖项或专家推荐</li>\n</ul>\n<h2 id=\"亲子阅读的实施建议\"><a href=\"#亲子阅读的实施建议\" class=\"headerlink\" title=\"亲子阅读的实施建议\"></a>亲子阅读的实施建议</h2><h3 id=\"创建阅读计划\"><a href=\"#创建阅读计划\" class=\"headerlink\" title=\"创建阅读计划\"></a>创建阅读计划</h3><p><strong>每日阅读时间安排：</strong></p>\n<ul>\n<li>3-6岁：15-20分钟</li>\n<li>7-10岁：30-45分钟</li>\n<li>11-14岁：45-60分钟</li>\n<li>15岁以上：60分钟以上</li>\n</ul>\n<p><strong>阅读方式多样化：</strong></p>\n<ul>\n<li>亲子共读</li>\n<li>独立阅读</li>\n<li>有声书辅助</li>\n<li>电子书补充</li>\n</ul>\n<h3 id=\"阅读后的互动\"><a href=\"#阅读后的互动\" class=\"headerlink\" title=\"阅读后的互动\"></a>阅读后的互动</h3><p><strong>讨论要点：</strong></p>\n<ul>\n<li>最喜欢的角色是谁？为什么？</li>\n<li>如果你是主人公，会怎么做？</li>\n<li>这个故事告诉我们什么道理？</li>\n<li>你想推荐给其他小朋友吗？</li>\n</ul>\n<p><strong>创意活动：</strong></p>\n<ul>\n<li>画出故事中的场景</li>\n<li>续写故事结尾</li>\n<li>表演故事片段</li>\n<li>制作读书笔记</li>\n</ul>\n<h2 id=\"建立家庭图书馆\"><a href=\"#建立家庭图书馆\" class=\"headerlink\" title=\"建立家庭图书馆\"></a>建立家庭图书馆</h2><h3 id=\"购书建议\"><a href=\"#购书建议\" class=\"headerlink\" title=\"购书建议\"></a>购书建议</h3><p><strong>预算分配：</strong></p>\n<ul>\n<li>经典必读书籍：60%</li>\n<li>孩子兴趣书籍：30%</li>\n<li>尝试性新书：10%</li>\n</ul>\n<p><strong>购买渠道：</strong></p>\n<ul>\n<li>实体书店：可以现场翻阅</li>\n<li>网上书店：价格优惠，选择丰富</li>\n<li>二手书市场：经济实惠</li>\n<li>图书馆借阅：先试读再决定是否购买</li>\n</ul>\n<h3 id=\"图书管理\"><a href=\"#图书管理\" class=\"headerlink\" title=\"图书管理\"></a>图书管理</h3><p><strong>分类整理：</strong></p>\n<ul>\n<li>按年龄段分类</li>\n<li>按主题分类</li>\n<li>按阅读状态分类（已读/未读/正在读）</li>\n</ul>\n<p><strong>阅读记录：</strong></p>\n<ul>\n<li>建立读书清单</li>\n<li>记录阅读日期</li>\n<li>写下简单感想</li>\n<li>评分推荐指数</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>培养孩子的阅读习惯是一个长期的过程，选择合适的书籍只是第一步。更重要的是要：</p>\n<ol>\n<li><strong>尊重孩子的选择</strong>：在推荐的基础上，让孩子有自主选择权</li>\n<li><strong>保持耐心</strong>：不要急于求成，允许孩子有自己的阅读节奏</li>\n<li><strong>以身作则</strong>：家长的阅读习惯是最好的榜样</li>\n<li><strong>创造氛围</strong>：营造良好的家庭阅读环境</li>\n<li><strong>适时引导</strong>：在孩子遇到困难时给予帮助和鼓励</li>\n</ol>\n<p>记住，每个孩子都是独特的，最适合的书单是根据自己孩子的特点量身定制的。希望这份书单能够为您提供参考，帮助您的孩子在书籍的海洋中找到属于自己的宝藏，从而逐步减少对手机的依赖，爱上阅读的美好世界。 </p>"},{"title":"正则与通配符区别","date":"2024-10-11T11:11:45.000Z","_content":"\n正则表达式（Regular Expressions）和通配符（Wildcards）都是用于模式匹配的工具，但它们在功能、语法和应用场景上有显著的区别。以下是它们之间的主要区别：\n\n### 1. 定义\n\n- **正则表达式**:\n  - 正则表达式是一种用于描述字符串模式的强大工具，允许复杂的匹配规则。它可以用于查找、替换和验证字符串。\n  \n- **通配符**:\n  - 通配符是一种简单的模式匹配符号，通常用于文件名匹配或简单的字符串匹配。它们的功能相对较简单。\n\n### 2. 语法\n\n- **正则表达式**:\n  - 正则表达式使用特定的语法来定义模式，包括字符类、量词、边界匹配、分组等。例如：\n    - `^abc`：匹配以 \"abc\" 开头的字符串。\n    - `\\d`：匹配任何数字字符。\n    - `.*`：匹配任意字符（包括空字符）零次或多次。\n\n- **通配符**:\n  - 通配符通常使用简单的符号来表示匹配模式：\n    - `*`：匹配零个或多个字符。\n    - `?`：匹配一个字符。\n    - `[]`：匹配括号内的任意一个字符（例如，`[abc]` 匹配 \"a\"、\"b\" 或 \"c\"）。\n\n### 3. 功能\n\n- **正则表达式**:\n  - 正则表达式功能强大，支持复杂的匹配规则、分组、反向引用、替换等操作。可以用于文本处理、数据验证、搜索引擎等多种场景。\n\n- **通配符**:\n  - 通配符功能相对简单，主要用于文件系统中的文件名匹配（如在命令行中使用）或简单的字符串匹配。它们不支持复杂的匹配规则。\n\n### 4. 应用场景\n\n- **正则表达式**:\n  - 常用于编程语言（如 Python、Java、JavaScript、C++ 等）中的字符串处理、数据验证（如电子邮件、电话号码格式）、文本搜索和替换等。\n\n- **通配符**:\n  - 常用于文件系统操作（如在命令行中查找文件）、数据库查询（如 SQL 中的 LIKE 操作）等。\n\n### 5. 示例\n\n- **正则表达式示例**:\n  ```regex\n  ^[A-Za-z0-9]+@[A-Za-z]+\\.[A-Za-z]{2,}$\n  ```\n  - 这个正则表达式用于匹配电子邮件地址。\n\n- **通配符示例**:\n  - `*.txt`：匹配所有以 `.txt` 结尾的文件。\n  - `file?.jpg`：匹配 `file1.jpg`、`file2.jpg` 等文件，但不匹配 `file10.jpg`。\n\n### 总结\n\n- **正则表达式** 是一种功能强大的模式匹配工具，适用于复杂的字符串处理和验证。\n- **通配符** 是一种简单的模式匹配符号，主要用于文件名匹配和简单的字符串匹配。\n\n根据具体的需求选择合适的工具，可以更有效地完成字符串匹配和处理任务。","source":"_posts/正则与通配符区别.md","raw":"---\ntitle: 正则与通配符区别\ndate: 2024-10-11 19:11:45\ntags:\n---\n\n正则表达式（Regular Expressions）和通配符（Wildcards）都是用于模式匹配的工具，但它们在功能、语法和应用场景上有显著的区别。以下是它们之间的主要区别：\n\n### 1. 定义\n\n- **正则表达式**:\n  - 正则表达式是一种用于描述字符串模式的强大工具，允许复杂的匹配规则。它可以用于查找、替换和验证字符串。\n  \n- **通配符**:\n  - 通配符是一种简单的模式匹配符号，通常用于文件名匹配或简单的字符串匹配。它们的功能相对较简单。\n\n### 2. 语法\n\n- **正则表达式**:\n  - 正则表达式使用特定的语法来定义模式，包括字符类、量词、边界匹配、分组等。例如：\n    - `^abc`：匹配以 \"abc\" 开头的字符串。\n    - `\\d`：匹配任何数字字符。\n    - `.*`：匹配任意字符（包括空字符）零次或多次。\n\n- **通配符**:\n  - 通配符通常使用简单的符号来表示匹配模式：\n    - `*`：匹配零个或多个字符。\n    - `?`：匹配一个字符。\n    - `[]`：匹配括号内的任意一个字符（例如，`[abc]` 匹配 \"a\"、\"b\" 或 \"c\"）。\n\n### 3. 功能\n\n- **正则表达式**:\n  - 正则表达式功能强大，支持复杂的匹配规则、分组、反向引用、替换等操作。可以用于文本处理、数据验证、搜索引擎等多种场景。\n\n- **通配符**:\n  - 通配符功能相对简单，主要用于文件系统中的文件名匹配（如在命令行中使用）或简单的字符串匹配。它们不支持复杂的匹配规则。\n\n### 4. 应用场景\n\n- **正则表达式**:\n  - 常用于编程语言（如 Python、Java、JavaScript、C++ 等）中的字符串处理、数据验证（如电子邮件、电话号码格式）、文本搜索和替换等。\n\n- **通配符**:\n  - 常用于文件系统操作（如在命令行中查找文件）、数据库查询（如 SQL 中的 LIKE 操作）等。\n\n### 5. 示例\n\n- **正则表达式示例**:\n  ```regex\n  ^[A-Za-z0-9]+@[A-Za-z]+\\.[A-Za-z]{2,}$\n  ```\n  - 这个正则表达式用于匹配电子邮件地址。\n\n- **通配符示例**:\n  - `*.txt`：匹配所有以 `.txt` 结尾的文件。\n  - `file?.jpg`：匹配 `file1.jpg`、`file2.jpg` 等文件，但不匹配 `file10.jpg`。\n\n### 总结\n\n- **正则表达式** 是一种功能强大的模式匹配工具，适用于复杂的字符串处理和验证。\n- **通配符** 是一种简单的模式匹配符号，主要用于文件名匹配和简单的字符串匹配。\n\n根据具体的需求选择合适的工具，可以更有效地完成字符串匹配和处理任务。","slug":"正则与通配符区别","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8l002x1xco50b594o4","content":"<p>正则表达式（Regular Expressions）和通配符（Wildcards）都是用于模式匹配的工具，但它们在功能、语法和应用场景上有显著的区别。以下是它们之间的主要区别：</p>\n<h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><span id=\"more\"></span>\n\n<ul>\n<li><strong>正则表达式</strong>:<ul>\n<li>正则表达式是一种用于描述字符串模式的强大工具，允许复杂的匹配规则。它可以用于查找、替换和验证字符串。</li>\n</ul>\n</li>\n<li><strong>通配符</strong>:<ul>\n<li>通配符是一种简单的模式匹配符号，通常用于文件名匹配或简单的字符串匹配。它们的功能相对较简单。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><ul>\n<li><p><strong>正则表达式</strong>:</p>\n<ul>\n<li>正则表达式使用特定的语法来定义模式，包括字符类、量词、边界匹配、分组等。例如：<ul>\n<li><code>^abc</code>：匹配以 “abc” 开头的字符串。</li>\n<li><code>\\d</code>：匹配任何数字字符。</li>\n<li><code>.*</code>：匹配任意字符（包括空字符）零次或多次。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>通配符</strong>:</p>\n<ul>\n<li>通配符通常使用简单的符号来表示匹配模式：<ul>\n<li><code>*</code>：匹配零个或多个字符。</li>\n<li><code>?</code>：匹配一个字符。</li>\n<li><code>[]</code>：匹配括号内的任意一个字符（例如，<code>[abc]</code> 匹配 “a”、”b” 或 “c”）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-功能\"><a href=\"#3-功能\" class=\"headerlink\" title=\"3. 功能\"></a>3. 功能</h3><ul>\n<li><p><strong>正则表达式</strong>:</p>\n<ul>\n<li>正则表达式功能强大，支持复杂的匹配规则、分组、反向引用、替换等操作。可以用于文本处理、数据验证、搜索引擎等多种场景。</li>\n</ul>\n</li>\n<li><p><strong>通配符</strong>:</p>\n<ul>\n<li>通配符功能相对简单，主要用于文件系统中的文件名匹配（如在命令行中使用）或简单的字符串匹配。它们不支持复杂的匹配规则。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-应用场景\"><a href=\"#4-应用场景\" class=\"headerlink\" title=\"4. 应用场景\"></a>4. 应用场景</h3><ul>\n<li><p><strong>正则表达式</strong>:</p>\n<ul>\n<li>常用于编程语言（如 Python、Java、JavaScript、C++ 等）中的字符串处理、数据验证（如电子邮件、电话号码格式）、文本搜索和替换等。</li>\n</ul>\n</li>\n<li><p><strong>通配符</strong>:</p>\n<ul>\n<li>常用于文件系统操作（如在命令行中查找文件）、数据库查询（如 SQL 中的 LIKE 操作）等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-示例\"><a href=\"#5-示例\" class=\"headerlink\" title=\"5. 示例\"></a>5. 示例</h3><ul>\n<li><p><strong>正则表达式示例</strong>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^[A-Za-z0-9]+@[A-Za-z]+\\.[A-Za-z]&#123;2,&#125;$</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这个正则表达式用于匹配电子邮件地址。</li>\n</ul>\n</li>\n<li><p><strong>通配符示例</strong>:</p>\n<ul>\n<li><code>*.txt</code>：匹配所有以 <code>.txt</code> 结尾的文件。</li>\n<li><code>file?.jpg</code>：匹配 <code>file1.jpg</code>、<code>file2.jpg</code> 等文件，但不匹配 <code>file10.jpg</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>正则表达式</strong> 是一种功能强大的模式匹配工具，适用于复杂的字符串处理和验证。</li>\n<li><strong>通配符</strong> 是一种简单的模式匹配符号，主要用于文件名匹配和简单的字符串匹配。</li>\n</ul>\n<p>根据具体的需求选择合适的工具，可以更有效地完成字符串匹配和处理任务。</p>\n","site":{"data":{}},"excerpt":"<p>正则表达式（Regular Expressions）和通配符（Wildcards）都是用于模式匹配的工具，但它们在功能、语法和应用场景上有显著的区别。以下是它们之间的主要区别：</p>\n<h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3>","more":"<ul>\n<li><strong>正则表达式</strong>:<ul>\n<li>正则表达式是一种用于描述字符串模式的强大工具，允许复杂的匹配规则。它可以用于查找、替换和验证字符串。</li>\n</ul>\n</li>\n<li><strong>通配符</strong>:<ul>\n<li>通配符是一种简单的模式匹配符号，通常用于文件名匹配或简单的字符串匹配。它们的功能相对较简单。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2. 语法\"></a>2. 语法</h3><ul>\n<li><p><strong>正则表达式</strong>:</p>\n<ul>\n<li>正则表达式使用特定的语法来定义模式，包括字符类、量词、边界匹配、分组等。例如：<ul>\n<li><code>^abc</code>：匹配以 “abc” 开头的字符串。</li>\n<li><code>\\d</code>：匹配任何数字字符。</li>\n<li><code>.*</code>：匹配任意字符（包括空字符）零次或多次。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>通配符</strong>:</p>\n<ul>\n<li>通配符通常使用简单的符号来表示匹配模式：<ul>\n<li><code>*</code>：匹配零个或多个字符。</li>\n<li><code>?</code>：匹配一个字符。</li>\n<li><code>[]</code>：匹配括号内的任意一个字符（例如，<code>[abc]</code> 匹配 “a”、”b” 或 “c”）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-功能\"><a href=\"#3-功能\" class=\"headerlink\" title=\"3. 功能\"></a>3. 功能</h3><ul>\n<li><p><strong>正则表达式</strong>:</p>\n<ul>\n<li>正则表达式功能强大，支持复杂的匹配规则、分组、反向引用、替换等操作。可以用于文本处理、数据验证、搜索引擎等多种场景。</li>\n</ul>\n</li>\n<li><p><strong>通配符</strong>:</p>\n<ul>\n<li>通配符功能相对简单，主要用于文件系统中的文件名匹配（如在命令行中使用）或简单的字符串匹配。它们不支持复杂的匹配规则。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-应用场景\"><a href=\"#4-应用场景\" class=\"headerlink\" title=\"4. 应用场景\"></a>4. 应用场景</h3><ul>\n<li><p><strong>正则表达式</strong>:</p>\n<ul>\n<li>常用于编程语言（如 Python、Java、JavaScript、C++ 等）中的字符串处理、数据验证（如电子邮件、电话号码格式）、文本搜索和替换等。</li>\n</ul>\n</li>\n<li><p><strong>通配符</strong>:</p>\n<ul>\n<li>常用于文件系统操作（如在命令行中查找文件）、数据库查询（如 SQL 中的 LIKE 操作）等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-示例\"><a href=\"#5-示例\" class=\"headerlink\" title=\"5. 示例\"></a>5. 示例</h3><ul>\n<li><p><strong>正则表达式示例</strong>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^[A-Za-z0-9]+@[A-Za-z]+\\.[A-Za-z]&#123;2,&#125;$</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这个正则表达式用于匹配电子邮件地址。</li>\n</ul>\n</li>\n<li><p><strong>通配符示例</strong>:</p>\n<ul>\n<li><code>*.txt</code>：匹配所有以 <code>.txt</code> 结尾的文件。</li>\n<li><code>file?.jpg</code>：匹配 <code>file1.jpg</code>、<code>file2.jpg</code> 等文件，但不匹配 <code>file10.jpg</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>正则表达式</strong> 是一种功能强大的模式匹配工具，适用于复杂的字符串处理和验证。</li>\n<li><strong>通配符</strong> 是一种简单的模式匹配符号，主要用于文件名匹配和简单的字符串匹配。</li>\n</ul>\n<p>根据具体的需求选择合适的工具，可以更有效地完成字符串匹配和处理任务。</p>"},{"title":"电子书目录","date":"2022-12-25T15:36:30.000Z","_content":"\n## 渲染整理\n\n\n#### 开放世界的场景管理\n\t1. 切成tile\n\t2. 数据分级LOD\n\t3. 根据天顶角，调整远平面，裁剪数据\n\n#### 游戏引擎分层架构\n\t1. EditorLayer\n\t2. FuntionLayer\n\t\t1. Rendering\n\t\t2. Animation\n\t\t3. Camera\n\t\t4. Physics\n\t\t5. Script\n\t3. ResourceLayer\n\t4. CoreLayer\n\t\t1. threadPoolManagement\n\t\t2. memoryPool\n\t\t3. mathLibrary\n\t5. PlatformLayer\n\t\t1. RHI\n\n#### Renderable\n\t1. shader\n\t\t1. vs,fs\n\t\t2. macro\n\t2. RenderState\n\t3. MVP \n\t4. Texture\n\t5. DrawImp\n\n#### 渲染效果\n\t1. 前向渲染\n  \t\t1. PBR\n  \t\t2. 布林冯模型\n\t2. 阴影shadowMap：\n\t\t1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性\n\t\t2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度\n\t3. 楼的倒影\n\t\t1. 矩阵楼块插入地面\n\t\t2. 模板测试，只有地面和水才绘制\n\t4. AO\n\t5. 聚光灯效果\n\t6. UV动画\n\n#### 技术点提炼\n\t1. 楼块\n\t\t1. 切成小块\n\t\t2. 柔化圆角\n\t\t3. 贴UV\n\t2. 3d瓦片绘制\n\t\t1. 瓦片的加载，与cache\n\t\t2. 非实施例渲染，按材质进行分类渲染\n\t\t3. 实例化渲染，动态计算lod进行渲染\n\t3. 模型渲染\n\t\t1. PBR渲染\n\t\t2. 非PBR渲染","source":"_posts/电子书目录.md","raw":"---\ntitle: 电子书目录\ndate: 2022-12-25 23:36:30\ntags:\n---\n\n## 渲染整理\n\n\n#### 开放世界的场景管理\n\t1. 切成tile\n\t2. 数据分级LOD\n\t3. 根据天顶角，调整远平面，裁剪数据\n\n#### 游戏引擎分层架构\n\t1. EditorLayer\n\t2. FuntionLayer\n\t\t1. Rendering\n\t\t2. Animation\n\t\t3. Camera\n\t\t4. Physics\n\t\t5. Script\n\t3. ResourceLayer\n\t4. CoreLayer\n\t\t1. threadPoolManagement\n\t\t2. memoryPool\n\t\t3. mathLibrary\n\t5. PlatformLayer\n\t\t1. RHI\n\n#### Renderable\n\t1. shader\n\t\t1. vs,fs\n\t\t2. macro\n\t2. RenderState\n\t3. MVP \n\t4. Texture\n\t5. DrawImp\n\n#### 渲染效果\n\t1. 前向渲染\n  \t\t1. PBR\n  \t\t2. 布林冯模型\n\t2. 阴影shadowMap：\n\t\t1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性\n\t\t2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度\n\t3. 楼的倒影\n\t\t1. 矩阵楼块插入地面\n\t\t2. 模板测试，只有地面和水才绘制\n\t4. AO\n\t5. 聚光灯效果\n\t6. UV动画\n\n#### 技术点提炼\n\t1. 楼块\n\t\t1. 切成小块\n\t\t2. 柔化圆角\n\t\t3. 贴UV\n\t2. 3d瓦片绘制\n\t\t1. 瓦片的加载，与cache\n\t\t2. 非实施例渲染，按材质进行分类渲染\n\t\t3. 实例化渲染，动态计算lod进行渲染\n\t3. 模型渲染\n\t\t1. PBR渲染\n\t\t2. 非PBR渲染","slug":"电子书目录","published":1,"updated":"2025-02-20T13:07:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbt3hg8l002y1xco488v0ps1","content":"<h2 id=\"渲染整理\"><a href=\"#渲染整理\" class=\"headerlink\" title=\"渲染整理\"></a>渲染整理</h2><h4 id=\"开放世界的场景管理\"><a href=\"#开放世界的场景管理\" class=\"headerlink\" title=\"开放世界的场景管理\"></a>开放世界的场景管理</h4><pre><code>1. 切成tile\n2. 数据分级LOD\n3. 根据天顶角，调整远平面，裁剪数据\n</code></pre>\n<span id=\"more\"></span>\n\n<h4 id=\"游戏引擎分层架构\"><a href=\"#游戏引擎分层架构\" class=\"headerlink\" title=\"游戏引擎分层架构\"></a>游戏引擎分层架构</h4><pre><code>1. EditorLayer\n2. FuntionLayer\n    1. Rendering\n    2. Animation\n    3. Camera\n    4. Physics\n    5. Script\n3. ResourceLayer\n4. CoreLayer\n    1. threadPoolManagement\n    2. memoryPool\n    3. mathLibrary\n5. PlatformLayer\n    1. RHI\n</code></pre>\n<h4 id=\"Renderable\"><a href=\"#Renderable\" class=\"headerlink\" title=\"Renderable\"></a>Renderable</h4><pre><code>1. shader\n    1. vs,fs\n    2. macro\n2. RenderState\n3. MVP \n4. Texture\n5. DrawImp\n</code></pre>\n<h4 id=\"渲染效果\"><a href=\"#渲染效果\" class=\"headerlink\" title=\"渲染效果\"></a>渲染效果</h4><pre><code>1. 前向渲染\n      1. PBR\n      2. 布林冯模型\n2. 阴影shadowMap：\n    1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性\n    2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度\n3. 楼的倒影\n    1. 矩阵楼块插入地面\n    2. 模板测试，只有地面和水才绘制\n4. AO\n5. 聚光灯效果\n6. UV动画\n</code></pre>\n<h4 id=\"技术点提炼\"><a href=\"#技术点提炼\" class=\"headerlink\" title=\"技术点提炼\"></a>技术点提炼</h4><pre><code>1. 楼块\n    1. 切成小块\n    2. 柔化圆角\n    3. 贴UV\n2. 3d瓦片绘制\n    1. 瓦片的加载，与cache\n    2. 非实施例渲染，按材质进行分类渲染\n    3. 实例化渲染，动态计算lod进行渲染\n3. 模型渲染\n    1. PBR渲染\n    2. 非PBR渲染\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"渲染整理\"><a href=\"#渲染整理\" class=\"headerlink\" title=\"渲染整理\"></a>渲染整理</h2><h4 id=\"开放世界的场景管理\"><a href=\"#开放世界的场景管理\" class=\"headerlink\" title=\"开放世界的场景管理\"></a>开放世界的场景管理</h4><pre><code>1. 切成tile\n2. 数据分级LOD\n3. 根据天顶角，调整远平面，裁剪数据\n</code></pre>","more":"<h4 id=\"游戏引擎分层架构\"><a href=\"#游戏引擎分层架构\" class=\"headerlink\" title=\"游戏引擎分层架构\"></a>游戏引擎分层架构</h4><pre><code>1. EditorLayer\n2. FuntionLayer\n    1. Rendering\n    2. Animation\n    3. Camera\n    4. Physics\n    5. Script\n3. ResourceLayer\n4. CoreLayer\n    1. threadPoolManagement\n    2. memoryPool\n    3. mathLibrary\n5. PlatformLayer\n    1. RHI\n</code></pre>\n<h4 id=\"Renderable\"><a href=\"#Renderable\" class=\"headerlink\" title=\"Renderable\"></a>Renderable</h4><pre><code>1. shader\n    1. vs,fs\n    2. macro\n2. RenderState\n3. MVP \n4. Texture\n5. DrawImp\n</code></pre>\n<h4 id=\"渲染效果\"><a href=\"#渲染效果\" class=\"headerlink\" title=\"渲染效果\"></a>渲染效果</h4><pre><code>1. 前向渲染\n      1. PBR\n      2. 布林冯模型\n2. 阴影shadowMap：\n    1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性\n    2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度\n3. 楼的倒影\n    1. 矩阵楼块插入地面\n    2. 模板测试，只有地面和水才绘制\n4. AO\n5. 聚光灯效果\n6. UV动画\n</code></pre>\n<h4 id=\"技术点提炼\"><a href=\"#技术点提炼\" class=\"headerlink\" title=\"技术点提炼\"></a>技术点提炼</h4><pre><code>1. 楼块\n    1. 切成小块\n    2. 柔化圆角\n    3. 贴UV\n2. 3d瓦片绘制\n    1. 瓦片的加载，与cache\n    2. 非实施例渲染，按材质进行分类渲染\n    3. 实例化渲染，动态计算lod进行渲染\n3. 模型渲染\n    1. PBR渲染\n    2. 非PBR渲染\n</code></pre>"},{"title":"C++宏定义陷阱与#、##操作符详解 - 播客分析","date":"2025-06-15T02:00:00.000Z","_content":"\n## 播客分析：C++宏定义的陷阱与#、##操作符详解\n\n\n### C++宏中的#和##操作符详解\n\n现在让我们深入了解C++宏系统中两个重要的操作符：\n\n#### 单个#操作符（字符串化操作符）\n\n单个`#`用于将宏参数转换为字符串字面量。\n\n**语法**：`#parameter`\n\n**示例**：\n```cpp\n#define STRINGIFY(x) #x\n\nint main() {\n    std::cout << STRINGIFY(hello world) << std::endl;\n    // 输出：hello world\n    \n    std::cout << STRINGIFY(123 + 456) << std::endl;\n    // 输出：123 + 456\n}\n```\n\n**工作原理**：\n- 预处理器将参数原样转换为字符串\n- 保留参数中的空格和特殊字符\n- 在字符串两端添加双引号\n\n**实际应用场景**：\n```cpp\n#define DEBUG_PRINT(var) \\\n    std::cout << #var << \" = \" << var << std::endl\n\nint x = 42;\nDEBUG_PRINT(x);  // 输出：x = 42\n```\n\n#### 双个##操作符（标记粘贴操作符）\n\n双个`##`用于将两个标记连接成一个标记。\n\n**语法**：`token1 ## token2`\n\n**示例**：\n```cpp\n#define CONCAT(a, b) a ## b\n\nint main() {\n    int CONCAT(var, 123) = 456;  // 创建变量 var123\n    std::cout << var123 << std::endl;  // 输出：456\n}\n```\n\n**更复杂的应用**：\n```cpp\n#define DECLARE_GETTER_SETTER(type, name) \\\n    private: \\\n        type name##_; \\\n    public: \\\n        type get##name() const { return name##_; } \\\n        void set##name(const type& value) { name##_ = value; }\n\nclass Person {\n    DECLARE_GETTER_SETTER(std::string, Name)\n    DECLARE_GETTER_SETTER(int, Age)\n};\n\n// 展开后相当于：\nclass Person {\nprivate:\n    std::string Name_;\n    int Age_;\npublic:\n    std::string getName() const { return Name_; }\n    void setName(const std::string& value) { Name_ = value; }\n    int getAge() const { return Age_; }\n    void setAge(const int& value) { Age_ = value; }\n};\n```\n\n---\n\n### 最佳实践建议\n\n#### 1. 宏定义的正确格式\n```cpp\n// 正确：宏名和宏体之间有空格\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\n// 错误：没有空格分隔\n#define MAX(a,b)((a)>(b)?(a):(b))\n```\n\n#### 2. 避免在宏中使用预处理指令\n```cpp\n// 危险：不要这样做\n#define INCLUDE_STRING #include <string>\n\n// 正确：如果需要条件包含，使用条件编译\n#ifdef NEED_STRING\n#include <string>\n#endif\n```\n\n#### 3. 使用括号保护宏参数\n```cpp\n// 危险：可能导致运算符优先级问题\n#define SQUARE(x) x * x\n\n// 正确：用括号保护参数和整个表达式\n#define SQUARE(x) ((x) * (x))\n```\n\n#### 4. 多行宏的正确写法\n```cpp\n#define COMPLEX_MACRO(x, y) \\\n    do { \\\n        std::cout << \"Processing: \" << #x << std::endl; \\\n        result = (x) + (y); \\\n    } while(0)\n```\n\n---\n\n### 现代C++的替代方案\n\n在现代C++中，我们有更好的替代方案：\n\n#### 1. 使用constexpr函数替代函数式宏\n```cpp\n// 传统宏\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\n// 现代C++\ntemplate<typename T>\nconstexpr T max(T a, T b) {\n    return (a > b) ? a : b;\n}\n```\n\n#### 2. 使用模板和constexpr替代复杂宏\n```cpp\n// 传统宏方式\n#define DECLARE_COMPARISON(type) \\\n    bool operator<(const type& other) const; \\\n    bool operator>(const type& other) const;\n\n// 现代C++方式\ntemplate<typename T>\nconcept Comparable = requires(T a, T b) {\n    { a < b } -> std::convertible_to<bool>;\n    { a > b } -> std::convertible_to<bool>;\n};\n```\n\n#### 3. 使用constexpr变量替代常量宏\n```cpp\n// 传统宏\n#define PI 3.14159265359\n\n// 现代C++\nconstexpr double PI = 3.14159265359;\n```\n\n---\n\n### 调试宏的技巧\n\n#### 1. 使用编译器选项查看宏展开\n```bash\n# GCC/Clang\ng++ -E source.cpp > preprocessed.cpp\n\n# 查看特定宏的展开\ng++ -E -dM source.cpp | grep MY_MACRO\n```\n\n#### 2. 使用静态断言验证宏行为\n```cpp\n#define IS_POWER_OF_TWO(x) (((x) & ((x) - 1)) == 0)\n\nstatic_assert(IS_POWER_OF_TWO(8), \"8 should be power of 2\");\nstatic_assert(!IS_POWER_OF_TWO(6), \"6 should not be power of 2\");\n```\n\n---\n\n### 常见宏陷阱总结\n\n#### 1. 副作用问题\n```cpp\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint i = 5;\nint result = MAX(++i, 10);  // i被递增两次！\n```\n\n#### 2. 类型问题\n```cpp\n#define ABS(x) ((x) < 0 ? -(x) : (x))\n\nunsigned int u = 1;\nint result = ABS(u - 2);  // 可能产生意外结果\n```\n\n#### 3. 作用域问题\n```cpp\n#define SWAP(a, b) { int temp = a; a = b; b = temp; }\n\nint temp = 100;\nint x = 1, y = 2;\nSWAP(x, y);  // temp变量名冲突！\n```\n\n---\n\n### 总结\n\n1. **语法正确性**：宏定义必须遵循正确的语法格式\n2. **语义合理性**：不要在宏中包含预处理指令\n3. **理解工具**：深入理解#和##操作符的作用机制\n4. **现代化思维**：在可能的情况下，优先使用现代C++特性\n\n**关键要点回顾**：\n- `#`操作符用于字符串化参数\n- `##`操作符用于标记粘贴\n- 宏定义需要正确的语法格式\n- 现代C++提供了更安全的替代方案\n- 调试宏需要特殊的技巧和工具\n\n记住，宏是一个强大但危险的工具。正确使用它们需要深入理解预处理器的工作原理，以及对潜在陷阱的充分认识。在现代C++开发中，我们应该优先考虑类型安全、易于调试的替代方案。\n\n感谢大家收听今天的播客，我们下期再见！\n\n---\n\n### 参考资料\n\n- [C++ Preprocessor Reference](https://en.cppreference.com/w/cpp/preprocessor)\n- [Effective Modern C++ by Scott Meyers](https://www.oreilly.com/library/view/effective-modern-c/9781491908419/)\n- [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines) ","source":"_posts/cpp-macro-analysis-podcast.md","raw":"---\ntitle: C++宏定义陷阱与#、##操作符详解 - 播客分析\ndate: 2025-06-15 10:00:00\ntags: [C++, 宏定义, 预处理器, 播客]\ncategories: [编程技术, C++]\n---\n\n## 播客分析：C++宏定义的陷阱与#、##操作符详解\n\n\n### C++宏中的#和##操作符详解\n\n现在让我们深入了解C++宏系统中两个重要的操作符：\n\n#### 单个#操作符（字符串化操作符）\n\n单个`#`用于将宏参数转换为字符串字面量。\n\n**语法**：`#parameter`\n\n**示例**：\n```cpp\n#define STRINGIFY(x) #x\n\nint main() {\n    std::cout << STRINGIFY(hello world) << std::endl;\n    // 输出：hello world\n    \n    std::cout << STRINGIFY(123 + 456) << std::endl;\n    // 输出：123 + 456\n}\n```\n\n**工作原理**：\n- 预处理器将参数原样转换为字符串\n- 保留参数中的空格和特殊字符\n- 在字符串两端添加双引号\n\n**实际应用场景**：\n```cpp\n#define DEBUG_PRINT(var) \\\n    std::cout << #var << \" = \" << var << std::endl\n\nint x = 42;\nDEBUG_PRINT(x);  // 输出：x = 42\n```\n\n#### 双个##操作符（标记粘贴操作符）\n\n双个`##`用于将两个标记连接成一个标记。\n\n**语法**：`token1 ## token2`\n\n**示例**：\n```cpp\n#define CONCAT(a, b) a ## b\n\nint main() {\n    int CONCAT(var, 123) = 456;  // 创建变量 var123\n    std::cout << var123 << std::endl;  // 输出：456\n}\n```\n\n**更复杂的应用**：\n```cpp\n#define DECLARE_GETTER_SETTER(type, name) \\\n    private: \\\n        type name##_; \\\n    public: \\\n        type get##name() const { return name##_; } \\\n        void set##name(const type& value) { name##_ = value; }\n\nclass Person {\n    DECLARE_GETTER_SETTER(std::string, Name)\n    DECLARE_GETTER_SETTER(int, Age)\n};\n\n// 展开后相当于：\nclass Person {\nprivate:\n    std::string Name_;\n    int Age_;\npublic:\n    std::string getName() const { return Name_; }\n    void setName(const std::string& value) { Name_ = value; }\n    int getAge() const { return Age_; }\n    void setAge(const int& value) { Age_ = value; }\n};\n```\n\n---\n\n### 最佳实践建议\n\n#### 1. 宏定义的正确格式\n```cpp\n// 正确：宏名和宏体之间有空格\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\n// 错误：没有空格分隔\n#define MAX(a,b)((a)>(b)?(a):(b))\n```\n\n#### 2. 避免在宏中使用预处理指令\n```cpp\n// 危险：不要这样做\n#define INCLUDE_STRING #include <string>\n\n// 正确：如果需要条件包含，使用条件编译\n#ifdef NEED_STRING\n#include <string>\n#endif\n```\n\n#### 3. 使用括号保护宏参数\n```cpp\n// 危险：可能导致运算符优先级问题\n#define SQUARE(x) x * x\n\n// 正确：用括号保护参数和整个表达式\n#define SQUARE(x) ((x) * (x))\n```\n\n#### 4. 多行宏的正确写法\n```cpp\n#define COMPLEX_MACRO(x, y) \\\n    do { \\\n        std::cout << \"Processing: \" << #x << std::endl; \\\n        result = (x) + (y); \\\n    } while(0)\n```\n\n---\n\n### 现代C++的替代方案\n\n在现代C++中，我们有更好的替代方案：\n\n#### 1. 使用constexpr函数替代函数式宏\n```cpp\n// 传统宏\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\n// 现代C++\ntemplate<typename T>\nconstexpr T max(T a, T b) {\n    return (a > b) ? a : b;\n}\n```\n\n#### 2. 使用模板和constexpr替代复杂宏\n```cpp\n// 传统宏方式\n#define DECLARE_COMPARISON(type) \\\n    bool operator<(const type& other) const; \\\n    bool operator>(const type& other) const;\n\n// 现代C++方式\ntemplate<typename T>\nconcept Comparable = requires(T a, T b) {\n    { a < b } -> std::convertible_to<bool>;\n    { a > b } -> std::convertible_to<bool>;\n};\n```\n\n#### 3. 使用constexpr变量替代常量宏\n```cpp\n// 传统宏\n#define PI 3.14159265359\n\n// 现代C++\nconstexpr double PI = 3.14159265359;\n```\n\n---\n\n### 调试宏的技巧\n\n#### 1. 使用编译器选项查看宏展开\n```bash\n# GCC/Clang\ng++ -E source.cpp > preprocessed.cpp\n\n# 查看特定宏的展开\ng++ -E -dM source.cpp | grep MY_MACRO\n```\n\n#### 2. 使用静态断言验证宏行为\n```cpp\n#define IS_POWER_OF_TWO(x) (((x) & ((x) - 1)) == 0)\n\nstatic_assert(IS_POWER_OF_TWO(8), \"8 should be power of 2\");\nstatic_assert(!IS_POWER_OF_TWO(6), \"6 should not be power of 2\");\n```\n\n---\n\n### 常见宏陷阱总结\n\n#### 1. 副作用问题\n```cpp\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint i = 5;\nint result = MAX(++i, 10);  // i被递增两次！\n```\n\n#### 2. 类型问题\n```cpp\n#define ABS(x) ((x) < 0 ? -(x) : (x))\n\nunsigned int u = 1;\nint result = ABS(u - 2);  // 可能产生意外结果\n```\n\n#### 3. 作用域问题\n```cpp\n#define SWAP(a, b) { int temp = a; a = b; b = temp; }\n\nint temp = 100;\nint x = 1, y = 2;\nSWAP(x, y);  // temp变量名冲突！\n```\n\n---\n\n### 总结\n\n1. **语法正确性**：宏定义必须遵循正确的语法格式\n2. **语义合理性**：不要在宏中包含预处理指令\n3. **理解工具**：深入理解#和##操作符的作用机制\n4. **现代化思维**：在可能的情况下，优先使用现代C++特性\n\n**关键要点回顾**：\n- `#`操作符用于字符串化参数\n- `##`操作符用于标记粘贴\n- 宏定义需要正确的语法格式\n- 现代C++提供了更安全的替代方案\n- 调试宏需要特殊的技巧和工具\n\n记住，宏是一个强大但危险的工具。正确使用它们需要深入理解预处理器的工作原理，以及对潜在陷阱的充分认识。在现代C++开发中，我们应该优先考虑类型安全、易于调试的替代方案。\n\n感谢大家收听今天的播客，我们下期再见！\n\n---\n\n### 参考资料\n\n- [C++ Preprocessor Reference](https://en.cppreference.com/w/cpp/preprocessor)\n- [Effective Modern C++ by Scott Meyers](https://www.oreilly.com/library/view/effective-modern-c/9781491908419/)\n- [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines) ","slug":"cpp-macro-analysis-podcast","published":1,"updated":"2025-06-15T03:13:50.380Z","_id":"cmbx3as1h000096j2gvwo9lbp","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"播客分析：C-宏定义的陷阱与-、-操作符详解\"><a href=\"#播客分析：C-宏定义的陷阱与-、-操作符详解\" class=\"headerlink\" title=\"播客分析：C++宏定义的陷阱与#、##操作符详解\"></a>播客分析：C++宏定义的陷阱与#、##操作符详解</h2><h3 id=\"C-宏中的-和-操作符详解\"><a href=\"#C-宏中的-和-操作符详解\" class=\"headerlink\" title=\"C++宏中的#和##操作符详解\"></a>C++宏中的#和##操作符详解</h3><span id=\"more\"></span>\n\n<p>现在让我们深入了解C++宏系统中两个重要的操作符：</p>\n<h4 id=\"单个-操作符（字符串化操作符）\"><a href=\"#单个-操作符（字符串化操作符）\" class=\"headerlink\" title=\"单个#操作符（字符串化操作符）\"></a>单个#操作符（字符串化操作符）</h4><p>单个<code>#</code>用于将宏参数转换为字符串字面量。</p>\n<p><strong>语法</strong>：<code>#parameter</code></p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STRINGIFY(x) #x</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"built_in\">STRINGIFY</span>(hello world) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"comment\">// 输出：hello world</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"built_in\">STRINGIFY</span>(<span class=\"number\">123</span> + <span class=\"number\">456</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"comment\">// 输出：123 + 456</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>工作原理</strong>：</p>\n<ul>\n<li>预处理器将参数原样转换为字符串</li>\n<li>保留参数中的空格和特殊字符</li>\n<li>在字符串两端添加双引号</li>\n</ul>\n<p><strong>实际应用场景</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DEBUG_PRINT(var) \\</span></span><br><span class=\"line\"><span class=\"meta\">    std::cout &lt;&lt; #var &lt;&lt; <span class=\"string\">&quot; = &quot;</span> &lt;&lt; var &lt;&lt; std::endl</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"built_in\">DEBUG_PRINT</span>(x);  <span class=\"comment\">// 输出：x = 42</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"双个-操作符（标记粘贴操作符）\"><a href=\"#双个-操作符（标记粘贴操作符）\" class=\"headerlink\" title=\"双个##操作符（标记粘贴操作符）\"></a>双个##操作符（标记粘贴操作符）</h4><p>双个<code>##</code>用于将两个标记连接成一个标记。</p>\n<p><strong>语法</strong>：<code>token1 ## token2</code></p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONCAT(a, b) a ## b</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">CONCAT</span><span class=\"params\">(var, <span class=\"number\">123</span>)</span> </span>= <span class=\"number\">456</span>;  <span class=\"comment\">// 创建变量 var123</span></span><br><span class=\"line\">    std::cout &lt;&lt; var123 &lt;&lt; std::endl;  <span class=\"comment\">// 输出：456</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>更复杂的应用</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DECLARE_GETTER_SETTER(type, name) \\</span></span><br><span class=\"line\"><span class=\"meta\">    private: \\</span></span><br><span class=\"line\"><span class=\"meta\">        type name##_; \\</span></span><br><span class=\"line\"><span class=\"meta\">    public: \\</span></span><br><span class=\"line\"><span class=\"meta\">        type get##name() const &#123; return name##_; &#125; \\</span></span><br><span class=\"line\"><span class=\"meta\">        void set##name(const type&amp; value) &#123; name##_ = value; &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_GETTER_SETTER</span>(std::string, Name)</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_GETTER_SETTER</span>(<span class=\"type\">int</span>, Age)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 展开后相当于：</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::string Name_;</span><br><span class=\"line\">    <span class=\"type\">int</span> Age_;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">getName</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> Name_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setName</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; value)</span> </span>&#123; Name_ = value; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> Age_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span>&amp; value)</span> </span>&#123; Age_ = value; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"最佳实践建议\"><a href=\"#最佳实践建议\" class=\"headerlink\" title=\"最佳实践建议\"></a>最佳实践建议</h3><h4 id=\"1-宏定义的正确格式\"><a href=\"#1-宏定义的正确格式\" class=\"headerlink\" title=\"1. 宏定义的正确格式\"></a>1. 宏定义的正确格式</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正确：宏名和宏体之间有空格</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误：没有空格分隔</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX(a,b)((a)&gt;(b)?(a):(b))</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-避免在宏中使用预处理指令\"><a href=\"#2-避免在宏中使用预处理指令\" class=\"headerlink\" title=\"2. 避免在宏中使用预处理指令\"></a>2. 避免在宏中使用预处理指令</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 危险：不要这样做</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INCLUDE_STRING #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确：如果需要条件包含，使用条件编译</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> NEED_STRING</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-使用括号保护宏参数\"><a href=\"#3-使用括号保护宏参数\" class=\"headerlink\" title=\"3. 使用括号保护宏参数\"></a>3. 使用括号保护宏参数</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 危险：可能导致运算符优先级问题</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SQUARE(x) x * x</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确：用括号保护参数和整个表达式</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SQUARE(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-多行宏的正确写法\"><a href=\"#4-多行宏的正确写法\" class=\"headerlink\" title=\"4. 多行宏的正确写法\"></a>4. 多行宏的正确写法</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COMPLEX_MACRO(x, y) \\</span></span><br><span class=\"line\"><span class=\"meta\">    do &#123; \\</span></span><br><span class=\"line\"><span class=\"meta\">        std::cout &lt;&lt; <span class=\"string\">&quot;Processing: &quot;</span> &lt;&lt; #x &lt;&lt; std::endl; \\</span></span><br><span class=\"line\"><span class=\"meta\">        result = (x) + (y); \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125; while(0)</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"现代C-的替代方案\"><a href=\"#现代C-的替代方案\" class=\"headerlink\" title=\"现代C++的替代方案\"></a>现代C++的替代方案</h3><p>在现代C++中，我们有更好的替代方案：</p>\n<h4 id=\"1-使用constexpr函数替代函数式宏\"><a href=\"#1-使用constexpr函数替代函数式宏\" class=\"headerlink\" title=\"1. 使用constexpr函数替代函数式宏\"></a>1. 使用constexpr函数替代函数式宏</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传统宏</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现代C++</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> T <span class=\"title\">max</span><span class=\"params\">(T a, T b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a &gt; b) ? a : b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-使用模板和constexpr替代复杂宏\"><a href=\"#2-使用模板和constexpr替代复杂宏\" class=\"headerlink\" title=\"2. 使用模板和constexpr替代复杂宏\"></a>2. 使用模板和constexpr替代复杂宏</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传统宏方式</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DECLARE_COMPARISON(type) \\</span></span><br><span class=\"line\"><span class=\"meta\">    bool operator&lt;(const type&amp; other) const; \\</span></span><br><span class=\"line\"><span class=\"meta\">    bool operator&gt;(const type&amp; other) const;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现代C++方式</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">concept</span> Comparable = <span class=\"built_in\">requires</span>(T a, T b) &#123;</span><br><span class=\"line\">    &#123; a &lt; b &#125; -&gt; std::convertible_to&lt;<span class=\"type\">bool</span>&gt;;</span><br><span class=\"line\">    &#123; a &gt; b &#125; -&gt; std::convertible_to&lt;<span class=\"type\">bool</span>&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-使用constexpr变量替代常量宏\"><a href=\"#3-使用constexpr变量替代常量宏\" class=\"headerlink\" title=\"3. 使用constexpr变量替代常量宏\"></a>3. 使用constexpr变量替代常量宏</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传统宏</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PI 3.14159265359</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现代C++</span></span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"type\">double</span> PI = <span class=\"number\">3.14159265359</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"调试宏的技巧\"><a href=\"#调试宏的技巧\" class=\"headerlink\" title=\"调试宏的技巧\"></a>调试宏的技巧</h3><h4 id=\"1-使用编译器选项查看宏展开\"><a href=\"#1-使用编译器选项查看宏展开\" class=\"headerlink\" title=\"1. 使用编译器选项查看宏展开\"></a>1. 使用编译器选项查看宏展开</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GCC/Clang</span></span><br><span class=\"line\">g++ -E source.cpp &gt; preprocessed.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看特定宏的展开</span></span><br><span class=\"line\">g++ -E -dM source.cpp | grep MY_MACRO</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-使用静态断言验证宏行为\"><a href=\"#2-使用静态断言验证宏行为\" class=\"headerlink\" title=\"2. 使用静态断言验证宏行为\"></a>2. 使用静态断言验证宏行为</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IS_POWER_OF_TWO(x) (((x) &amp; ((x) - 1)) == 0)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">static_assert</span>(<span class=\"built_in\">IS_POWER_OF_TWO</span>(<span class=\"number\">8</span>), <span class=\"string\">&quot;8 should be power of 2&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">static_assert</span>(!<span class=\"built_in\">IS_POWER_OF_TWO</span>(<span class=\"number\">6</span>), <span class=\"string\">&quot;6 should not be power of 2&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"常见宏陷阱总结\"><a href=\"#常见宏陷阱总结\" class=\"headerlink\" title=\"常见宏陷阱总结\"></a>常见宏陷阱总结</h3><h4 id=\"1-副作用问题\"><a href=\"#1-副作用问题\" class=\"headerlink\" title=\"1. 副作用问题\"></a>1. 副作用问题</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> result = <span class=\"built_in\">MAX</span>(++i, <span class=\"number\">10</span>);  <span class=\"comment\">// i被递增两次！</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-类型问题\"><a href=\"#2-类型问题\" class=\"headerlink\" title=\"2. 类型问题\"></a>2. 类型问题</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ABS(x) ((x) &lt; 0 ? -(x) : (x))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> u = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> result = <span class=\"built_in\">ABS</span>(u - <span class=\"number\">2</span>);  <span class=\"comment\">// 可能产生意外结果</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-作用域问题\"><a href=\"#3-作用域问题\" class=\"headerlink\" title=\"3. 作用域问题\"></a>3. 作用域问题</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SWAP(a, b) &#123; int temp = a; a = b; b = temp; &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> temp = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">1</span>, y = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">SWAP</span>(x, y);  <span class=\"comment\">// temp变量名冲突！</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><strong>语法正确性</strong>：宏定义必须遵循正确的语法格式</li>\n<li><strong>语义合理性</strong>：不要在宏中包含预处理指令</li>\n<li><strong>理解工具</strong>：深入理解#和##操作符的作用机制</li>\n<li><strong>现代化思维</strong>：在可能的情况下，优先使用现代C++特性</li>\n</ol>\n<p><strong>关键要点回顾</strong>：</p>\n<ul>\n<li><code>#</code>操作符用于字符串化参数</li>\n<li><code>##</code>操作符用于标记粘贴</li>\n<li>宏定义需要正确的语法格式</li>\n<li>现代C++提供了更安全的替代方案</li>\n<li>调试宏需要特殊的技巧和工具</li>\n</ul>\n<p>记住，宏是一个强大但危险的工具。正确使用它们需要深入理解预处理器的工作原理，以及对潜在陷阱的充分认识。在现代C++开发中，我们应该优先考虑类型安全、易于调试的替代方案。</p>\n<p>感谢大家收听今天的播客，我们下期再见！</p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://en.cppreference.com/w/cpp/preprocessor\">C++ Preprocessor Reference</a></li>\n<li><a href=\"https://www.oreilly.com/library/view/effective-modern-c/9781491908419/\">Effective Modern C++ by Scott Meyers</a></li>\n<li><a href=\"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines\">C++ Core Guidelines</a> </li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"播客分析：C-宏定义的陷阱与-、-操作符详解\"><a href=\"#播客分析：C-宏定义的陷阱与-、-操作符详解\" class=\"headerlink\" title=\"播客分析：C++宏定义的陷阱与#、##操作符详解\"></a>播客分析：C++宏定义的陷阱与#、##操作符详解</h2><h3 id=\"C-宏中的-和-操作符详解\"><a href=\"#C-宏中的-和-操作符详解\" class=\"headerlink\" title=\"C++宏中的#和##操作符详解\"></a>C++宏中的#和##操作符详解</h3>","more":"<p>现在让我们深入了解C++宏系统中两个重要的操作符：</p>\n<h4 id=\"单个-操作符（字符串化操作符）\"><a href=\"#单个-操作符（字符串化操作符）\" class=\"headerlink\" title=\"单个#操作符（字符串化操作符）\"></a>单个#操作符（字符串化操作符）</h4><p>单个<code>#</code>用于将宏参数转换为字符串字面量。</p>\n<p><strong>语法</strong>：<code>#parameter</code></p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STRINGIFY(x) #x</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"built_in\">STRINGIFY</span>(hello world) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"comment\">// 输出：hello world</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"built_in\">STRINGIFY</span>(<span class=\"number\">123</span> + <span class=\"number\">456</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"comment\">// 输出：123 + 456</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>工作原理</strong>：</p>\n<ul>\n<li>预处理器将参数原样转换为字符串</li>\n<li>保留参数中的空格和特殊字符</li>\n<li>在字符串两端添加双引号</li>\n</ul>\n<p><strong>实际应用场景</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DEBUG_PRINT(var) \\</span></span><br><span class=\"line\"><span class=\"meta\">    std::cout &lt;&lt; #var &lt;&lt; <span class=\"string\">&quot; = &quot;</span> &lt;&lt; var &lt;&lt; std::endl</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"built_in\">DEBUG_PRINT</span>(x);  <span class=\"comment\">// 输出：x = 42</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"双个-操作符（标记粘贴操作符）\"><a href=\"#双个-操作符（标记粘贴操作符）\" class=\"headerlink\" title=\"双个##操作符（标记粘贴操作符）\"></a>双个##操作符（标记粘贴操作符）</h4><p>双个<code>##</code>用于将两个标记连接成一个标记。</p>\n<p><strong>语法</strong>：<code>token1 ## token2</code></p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONCAT(a, b) a ## b</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">CONCAT</span><span class=\"params\">(var, <span class=\"number\">123</span>)</span> </span>= <span class=\"number\">456</span>;  <span class=\"comment\">// 创建变量 var123</span></span><br><span class=\"line\">    std::cout &lt;&lt; var123 &lt;&lt; std::endl;  <span class=\"comment\">// 输出：456</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>更复杂的应用</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DECLARE_GETTER_SETTER(type, name) \\</span></span><br><span class=\"line\"><span class=\"meta\">    private: \\</span></span><br><span class=\"line\"><span class=\"meta\">        type name##_; \\</span></span><br><span class=\"line\"><span class=\"meta\">    public: \\</span></span><br><span class=\"line\"><span class=\"meta\">        type get##name() const &#123; return name##_; &#125; \\</span></span><br><span class=\"line\"><span class=\"meta\">        void set##name(const type&amp; value) &#123; name##_ = value; &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_GETTER_SETTER</span>(std::string, Name)</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_GETTER_SETTER</span>(<span class=\"type\">int</span>, Age)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 展开后相当于：</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::string Name_;</span><br><span class=\"line\">    <span class=\"type\">int</span> Age_;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">getName</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> Name_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setName</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; value)</span> </span>&#123; Name_ = value; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> Age_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span>&amp; value)</span> </span>&#123; Age_ = value; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"最佳实践建议\"><a href=\"#最佳实践建议\" class=\"headerlink\" title=\"最佳实践建议\"></a>最佳实践建议</h3><h4 id=\"1-宏定义的正确格式\"><a href=\"#1-宏定义的正确格式\" class=\"headerlink\" title=\"1. 宏定义的正确格式\"></a>1. 宏定义的正确格式</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正确：宏名和宏体之间有空格</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误：没有空格分隔</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX(a,b)((a)&gt;(b)?(a):(b))</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-避免在宏中使用预处理指令\"><a href=\"#2-避免在宏中使用预处理指令\" class=\"headerlink\" title=\"2. 避免在宏中使用预处理指令\"></a>2. 避免在宏中使用预处理指令</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 危险：不要这样做</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INCLUDE_STRING #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确：如果需要条件包含，使用条件编译</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> NEED_STRING</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-使用括号保护宏参数\"><a href=\"#3-使用括号保护宏参数\" class=\"headerlink\" title=\"3. 使用括号保护宏参数\"></a>3. 使用括号保护宏参数</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 危险：可能导致运算符优先级问题</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SQUARE(x) x * x</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确：用括号保护参数和整个表达式</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SQUARE(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-多行宏的正确写法\"><a href=\"#4-多行宏的正确写法\" class=\"headerlink\" title=\"4. 多行宏的正确写法\"></a>4. 多行宏的正确写法</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COMPLEX_MACRO(x, y) \\</span></span><br><span class=\"line\"><span class=\"meta\">    do &#123; \\</span></span><br><span class=\"line\"><span class=\"meta\">        std::cout &lt;&lt; <span class=\"string\">&quot;Processing: &quot;</span> &lt;&lt; #x &lt;&lt; std::endl; \\</span></span><br><span class=\"line\"><span class=\"meta\">        result = (x) + (y); \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125; while(0)</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"现代C-的替代方案\"><a href=\"#现代C-的替代方案\" class=\"headerlink\" title=\"现代C++的替代方案\"></a>现代C++的替代方案</h3><p>在现代C++中，我们有更好的替代方案：</p>\n<h4 id=\"1-使用constexpr函数替代函数式宏\"><a href=\"#1-使用constexpr函数替代函数式宏\" class=\"headerlink\" title=\"1. 使用constexpr函数替代函数式宏\"></a>1. 使用constexpr函数替代函数式宏</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传统宏</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现代C++</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> T <span class=\"title\">max</span><span class=\"params\">(T a, T b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a &gt; b) ? a : b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-使用模板和constexpr替代复杂宏\"><a href=\"#2-使用模板和constexpr替代复杂宏\" class=\"headerlink\" title=\"2. 使用模板和constexpr替代复杂宏\"></a>2. 使用模板和constexpr替代复杂宏</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传统宏方式</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DECLARE_COMPARISON(type) \\</span></span><br><span class=\"line\"><span class=\"meta\">    bool operator&lt;(const type&amp; other) const; \\</span></span><br><span class=\"line\"><span class=\"meta\">    bool operator&gt;(const type&amp; other) const;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现代C++方式</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">concept</span> Comparable = <span class=\"built_in\">requires</span>(T a, T b) &#123;</span><br><span class=\"line\">    &#123; a &lt; b &#125; -&gt; std::convertible_to&lt;<span class=\"type\">bool</span>&gt;;</span><br><span class=\"line\">    &#123; a &gt; b &#125; -&gt; std::convertible_to&lt;<span class=\"type\">bool</span>&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-使用constexpr变量替代常量宏\"><a href=\"#3-使用constexpr变量替代常量宏\" class=\"headerlink\" title=\"3. 使用constexpr变量替代常量宏\"></a>3. 使用constexpr变量替代常量宏</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传统宏</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PI 3.14159265359</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现代C++</span></span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"type\">double</span> PI = <span class=\"number\">3.14159265359</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"调试宏的技巧\"><a href=\"#调试宏的技巧\" class=\"headerlink\" title=\"调试宏的技巧\"></a>调试宏的技巧</h3><h4 id=\"1-使用编译器选项查看宏展开\"><a href=\"#1-使用编译器选项查看宏展开\" class=\"headerlink\" title=\"1. 使用编译器选项查看宏展开\"></a>1. 使用编译器选项查看宏展开</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GCC/Clang</span></span><br><span class=\"line\">g++ -E source.cpp &gt; preprocessed.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看特定宏的展开</span></span><br><span class=\"line\">g++ -E -dM source.cpp | grep MY_MACRO</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-使用静态断言验证宏行为\"><a href=\"#2-使用静态断言验证宏行为\" class=\"headerlink\" title=\"2. 使用静态断言验证宏行为\"></a>2. 使用静态断言验证宏行为</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IS_POWER_OF_TWO(x) (((x) &amp; ((x) - 1)) == 0)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">static_assert</span>(<span class=\"built_in\">IS_POWER_OF_TWO</span>(<span class=\"number\">8</span>), <span class=\"string\">&quot;8 should be power of 2&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">static_assert</span>(!<span class=\"built_in\">IS_POWER_OF_TWO</span>(<span class=\"number\">6</span>), <span class=\"string\">&quot;6 should not be power of 2&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"常见宏陷阱总结\"><a href=\"#常见宏陷阱总结\" class=\"headerlink\" title=\"常见宏陷阱总结\"></a>常见宏陷阱总结</h3><h4 id=\"1-副作用问题\"><a href=\"#1-副作用问题\" class=\"headerlink\" title=\"1. 副作用问题\"></a>1. 副作用问题</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> result = <span class=\"built_in\">MAX</span>(++i, <span class=\"number\">10</span>);  <span class=\"comment\">// i被递增两次！</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-类型问题\"><a href=\"#2-类型问题\" class=\"headerlink\" title=\"2. 类型问题\"></a>2. 类型问题</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ABS(x) ((x) &lt; 0 ? -(x) : (x))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> u = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> result = <span class=\"built_in\">ABS</span>(u - <span class=\"number\">2</span>);  <span class=\"comment\">// 可能产生意外结果</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-作用域问题\"><a href=\"#3-作用域问题\" class=\"headerlink\" title=\"3. 作用域问题\"></a>3. 作用域问题</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SWAP(a, b) &#123; int temp = a; a = b; b = temp; &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> temp = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">1</span>, y = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">SWAP</span>(x, y);  <span class=\"comment\">// temp变量名冲突！</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><strong>语法正确性</strong>：宏定义必须遵循正确的语法格式</li>\n<li><strong>语义合理性</strong>：不要在宏中包含预处理指令</li>\n<li><strong>理解工具</strong>：深入理解#和##操作符的作用机制</li>\n<li><strong>现代化思维</strong>：在可能的情况下，优先使用现代C++特性</li>\n</ol>\n<p><strong>关键要点回顾</strong>：</p>\n<ul>\n<li><code>#</code>操作符用于字符串化参数</li>\n<li><code>##</code>操作符用于标记粘贴</li>\n<li>宏定义需要正确的语法格式</li>\n<li>现代C++提供了更安全的替代方案</li>\n<li>调试宏需要特殊的技巧和工具</li>\n</ul>\n<p>记住，宏是一个强大但危险的工具。正确使用它们需要深入理解预处理器的工作原理，以及对潜在陷阱的充分认识。在现代C++开发中，我们应该优先考虑类型安全、易于调试的替代方案。</p>\n<p>感谢大家收听今天的播客，我们下期再见！</p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://en.cppreference.com/w/cpp/preprocessor\">C++ Preprocessor Reference</a></li>\n<li><a href=\"https://www.oreilly.com/library/view/effective-modern-c/9781491908419/\">Effective Modern C++ by Scott Meyers</a></li>\n<li><a href=\"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines\">C++ Core Guidelines</a> </li>\n</ul>"},{"title":"高性能std::string实现分析","date":"2025-01-27T02:00:00.000Z","_content":"\n# 高性能std::string实现分析\n\n## 1. 字符串存储策略\n\n### 1.1 小字符串优化（SSO）\n```cpp\nclass string {\nprivate:\n    static const size_t SSO_SIZE = 15;  // 典型值\n    union {\n        struct {\n            char* data;\n            size_t size;\n            size_t capacity;\n        } heap;\n        struct {\n            char data[SSO_SIZE + 1];\n            unsigned char size;\n        } stack;\n    } storage;\n    bool is_sso() const { return storage.stack.size < SSO_SIZE; }\n};\n```\n\n**优势**：\n- 避免小字符串的堆分配\n- 减少内存碎片\n- 提高缓存局部性\n\n### 1.2 中长字符串处理\n```cpp\nclass string {\n    // 堆分配策略\n    void grow(size_t new_capacity) {\n        size_t new_size = std::max(\n            new_capacity,\n            capacity() * 2  // 2倍增长策略\n        );\n        char* new_data = allocate(new_size);\n        memcpy(new_data, data(), size());\n        deallocate(data());\n        storage.heap.data = new_data;\n        storage.heap.capacity = new_size;\n    }\n};\n```\n\n## 2. 引用计数优化\n\n### 2.1 共享字符串实现\n```cpp\nclass string {\nprivate:\n    struct SharedData {\n        std::atomic<size_t> ref_count;\n        size_t size;\n        size_t capacity;\n        char data[1];  // 柔性数组\n    };\n    \n    SharedData* shared;\n    \n    void add_ref() {\n        if (shared) {\n            shared->ref_count.fetch_add(1, std::memory_order_relaxed);\n        }\n    }\n    \n    void release() {\n        if (shared && shared->ref_count.fetch_sub(1, std::memory_order_acq_rel) == 1) {\n            deallocate(shared);\n        }\n    }\n};\n```\n\n### 2.2 写时复制（COW）\n```cpp\nclass string {\n    void ensure_unique() {\n        if (shared && shared->ref_count.load(std::memory_order_acquire) > 1) {\n            SharedData* new_data = allocate(size());\n            memcpy(new_data->data, shared->data, size());\n            release();\n            shared = new_data;\n            shared->ref_count.store(1, std::memory_order_relaxed);\n        }\n    }\n};\n```\n\n## 3. 字面量优化\n\n### 3.1 字符串字面量处理\n```cpp\nclass string {\n    // 字面量优化\n    template<size_t N>\n    string(const char (&str)[N]) {\n        if (N <= SSO_SIZE) {\n            // 使用SSO\n            memcpy(storage.stack.data, str, N);\n            storage.stack.size = N;\n        } else {\n            // 堆分配\n            storage.heap.data = allocate(N);\n            memcpy(storage.heap.data, str, N);\n            storage.heap.size = N;\n            storage.heap.capacity = N;\n        }\n    }\n};\n```\n\n### 3.2 字符串视图\n```cpp\nclass string_view {\n    const char* data_;\n    size_t size_;\n    \npublic:\n    // 零拷贝构造\n    string_view(const string& str) \n        : data_(str.data()), size_(str.size()) {}\n};\n```\n\n## 4. 内存管理优化\n\n### 4.1 内存池\n```cpp\nclass StringPool {\n    static const size_t BLOCK_SIZE = 4096;\n    struct Block {\n        char* data;\n        size_t used;\n        Block* next;\n    };\n    \n    Block* current_block;\n    \n    char* allocate(size_t size) {\n        if (current_block->used + size > BLOCK_SIZE) {\n            allocate_new_block();\n        }\n        char* ptr = current_block->data + current_block->used;\n        current_block->used += size;\n        return ptr;\n    }\n};\n```\n\n### 4.2 对齐优化\n```cpp\nclass string {\n    static const size_t ALIGNMENT = 16;\n    \n    char* allocate(size_t size) {\n        size_t aligned_size = (size + ALIGNMENT - 1) & ~(ALIGNMENT - 1);\n        return static_cast<char*>(aligned_alloc(ALIGNMENT, aligned_size));\n    }\n};\n```\n\n## 5. 性能优化技巧\n\n### 5.1 移动语义\n```cpp\nclass string {\n    string(string&& other) noexcept {\n        if (other.is_sso()) {\n            memcpy(storage.stack.data, other.storage.stack.data, other.size());\n            storage.stack.size = other.storage.stack.size;\n        } else {\n            storage.heap = other.storage.heap;\n            other.storage.heap.data = nullptr;\n            other.storage.heap.size = 0;\n            other.storage.heap.capacity = 0;\n        }\n    }\n};\n```\n\n### 5.2 预留空间\n```cpp\nclass string {\n    void reserve(size_t new_capacity) {\n        if (new_capacity > capacity()) {\n            if (is_sso() && new_capacity <= SSO_SIZE) {\n                return;  // 已经在栈上，且空间足够\n            }\n            grow(new_capacity);\n        }\n    }\n};\n```\n\n## 6. 线程安全考虑\n\n### 6.1 引用计数原子操作\n```cpp\nclass string {\n    struct SharedData {\n        std::atomic<size_t> ref_count;\n        // ...\n    };\n    \n    void add_ref() {\n        if (shared) {\n            shared->ref_count.fetch_add(1, std::memory_order_relaxed);\n        }\n    }\n};\n```\n\n### 6.2 写时复制线程安全\n```cpp\nclass string {\n    void ensure_unique() {\n        if (shared) {\n            size_t refs = shared->ref_count.load(std::memory_order_acquire);\n            if (refs > 1) {\n                // 创建新副本\n                SharedData* new_data = allocate(size());\n                memcpy(new_data->data, shared->data, size());\n                release();\n                shared = new_data;\n                shared->ref_count.store(1, std::memory_order_relaxed);\n            }\n        }\n    }\n};\n```\n\n## 7. 性能测试指标\n\n### 7.1 内存使用\n- 小字符串（<16字节）：栈存储，零堆分配\n- 中字符串（16-64字节）：单次堆分配\n- 大字符串（>64字节）：多次堆分配\n\n### 7.2 操作性能\n- 构造/析构：O(1) 小字符串，O(n) 大字符串\n- 复制：O(1) 引用计数，O(n) 写时复制\n- 修改：O(1) 小字符串，O(n) 大字符串\n\n## 8. 总结\n\n高性能std::string实现需要综合考虑多个方面：\n1. 小字符串优化（SSO）减少堆分配\n2. 引用计数优化内存使用\n3. 字面量处理提高构造效率\n4. 内存管理优化减少碎片\n5. 移动语义提升性能\n6. 线程安全保证正确性\n\n通过合理使用这些技术，可以在保证功能正确性的同时，显著提升字符串操作的性能。 ","source":"_posts/high-performance-string-implementation.md","raw":"---\ntitle: 高性能std::string实现分析\ndate: 2025-01-27 10:00:00\ntags: [C++, 字符串, 性能优化]\ncategories: [编程技术]\n---\n\n# 高性能std::string实现分析\n\n## 1. 字符串存储策略\n\n### 1.1 小字符串优化（SSO）\n```cpp\nclass string {\nprivate:\n    static const size_t SSO_SIZE = 15;  // 典型值\n    union {\n        struct {\n            char* data;\n            size_t size;\n            size_t capacity;\n        } heap;\n        struct {\n            char data[SSO_SIZE + 1];\n            unsigned char size;\n        } stack;\n    } storage;\n    bool is_sso() const { return storage.stack.size < SSO_SIZE; }\n};\n```\n\n**优势**：\n- 避免小字符串的堆分配\n- 减少内存碎片\n- 提高缓存局部性\n\n### 1.2 中长字符串处理\n```cpp\nclass string {\n    // 堆分配策略\n    void grow(size_t new_capacity) {\n        size_t new_size = std::max(\n            new_capacity,\n            capacity() * 2  // 2倍增长策略\n        );\n        char* new_data = allocate(new_size);\n        memcpy(new_data, data(), size());\n        deallocate(data());\n        storage.heap.data = new_data;\n        storage.heap.capacity = new_size;\n    }\n};\n```\n\n## 2. 引用计数优化\n\n### 2.1 共享字符串实现\n```cpp\nclass string {\nprivate:\n    struct SharedData {\n        std::atomic<size_t> ref_count;\n        size_t size;\n        size_t capacity;\n        char data[1];  // 柔性数组\n    };\n    \n    SharedData* shared;\n    \n    void add_ref() {\n        if (shared) {\n            shared->ref_count.fetch_add(1, std::memory_order_relaxed);\n        }\n    }\n    \n    void release() {\n        if (shared && shared->ref_count.fetch_sub(1, std::memory_order_acq_rel) == 1) {\n            deallocate(shared);\n        }\n    }\n};\n```\n\n### 2.2 写时复制（COW）\n```cpp\nclass string {\n    void ensure_unique() {\n        if (shared && shared->ref_count.load(std::memory_order_acquire) > 1) {\n            SharedData* new_data = allocate(size());\n            memcpy(new_data->data, shared->data, size());\n            release();\n            shared = new_data;\n            shared->ref_count.store(1, std::memory_order_relaxed);\n        }\n    }\n};\n```\n\n## 3. 字面量优化\n\n### 3.1 字符串字面量处理\n```cpp\nclass string {\n    // 字面量优化\n    template<size_t N>\n    string(const char (&str)[N]) {\n        if (N <= SSO_SIZE) {\n            // 使用SSO\n            memcpy(storage.stack.data, str, N);\n            storage.stack.size = N;\n        } else {\n            // 堆分配\n            storage.heap.data = allocate(N);\n            memcpy(storage.heap.data, str, N);\n            storage.heap.size = N;\n            storage.heap.capacity = N;\n        }\n    }\n};\n```\n\n### 3.2 字符串视图\n```cpp\nclass string_view {\n    const char* data_;\n    size_t size_;\n    \npublic:\n    // 零拷贝构造\n    string_view(const string& str) \n        : data_(str.data()), size_(str.size()) {}\n};\n```\n\n## 4. 内存管理优化\n\n### 4.1 内存池\n```cpp\nclass StringPool {\n    static const size_t BLOCK_SIZE = 4096;\n    struct Block {\n        char* data;\n        size_t used;\n        Block* next;\n    };\n    \n    Block* current_block;\n    \n    char* allocate(size_t size) {\n        if (current_block->used + size > BLOCK_SIZE) {\n            allocate_new_block();\n        }\n        char* ptr = current_block->data + current_block->used;\n        current_block->used += size;\n        return ptr;\n    }\n};\n```\n\n### 4.2 对齐优化\n```cpp\nclass string {\n    static const size_t ALIGNMENT = 16;\n    \n    char* allocate(size_t size) {\n        size_t aligned_size = (size + ALIGNMENT - 1) & ~(ALIGNMENT - 1);\n        return static_cast<char*>(aligned_alloc(ALIGNMENT, aligned_size));\n    }\n};\n```\n\n## 5. 性能优化技巧\n\n### 5.1 移动语义\n```cpp\nclass string {\n    string(string&& other) noexcept {\n        if (other.is_sso()) {\n            memcpy(storage.stack.data, other.storage.stack.data, other.size());\n            storage.stack.size = other.storage.stack.size;\n        } else {\n            storage.heap = other.storage.heap;\n            other.storage.heap.data = nullptr;\n            other.storage.heap.size = 0;\n            other.storage.heap.capacity = 0;\n        }\n    }\n};\n```\n\n### 5.2 预留空间\n```cpp\nclass string {\n    void reserve(size_t new_capacity) {\n        if (new_capacity > capacity()) {\n            if (is_sso() && new_capacity <= SSO_SIZE) {\n                return;  // 已经在栈上，且空间足够\n            }\n            grow(new_capacity);\n        }\n    }\n};\n```\n\n## 6. 线程安全考虑\n\n### 6.1 引用计数原子操作\n```cpp\nclass string {\n    struct SharedData {\n        std::atomic<size_t> ref_count;\n        // ...\n    };\n    \n    void add_ref() {\n        if (shared) {\n            shared->ref_count.fetch_add(1, std::memory_order_relaxed);\n        }\n    }\n};\n```\n\n### 6.2 写时复制线程安全\n```cpp\nclass string {\n    void ensure_unique() {\n        if (shared) {\n            size_t refs = shared->ref_count.load(std::memory_order_acquire);\n            if (refs > 1) {\n                // 创建新副本\n                SharedData* new_data = allocate(size());\n                memcpy(new_data->data, shared->data, size());\n                release();\n                shared = new_data;\n                shared->ref_count.store(1, std::memory_order_relaxed);\n            }\n        }\n    }\n};\n```\n\n## 7. 性能测试指标\n\n### 7.1 内存使用\n- 小字符串（<16字节）：栈存储，零堆分配\n- 中字符串（16-64字节）：单次堆分配\n- 大字符串（>64字节）：多次堆分配\n\n### 7.2 操作性能\n- 构造/析构：O(1) 小字符串，O(n) 大字符串\n- 复制：O(1) 引用计数，O(n) 写时复制\n- 修改：O(1) 小字符串，O(n) 大字符串\n\n## 8. 总结\n\n高性能std::string实现需要综合考虑多个方面：\n1. 小字符串优化（SSO）减少堆分配\n2. 引用计数优化内存使用\n3. 字面量处理提高构造效率\n4. 内存管理优化减少碎片\n5. 移动语义提升性能\n6. 线程安全保证正确性\n\n通过合理使用这些技术，可以在保证功能正确性的同时，显著提升字符串操作的性能。 ","slug":"high-performance-string-implementation","published":1,"updated":"2025-06-15T03:42:06.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbx4ojeh0000h2j28xxnh5y2","content":"<h1 id=\"高性能std-string实现分析\"><a href=\"#高性能std-string实现分析\" class=\"headerlink\" title=\"高性能std::string实现分析\"></a>高性能std::string实现分析</h1><h2 id=\"1-字符串存储策略\"><a href=\"#1-字符串存储策略\" class=\"headerlink\" title=\"1. 字符串存储策略\"></a>1. 字符串存储策略</h2><span id=\"more\"></span>\n\n<h3 id=\"1-1-小字符串优化（SSO）\"><a href=\"#1-1-小字符串优化（SSO）\" class=\"headerlink\" title=\"1.1 小字符串优化（SSO）\"></a>1.1 小字符串优化（SSO）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> SSO_SIZE = <span class=\"number\">15</span>;  <span class=\"comment\">// 典型值</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span>* data;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> size;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> capacity;</span><br><span class=\"line\">        &#125; heap;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> data[SSO_SIZE + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"type\">unsigned</span> <span class=\"type\">char</span> size;</span><br><span class=\"line\">        &#125; stack;</span><br><span class=\"line\">    &#125; storage;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">is_sso</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> storage.stack.size &lt; SSO_SIZE; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优势</strong>：</p>\n<ul>\n<li>避免小字符串的堆分配</li>\n<li>减少内存碎片</li>\n<li>提高缓存局部性</li>\n</ul>\n<h3 id=\"1-2-中长字符串处理\"><a href=\"#1-2-中长字符串处理\" class=\"headerlink\" title=\"1.2 中长字符串处理\"></a>1.2 中长字符串处理</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 堆分配策略</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"type\">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> new_size = std::<span class=\"built_in\">max</span>(</span><br><span class=\"line\">            new_capacity,</span><br><span class=\"line\">            <span class=\"built_in\">capacity</span>() * <span class=\"number\">2</span>  <span class=\"comment\">// 2倍增长策略</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"type\">char</span>* new_data = <span class=\"built_in\">allocate</span>(new_size);</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(new_data, <span class=\"built_in\">data</span>(), <span class=\"built_in\">size</span>());</span><br><span class=\"line\">        <span class=\"built_in\">deallocate</span>(<span class=\"built_in\">data</span>());</span><br><span class=\"line\">        storage.heap.data = new_data;</span><br><span class=\"line\">        storage.heap.capacity = new_size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-引用计数优化\"><a href=\"#2-引用计数优化\" class=\"headerlink\" title=\"2. 引用计数优化\"></a>2. 引用计数优化</h2><h3 id=\"2-1-共享字符串实现\"><a href=\"#2-1-共享字符串实现\" class=\"headerlink\" title=\"2.1 共享字符串实现\"></a>2.1 共享字符串实现</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">SharedData</span> &#123;</span><br><span class=\"line\">        std::atomic&lt;<span class=\"type\">size_t</span>&gt; ref_count;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> size;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> capacity;</span><br><span class=\"line\">        <span class=\"type\">char</span> data[<span class=\"number\">1</span>];  <span class=\"comment\">// 柔性数组</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SharedData* shared;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_ref</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shared) &#123;</span><br><span class=\"line\">            shared-&gt;ref_count.<span class=\"built_in\">fetch_add</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shared &amp;&amp; shared-&gt;ref_count.<span class=\"built_in\">fetch_sub</span>(<span class=\"number\">1</span>, std::memory_order_acq_rel) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">deallocate</span>(shared);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-写时复制（COW）\"><a href=\"#2-2-写时复制（COW）\" class=\"headerlink\" title=\"2.2 写时复制（COW）\"></a>2.2 写时复制（COW）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ensure_unique</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shared &amp;&amp; shared-&gt;ref_count.<span class=\"built_in\">load</span>(std::memory_order_acquire) &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            SharedData* new_data = <span class=\"built_in\">allocate</span>(<span class=\"built_in\">size</span>());</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(new_data-&gt;data, shared-&gt;data, <span class=\"built_in\">size</span>());</span><br><span class=\"line\">            <span class=\"built_in\">release</span>();</span><br><span class=\"line\">            shared = new_data;</span><br><span class=\"line\">            shared-&gt;ref_count.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-字面量优化\"><a href=\"#3-字面量优化\" class=\"headerlink\" title=\"3. 字面量优化\"></a>3. 字面量优化</h2><h3 id=\"3-1-字符串字面量处理\"><a href=\"#3-1-字符串字面量处理\" class=\"headerlink\" title=\"3.1 字符串字面量处理\"></a>3.1 字符串字面量处理</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 字面量优化</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">size_t</span> N&gt;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">string</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> (&amp;str)[N])</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (N &lt;= SSO_SIZE) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用SSO</span></span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(storage.stack.data, str, N);</span><br><span class=\"line\">            storage.stack.size = N;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 堆分配</span></span><br><span class=\"line\">            storage.heap.data = <span class=\"built_in\">allocate</span>(N);</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(storage.heap.data, str, N);</span><br><span class=\"line\">            storage.heap.size = N;</span><br><span class=\"line\">            storage.heap.capacity = N;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-字符串视图\"><a href=\"#3-2-字符串视图\" class=\"headerlink\" title=\"3.2 字符串视图\"></a>3.2 字符串视图</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string_view</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* data_;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size_;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 零拷贝构造</span></span><br><span class=\"line\">    <span class=\"built_in\">string_view</span>(<span class=\"type\">const</span> string&amp; str) </span><br><span class=\"line\">        : <span class=\"built_in\">data_</span>(str.<span class=\"built_in\">data</span>()), <span class=\"built_in\">size_</span>(str.<span class=\"built_in\">size</span>()) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-内存管理优化\"><a href=\"#4-内存管理优化\" class=\"headerlink\" title=\"4. 内存管理优化\"></a>4. 内存管理优化</h2><h3 id=\"4-1-内存池\"><a href=\"#4-1-内存池\" class=\"headerlink\" title=\"4.1 内存池\"></a>4.1 内存池</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">StringPool</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> BLOCK_SIZE = <span class=\"number\">4096</span>;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Block</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span>* data;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> used;</span><br><span class=\"line\">        Block* next;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Block* current_block;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">char</span>* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"type\">size_t</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current_block-&gt;used + size &gt; BLOCK_SIZE) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">allocate_new_block</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">char</span>* ptr = current_block-&gt;data + current_block-&gt;used;</span><br><span class=\"line\">        current_block-&gt;used += size;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-对齐优化\"><a href=\"#4-2-对齐优化\" class=\"headerlink\" title=\"4.2 对齐优化\"></a>4.2 对齐优化</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> ALIGNMENT = <span class=\"number\">16</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">char</span>* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"type\">size_t</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> aligned_size = (size + ALIGNMENT - <span class=\"number\">1</span>) &amp; ~(ALIGNMENT - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">char</span>*&gt;(<span class=\"built_in\">aligned_alloc</span>(ALIGNMENT, aligned_size));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-性能优化技巧\"><a href=\"#5-性能优化技巧\" class=\"headerlink\" title=\"5. 性能优化技巧\"></a>5. 性能优化技巧</h2><h3 id=\"5-1-移动语义\"><a href=\"#5-1-移动语义\" class=\"headerlink\" title=\"5.1 移动语义\"></a>5.1 移动语义</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span>(string&amp;&amp; other) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.<span class=\"built_in\">is_sso</span>()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(storage.stack.data, other.storage.stack.data, other.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">            storage.stack.size = other.storage.stack.size;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            storage.heap = other.storage.heap;</span><br><span class=\"line\">            other.storage.heap.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            other.storage.heap.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">            other.storage.heap.capacity = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-预留空间\"><a href=\"#5-2-预留空间\" class=\"headerlink\" title=\"5.2 预留空间\"></a>5.2 预留空间</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reserve</span><span class=\"params\">(<span class=\"type\">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (new_capacity &gt; <span class=\"built_in\">capacity</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">is_sso</span>() &amp;&amp; new_capacity &lt;= SSO_SIZE) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;  <span class=\"comment\">// 已经在栈上，且空间足够</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">grow</span>(new_capacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-线程安全考虑\"><a href=\"#6-线程安全考虑\" class=\"headerlink\" title=\"6. 线程安全考虑\"></a>6. 线程安全考虑</h2><h3 id=\"6-1-引用计数原子操作\"><a href=\"#6-1-引用计数原子操作\" class=\"headerlink\" title=\"6.1 引用计数原子操作\"></a>6.1 引用计数原子操作</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">SharedData</span> &#123;</span><br><span class=\"line\">        std::atomic&lt;<span class=\"type\">size_t</span>&gt; ref_count;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_ref</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shared) &#123;</span><br><span class=\"line\">            shared-&gt;ref_count.<span class=\"built_in\">fetch_add</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-2-写时复制线程安全\"><a href=\"#6-2-写时复制线程安全\" class=\"headerlink\" title=\"6.2 写时复制线程安全\"></a>6.2 写时复制线程安全</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ensure_unique</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shared) &#123;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> refs = shared-&gt;ref_count.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (refs &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 创建新副本</span></span><br><span class=\"line\">                SharedData* new_data = <span class=\"built_in\">allocate</span>(<span class=\"built_in\">size</span>());</span><br><span class=\"line\">                <span class=\"built_in\">memcpy</span>(new_data-&gt;data, shared-&gt;data, <span class=\"built_in\">size</span>());</span><br><span class=\"line\">                <span class=\"built_in\">release</span>();</span><br><span class=\"line\">                shared = new_data;</span><br><span class=\"line\">                shared-&gt;ref_count.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-性能测试指标\"><a href=\"#7-性能测试指标\" class=\"headerlink\" title=\"7. 性能测试指标\"></a>7. 性能测试指标</h2><h3 id=\"7-1-内存使用\"><a href=\"#7-1-内存使用\" class=\"headerlink\" title=\"7.1 内存使用\"></a>7.1 内存使用</h3><ul>\n<li>小字符串（&lt;16字节）：栈存储，零堆分配</li>\n<li>中字符串（16-64字节）：单次堆分配</li>\n<li>大字符串（&gt;64字节）：多次堆分配</li>\n</ul>\n<h3 id=\"7-2-操作性能\"><a href=\"#7-2-操作性能\" class=\"headerlink\" title=\"7.2 操作性能\"></a>7.2 操作性能</h3><ul>\n<li>构造/析构：O(1) 小字符串，O(n) 大字符串</li>\n<li>复制：O(1) 引用计数，O(n) 写时复制</li>\n<li>修改：O(1) 小字符串，O(n) 大字符串</li>\n</ul>\n<h2 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8. 总结\"></a>8. 总结</h2><p>高性能std::string实现需要综合考虑多个方面：</p>\n<ol>\n<li>小字符串优化（SSO）减少堆分配</li>\n<li>引用计数优化内存使用</li>\n<li>字面量处理提高构造效率</li>\n<li>内存管理优化减少碎片</li>\n<li>移动语义提升性能</li>\n<li>线程安全保证正确性</li>\n</ol>\n<p>通过合理使用这些技术，可以在保证功能正确性的同时，显著提升字符串操作的性能。 </p>\n","site":{"data":{}},"excerpt":"<h1 id=\"高性能std-string实现分析\"><a href=\"#高性能std-string实现分析\" class=\"headerlink\" title=\"高性能std::string实现分析\"></a>高性能std::string实现分析</h1><h2 id=\"1-字符串存储策略\"><a href=\"#1-字符串存储策略\" class=\"headerlink\" title=\"1. 字符串存储策略\"></a>1. 字符串存储策略</h2>","more":"<h3 id=\"1-1-小字符串优化（SSO）\"><a href=\"#1-1-小字符串优化（SSO）\" class=\"headerlink\" title=\"1.1 小字符串优化（SSO）\"></a>1.1 小字符串优化（SSO）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> SSO_SIZE = <span class=\"number\">15</span>;  <span class=\"comment\">// 典型值</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span>* data;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> size;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> capacity;</span><br><span class=\"line\">        &#125; heap;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> data[SSO_SIZE + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"type\">unsigned</span> <span class=\"type\">char</span> size;</span><br><span class=\"line\">        &#125; stack;</span><br><span class=\"line\">    &#125; storage;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">is_sso</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> storage.stack.size &lt; SSO_SIZE; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优势</strong>：</p>\n<ul>\n<li>避免小字符串的堆分配</li>\n<li>减少内存碎片</li>\n<li>提高缓存局部性</li>\n</ul>\n<h3 id=\"1-2-中长字符串处理\"><a href=\"#1-2-中长字符串处理\" class=\"headerlink\" title=\"1.2 中长字符串处理\"></a>1.2 中长字符串处理</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 堆分配策略</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"type\">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> new_size = std::<span class=\"built_in\">max</span>(</span><br><span class=\"line\">            new_capacity,</span><br><span class=\"line\">            <span class=\"built_in\">capacity</span>() * <span class=\"number\">2</span>  <span class=\"comment\">// 2倍增长策略</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"type\">char</span>* new_data = <span class=\"built_in\">allocate</span>(new_size);</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(new_data, <span class=\"built_in\">data</span>(), <span class=\"built_in\">size</span>());</span><br><span class=\"line\">        <span class=\"built_in\">deallocate</span>(<span class=\"built_in\">data</span>());</span><br><span class=\"line\">        storage.heap.data = new_data;</span><br><span class=\"line\">        storage.heap.capacity = new_size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-引用计数优化\"><a href=\"#2-引用计数优化\" class=\"headerlink\" title=\"2. 引用计数优化\"></a>2. 引用计数优化</h2><h3 id=\"2-1-共享字符串实现\"><a href=\"#2-1-共享字符串实现\" class=\"headerlink\" title=\"2.1 共享字符串实现\"></a>2.1 共享字符串实现</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">SharedData</span> &#123;</span><br><span class=\"line\">        std::atomic&lt;<span class=\"type\">size_t</span>&gt; ref_count;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> size;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> capacity;</span><br><span class=\"line\">        <span class=\"type\">char</span> data[<span class=\"number\">1</span>];  <span class=\"comment\">// 柔性数组</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SharedData* shared;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_ref</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shared) &#123;</span><br><span class=\"line\">            shared-&gt;ref_count.<span class=\"built_in\">fetch_add</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shared &amp;&amp; shared-&gt;ref_count.<span class=\"built_in\">fetch_sub</span>(<span class=\"number\">1</span>, std::memory_order_acq_rel) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">deallocate</span>(shared);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-写时复制（COW）\"><a href=\"#2-2-写时复制（COW）\" class=\"headerlink\" title=\"2.2 写时复制（COW）\"></a>2.2 写时复制（COW）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ensure_unique</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shared &amp;&amp; shared-&gt;ref_count.<span class=\"built_in\">load</span>(std::memory_order_acquire) &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            SharedData* new_data = <span class=\"built_in\">allocate</span>(<span class=\"built_in\">size</span>());</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(new_data-&gt;data, shared-&gt;data, <span class=\"built_in\">size</span>());</span><br><span class=\"line\">            <span class=\"built_in\">release</span>();</span><br><span class=\"line\">            shared = new_data;</span><br><span class=\"line\">            shared-&gt;ref_count.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-字面量优化\"><a href=\"#3-字面量优化\" class=\"headerlink\" title=\"3. 字面量优化\"></a>3. 字面量优化</h2><h3 id=\"3-1-字符串字面量处理\"><a href=\"#3-1-字符串字面量处理\" class=\"headerlink\" title=\"3.1 字符串字面量处理\"></a>3.1 字符串字面量处理</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 字面量优化</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">size_t</span> N&gt;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">string</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> (&amp;str)[N])</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (N &lt;= SSO_SIZE) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用SSO</span></span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(storage.stack.data, str, N);</span><br><span class=\"line\">            storage.stack.size = N;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 堆分配</span></span><br><span class=\"line\">            storage.heap.data = <span class=\"built_in\">allocate</span>(N);</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(storage.heap.data, str, N);</span><br><span class=\"line\">            storage.heap.size = N;</span><br><span class=\"line\">            storage.heap.capacity = N;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-字符串视图\"><a href=\"#3-2-字符串视图\" class=\"headerlink\" title=\"3.2 字符串视图\"></a>3.2 字符串视图</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string_view</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* data_;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size_;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 零拷贝构造</span></span><br><span class=\"line\">    <span class=\"built_in\">string_view</span>(<span class=\"type\">const</span> string&amp; str) </span><br><span class=\"line\">        : <span class=\"built_in\">data_</span>(str.<span class=\"built_in\">data</span>()), <span class=\"built_in\">size_</span>(str.<span class=\"built_in\">size</span>()) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-内存管理优化\"><a href=\"#4-内存管理优化\" class=\"headerlink\" title=\"4. 内存管理优化\"></a>4. 内存管理优化</h2><h3 id=\"4-1-内存池\"><a href=\"#4-1-内存池\" class=\"headerlink\" title=\"4.1 内存池\"></a>4.1 内存池</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">StringPool</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> BLOCK_SIZE = <span class=\"number\">4096</span>;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Block</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span>* data;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> used;</span><br><span class=\"line\">        Block* next;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Block* current_block;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">char</span>* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"type\">size_t</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current_block-&gt;used + size &gt; BLOCK_SIZE) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">allocate_new_block</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">char</span>* ptr = current_block-&gt;data + current_block-&gt;used;</span><br><span class=\"line\">        current_block-&gt;used += size;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-对齐优化\"><a href=\"#4-2-对齐优化\" class=\"headerlink\" title=\"4.2 对齐优化\"></a>4.2 对齐优化</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">size_t</span> ALIGNMENT = <span class=\"number\">16</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">char</span>* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"type\">size_t</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> aligned_size = (size + ALIGNMENT - <span class=\"number\">1</span>) &amp; ~(ALIGNMENT - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">char</span>*&gt;(<span class=\"built_in\">aligned_alloc</span>(ALIGNMENT, aligned_size));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-性能优化技巧\"><a href=\"#5-性能优化技巧\" class=\"headerlink\" title=\"5. 性能优化技巧\"></a>5. 性能优化技巧</h2><h3 id=\"5-1-移动语义\"><a href=\"#5-1-移动语义\" class=\"headerlink\" title=\"5.1 移动语义\"></a>5.1 移动语义</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span>(string&amp;&amp; other) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.<span class=\"built_in\">is_sso</span>()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(storage.stack.data, other.storage.stack.data, other.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">            storage.stack.size = other.storage.stack.size;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            storage.heap = other.storage.heap;</span><br><span class=\"line\">            other.storage.heap.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            other.storage.heap.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">            other.storage.heap.capacity = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-预留空间\"><a href=\"#5-2-预留空间\" class=\"headerlink\" title=\"5.2 预留空间\"></a>5.2 预留空间</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reserve</span><span class=\"params\">(<span class=\"type\">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (new_capacity &gt; <span class=\"built_in\">capacity</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">is_sso</span>() &amp;&amp; new_capacity &lt;= SSO_SIZE) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;  <span class=\"comment\">// 已经在栈上，且空间足够</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">grow</span>(new_capacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-线程安全考虑\"><a href=\"#6-线程安全考虑\" class=\"headerlink\" title=\"6. 线程安全考虑\"></a>6. 线程安全考虑</h2><h3 id=\"6-1-引用计数原子操作\"><a href=\"#6-1-引用计数原子操作\" class=\"headerlink\" title=\"6.1 引用计数原子操作\"></a>6.1 引用计数原子操作</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">SharedData</span> &#123;</span><br><span class=\"line\">        std::atomic&lt;<span class=\"type\">size_t</span>&gt; ref_count;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_ref</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shared) &#123;</span><br><span class=\"line\">            shared-&gt;ref_count.<span class=\"built_in\">fetch_add</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-2-写时复制线程安全\"><a href=\"#6-2-写时复制线程安全\" class=\"headerlink\" title=\"6.2 写时复制线程安全\"></a>6.2 写时复制线程安全</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ensure_unique</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shared) &#123;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> refs = shared-&gt;ref_count.<span class=\"built_in\">load</span>(std::memory_order_acquire);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (refs &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 创建新副本</span></span><br><span class=\"line\">                SharedData* new_data = <span class=\"built_in\">allocate</span>(<span class=\"built_in\">size</span>());</span><br><span class=\"line\">                <span class=\"built_in\">memcpy</span>(new_data-&gt;data, shared-&gt;data, <span class=\"built_in\">size</span>());</span><br><span class=\"line\">                <span class=\"built_in\">release</span>();</span><br><span class=\"line\">                shared = new_data;</span><br><span class=\"line\">                shared-&gt;ref_count.<span class=\"built_in\">store</span>(<span class=\"number\">1</span>, std::memory_order_relaxed);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-性能测试指标\"><a href=\"#7-性能测试指标\" class=\"headerlink\" title=\"7. 性能测试指标\"></a>7. 性能测试指标</h2><h3 id=\"7-1-内存使用\"><a href=\"#7-1-内存使用\" class=\"headerlink\" title=\"7.1 内存使用\"></a>7.1 内存使用</h3><ul>\n<li>小字符串（&lt;16字节）：栈存储，零堆分配</li>\n<li>中字符串（16-64字节）：单次堆分配</li>\n<li>大字符串（&gt;64字节）：多次堆分配</li>\n</ul>\n<h3 id=\"7-2-操作性能\"><a href=\"#7-2-操作性能\" class=\"headerlink\" title=\"7.2 操作性能\"></a>7.2 操作性能</h3><ul>\n<li>构造/析构：O(1) 小字符串，O(n) 大字符串</li>\n<li>复制：O(1) 引用计数，O(n) 写时复制</li>\n<li>修改：O(1) 小字符串，O(n) 大字符串</li>\n</ul>\n<h2 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8. 总结\"></a>8. 总结</h2><p>高性能std::string实现需要综合考虑多个方面：</p>\n<ol>\n<li>小字符串优化（SSO）减少堆分配</li>\n<li>引用计数优化内存使用</li>\n<li>字面量处理提高构造效率</li>\n<li>内存管理优化减少碎片</li>\n<li>移动语义提升性能</li>\n<li>线程安全保证正确性</li>\n</ol>\n<p>通过合理使用这些技术，可以在保证功能正确性的同时，显著提升字符串操作的性能。 </p>"},{"title":"移动端SSAO实现方案分析","date":"2025-01-27T02:00:00.000Z","_content":"\n# 移动端SSAO实现方案分析\n\n## 1. 核心依赖\n\n### 1.1 G-Buffer渲染\n- **深度缓冲区（Depth Buffer）**：用于重建世界空间位置\n- **法线缓冲区（Normal Buffer）**：存储视空间或世界空间法线\n- **可选的位置缓冲区**：直接存储位置，避免重建计算\n\n### 1.2 相机参数\n- 投影矩阵：屏幕空间到视空间的转换\n- 视图矩阵：世界空间到视空间转换\n- 近远平面参数：深度值线性化\n\n## 2. 移动端优化方案\n\n### 2.1 简化的采样策略\n```glsl\n// 减少采样点数量（桌面端通常64个，移动端8-16个）\nconst int SAMPLE_COUNT = 12;\nvec3 samples[SAMPLE_COUNT] = {\n    vec3(0.04, 0.04, 0.02),\n    vec3(-0.08, 0.05, 0.03),\n    // ... 更多采样点\n};\n```\n\n### 2.2 分辨率降级\n- 半分辨率渲染：在屏幕分辨率的1/2进行SSAO计算\n- 四分之一分辨率：极端性能要求下使用1/4分辨率\n- 双线性上采样：将低分辨率结果上采样到全分辨率\n\n### 2.3 深度重建优化\n```glsl\nvec3 reconstructViewPos(vec2 uv, float depth) {\n    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth, 1.0);\n    vec4 viewPos = u_invProjection * clipPos;\n    return viewPos.xyz / viewPos.w;\n}\n```\n\n## 3. 移动端特定优化\n\n### 3.1 自适应采样半径\n```glsl\nfloat getAdaptiveRadius(float viewDepth) {\n    return mix(minRadius, maxRadius, 1.0 / (1.0 + viewDepth * 0.1));\n}\n```\n\n### 3.2 分层SSAO\n- 近景高质量：对近距离物体使用更多采样点\n- 远景简化：远距离物体使用简化算法或跳过处理\n\n### 3.3 时间分片\n```cpp\nclass TemporalSSAO {\n    int currentTile = 0;\n    const int tilesPerFrame = 4;\n    \n    void renderFrame() {\n        renderSSAOTile(currentTile, tilesPerFrame);\n        currentTile = (currentTile + 1) % totalTiles;\n    }\n};\n```\n\n## 4. 内存和带宽优化\n\n### 4.1 纹理格式优化\n- R8格式：AO值只需要单通道\n- 压缩纹理：使用ETC2/ASTC压缩法线纹理\n- 打包存储：将多个值打包到单个纹理通道\n\n### 4.2 渲染目标管理\n```cpp\nRenderTarget ssaoRT = createRT(width/2, height/2, R8_UNORM);\nRenderTarget blurRT = ssaoRT; // 乒乓缓冲复用\n```\n\n## 5. 质量与性能平衡\n\n### 5.1 LOD系统集成\n- 距离衰减：根据相机距离调整SSAO强度\n- 重要性采样：对重要物体使用高质量SSAO\n\n### 5.2 动态质量调整\n```cpp\nclass AdaptiveSSAO {\n    float targetFrameTime = 16.67f; // 60fps\n    int currentSampleCount = 12;\n    \n    void adjustQuality(float frameTime) {\n        if (frameTime > targetFrameTime * 1.1f) {\n            currentSampleCount = max(8, currentSampleCount - 2);\n        } else if (frameTime < targetFrameTime * 0.9f) {\n            currentSampleCount = min(16, currentSampleCount + 1);\n        }\n    }\n};\n```\n\n## 6. 移动端特殊考虑\n\n### 6.1 功耗优化\n- Early-Z优化：利用移动GPU的Early-Z特性\n- Shader分支减少：避免动态分支，使用预编译变体\n\n### 6.2 带宽敏感优化\n- 就地模糊：在同一个Pass中完成AO计算和模糊\n- 单Pass实现：将多个步骤合并到单个着色器\n\n### 6.3 兼容性处理\n```glsl\n#ifdef GL_ES\n    precision mediump float;\n    #define SAMPLE_COUNT 8\n#else\n    #define SAMPLE_COUNT 16\n#endif\n```\n\n## 7. 实现流程\n\n1. G-Buffer Pass：渲染深度和法线\n2. SSAO Pass：在降级分辨率下计算AO\n3. 模糊Pass：边缘保持模糊（可选）\n4. 上采样Pass：恢复到全分辨率\n5. 合成Pass：与最终渲染结果混合\n\n## 8. 性能指标\n\n- 采样点数：8-16个（vs桌面端32-64个）\n- 渲染分辨率：1/2到1/4屏幕分辨率\n- GPU时间：目标控制在1-2ms内\n- 内存占用：额外2-4MB纹理内存\n\n## 9. 总结\n\n移动端SSAO实现需要在视觉效果和性能之间找到平衡点。通过合理的优化策略，包括采样点减少、分辨率降级、自适应质量调整等技术，可以在移动设备上实现可接受的SSAO效果，同时保持稳定的帧率表现。关键是要根据具体项目的性能要求和目标设备来选择合适的优化方案。 ","source":"_posts/mobile-ssao-implementation.md","raw":"---\ntitle: 移动端SSAO实现方案分析\ndate: 2025-01-27 10:00:00\ntags: [图形学, SSAO, 移动端优化]\ncategories: [图形渲染]\n---\n\n# 移动端SSAO实现方案分析\n\n## 1. 核心依赖\n\n### 1.1 G-Buffer渲染\n- **深度缓冲区（Depth Buffer）**：用于重建世界空间位置\n- **法线缓冲区（Normal Buffer）**：存储视空间或世界空间法线\n- **可选的位置缓冲区**：直接存储位置，避免重建计算\n\n### 1.2 相机参数\n- 投影矩阵：屏幕空间到视空间的转换\n- 视图矩阵：世界空间到视空间转换\n- 近远平面参数：深度值线性化\n\n## 2. 移动端优化方案\n\n### 2.1 简化的采样策略\n```glsl\n// 减少采样点数量（桌面端通常64个，移动端8-16个）\nconst int SAMPLE_COUNT = 12;\nvec3 samples[SAMPLE_COUNT] = {\n    vec3(0.04, 0.04, 0.02),\n    vec3(-0.08, 0.05, 0.03),\n    // ... 更多采样点\n};\n```\n\n### 2.2 分辨率降级\n- 半分辨率渲染：在屏幕分辨率的1/2进行SSAO计算\n- 四分之一分辨率：极端性能要求下使用1/4分辨率\n- 双线性上采样：将低分辨率结果上采样到全分辨率\n\n### 2.3 深度重建优化\n```glsl\nvec3 reconstructViewPos(vec2 uv, float depth) {\n    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth, 1.0);\n    vec4 viewPos = u_invProjection * clipPos;\n    return viewPos.xyz / viewPos.w;\n}\n```\n\n## 3. 移动端特定优化\n\n### 3.1 自适应采样半径\n```glsl\nfloat getAdaptiveRadius(float viewDepth) {\n    return mix(minRadius, maxRadius, 1.0 / (1.0 + viewDepth * 0.1));\n}\n```\n\n### 3.2 分层SSAO\n- 近景高质量：对近距离物体使用更多采样点\n- 远景简化：远距离物体使用简化算法或跳过处理\n\n### 3.3 时间分片\n```cpp\nclass TemporalSSAO {\n    int currentTile = 0;\n    const int tilesPerFrame = 4;\n    \n    void renderFrame() {\n        renderSSAOTile(currentTile, tilesPerFrame);\n        currentTile = (currentTile + 1) % totalTiles;\n    }\n};\n```\n\n## 4. 内存和带宽优化\n\n### 4.1 纹理格式优化\n- R8格式：AO值只需要单通道\n- 压缩纹理：使用ETC2/ASTC压缩法线纹理\n- 打包存储：将多个值打包到单个纹理通道\n\n### 4.2 渲染目标管理\n```cpp\nRenderTarget ssaoRT = createRT(width/2, height/2, R8_UNORM);\nRenderTarget blurRT = ssaoRT; // 乒乓缓冲复用\n```\n\n## 5. 质量与性能平衡\n\n### 5.1 LOD系统集成\n- 距离衰减：根据相机距离调整SSAO强度\n- 重要性采样：对重要物体使用高质量SSAO\n\n### 5.2 动态质量调整\n```cpp\nclass AdaptiveSSAO {\n    float targetFrameTime = 16.67f; // 60fps\n    int currentSampleCount = 12;\n    \n    void adjustQuality(float frameTime) {\n        if (frameTime > targetFrameTime * 1.1f) {\n            currentSampleCount = max(8, currentSampleCount - 2);\n        } else if (frameTime < targetFrameTime * 0.9f) {\n            currentSampleCount = min(16, currentSampleCount + 1);\n        }\n    }\n};\n```\n\n## 6. 移动端特殊考虑\n\n### 6.1 功耗优化\n- Early-Z优化：利用移动GPU的Early-Z特性\n- Shader分支减少：避免动态分支，使用预编译变体\n\n### 6.2 带宽敏感优化\n- 就地模糊：在同一个Pass中完成AO计算和模糊\n- 单Pass实现：将多个步骤合并到单个着色器\n\n### 6.3 兼容性处理\n```glsl\n#ifdef GL_ES\n    precision mediump float;\n    #define SAMPLE_COUNT 8\n#else\n    #define SAMPLE_COUNT 16\n#endif\n```\n\n## 7. 实现流程\n\n1. G-Buffer Pass：渲染深度和法线\n2. SSAO Pass：在降级分辨率下计算AO\n3. 模糊Pass：边缘保持模糊（可选）\n4. 上采样Pass：恢复到全分辨率\n5. 合成Pass：与最终渲染结果混合\n\n## 8. 性能指标\n\n- 采样点数：8-16个（vs桌面端32-64个）\n- 渲染分辨率：1/2到1/4屏幕分辨率\n- GPU时间：目标控制在1-2ms内\n- 内存占用：额外2-4MB纹理内存\n\n## 9. 总结\n\n移动端SSAO实现需要在视觉效果和性能之间找到平衡点。通过合理的优化策略，包括采样点减少、分辨率降级、自适应质量调整等技术，可以在移动设备上实现可接受的SSAO效果，同时保持稳定的帧率表现。关键是要根据具体项目的性能要求和目标设备来选择合适的优化方案。 ","slug":"mobile-ssao-implementation","published":1,"updated":"2025-06-15T03:40:42.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbx4ojei0001h2j2307y18ps","content":"<h1 id=\"移动端SSAO实现方案分析\"><a href=\"#移动端SSAO实现方案分析\" class=\"headerlink\" title=\"移动端SSAO实现方案分析\"></a>移动端SSAO实现方案分析</h1><h2 id=\"1-核心依赖\"><a href=\"#1-核心依赖\" class=\"headerlink\" title=\"1. 核心依赖\"></a>1. 核心依赖</h2><span id=\"more\"></span>\n\n<h3 id=\"1-1-G-Buffer渲染\"><a href=\"#1-1-G-Buffer渲染\" class=\"headerlink\" title=\"1.1 G-Buffer渲染\"></a>1.1 G-Buffer渲染</h3><ul>\n<li><strong>深度缓冲区（Depth Buffer）</strong>：用于重建世界空间位置</li>\n<li><strong>法线缓冲区（Normal Buffer）</strong>：存储视空间或世界空间法线</li>\n<li><strong>可选的位置缓冲区</strong>：直接存储位置，避免重建计算</li>\n</ul>\n<h3 id=\"1-2-相机参数\"><a href=\"#1-2-相机参数\" class=\"headerlink\" title=\"1.2 相机参数\"></a>1.2 相机参数</h3><ul>\n<li>投影矩阵：屏幕空间到视空间的转换</li>\n<li>视图矩阵：世界空间到视空间转换</li>\n<li>近远平面参数：深度值线性化</li>\n</ul>\n<h2 id=\"2-移动端优化方案\"><a href=\"#2-移动端优化方案\" class=\"headerlink\" title=\"2. 移动端优化方案\"></a>2. 移动端优化方案</h2><h3 id=\"2-1-简化的采样策略\"><a href=\"#2-1-简化的采样策略\" class=\"headerlink\" title=\"2.1 简化的采样策略\"></a>2.1 简化的采样策略</h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 减少采样点数量（桌面端通常64个，移动端8-16个）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"type\">int</span> SAMPLE_COUNT = <span class=\"number\">12</span>;</span><br><span class=\"line\"><span class=\"type\">vec3</span> samples[SAMPLE_COUNT] = &#123;</span><br><span class=\"line\">    <span class=\"type\">vec3</span>(<span class=\"number\">0.04</span>, <span class=\"number\">0.04</span>, <span class=\"number\">0.02</span>),</span><br><span class=\"line\">    <span class=\"type\">vec3</span>(<span class=\"number\">-0.08</span>, <span class=\"number\">0.05</span>, <span class=\"number\">0.03</span>),</span><br><span class=\"line\">    <span class=\"comment\">// ... 更多采样点</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-分辨率降级\"><a href=\"#2-2-分辨率降级\" class=\"headerlink\" title=\"2.2 分辨率降级\"></a>2.2 分辨率降级</h3><ul>\n<li>半分辨率渲染：在屏幕分辨率的1/2进行SSAO计算</li>\n<li>四分之一分辨率：极端性能要求下使用1/4分辨率</li>\n<li>双线性上采样：将低分辨率结果上采样到全分辨率</li>\n</ul>\n<h3 id=\"2-3-深度重建优化\"><a href=\"#2-3-深度重建优化\" class=\"headerlink\" title=\"2.3 深度重建优化\"></a>2.3 深度重建优化</h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec3</span> reconstructViewPos(<span class=\"type\">vec2</span> uv, <span class=\"type\">float</span> depth) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec4</span> clipPos = <span class=\"type\">vec4</span>(uv * <span class=\"number\">2.0</span> - <span class=\"number\">1.0</span>, depth, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    <span class=\"type\">vec4</span> viewPos = u_invProjection * clipPos;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> viewPos.xyz / viewPos.w;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-移动端特定优化\"><a href=\"#3-移动端特定优化\" class=\"headerlink\" title=\"3. 移动端特定优化\"></a>3. 移动端特定优化</h2><h3 id=\"3-1-自适应采样半径\"><a href=\"#3-1-自适应采样半径\" class=\"headerlink\" title=\"3.1 自适应采样半径\"></a>3.1 自适应采样半径</h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> getAdaptiveRadius(<span class=\"type\">float</span> viewDepth) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">mix</span>(minRadius, maxRadius, <span class=\"number\">1.0</span> / (<span class=\"number\">1.0</span> + viewDepth * <span class=\"number\">0.1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-分层SSAO\"><a href=\"#3-2-分层SSAO\" class=\"headerlink\" title=\"3.2 分层SSAO\"></a>3.2 分层SSAO</h3><ul>\n<li>近景高质量：对近距离物体使用更多采样点</li>\n<li>远景简化：远距离物体使用简化算法或跳过处理</li>\n</ul>\n<h3 id=\"3-3-时间分片\"><a href=\"#3-3-时间分片\" class=\"headerlink\" title=\"3.3 时间分片\"></a>3.3 时间分片</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TemporalSSAO</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> currentTile = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> tilesPerFrame = <span class=\"number\">4</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">renderFrame</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">renderSSAOTile</span>(currentTile, tilesPerFrame);</span><br><span class=\"line\">        currentTile = (currentTile + <span class=\"number\">1</span>) % totalTiles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-内存和带宽优化\"><a href=\"#4-内存和带宽优化\" class=\"headerlink\" title=\"4. 内存和带宽优化\"></a>4. 内存和带宽优化</h2><h3 id=\"4-1-纹理格式优化\"><a href=\"#4-1-纹理格式优化\" class=\"headerlink\" title=\"4.1 纹理格式优化\"></a>4.1 纹理格式优化</h3><ul>\n<li>R8格式：AO值只需要单通道</li>\n<li>压缩纹理：使用ETC2/ASTC压缩法线纹理</li>\n<li>打包存储：将多个值打包到单个纹理通道</li>\n</ul>\n<h3 id=\"4-2-渲染目标管理\"><a href=\"#4-2-渲染目标管理\" class=\"headerlink\" title=\"4.2 渲染目标管理\"></a>4.2 渲染目标管理</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RenderTarget ssaoRT = <span class=\"built_in\">createRT</span>(width/<span class=\"number\">2</span>, height/<span class=\"number\">2</span>, R8_UNORM);</span><br><span class=\"line\">RenderTarget blurRT = ssaoRT; <span class=\"comment\">// 乒乓缓冲复用</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-质量与性能平衡\"><a href=\"#5-质量与性能平衡\" class=\"headerlink\" title=\"5. 质量与性能平衡\"></a>5. 质量与性能平衡</h2><h3 id=\"5-1-LOD系统集成\"><a href=\"#5-1-LOD系统集成\" class=\"headerlink\" title=\"5.1 LOD系统集成\"></a>5.1 LOD系统集成</h3><ul>\n<li>距离衰减：根据相机距离调整SSAO强度</li>\n<li>重要性采样：对重要物体使用高质量SSAO</li>\n</ul>\n<h3 id=\"5-2-动态质量调整\"><a href=\"#5-2-动态质量调整\" class=\"headerlink\" title=\"5.2 动态质量调整\"></a>5.2 动态质量调整</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AdaptiveSSAO</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> targetFrameTime = <span class=\"number\">16.67f</span>; <span class=\"comment\">// 60fps</span></span><br><span class=\"line\">    <span class=\"type\">int</span> currentSampleCount = <span class=\"number\">12</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">adjustQuality</span><span class=\"params\">(<span class=\"type\">float</span> frameTime)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (frameTime &gt; targetFrameTime * <span class=\"number\">1.1f</span>) &#123;</span><br><span class=\"line\">            currentSampleCount = <span class=\"built_in\">max</span>(<span class=\"number\">8</span>, currentSampleCount - <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (frameTime &lt; targetFrameTime * <span class=\"number\">0.9f</span>) &#123;</span><br><span class=\"line\">            currentSampleCount = <span class=\"built_in\">min</span>(<span class=\"number\">16</span>, currentSampleCount + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-移动端特殊考虑\"><a href=\"#6-移动端特殊考虑\" class=\"headerlink\" title=\"6. 移动端特殊考虑\"></a>6. 移动端特殊考虑</h2><h3 id=\"6-1-功耗优化\"><a href=\"#6-1-功耗优化\" class=\"headerlink\" title=\"6.1 功耗优化\"></a>6.1 功耗优化</h3><ul>\n<li>Early-Z优化：利用移动GPU的Early-Z特性</li>\n<li>Shader分支减少：避免动态分支，使用预编译变体</li>\n</ul>\n<h3 id=\"6-2-带宽敏感优化\"><a href=\"#6-2-带宽敏感优化\" class=\"headerlink\" title=\"6.2 带宽敏感优化\"></a>6.2 带宽敏感优化</h3><ul>\n<li>就地模糊：在同一个Pass中完成AO计算和模糊</li>\n<li>单Pass实现：将多个步骤合并到单个着色器</li>\n</ul>\n<h3 id=\"6-3-兼容性处理\"><a href=\"#6-3-兼容性处理\" class=\"headerlink\" title=\"6.3 兼容性处理\"></a>6.3 兼容性处理</h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifdef GL_ES</span></span><br><span class=\"line\">    <span class=\"keyword\">precision</span> <span class=\"keyword\">mediump</span> <span class=\"type\">float</span>;</span><br><span class=\"line\">    <span class=\"meta\">#define SAMPLE_COUNT 8</span></span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\">    <span class=\"meta\">#define SAMPLE_COUNT 16</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-实现流程\"><a href=\"#7-实现流程\" class=\"headerlink\" title=\"7. 实现流程\"></a>7. 实现流程</h2><ol>\n<li>G-Buffer Pass：渲染深度和法线</li>\n<li>SSAO Pass：在降级分辨率下计算AO</li>\n<li>模糊Pass：边缘保持模糊（可选）</li>\n<li>上采样Pass：恢复到全分辨率</li>\n<li>合成Pass：与最终渲染结果混合</li>\n</ol>\n<h2 id=\"8-性能指标\"><a href=\"#8-性能指标\" class=\"headerlink\" title=\"8. 性能指标\"></a>8. 性能指标</h2><ul>\n<li>采样点数：8-16个（vs桌面端32-64个）</li>\n<li>渲染分辨率：1/2到1/4屏幕分辨率</li>\n<li>GPU时间：目标控制在1-2ms内</li>\n<li>内存占用：额外2-4MB纹理内存</li>\n</ul>\n<h2 id=\"9-总结\"><a href=\"#9-总结\" class=\"headerlink\" title=\"9. 总结\"></a>9. 总结</h2><p>移动端SSAO实现需要在视觉效果和性能之间找到平衡点。通过合理的优化策略，包括采样点减少、分辨率降级、自适应质量调整等技术，可以在移动设备上实现可接受的SSAO效果，同时保持稳定的帧率表现。关键是要根据具体项目的性能要求和目标设备来选择合适的优化方案。 </p>\n","site":{"data":{}},"excerpt":"<h1 id=\"移动端SSAO实现方案分析\"><a href=\"#移动端SSAO实现方案分析\" class=\"headerlink\" title=\"移动端SSAO实现方案分析\"></a>移动端SSAO实现方案分析</h1><h2 id=\"1-核心依赖\"><a href=\"#1-核心依赖\" class=\"headerlink\" title=\"1. 核心依赖\"></a>1. 核心依赖</h2>","more":"<h3 id=\"1-1-G-Buffer渲染\"><a href=\"#1-1-G-Buffer渲染\" class=\"headerlink\" title=\"1.1 G-Buffer渲染\"></a>1.1 G-Buffer渲染</h3><ul>\n<li><strong>深度缓冲区（Depth Buffer）</strong>：用于重建世界空间位置</li>\n<li><strong>法线缓冲区（Normal Buffer）</strong>：存储视空间或世界空间法线</li>\n<li><strong>可选的位置缓冲区</strong>：直接存储位置，避免重建计算</li>\n</ul>\n<h3 id=\"1-2-相机参数\"><a href=\"#1-2-相机参数\" class=\"headerlink\" title=\"1.2 相机参数\"></a>1.2 相机参数</h3><ul>\n<li>投影矩阵：屏幕空间到视空间的转换</li>\n<li>视图矩阵：世界空间到视空间转换</li>\n<li>近远平面参数：深度值线性化</li>\n</ul>\n<h2 id=\"2-移动端优化方案\"><a href=\"#2-移动端优化方案\" class=\"headerlink\" title=\"2. 移动端优化方案\"></a>2. 移动端优化方案</h2><h3 id=\"2-1-简化的采样策略\"><a href=\"#2-1-简化的采样策略\" class=\"headerlink\" title=\"2.1 简化的采样策略\"></a>2.1 简化的采样策略</h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 减少采样点数量（桌面端通常64个，移动端8-16个）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"type\">int</span> SAMPLE_COUNT = <span class=\"number\">12</span>;</span><br><span class=\"line\"><span class=\"type\">vec3</span> samples[SAMPLE_COUNT] = &#123;</span><br><span class=\"line\">    <span class=\"type\">vec3</span>(<span class=\"number\">0.04</span>, <span class=\"number\">0.04</span>, <span class=\"number\">0.02</span>),</span><br><span class=\"line\">    <span class=\"type\">vec3</span>(<span class=\"number\">-0.08</span>, <span class=\"number\">0.05</span>, <span class=\"number\">0.03</span>),</span><br><span class=\"line\">    <span class=\"comment\">// ... 更多采样点</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-分辨率降级\"><a href=\"#2-2-分辨率降级\" class=\"headerlink\" title=\"2.2 分辨率降级\"></a>2.2 分辨率降级</h3><ul>\n<li>半分辨率渲染：在屏幕分辨率的1/2进行SSAO计算</li>\n<li>四分之一分辨率：极端性能要求下使用1/4分辨率</li>\n<li>双线性上采样：将低分辨率结果上采样到全分辨率</li>\n</ul>\n<h3 id=\"2-3-深度重建优化\"><a href=\"#2-3-深度重建优化\" class=\"headerlink\" title=\"2.3 深度重建优化\"></a>2.3 深度重建优化</h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">vec3</span> reconstructViewPos(<span class=\"type\">vec2</span> uv, <span class=\"type\">float</span> depth) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec4</span> clipPos = <span class=\"type\">vec4</span>(uv * <span class=\"number\">2.0</span> - <span class=\"number\">1.0</span>, depth, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    <span class=\"type\">vec4</span> viewPos = u_invProjection * clipPos;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> viewPos.xyz / viewPos.w;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-移动端特定优化\"><a href=\"#3-移动端特定优化\" class=\"headerlink\" title=\"3. 移动端特定优化\"></a>3. 移动端特定优化</h2><h3 id=\"3-1-自适应采样半径\"><a href=\"#3-1-自适应采样半径\" class=\"headerlink\" title=\"3.1 自适应采样半径\"></a>3.1 自适应采样半径</h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> getAdaptiveRadius(<span class=\"type\">float</span> viewDepth) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">mix</span>(minRadius, maxRadius, <span class=\"number\">1.0</span> / (<span class=\"number\">1.0</span> + viewDepth * <span class=\"number\">0.1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-分层SSAO\"><a href=\"#3-2-分层SSAO\" class=\"headerlink\" title=\"3.2 分层SSAO\"></a>3.2 分层SSAO</h3><ul>\n<li>近景高质量：对近距离物体使用更多采样点</li>\n<li>远景简化：远距离物体使用简化算法或跳过处理</li>\n</ul>\n<h3 id=\"3-3-时间分片\"><a href=\"#3-3-时间分片\" class=\"headerlink\" title=\"3.3 时间分片\"></a>3.3 时间分片</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TemporalSSAO</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> currentTile = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> tilesPerFrame = <span class=\"number\">4</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">renderFrame</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">renderSSAOTile</span>(currentTile, tilesPerFrame);</span><br><span class=\"line\">        currentTile = (currentTile + <span class=\"number\">1</span>) % totalTiles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-内存和带宽优化\"><a href=\"#4-内存和带宽优化\" class=\"headerlink\" title=\"4. 内存和带宽优化\"></a>4. 内存和带宽优化</h2><h3 id=\"4-1-纹理格式优化\"><a href=\"#4-1-纹理格式优化\" class=\"headerlink\" title=\"4.1 纹理格式优化\"></a>4.1 纹理格式优化</h3><ul>\n<li>R8格式：AO值只需要单通道</li>\n<li>压缩纹理：使用ETC2/ASTC压缩法线纹理</li>\n<li>打包存储：将多个值打包到单个纹理通道</li>\n</ul>\n<h3 id=\"4-2-渲染目标管理\"><a href=\"#4-2-渲染目标管理\" class=\"headerlink\" title=\"4.2 渲染目标管理\"></a>4.2 渲染目标管理</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RenderTarget ssaoRT = <span class=\"built_in\">createRT</span>(width/<span class=\"number\">2</span>, height/<span class=\"number\">2</span>, R8_UNORM);</span><br><span class=\"line\">RenderTarget blurRT = ssaoRT; <span class=\"comment\">// 乒乓缓冲复用</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-质量与性能平衡\"><a href=\"#5-质量与性能平衡\" class=\"headerlink\" title=\"5. 质量与性能平衡\"></a>5. 质量与性能平衡</h2><h3 id=\"5-1-LOD系统集成\"><a href=\"#5-1-LOD系统集成\" class=\"headerlink\" title=\"5.1 LOD系统集成\"></a>5.1 LOD系统集成</h3><ul>\n<li>距离衰减：根据相机距离调整SSAO强度</li>\n<li>重要性采样：对重要物体使用高质量SSAO</li>\n</ul>\n<h3 id=\"5-2-动态质量调整\"><a href=\"#5-2-动态质量调整\" class=\"headerlink\" title=\"5.2 动态质量调整\"></a>5.2 动态质量调整</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AdaptiveSSAO</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> targetFrameTime = <span class=\"number\">16.67f</span>; <span class=\"comment\">// 60fps</span></span><br><span class=\"line\">    <span class=\"type\">int</span> currentSampleCount = <span class=\"number\">12</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">adjustQuality</span><span class=\"params\">(<span class=\"type\">float</span> frameTime)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (frameTime &gt; targetFrameTime * <span class=\"number\">1.1f</span>) &#123;</span><br><span class=\"line\">            currentSampleCount = <span class=\"built_in\">max</span>(<span class=\"number\">8</span>, currentSampleCount - <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (frameTime &lt; targetFrameTime * <span class=\"number\">0.9f</span>) &#123;</span><br><span class=\"line\">            currentSampleCount = <span class=\"built_in\">min</span>(<span class=\"number\">16</span>, currentSampleCount + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-移动端特殊考虑\"><a href=\"#6-移动端特殊考虑\" class=\"headerlink\" title=\"6. 移动端特殊考虑\"></a>6. 移动端特殊考虑</h2><h3 id=\"6-1-功耗优化\"><a href=\"#6-1-功耗优化\" class=\"headerlink\" title=\"6.1 功耗优化\"></a>6.1 功耗优化</h3><ul>\n<li>Early-Z优化：利用移动GPU的Early-Z特性</li>\n<li>Shader分支减少：避免动态分支，使用预编译变体</li>\n</ul>\n<h3 id=\"6-2-带宽敏感优化\"><a href=\"#6-2-带宽敏感优化\" class=\"headerlink\" title=\"6.2 带宽敏感优化\"></a>6.2 带宽敏感优化</h3><ul>\n<li>就地模糊：在同一个Pass中完成AO计算和模糊</li>\n<li>单Pass实现：将多个步骤合并到单个着色器</li>\n</ul>\n<h3 id=\"6-3-兼容性处理\"><a href=\"#6-3-兼容性处理\" class=\"headerlink\" title=\"6.3 兼容性处理\"></a>6.3 兼容性处理</h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#ifdef GL_ES</span></span><br><span class=\"line\">    <span class=\"keyword\">precision</span> <span class=\"keyword\">mediump</span> <span class=\"type\">float</span>;</span><br><span class=\"line\">    <span class=\"meta\">#define SAMPLE_COUNT 8</span></span><br><span class=\"line\"><span class=\"meta\">#else</span></span><br><span class=\"line\">    <span class=\"meta\">#define SAMPLE_COUNT 16</span></span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-实现流程\"><a href=\"#7-实现流程\" class=\"headerlink\" title=\"7. 实现流程\"></a>7. 实现流程</h2><ol>\n<li>G-Buffer Pass：渲染深度和法线</li>\n<li>SSAO Pass：在降级分辨率下计算AO</li>\n<li>模糊Pass：边缘保持模糊（可选）</li>\n<li>上采样Pass：恢复到全分辨率</li>\n<li>合成Pass：与最终渲染结果混合</li>\n</ol>\n<h2 id=\"8-性能指标\"><a href=\"#8-性能指标\" class=\"headerlink\" title=\"8. 性能指标\"></a>8. 性能指标</h2><ul>\n<li>采样点数：8-16个（vs桌面端32-64个）</li>\n<li>渲染分辨率：1/2到1/4屏幕分辨率</li>\n<li>GPU时间：目标控制在1-2ms内</li>\n<li>内存占用：额外2-4MB纹理内存</li>\n</ul>\n<h2 id=\"9-总结\"><a href=\"#9-总结\" class=\"headerlink\" title=\"9. 总结\"></a>9. 总结</h2><p>移动端SSAO实现需要在视觉效果和性能之间找到平衡点。通过合理的优化策略，包括采样点减少、分辨率降级、自适应质量调整等技术，可以在移动设备上实现可接受的SSAO效果，同时保持稳定的帧率表现。关键是要根据具体项目的性能要求和目标设备来选择合适的优化方案。 </p>"},{"title":"Android动态库加载-dlopen与System.loadLibrary对比","date":"2024-06-12T15:00:00.000Z","_content":"\n### 前言\n\n在Android开发中，我们经常需要加载本地动态库（.so文件）来实现一些底层功能。Android提供了两种主要的动态库加载方式：`dlopen`和`System.loadLibrary`。本文将详细对比这两种方式的区别，并分析`System.loadLibrary`可能失败的原因。\n\n### dlopen vs System.loadLibrary\n\n#### 1. dlopen方式\n\n```cpp\n#include <dlfcn.h>\n\n// 定义函数指针类型\ntypedef int (*AddFunc)(int a, int b);\ntypedef void (*PrintFunc)(const char* message);\n\nvoid* handle = dlopen(\"libexample.so\", RTLD_NOW);\nif (handle == NULL) {\n    char* error = dlerror();\n    // 处理错误\n    return;\n}\n\n// 获取函数指针\nAddFunc add = (AddFunc)dlsym(handle, \"add\");\nPrintFunc print = (PrintFunc)dlsym(handle, \"print\");\n\nif (add == NULL || print == NULL) {\n    char* error = dlerror();\n    // 处理错误\n    dlclose(handle);\n    return;\n}\n\n// 调用函数\nint result = add(1, 2);\nprint(\"Hello from dynamic library!\");\n\n// 使用完毕后关闭库\ndlclose(handle);\n```\n\n对应的动态库头文件示例：\n```cpp\n// example.h\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint add(int a, int b);\nvoid print(const char* message);\n\n#ifdef __cplusplus\n}\n#endif\n```\n\n动态库实现示例：\n```cpp\n// example.cpp\n#include \"example.h\"\n#include <stdio.h>\n\nint add(int a, int b) {\n    return a + b;\n}\n\nvoid print(const char* message) {\n    printf(\"%s\\n\", message);\n}\n```\n\n特点：\n- 直接调用系统API\n- 可以指定库的完整路径\n- 需要手动管理库的生命周期\n- 可以动态加载和卸载\n- 可以获取加载失败的具体原因\n- 可以动态获取和调用库中的函数\n- 支持运行时加载不同版本的库\n- 可以实现插件化架构\n\n注意事项：\n1. 函数指针类型定义要与库中函数签名完全匹配\n2. 使用`extern \"C\"`防止C++名称修饰\n3. 记得检查函数指针是否为NULL\n4. 使用完毕后要调用`dlclose`释放资源\n5. 错误处理要使用`dlerror`获取详细信息\n\n#### 2. System.loadLibrary方式\n\n```java\ntry {\n    System.loadLibrary(\"example\");\n} catch (UnsatisfiedLinkError e) {\n    // 处理错误\n}\n```\n\n特点：\n- Java层API，使用更简单\n- 自动管理库的生命周期\n- 只能加载应用lib目录下的库\n- 错误信息相对简单\n\n### System.loadLibrary失败原因分析\n\n即使APK中存在.so文件，`System.loadLibrary`仍然可能失败，主要原因包括：\n\n#### 1. 架构不匹配\n\n```java\n// 检查当前设备支持的架构\nString[] supportedABIs = Build.SUPPORTED_ABIS;\n```\n\n可能的原因：\n- 库文件与设备CPU架构不匹配\n- 库文件缺少目标架构的支持\n- 库文件被错误打包到错误的目录\n\n#### 2. 依赖库缺失\n\n```bash\n# 使用readelf查看库的依赖\nreadelf -d libexample.so\n```\n\n常见问题：\n- 依赖的其他.so文件不存在\n- 依赖的系统库版本不兼容\n- 依赖库的路径问题\n\n#### 3. 权限问题\n\n```xml\n<!-- AndroidManifest.xml -->\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n```\n\n可能的原因：\n- 应用没有读取权限\n- 文件系统权限设置不正确\n- SELinux策略限制\n\n#### 4. 库文件损坏\n\n```java\n// 检查文件完整性\nFile libFile = new File(getApplicationInfo().nativeLibraryDir + \"/libexample.so\");\nif (!libFile.exists() || libFile.length() == 0) {\n    // 文件不存在或为空\n}\n```\n\n可能的原因：\n- 文件下载不完整\n- 文件被损坏\n- 文件格式错误\n\n#### 5. 内存问题\n\n```java\n// 检查内存状态\nRuntime runtime = Runtime.getRuntime();\nlong maxMemory = runtime.maxMemory();\nlong usedMemory = runtime.totalMemory() - runtime.freeMemory();\n```\n\n可能的原因：\n- 内存不足\n- 内存碎片化\n- 内存限制\n\n### 调试技巧\n\n#### 1. 使用dlopen调试\n\n```cpp\nvoid* handle = dlopen(\"libexample.so\", RTLD_NOW);\nif (handle == NULL) {\n    char* error = dlerror();\n    __android_log_print(ANDROID_LOG_ERROR, \"NativeLib\", \"dlopen failed: %s\", error);\n}\n```\n\n#### 2. 检查库文件信息\n\n```bash\n# 查看库文件信息\nfile libexample.so\n# 查看库文件依赖\nldd libexample.so\n# 查看库文件符号\nnm libexample.so\n```\n\n#### 3. 日志分析\n\n```java\n// 开启详细日志\nSystem.setProperty(\"java.library.path\", \"/data/app/.../lib/arm64\");\nSystem.loadLibrary(\"example\");\n```\n\n### 最佳实践\n\n1. **架构支持**\n```gradle\nandroid {\n    defaultConfig {\n        ndk {\n            abiFilters 'armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64'\n        }\n    }\n}\n```\n\n2. **错误处理**\n```java\ntry {\n    System.loadLibrary(\"example\");\n} catch (UnsatisfiedLinkError e) {\n    Log.e(\"NativeLib\", \"Failed to load library: \" + e.getMessage());\n    // 尝试使用备用方案\n    try {\n        System.load(\"/data/data/com.example.app/lib/libexample.so\");\n    } catch (UnsatisfiedLinkError e2) {\n        // 处理错误\n    }\n}\n```\n\n3. **版本兼容**\n```java\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n    // 使用新版本API\n} else {\n    // 使用兼容方案\n}\n```\n\n### 总结\n\n1. `dlopen`和`System.loadLibrary`各有优势，选择合适的方式取决于具体需求\n2. `System.loadLibrary`失败的原因多种多样，需要系统性地排查\n3. 良好的错误处理和日志记录对调试至关重要\n4. 遵循最佳实践可以避免大多数常见问题\n\n### 参考资源\n\n- [Android NDK文档](https://developer.android.com/ndk/guides)\n- [JNI规范](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/)\n- [Android动态库加载机制](https://source.android.com/devices/architecture/vndk) ","source":"_posts/Android动态库加载-dlopen与System.loadLibrary对比.md","raw":"---\ntitle: Android动态库加载-dlopen与System.loadLibrary对比\ndate: 2024-06-12 23:00:00\ntags:\n    - Android\n    - JNI\n    - 动态库\n---\n\n### 前言\n\n在Android开发中，我们经常需要加载本地动态库（.so文件）来实现一些底层功能。Android提供了两种主要的动态库加载方式：`dlopen`和`System.loadLibrary`。本文将详细对比这两种方式的区别，并分析`System.loadLibrary`可能失败的原因。\n\n### dlopen vs System.loadLibrary\n\n#### 1. dlopen方式\n\n```cpp\n#include <dlfcn.h>\n\n// 定义函数指针类型\ntypedef int (*AddFunc)(int a, int b);\ntypedef void (*PrintFunc)(const char* message);\n\nvoid* handle = dlopen(\"libexample.so\", RTLD_NOW);\nif (handle == NULL) {\n    char* error = dlerror();\n    // 处理错误\n    return;\n}\n\n// 获取函数指针\nAddFunc add = (AddFunc)dlsym(handle, \"add\");\nPrintFunc print = (PrintFunc)dlsym(handle, \"print\");\n\nif (add == NULL || print == NULL) {\n    char* error = dlerror();\n    // 处理错误\n    dlclose(handle);\n    return;\n}\n\n// 调用函数\nint result = add(1, 2);\nprint(\"Hello from dynamic library!\");\n\n// 使用完毕后关闭库\ndlclose(handle);\n```\n\n对应的动态库头文件示例：\n```cpp\n// example.h\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint add(int a, int b);\nvoid print(const char* message);\n\n#ifdef __cplusplus\n}\n#endif\n```\n\n动态库实现示例：\n```cpp\n// example.cpp\n#include \"example.h\"\n#include <stdio.h>\n\nint add(int a, int b) {\n    return a + b;\n}\n\nvoid print(const char* message) {\n    printf(\"%s\\n\", message);\n}\n```\n\n特点：\n- 直接调用系统API\n- 可以指定库的完整路径\n- 需要手动管理库的生命周期\n- 可以动态加载和卸载\n- 可以获取加载失败的具体原因\n- 可以动态获取和调用库中的函数\n- 支持运行时加载不同版本的库\n- 可以实现插件化架构\n\n注意事项：\n1. 函数指针类型定义要与库中函数签名完全匹配\n2. 使用`extern \"C\"`防止C++名称修饰\n3. 记得检查函数指针是否为NULL\n4. 使用完毕后要调用`dlclose`释放资源\n5. 错误处理要使用`dlerror`获取详细信息\n\n#### 2. System.loadLibrary方式\n\n```java\ntry {\n    System.loadLibrary(\"example\");\n} catch (UnsatisfiedLinkError e) {\n    // 处理错误\n}\n```\n\n特点：\n- Java层API，使用更简单\n- 自动管理库的生命周期\n- 只能加载应用lib目录下的库\n- 错误信息相对简单\n\n### System.loadLibrary失败原因分析\n\n即使APK中存在.so文件，`System.loadLibrary`仍然可能失败，主要原因包括：\n\n#### 1. 架构不匹配\n\n```java\n// 检查当前设备支持的架构\nString[] supportedABIs = Build.SUPPORTED_ABIS;\n```\n\n可能的原因：\n- 库文件与设备CPU架构不匹配\n- 库文件缺少目标架构的支持\n- 库文件被错误打包到错误的目录\n\n#### 2. 依赖库缺失\n\n```bash\n# 使用readelf查看库的依赖\nreadelf -d libexample.so\n```\n\n常见问题：\n- 依赖的其他.so文件不存在\n- 依赖的系统库版本不兼容\n- 依赖库的路径问题\n\n#### 3. 权限问题\n\n```xml\n<!-- AndroidManifest.xml -->\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n```\n\n可能的原因：\n- 应用没有读取权限\n- 文件系统权限设置不正确\n- SELinux策略限制\n\n#### 4. 库文件损坏\n\n```java\n// 检查文件完整性\nFile libFile = new File(getApplicationInfo().nativeLibraryDir + \"/libexample.so\");\nif (!libFile.exists() || libFile.length() == 0) {\n    // 文件不存在或为空\n}\n```\n\n可能的原因：\n- 文件下载不完整\n- 文件被损坏\n- 文件格式错误\n\n#### 5. 内存问题\n\n```java\n// 检查内存状态\nRuntime runtime = Runtime.getRuntime();\nlong maxMemory = runtime.maxMemory();\nlong usedMemory = runtime.totalMemory() - runtime.freeMemory();\n```\n\n可能的原因：\n- 内存不足\n- 内存碎片化\n- 内存限制\n\n### 调试技巧\n\n#### 1. 使用dlopen调试\n\n```cpp\nvoid* handle = dlopen(\"libexample.so\", RTLD_NOW);\nif (handle == NULL) {\n    char* error = dlerror();\n    __android_log_print(ANDROID_LOG_ERROR, \"NativeLib\", \"dlopen failed: %s\", error);\n}\n```\n\n#### 2. 检查库文件信息\n\n```bash\n# 查看库文件信息\nfile libexample.so\n# 查看库文件依赖\nldd libexample.so\n# 查看库文件符号\nnm libexample.so\n```\n\n#### 3. 日志分析\n\n```java\n// 开启详细日志\nSystem.setProperty(\"java.library.path\", \"/data/app/.../lib/arm64\");\nSystem.loadLibrary(\"example\");\n```\n\n### 最佳实践\n\n1. **架构支持**\n```gradle\nandroid {\n    defaultConfig {\n        ndk {\n            abiFilters 'armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64'\n        }\n    }\n}\n```\n\n2. **错误处理**\n```java\ntry {\n    System.loadLibrary(\"example\");\n} catch (UnsatisfiedLinkError e) {\n    Log.e(\"NativeLib\", \"Failed to load library: \" + e.getMessage());\n    // 尝试使用备用方案\n    try {\n        System.load(\"/data/data/com.example.app/lib/libexample.so\");\n    } catch (UnsatisfiedLinkError e2) {\n        // 处理错误\n    }\n}\n```\n\n3. **版本兼容**\n```java\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n    // 使用新版本API\n} else {\n    // 使用兼容方案\n}\n```\n\n### 总结\n\n1. `dlopen`和`System.loadLibrary`各有优势，选择合适的方式取决于具体需求\n2. `System.loadLibrary`失败的原因多种多样，需要系统性地排查\n3. 良好的错误处理和日志记录对调试至关重要\n4. 遵循最佳实践可以避免大多数常见问题\n\n### 参考资源\n\n- [Android NDK文档](https://developer.android.com/ndk/guides)\n- [JNI规范](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/)\n- [Android动态库加载机制](https://source.android.com/devices/architecture/vndk) ","slug":"Android动态库加载-dlopen与System.loadLibrary对比","published":1,"updated":"2025-06-13T03:45:51.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmc9xgo8p00005tco0slledk0","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在Android开发中，我们经常需要加载本地动态库（.so文件）来实现一些底层功能。Android提供了两种主要的动态库加载方式：<code>dlopen</code>和<code>System.loadLibrary</code>。本文将详细对比这两种方式的区别，并分析<code>System.loadLibrary</code>可能失败的原因。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"dlopen-vs-System-loadLibrary\"><a href=\"#dlopen-vs-System-loadLibrary\" class=\"headerlink\" title=\"dlopen vs System.loadLibrary\"></a>dlopen vs System.loadLibrary</h3><h4 id=\"1-dlopen方式\"><a href=\"#1-dlopen方式\" class=\"headerlink\" title=\"1. dlopen方式\"></a>1. dlopen方式</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;dlfcn.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义函数指针类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*AddFunc)</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*PrintFunc)</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* message)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span>* handle = <span class=\"built_in\">dlopen</span>(<span class=\"string\">&quot;libexample.so&quot;</span>, RTLD_NOW);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (handle == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = <span class=\"built_in\">dlerror</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 处理错误</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取函数指针</span></span><br><span class=\"line\">AddFunc add = (AddFunc)<span class=\"built_in\">dlsym</span>(handle, <span class=\"string\">&quot;add&quot;</span>);</span><br><span class=\"line\">PrintFunc print = (PrintFunc)<span class=\"built_in\">dlsym</span>(handle, <span class=\"string\">&quot;print&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (add == <span class=\"literal\">NULL</span> || print == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = <span class=\"built_in\">dlerror</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 处理错误</span></span><br><span class=\"line\">    <span class=\"built_in\">dlclose</span>(handle);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用函数</span></span><br><span class=\"line\"><span class=\"type\">int</span> result = <span class=\"built_in\">add</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello from dynamic library!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用完毕后关闭库</span></span><br><span class=\"line\"><span class=\"built_in\">dlclose</span>(handle);</span><br></pre></td></tr></table></figure>\n\n<p>对应的动态库头文件示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// example.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* message)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>动态库实现示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// example.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;example.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>特点：</p>\n<ul>\n<li>直接调用系统API</li>\n<li>可以指定库的完整路径</li>\n<li>需要手动管理库的生命周期</li>\n<li>可以动态加载和卸载</li>\n<li>可以获取加载失败的具体原因</li>\n<li>可以动态获取和调用库中的函数</li>\n<li>支持运行时加载不同版本的库</li>\n<li>可以实现插件化架构</li>\n</ul>\n<p>注意事项：</p>\n<ol>\n<li>函数指针类型定义要与库中函数签名完全匹配</li>\n<li>使用<code>extern &quot;C&quot;</code>防止C++名称修饰</li>\n<li>记得检查函数指针是否为NULL</li>\n<li>使用完毕后要调用<code>dlclose</code>释放资源</li>\n<li>错误处理要使用<code>dlerror</code>获取详细信息</li>\n</ol>\n<h4 id=\"2-System-loadLibrary方式\"><a href=\"#2-System-loadLibrary方式\" class=\"headerlink\" title=\"2. System.loadLibrary方式\"></a>2. System.loadLibrary方式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    System.loadLibrary(<span class=\"string\">&quot;example&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (UnsatisfiedLinkError e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>特点：</p>\n<ul>\n<li>Java层API，使用更简单</li>\n<li>自动管理库的生命周期</li>\n<li>只能加载应用lib目录下的库</li>\n<li>错误信息相对简单</li>\n</ul>\n<h3 id=\"System-loadLibrary失败原因分析\"><a href=\"#System-loadLibrary失败原因分析\" class=\"headerlink\" title=\"System.loadLibrary失败原因分析\"></a>System.loadLibrary失败原因分析</h3><p>即使APK中存在.so文件，<code>System.loadLibrary</code>仍然可能失败，主要原因包括：</p>\n<h4 id=\"1-架构不匹配\"><a href=\"#1-架构不匹配\" class=\"headerlink\" title=\"1. 架构不匹配\"></a>1. 架构不匹配</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查当前设备支持的架构</span></span><br><span class=\"line\">String[] supportedABIs = Build.SUPPORTED_ABIS;</span><br></pre></td></tr></table></figure>\n\n<p>可能的原因：</p>\n<ul>\n<li>库文件与设备CPU架构不匹配</li>\n<li>库文件缺少目标架构的支持</li>\n<li>库文件被错误打包到错误的目录</li>\n</ul>\n<h4 id=\"2-依赖库缺失\"><a href=\"#2-依赖库缺失\" class=\"headerlink\" title=\"2. 依赖库缺失\"></a>2. 依赖库缺失</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用readelf查看库的依赖</span></span><br><span class=\"line\">readelf -d libexample.so</span><br></pre></td></tr></table></figure>\n\n<p>常见问题：</p>\n<ul>\n<li>依赖的其他.so文件不存在</li>\n<li>依赖的系统库版本不兼容</li>\n<li>依赖库的路径问题</li>\n</ul>\n<h4 id=\"3-权限问题\"><a href=\"#3-权限问题\" class=\"headerlink\" title=\"3. 权限问题\"></a>3. 权限问题</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- AndroidManifest.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可能的原因：</p>\n<ul>\n<li>应用没有读取权限</li>\n<li>文件系统权限设置不正确</li>\n<li>SELinux策略限制</li>\n</ul>\n<h4 id=\"4-库文件损坏\"><a href=\"#4-库文件损坏\" class=\"headerlink\" title=\"4. 库文件损坏\"></a>4. 库文件损坏</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查文件完整性</span></span><br><span class=\"line\"><span class=\"type\">File</span> <span class=\"variable\">libFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(getApplicationInfo().nativeLibraryDir + <span class=\"string\">&quot;/libexample.so&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!libFile.exists() || libFile.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 文件不存在或为空</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可能的原因：</p>\n<ul>\n<li>文件下载不完整</li>\n<li>文件被损坏</li>\n<li>文件格式错误</li>\n</ul>\n<h4 id=\"5-内存问题\"><a href=\"#5-内存问题\" class=\"headerlink\" title=\"5. 内存问题\"></a>5. 内存问题</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查内存状态</span></span><br><span class=\"line\"><span class=\"type\">Runtime</span> <span class=\"variable\">runtime</span> <span class=\"operator\">=</span> Runtime.getRuntime();</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">maxMemory</span> <span class=\"operator\">=</span> runtime.maxMemory();</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">usedMemory</span> <span class=\"operator\">=</span> runtime.totalMemory() - runtime.freeMemory();</span><br></pre></td></tr></table></figure>\n\n<p>可能的原因：</p>\n<ul>\n<li>内存不足</li>\n<li>内存碎片化</li>\n<li>内存限制</li>\n</ul>\n<h3 id=\"调试技巧\"><a href=\"#调试技巧\" class=\"headerlink\" title=\"调试技巧\"></a>调试技巧</h3><h4 id=\"1-使用dlopen调试\"><a href=\"#1-使用dlopen调试\" class=\"headerlink\" title=\"1. 使用dlopen调试\"></a>1. 使用dlopen调试</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>* handle = <span class=\"built_in\">dlopen</span>(<span class=\"string\">&quot;libexample.so&quot;</span>, RTLD_NOW);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (handle == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = <span class=\"built_in\">dlerror</span>();</span><br><span class=\"line\">    __android_log_print(ANDROID_LOG_ERROR, <span class=\"string\">&quot;NativeLib&quot;</span>, <span class=\"string\">&quot;dlopen failed: %s&quot;</span>, error);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-检查库文件信息\"><a href=\"#2-检查库文件信息\" class=\"headerlink\" title=\"2. 检查库文件信息\"></a>2. 检查库文件信息</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看库文件信息</span></span><br><span class=\"line\">file libexample.so</span><br><span class=\"line\"><span class=\"comment\"># 查看库文件依赖</span></span><br><span class=\"line\">ldd libexample.so</span><br><span class=\"line\"><span class=\"comment\"># 查看库文件符号</span></span><br><span class=\"line\">nm libexample.so</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-日志分析\"><a href=\"#3-日志分析\" class=\"headerlink\" title=\"3. 日志分析\"></a>3. 日志分析</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开启详细日志</span></span><br><span class=\"line\">System.setProperty(<span class=\"string\">&quot;java.library.path&quot;</span>, <span class=\"string\">&quot;/data/app/.../lib/arm64&quot;</span>);</span><br><span class=\"line\">System.loadLibrary(<span class=\"string\">&quot;example&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><ol>\n<li><p><strong>架构支持</strong></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        ndk &#123;</span><br><span class=\"line\">            abiFilters <span class=\"string\">&#x27;armeabi-v7a&#x27;</span>, <span class=\"string\">&#x27;arm64-v8a&#x27;</span>, <span class=\"string\">&#x27;x86&#x27;</span>, <span class=\"string\">&#x27;x86_64&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>错误处理</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    System.loadLibrary(<span class=\"string\">&quot;example&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (UnsatisfiedLinkError e) &#123;</span><br><span class=\"line\">    Log.e(<span class=\"string\">&quot;NativeLib&quot;</span>, <span class=\"string\">&quot;Failed to load library: &quot;</span> + e.getMessage());</span><br><span class=\"line\">    <span class=\"comment\">// 尝试使用备用方案</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.load(<span class=\"string\">&quot;/data/data/com.example.app/lib/libexample.so&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsatisfiedLinkError e2) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理错误</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>版本兼容</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用新版本API</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用兼容方案</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><code>dlopen</code>和<code>System.loadLibrary</code>各有优势，选择合适的方式取决于具体需求</li>\n<li><code>System.loadLibrary</code>失败的原因多种多样，需要系统性地排查</li>\n<li>良好的错误处理和日志记录对调试至关重要</li>\n<li>遵循最佳实践可以避免大多数常见问题</li>\n</ol>\n<h3 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h3><ul>\n<li><a href=\"https://developer.android.com/ndk/guides\">Android NDK文档</a></li>\n<li><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/jni/\">JNI规范</a></li>\n<li><a href=\"https://source.android.com/devices/architecture/vndk\">Android动态库加载机制</a> </li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在Android开发中，我们经常需要加载本地动态库（.so文件）来实现一些底层功能。Android提供了两种主要的动态库加载方式：<code>dlopen</code>和<code>System.loadLibrary</code>。本文将详细对比这两种方式的区别，并分析<code>System.loadLibrary</code>可能失败的原因。</p>","more":"<h3 id=\"dlopen-vs-System-loadLibrary\"><a href=\"#dlopen-vs-System-loadLibrary\" class=\"headerlink\" title=\"dlopen vs System.loadLibrary\"></a>dlopen vs System.loadLibrary</h3><h4 id=\"1-dlopen方式\"><a href=\"#1-dlopen方式\" class=\"headerlink\" title=\"1. dlopen方式\"></a>1. dlopen方式</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;dlfcn.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义函数指针类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*AddFunc)</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*PrintFunc)</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* message)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span>* handle = <span class=\"built_in\">dlopen</span>(<span class=\"string\">&quot;libexample.so&quot;</span>, RTLD_NOW);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (handle == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = <span class=\"built_in\">dlerror</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 处理错误</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取函数指针</span></span><br><span class=\"line\">AddFunc add = (AddFunc)<span class=\"built_in\">dlsym</span>(handle, <span class=\"string\">&quot;add&quot;</span>);</span><br><span class=\"line\">PrintFunc print = (PrintFunc)<span class=\"built_in\">dlsym</span>(handle, <span class=\"string\">&quot;print&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (add == <span class=\"literal\">NULL</span> || print == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = <span class=\"built_in\">dlerror</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 处理错误</span></span><br><span class=\"line\">    <span class=\"built_in\">dlclose</span>(handle);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用函数</span></span><br><span class=\"line\"><span class=\"type\">int</span> result = <span class=\"built_in\">add</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello from dynamic library!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用完毕后关闭库</span></span><br><span class=\"line\"><span class=\"built_in\">dlclose</span>(handle);</span><br></pre></td></tr></table></figure>\n\n<p>对应的动态库头文件示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// example.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* message)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>动态库实现示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// example.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;example.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>特点：</p>\n<ul>\n<li>直接调用系统API</li>\n<li>可以指定库的完整路径</li>\n<li>需要手动管理库的生命周期</li>\n<li>可以动态加载和卸载</li>\n<li>可以获取加载失败的具体原因</li>\n<li>可以动态获取和调用库中的函数</li>\n<li>支持运行时加载不同版本的库</li>\n<li>可以实现插件化架构</li>\n</ul>\n<p>注意事项：</p>\n<ol>\n<li>函数指针类型定义要与库中函数签名完全匹配</li>\n<li>使用<code>extern &quot;C&quot;</code>防止C++名称修饰</li>\n<li>记得检查函数指针是否为NULL</li>\n<li>使用完毕后要调用<code>dlclose</code>释放资源</li>\n<li>错误处理要使用<code>dlerror</code>获取详细信息</li>\n</ol>\n<h4 id=\"2-System-loadLibrary方式\"><a href=\"#2-System-loadLibrary方式\" class=\"headerlink\" title=\"2. System.loadLibrary方式\"></a>2. System.loadLibrary方式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    System.loadLibrary(<span class=\"string\">&quot;example&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (UnsatisfiedLinkError e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>特点：</p>\n<ul>\n<li>Java层API，使用更简单</li>\n<li>自动管理库的生命周期</li>\n<li>只能加载应用lib目录下的库</li>\n<li>错误信息相对简单</li>\n</ul>\n<h3 id=\"System-loadLibrary失败原因分析\"><a href=\"#System-loadLibrary失败原因分析\" class=\"headerlink\" title=\"System.loadLibrary失败原因分析\"></a>System.loadLibrary失败原因分析</h3><p>即使APK中存在.so文件，<code>System.loadLibrary</code>仍然可能失败，主要原因包括：</p>\n<h4 id=\"1-架构不匹配\"><a href=\"#1-架构不匹配\" class=\"headerlink\" title=\"1. 架构不匹配\"></a>1. 架构不匹配</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查当前设备支持的架构</span></span><br><span class=\"line\">String[] supportedABIs = Build.SUPPORTED_ABIS;</span><br></pre></td></tr></table></figure>\n\n<p>可能的原因：</p>\n<ul>\n<li>库文件与设备CPU架构不匹配</li>\n<li>库文件缺少目标架构的支持</li>\n<li>库文件被错误打包到错误的目录</li>\n</ul>\n<h4 id=\"2-依赖库缺失\"><a href=\"#2-依赖库缺失\" class=\"headerlink\" title=\"2. 依赖库缺失\"></a>2. 依赖库缺失</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用readelf查看库的依赖</span></span><br><span class=\"line\">readelf -d libexample.so</span><br></pre></td></tr></table></figure>\n\n<p>常见问题：</p>\n<ul>\n<li>依赖的其他.so文件不存在</li>\n<li>依赖的系统库版本不兼容</li>\n<li>依赖库的路径问题</li>\n</ul>\n<h4 id=\"3-权限问题\"><a href=\"#3-权限问题\" class=\"headerlink\" title=\"3. 权限问题\"></a>3. 权限问题</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- AndroidManifest.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可能的原因：</p>\n<ul>\n<li>应用没有读取权限</li>\n<li>文件系统权限设置不正确</li>\n<li>SELinux策略限制</li>\n</ul>\n<h4 id=\"4-库文件损坏\"><a href=\"#4-库文件损坏\" class=\"headerlink\" title=\"4. 库文件损坏\"></a>4. 库文件损坏</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查文件完整性</span></span><br><span class=\"line\"><span class=\"type\">File</span> <span class=\"variable\">libFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(getApplicationInfo().nativeLibraryDir + <span class=\"string\">&quot;/libexample.so&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!libFile.exists() || libFile.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 文件不存在或为空</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可能的原因：</p>\n<ul>\n<li>文件下载不完整</li>\n<li>文件被损坏</li>\n<li>文件格式错误</li>\n</ul>\n<h4 id=\"5-内存问题\"><a href=\"#5-内存问题\" class=\"headerlink\" title=\"5. 内存问题\"></a>5. 内存问题</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查内存状态</span></span><br><span class=\"line\"><span class=\"type\">Runtime</span> <span class=\"variable\">runtime</span> <span class=\"operator\">=</span> Runtime.getRuntime();</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">maxMemory</span> <span class=\"operator\">=</span> runtime.maxMemory();</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">usedMemory</span> <span class=\"operator\">=</span> runtime.totalMemory() - runtime.freeMemory();</span><br></pre></td></tr></table></figure>\n\n<p>可能的原因：</p>\n<ul>\n<li>内存不足</li>\n<li>内存碎片化</li>\n<li>内存限制</li>\n</ul>\n<h3 id=\"调试技巧\"><a href=\"#调试技巧\" class=\"headerlink\" title=\"调试技巧\"></a>调试技巧</h3><h4 id=\"1-使用dlopen调试\"><a href=\"#1-使用dlopen调试\" class=\"headerlink\" title=\"1. 使用dlopen调试\"></a>1. 使用dlopen调试</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>* handle = <span class=\"built_in\">dlopen</span>(<span class=\"string\">&quot;libexample.so&quot;</span>, RTLD_NOW);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (handle == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* error = <span class=\"built_in\">dlerror</span>();</span><br><span class=\"line\">    __android_log_print(ANDROID_LOG_ERROR, <span class=\"string\">&quot;NativeLib&quot;</span>, <span class=\"string\">&quot;dlopen failed: %s&quot;</span>, error);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-检查库文件信息\"><a href=\"#2-检查库文件信息\" class=\"headerlink\" title=\"2. 检查库文件信息\"></a>2. 检查库文件信息</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看库文件信息</span></span><br><span class=\"line\">file libexample.so</span><br><span class=\"line\"><span class=\"comment\"># 查看库文件依赖</span></span><br><span class=\"line\">ldd libexample.so</span><br><span class=\"line\"><span class=\"comment\"># 查看库文件符号</span></span><br><span class=\"line\">nm libexample.so</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-日志分析\"><a href=\"#3-日志分析\" class=\"headerlink\" title=\"3. 日志分析\"></a>3. 日志分析</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开启详细日志</span></span><br><span class=\"line\">System.setProperty(<span class=\"string\">&quot;java.library.path&quot;</span>, <span class=\"string\">&quot;/data/app/.../lib/arm64&quot;</span>);</span><br><span class=\"line\">System.loadLibrary(<span class=\"string\">&quot;example&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><ol>\n<li><p><strong>架构支持</strong></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        ndk &#123;</span><br><span class=\"line\">            abiFilters <span class=\"string\">&#x27;armeabi-v7a&#x27;</span>, <span class=\"string\">&#x27;arm64-v8a&#x27;</span>, <span class=\"string\">&#x27;x86&#x27;</span>, <span class=\"string\">&#x27;x86_64&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>错误处理</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    System.loadLibrary(<span class=\"string\">&quot;example&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (UnsatisfiedLinkError e) &#123;</span><br><span class=\"line\">    Log.e(<span class=\"string\">&quot;NativeLib&quot;</span>, <span class=\"string\">&quot;Failed to load library: &quot;</span> + e.getMessage());</span><br><span class=\"line\">    <span class=\"comment\">// 尝试使用备用方案</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.load(<span class=\"string\">&quot;/data/data/com.example.app/lib/libexample.so&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsatisfiedLinkError e2) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理错误</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>版本兼容</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用新版本API</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用兼容方案</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><code>dlopen</code>和<code>System.loadLibrary</code>各有优势，选择合适的方式取决于具体需求</li>\n<li><code>System.loadLibrary</code>失败的原因多种多样，需要系统性地排查</li>\n<li>良好的错误处理和日志记录对调试至关重要</li>\n<li>遵循最佳实践可以避免大多数常见问题</li>\n</ol>\n<h3 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h3><ul>\n<li><a href=\"https://developer.android.com/ndk/guides\">Android NDK文档</a></li>\n<li><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/jni/\">JNI规范</a></li>\n<li><a href=\"https://source.android.com/devices/architecture/vndk\">Android动态库加载机制</a> </li>\n</ul>"},{"title":"GLSL中的smoothstep函数详解","date":"2025-06-24T12:00:00.000Z","_content":"\n### 前言\n\n在GLSL(OpenGL Shading Language)编程中，`smoothstep`函数是一个非常有用且常用的内置函数。它能够在两个值之间创建平滑的插值，广泛应用于边缘软化、渐变效果、动画过渡等场景。本文将深入介绍smoothstep函数的用法、数学原理和实际应用。\n\n### smoothstep函数基础\n\n#### 函数签名\n\n```glsl\n// 基本形式\nfloat smoothstep(float edge0, float edge1, float x)\nvec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x)\nvec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x)\nvec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x)\n\n// 混合形式\nvec2 smoothstep(float edge0, float edge1, vec2 x)\nvec3 smoothstep(float edge0, float edge1, vec3 x)\nvec4 smoothstep(float edge0, float edge1, vec4 x)\n```\n\n#### 参数说明\n\n- `edge0`: 下边界值，当x <= edge0时返回0.0\n- `edge1`: 上边界值，当x >= edge1时返回1.0  \n- `x`: 输入值\n- 返回值: 在[0.0, 1.0]范围内的平滑插值结果\n\n### 数学原理\n\nsmoothstep函数实现的是一个S形的平滑插值曲线，其数学公式为：\n\n```glsl\n// smoothstep的等价实现\nfloat mySmooth(float edge0, float edge1, float x) {\n    // 将x规范化到[0,1]范围\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    // Hermite插值: 3t² - 2t³\n    return t * t * (3.0 - 2.0 * t);\n}\n```\n\n#### 函数特性\n\n1. **平滑性**: 在边界处一阶导数为0，确保平滑过渡\n2. **单调性**: 在[edge0, edge1]区间内严格递增\n3. **边界行为**: 在边界外返回0或1，无超调\n\n#### 与其他插值函数对比\n\n```glsl\n// 线性插值 - 存在尖锐边界\nfloat linearStep(float edge0, float edge1, float x) {\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\n// smoothstep - S形平滑曲线\nfloat smoothStep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\n// smootherstep - 更平滑的曲线\nfloat smootherStep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n```\n\n### 基本用法示例\n\n#### 1. 简单的边缘软化\n\n```glsl\n// Fragment Shader - 软化圆形边缘\nvoid main() {\n    vec2 center = vec2(0.5, 0.5);\n    float dist = distance(gl_FragCoord.xy / resolution.xy, center);\n    \n    // 硬边缘\n    float hardCircle = step(0.3, dist);\n    \n    // 软边缘\n    float softCircle = smoothstep(0.25, 0.35, dist);\n    \n    gl_FragColor = vec4(vec3(1.0 - softCircle), 1.0);\n}\n```\n\n#### 2. 渐变效果\n\n```glsl\n// 水平渐变\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    \n    // 线性渐变\n    float linear = uv.x;\n    \n    // 平滑渐变\n    float smooth = smoothstep(0.0, 1.0, uv.x);\n    \n    gl_FragColor = vec4(vec3(smooth), 1.0);\n}\n```\n\n### 实际应用场景\n\n#### 1. 雾效实现\n\n```glsl\nuniform float fogNear;\nuniform float fogFar;\nuniform vec3 fogColor;\n\nvoid main() {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    \n    // 使用smoothstep创建平滑的雾效\n    float fogFactor = smoothstep(fogNear, fogFar, depth);\n    \n    vec3 finalColor = mix(objectColor, fogColor, fogFactor);\n    gl_FragColor = vec4(finalColor, 1.0);\n}\n```\n\n#### 2. 材质混合\n\n```glsl\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform float mixFactor;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    \n    vec4 color1 = texture2D(texture1, uv);\n    vec4 color2 = texture2D(texture2, uv);\n    \n    // 平滑的材质过渡\n    float factor = smoothstep(0.3, 0.7, mixFactor);\n    vec4 finalColor = mix(color1, color2, factor);\n    \n    gl_FragColor = finalColor;\n}\n```\n\n#### 3. 动画过渡\n\n```glsl\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    \n    // 创建脉动效果\n    float pulse = sin(time * 2.0) * 0.5 + 0.5;\n    float radius = smoothstep(0.0, 1.0, pulse) * 0.5;\n    \n    float dist = distance(uv, vec2(0.5));\n    float circle = 1.0 - smoothstep(radius - 0.05, radius + 0.05, dist);\n    \n    gl_FragColor = vec4(vec3(circle), 1.0);\n}\n```\n\n#### 4. 边缘检测和轮廓\n\n```glsl\nuniform sampler2D inputTexture;\nuniform vec2 resolution;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    \n    // 采样周围像素\n    float tl = texture2D(inputTexture, uv + vec2(-1.0, -1.0) / resolution).r;\n    float tr = texture2D(inputTexture, uv + vec2(1.0, -1.0) / resolution).r;\n    float bl = texture2D(inputTexture, uv + vec2(-1.0, 1.0) / resolution).r;\n    float br = texture2D(inputTexture, uv + vec2(1.0, 1.0) / resolution).r;\n    \n    // 计算梯度\n    float gradient = abs(tl - br) + abs(tr - bl);\n    \n    // 使用smoothstep创建清晰的边缘\n    float edge = smoothstep(0.1, 0.3, gradient);\n    \n    gl_FragColor = vec4(vec3(edge), 1.0);\n}\n```\n\n### 高级技巧\n\n#### 1. 多重smoothstep组合\n\n```glsl\n// 创建多段渐变\nfloat multiStep(float x) {\n    float step1 = smoothstep(0.0, 0.3, x);\n    float step2 = smoothstep(0.3, 0.7, x);\n    float step3 = smoothstep(0.7, 1.0, x);\n    \n    return step1 * 0.3 + step2 * 0.4 + step3 * 0.3;\n}\n```\n\n#### 2. 自定义缓动函数\n\n```glsl\n// 缓入缓出\nfloat easeInOut(float t) {\n    return smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, t));\n}\n\n// 弹性效果\nfloat elastic(float t) {\n    return smoothstep(0.0, 1.0, t) * (1.0 + sin(t * 3.14159 * 4.0) * 0.1);\n}\n```\n\n#### 3. 向量化操作\n\n```glsl\n// 对RGB通道分别应用smoothstep\nvec3 colorTransition(vec3 color, float factor) {\n    return smoothstep(vec3(0.2), vec3(0.8), vec3(factor));\n}\n\n// 创建彩虹效果\nvec3 rainbow(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n```\n\n### 性能考虑\n\n#### 1. 内置函数优势\n\n```glsl\n// 推荐：使用内置smoothstep\nfloat result = smoothstep(0.0, 1.0, x);\n\n// 不推荐：手动实现（除非需要自定义行为）\nfloat t = clamp((x - 0.0) / (1.0 - 0.0), 0.0, 1.0);\nfloat result = t * t * (3.0 - 2.0 * t);\n```\n\n#### 2. 预计算优化\n\n```glsl\n// 对于常量参数，可以预计算\nuniform float precomputedRange; // = 1.0 / (edge1 - edge0)\nuniform float precomputedOffset; // = -edge0 / (edge1 - edge0)\n\nfloat optimizedSmoothstep(float x) {\n    float t = clamp(x * precomputedRange + precomputedOffset, 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n```\n\n### 调试技巧\n\n#### 1. 可视化smoothstep曲线\n\n```glsl\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    \n    // 绘制函数曲线\n    float x = uv.x;\n    float y = smoothstep(0.2, 0.8, x);\n    \n    // 显示曲线\n    float line = abs(uv.y - y) < 0.01 ? 1.0 : 0.0;\n    \n    gl_FragColor = vec4(vec3(line), 1.0);\n}\n```\n\n#### 2. 参数调试\n\n```glsl\nuniform float debugEdge0;\nuniform float debugEdge1;\nuniform float debugInput;\n\nvoid main() {\n    float result = smoothstep(debugEdge0, debugEdge1, debugInput);\n    gl_FragColor = vec4(vec3(result), 1.0);\n}\n```\n\n### 常见问题和解决方案\n\n#### 1. 边界值相等\n\n```glsl\n// 错误：edge0 == edge1会导致除零\nfloat bad = smoothstep(0.5, 0.5, x);\n\n// 解决：确保边界值不同\nfloat safe = smoothstep(0.5, 0.5 + 0.001, x);\n```\n\n#### 2. 参数顺序\n\n```glsl\n// 注意：edge0应该小于edge1\nfloat correct = smoothstep(0.2, 0.8, x);   // 正确\nfloat incorrect = smoothstep(0.8, 0.2, x); // 结果会反转\n```\n\n### 总结\n\nsmoothstep函数是GLSL中一个强大而优雅的工具，它提供了：\n\n1. **数学上的优美性**: S形曲线确保平滑过渡\n2. **实用性**: 广泛适用于各种图形效果\n3. **性能**: 硬件优化的内置实现\n4. **灵活性**: 支持标量和向量操作\n\n掌握smoothstep函数的使用技巧，能够显著提升shader编程的效果和效率。无论是创建艺术效果还是解决实际的渲染问题，smoothstep都是不可或缺的工具。\n\n### 参考资源\n\n- [OpenGL官方文档 - smoothstep](https://www.khronos.org/registry/OpenGL-Refpages/)\n- [Shadertoy](https://www.shadertoy.com/) - 在线shader编辑器\n- [The Book of Shaders](https://thebookofshaders.com/) - shader学习资源\n- [GLSL规范](https://www.khronos.org/files/opengles_shading_language.pdf) \n","source":"_posts/GLSL中的smoothstep函数详解.md","raw":"---\ntitle: GLSL中的smoothstep函数详解\ndate: 2025-06-24 20:00:00\ntags:\n    - GLSL\n    - Shader\n    - 图形编程\n    - 计算机图形学\n---\n\n### 前言\n\n在GLSL(OpenGL Shading Language)编程中，`smoothstep`函数是一个非常有用且常用的内置函数。它能够在两个值之间创建平滑的插值，广泛应用于边缘软化、渐变效果、动画过渡等场景。本文将深入介绍smoothstep函数的用法、数学原理和实际应用。\n\n### smoothstep函数基础\n\n#### 函数签名\n\n```glsl\n// 基本形式\nfloat smoothstep(float edge0, float edge1, float x)\nvec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x)\nvec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x)\nvec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x)\n\n// 混合形式\nvec2 smoothstep(float edge0, float edge1, vec2 x)\nvec3 smoothstep(float edge0, float edge1, vec3 x)\nvec4 smoothstep(float edge0, float edge1, vec4 x)\n```\n\n#### 参数说明\n\n- `edge0`: 下边界值，当x <= edge0时返回0.0\n- `edge1`: 上边界值，当x >= edge1时返回1.0  \n- `x`: 输入值\n- 返回值: 在[0.0, 1.0]范围内的平滑插值结果\n\n### 数学原理\n\nsmoothstep函数实现的是一个S形的平滑插值曲线，其数学公式为：\n\n```glsl\n// smoothstep的等价实现\nfloat mySmooth(float edge0, float edge1, float x) {\n    // 将x规范化到[0,1]范围\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    // Hermite插值: 3t² - 2t³\n    return t * t * (3.0 - 2.0 * t);\n}\n```\n\n#### 函数特性\n\n1. **平滑性**: 在边界处一阶导数为0，确保平滑过渡\n2. **单调性**: 在[edge0, edge1]区间内严格递增\n3. **边界行为**: 在边界外返回0或1，无超调\n\n#### 与其他插值函数对比\n\n```glsl\n// 线性插值 - 存在尖锐边界\nfloat linearStep(float edge0, float edge1, float x) {\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\n// smoothstep - S形平滑曲线\nfloat smoothStep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\n// smootherstep - 更平滑的曲线\nfloat smootherStep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n```\n\n### 基本用法示例\n\n#### 1. 简单的边缘软化\n\n```glsl\n// Fragment Shader - 软化圆形边缘\nvoid main() {\n    vec2 center = vec2(0.5, 0.5);\n    float dist = distance(gl_FragCoord.xy / resolution.xy, center);\n    \n    // 硬边缘\n    float hardCircle = step(0.3, dist);\n    \n    // 软边缘\n    float softCircle = smoothstep(0.25, 0.35, dist);\n    \n    gl_FragColor = vec4(vec3(1.0 - softCircle), 1.0);\n}\n```\n\n#### 2. 渐变效果\n\n```glsl\n// 水平渐变\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    \n    // 线性渐变\n    float linear = uv.x;\n    \n    // 平滑渐变\n    float smooth = smoothstep(0.0, 1.0, uv.x);\n    \n    gl_FragColor = vec4(vec3(smooth), 1.0);\n}\n```\n\n### 实际应用场景\n\n#### 1. 雾效实现\n\n```glsl\nuniform float fogNear;\nuniform float fogFar;\nuniform vec3 fogColor;\n\nvoid main() {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    \n    // 使用smoothstep创建平滑的雾效\n    float fogFactor = smoothstep(fogNear, fogFar, depth);\n    \n    vec3 finalColor = mix(objectColor, fogColor, fogFactor);\n    gl_FragColor = vec4(finalColor, 1.0);\n}\n```\n\n#### 2. 材质混合\n\n```glsl\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform float mixFactor;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    \n    vec4 color1 = texture2D(texture1, uv);\n    vec4 color2 = texture2D(texture2, uv);\n    \n    // 平滑的材质过渡\n    float factor = smoothstep(0.3, 0.7, mixFactor);\n    vec4 finalColor = mix(color1, color2, factor);\n    \n    gl_FragColor = finalColor;\n}\n```\n\n#### 3. 动画过渡\n\n```glsl\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    \n    // 创建脉动效果\n    float pulse = sin(time * 2.0) * 0.5 + 0.5;\n    float radius = smoothstep(0.0, 1.0, pulse) * 0.5;\n    \n    float dist = distance(uv, vec2(0.5));\n    float circle = 1.0 - smoothstep(radius - 0.05, radius + 0.05, dist);\n    \n    gl_FragColor = vec4(vec3(circle), 1.0);\n}\n```\n\n#### 4. 边缘检测和轮廓\n\n```glsl\nuniform sampler2D inputTexture;\nuniform vec2 resolution;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    \n    // 采样周围像素\n    float tl = texture2D(inputTexture, uv + vec2(-1.0, -1.0) / resolution).r;\n    float tr = texture2D(inputTexture, uv + vec2(1.0, -1.0) / resolution).r;\n    float bl = texture2D(inputTexture, uv + vec2(-1.0, 1.0) / resolution).r;\n    float br = texture2D(inputTexture, uv + vec2(1.0, 1.0) / resolution).r;\n    \n    // 计算梯度\n    float gradient = abs(tl - br) + abs(tr - bl);\n    \n    // 使用smoothstep创建清晰的边缘\n    float edge = smoothstep(0.1, 0.3, gradient);\n    \n    gl_FragColor = vec4(vec3(edge), 1.0);\n}\n```\n\n### 高级技巧\n\n#### 1. 多重smoothstep组合\n\n```glsl\n// 创建多段渐变\nfloat multiStep(float x) {\n    float step1 = smoothstep(0.0, 0.3, x);\n    float step2 = smoothstep(0.3, 0.7, x);\n    float step3 = smoothstep(0.7, 1.0, x);\n    \n    return step1 * 0.3 + step2 * 0.4 + step3 * 0.3;\n}\n```\n\n#### 2. 自定义缓动函数\n\n```glsl\n// 缓入缓出\nfloat easeInOut(float t) {\n    return smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, t));\n}\n\n// 弹性效果\nfloat elastic(float t) {\n    return smoothstep(0.0, 1.0, t) * (1.0 + sin(t * 3.14159 * 4.0) * 0.1);\n}\n```\n\n#### 3. 向量化操作\n\n```glsl\n// 对RGB通道分别应用smoothstep\nvec3 colorTransition(vec3 color, float factor) {\n    return smoothstep(vec3(0.2), vec3(0.8), vec3(factor));\n}\n\n// 创建彩虹效果\nvec3 rainbow(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n```\n\n### 性能考虑\n\n#### 1. 内置函数优势\n\n```glsl\n// 推荐：使用内置smoothstep\nfloat result = smoothstep(0.0, 1.0, x);\n\n// 不推荐：手动实现（除非需要自定义行为）\nfloat t = clamp((x - 0.0) / (1.0 - 0.0), 0.0, 1.0);\nfloat result = t * t * (3.0 - 2.0 * t);\n```\n\n#### 2. 预计算优化\n\n```glsl\n// 对于常量参数，可以预计算\nuniform float precomputedRange; // = 1.0 / (edge1 - edge0)\nuniform float precomputedOffset; // = -edge0 / (edge1 - edge0)\n\nfloat optimizedSmoothstep(float x) {\n    float t = clamp(x * precomputedRange + precomputedOffset, 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n```\n\n### 调试技巧\n\n#### 1. 可视化smoothstep曲线\n\n```glsl\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    \n    // 绘制函数曲线\n    float x = uv.x;\n    float y = smoothstep(0.2, 0.8, x);\n    \n    // 显示曲线\n    float line = abs(uv.y - y) < 0.01 ? 1.0 : 0.0;\n    \n    gl_FragColor = vec4(vec3(line), 1.0);\n}\n```\n\n#### 2. 参数调试\n\n```glsl\nuniform float debugEdge0;\nuniform float debugEdge1;\nuniform float debugInput;\n\nvoid main() {\n    float result = smoothstep(debugEdge0, debugEdge1, debugInput);\n    gl_FragColor = vec4(vec3(result), 1.0);\n}\n```\n\n### 常见问题和解决方案\n\n#### 1. 边界值相等\n\n```glsl\n// 错误：edge0 == edge1会导致除零\nfloat bad = smoothstep(0.5, 0.5, x);\n\n// 解决：确保边界值不同\nfloat safe = smoothstep(0.5, 0.5 + 0.001, x);\n```\n\n#### 2. 参数顺序\n\n```glsl\n// 注意：edge0应该小于edge1\nfloat correct = smoothstep(0.2, 0.8, x);   // 正确\nfloat incorrect = smoothstep(0.8, 0.2, x); // 结果会反转\n```\n\n### 总结\n\nsmoothstep函数是GLSL中一个强大而优雅的工具，它提供了：\n\n1. **数学上的优美性**: S形曲线确保平滑过渡\n2. **实用性**: 广泛适用于各种图形效果\n3. **性能**: 硬件优化的内置实现\n4. **灵活性**: 支持标量和向量操作\n\n掌握smoothstep函数的使用技巧，能够显著提升shader编程的效果和效率。无论是创建艺术效果还是解决实际的渲染问题，smoothstep都是不可或缺的工具。\n\n### 参考资源\n\n- [OpenGL官方文档 - smoothstep](https://www.khronos.org/registry/OpenGL-Refpages/)\n- [Shadertoy](https://www.shadertoy.com/) - 在线shader编辑器\n- [The Book of Shaders](https://thebookofshaders.com/) - shader学习资源\n- [GLSL规范](https://www.khronos.org/files/opengles_shading_language.pdf) \n","slug":"GLSL中的smoothstep函数详解","published":1,"updated":"2025-06-24T09:01:55.360Z","_id":"cmc9xgo8q00015tcobfgv3v1s","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在GLSL(OpenGL Shading Language)编程中，<code>smoothstep</code>函数是一个非常有用且常用的内置函数。它能够在两个值之间创建平滑的插值，广泛应用于边缘软化、渐变效果、动画过渡等场景。本文将深入介绍smoothstep函数的用法、数学原理和实际应用。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"smoothstep函数基础\"><a href=\"#smoothstep函数基础\" class=\"headerlink\" title=\"smoothstep函数基础\"></a>smoothstep函数基础</h3><h4 id=\"函数签名\"><a href=\"#函数签名\" class=\"headerlink\" title=\"函数签名\"></a>函数签名</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本形式</span></span><br><span class=\"line\"><span class=\"type\">float</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">float</span> x)</span><br><span class=\"line\"><span class=\"type\">vec2</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">vec2</span> edge0, <span class=\"type\">vec2</span> edge1, <span class=\"type\">vec2</span> x)</span><br><span class=\"line\"><span class=\"type\">vec3</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">vec3</span> edge0, <span class=\"type\">vec3</span> edge1, <span class=\"type\">vec3</span> x)</span><br><span class=\"line\"><span class=\"type\">vec4</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">vec4</span> edge0, <span class=\"type\">vec4</span> edge1, <span class=\"type\">vec4</span> x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 混合形式</span></span><br><span class=\"line\"><span class=\"type\">vec2</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">vec2</span> x)</span><br><span class=\"line\"><span class=\"type\">vec3</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">vec3</span> x)</span><br><span class=\"line\"><span class=\"type\">vec4</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">vec4</span> x)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h4><ul>\n<li><code>edge0</code>: 下边界值，当x &lt;= edge0时返回0.0</li>\n<li><code>edge1</code>: 上边界值，当x &gt;= edge1时返回1.0  </li>\n<li><code>x</code>: 输入值</li>\n<li>返回值: 在[0.0, 1.0]范围内的平滑插值结果</li>\n</ul>\n<h3 id=\"数学原理\"><a href=\"#数学原理\" class=\"headerlink\" title=\"数学原理\"></a>数学原理</h3><p>smoothstep函数实现的是一个S形的平滑插值曲线，其数学公式为：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// smoothstep的等价实现</span></span><br><span class=\"line\"><span class=\"type\">float</span> mySmooth(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将x规范化到[0,1]范围</span></span><br><span class=\"line\">    <span class=\"type\">float</span> t = <span class=\"built_in\">clamp</span>((x - edge0) / (edge1 - edge0), <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Hermite插值: 3t² - 2t³</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> t * t * (<span class=\"number\">3.0</span> - <span class=\"number\">2.0</span> * t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"函数特性\"><a href=\"#函数特性\" class=\"headerlink\" title=\"函数特性\"></a>函数特性</h4><ol>\n<li><strong>平滑性</strong>: 在边界处一阶导数为0，确保平滑过渡</li>\n<li><strong>单调性</strong>: 在[edge0, edge1]区间内严格递增</li>\n<li><strong>边界行为</strong>: 在边界外返回0或1，无超调</li>\n</ol>\n<h4 id=\"与其他插值函数对比\"><a href=\"#与其他插值函数对比\" class=\"headerlink\" title=\"与其他插值函数对比\"></a>与其他插值函数对比</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线性插值 - 存在尖锐边界</span></span><br><span class=\"line\"><span class=\"type\">float</span> linearStep(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">clamp</span>((x - edge0) / (edge1 - edge0), <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// smoothstep - S形平滑曲线</span></span><br><span class=\"line\"><span class=\"type\">float</span> smoothStep(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> t = <span class=\"built_in\">clamp</span>((x - edge0) / (edge1 - edge0), <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t * t * (<span class=\"number\">3.0</span> - <span class=\"number\">2.0</span> * t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// smootherstep - 更平滑的曲线</span></span><br><span class=\"line\"><span class=\"type\">float</span> smootherStep(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> t = <span class=\"built_in\">clamp</span>((x - edge0) / (edge1 - edge0), <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t * t * t * (t * (t * <span class=\"number\">6.0</span> - <span class=\"number\">15.0</span>) + <span class=\"number\">10.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本用法示例\"><a href=\"#基本用法示例\" class=\"headerlink\" title=\"基本用法示例\"></a>基本用法示例</h3><h4 id=\"1-简单的边缘软化\"><a href=\"#1-简单的边缘软化\" class=\"headerlink\" title=\"1. 简单的边缘软化\"></a>1. 简单的边缘软化</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fragment Shader - 软化圆形边缘</span></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> center = <span class=\"type\">vec2</span>(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> dist = <span class=\"built_in\">distance</span>(<span class=\"built_in\">gl_FragCoord</span>.xy / resolution.xy, center);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 硬边缘</span></span><br><span class=\"line\">    <span class=\"type\">float</span> hardCircle = <span class=\"built_in\">step</span>(<span class=\"number\">0.3</span>, dist);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 软边缘</span></span><br><span class=\"line\">    <span class=\"type\">float</span> softCircle = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.25</span>, <span class=\"number\">0.35</span>, dist);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(<span class=\"type\">vec3</span>(<span class=\"number\">1.0</span> - softCircle), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-渐变效果\"><a href=\"#2-渐变效果\" class=\"headerlink\" title=\"2. 渐变效果\"></a>2. 渐变效果</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 水平渐变</span></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> uv = <span class=\"built_in\">gl_FragCoord</span>.xy / resolution.xy;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 线性渐变</span></span><br><span class=\"line\">    <span class=\"type\">float</span> linear = uv.x;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 平滑渐变</span></span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"keyword\">smooth</span> = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, uv.x);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(<span class=\"type\">vec3</span>(<span class=\"keyword\">smooth</span>), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实际应用场景\"><a href=\"#实际应用场景\" class=\"headerlink\" title=\"实际应用场景\"></a>实际应用场景</h3><h4 id=\"1-雾效实现\"><a href=\"#1-雾效实现\" class=\"headerlink\" title=\"1. 雾效实现\"></a>1. 雾效实现</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> fogNear;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> fogFar;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">vec3</span> fogColor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> depth = <span class=\"built_in\">gl_FragCoord</span>.z / <span class=\"built_in\">gl_FragCoord</span>.w;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用smoothstep创建平滑的雾效</span></span><br><span class=\"line\">    <span class=\"type\">float</span> fogFactor = <span class=\"built_in\">smoothstep</span>(fogNear, fogFar, depth);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">vec3</span> finalColor = <span class=\"built_in\">mix</span>(objectColor, fogColor, fogFactor);</span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(finalColor, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-材质混合\"><a href=\"#2-材质混合\" class=\"headerlink\" title=\"2. 材质混合\"></a>2. 材质混合</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> texture1;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> texture2;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> mixFactor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> uv = <span class=\"built_in\">gl_FragCoord</span>.xy / resolution.xy;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">vec4</span> color1 = <span class=\"built_in\">texture2D</span>(texture1, uv);</span><br><span class=\"line\">    <span class=\"type\">vec4</span> color2 = <span class=\"built_in\">texture2D</span>(texture2, uv);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 平滑的材质过渡</span></span><br><span class=\"line\">    <span class=\"type\">float</span> factor = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.3</span>, <span class=\"number\">0.7</span>, mixFactor);</span><br><span class=\"line\">    <span class=\"type\">vec4</span> finalColor = <span class=\"built_in\">mix</span>(color1, color2, factor);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = finalColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-动画过渡\"><a href=\"#3-动画过渡\" class=\"headerlink\" title=\"3. 动画过渡\"></a>3. 动画过渡</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> time;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> uv = <span class=\"built_in\">gl_FragCoord</span>.xy / resolution.xy;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建脉动效果</span></span><br><span class=\"line\">    <span class=\"type\">float</span> pulse = <span class=\"built_in\">sin</span>(time * <span class=\"number\">2.0</span>) * <span class=\"number\">0.5</span> + <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"type\">float</span> radius = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, pulse) * <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">float</span> dist = <span class=\"built_in\">distance</span>(uv, <span class=\"type\">vec2</span>(<span class=\"number\">0.5</span>));</span><br><span class=\"line\">    <span class=\"type\">float</span> circle = <span class=\"number\">1.0</span> - <span class=\"built_in\">smoothstep</span>(radius - <span class=\"number\">0.05</span>, radius + <span class=\"number\">0.05</span>, dist);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(<span class=\"type\">vec3</span>(circle), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-边缘检测和轮廓\"><a href=\"#4-边缘检测和轮廓\" class=\"headerlink\" title=\"4. 边缘检测和轮廓\"></a>4. 边缘检测和轮廓</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> inputTexture;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">vec2</span> resolution;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> uv = <span class=\"built_in\">gl_FragCoord</span>.xy / resolution;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 采样周围像素</span></span><br><span class=\"line\">    <span class=\"type\">float</span> tl = <span class=\"built_in\">texture2D</span>(inputTexture, uv + <span class=\"type\">vec2</span>(<span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>) / resolution).r;</span><br><span class=\"line\">    <span class=\"type\">float</span> tr = <span class=\"built_in\">texture2D</span>(inputTexture, uv + <span class=\"type\">vec2</span>(<span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>) / resolution).r;</span><br><span class=\"line\">    <span class=\"type\">float</span> bl = <span class=\"built_in\">texture2D</span>(inputTexture, uv + <span class=\"type\">vec2</span>(<span class=\"number\">-1.0</span>, <span class=\"number\">1.0</span>) / resolution).r;</span><br><span class=\"line\">    <span class=\"type\">float</span> br = <span class=\"built_in\">texture2D</span>(inputTexture, uv + <span class=\"type\">vec2</span>(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>) / resolution).r;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 计算梯度</span></span><br><span class=\"line\">    <span class=\"type\">float</span> gradient = <span class=\"built_in\">abs</span>(tl - br) + <span class=\"built_in\">abs</span>(tr - bl);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用smoothstep创建清晰的边缘</span></span><br><span class=\"line\">    <span class=\"type\">float</span> edge = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.1</span>, <span class=\"number\">0.3</span>, gradient);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(<span class=\"type\">vec3</span>(edge), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高级技巧\"><a href=\"#高级技巧\" class=\"headerlink\" title=\"高级技巧\"></a>高级技巧</h3><h4 id=\"1-多重smoothstep组合\"><a href=\"#1-多重smoothstep组合\" class=\"headerlink\" title=\"1. 多重smoothstep组合\"></a>1. 多重smoothstep组合</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建多段渐变</span></span><br><span class=\"line\"><span class=\"type\">float</span> multiStep(<span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> step1 = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">0.3</span>, x);</span><br><span class=\"line\">    <span class=\"type\">float</span> step2 = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.3</span>, <span class=\"number\">0.7</span>, x);</span><br><span class=\"line\">    <span class=\"type\">float</span> step3 = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.7</span>, <span class=\"number\">1.0</span>, x);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> step1 * <span class=\"number\">0.3</span> + step2 * <span class=\"number\">0.4</span> + step3 * <span class=\"number\">0.3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-自定义缓动函数\"><a href=\"#2-自定义缓动函数\" class=\"headerlink\" title=\"2. 自定义缓动函数\"></a>2. 自定义缓动函数</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 缓入缓出</span></span><br><span class=\"line\"><span class=\"type\">float</span> easeInOut(<span class=\"type\">float</span> t) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, t));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 弹性效果</span></span><br><span class=\"line\"><span class=\"type\">float</span> elastic(<span class=\"type\">float</span> t) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, t) * (<span class=\"number\">1.0</span> + <span class=\"built_in\">sin</span>(t * <span class=\"number\">3.14159</span> * <span class=\"number\">4.0</span>) * <span class=\"number\">0.1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-向量化操作\"><a href=\"#3-向量化操作\" class=\"headerlink\" title=\"3. 向量化操作\"></a>3. 向量化操作</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对RGB通道分别应用smoothstep</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> colorTransition(<span class=\"type\">vec3</span> color, <span class=\"type\">float</span> factor) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">vec3</span>(<span class=\"number\">0.2</span>), <span class=\"type\">vec3</span>(<span class=\"number\">0.8</span>), <span class=\"type\">vec3</span>(factor));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建彩虹效果</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> rainbow(<span class=\"type\">float</span> t) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> a = <span class=\"type\">vec3</span>(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">    <span class=\"type\">vec3</span> b = <span class=\"type\">vec3</span>(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">    <span class=\"type\">vec3</span> c = <span class=\"type\">vec3</span>(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    <span class=\"type\">vec3</span> d = <span class=\"type\">vec3</span>(<span class=\"number\">0.0</span>, <span class=\"number\">0.33</span>, <span class=\"number\">0.67</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b * <span class=\"built_in\">cos</span>(<span class=\"number\">6.28318</span> * (c * t + d));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"性能考虑\"><a href=\"#性能考虑\" class=\"headerlink\" title=\"性能考虑\"></a>性能考虑</h3><h4 id=\"1-内置函数优势\"><a href=\"#1-内置函数优势\" class=\"headerlink\" title=\"1. 内置函数优势\"></a>1. 内置函数优势</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 推荐：使用内置smoothstep</span></span><br><span class=\"line\"><span class=\"type\">float</span> result = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不推荐：手动实现（除非需要自定义行为）</span></span><br><span class=\"line\"><span class=\"type\">float</span> t = <span class=\"built_in\">clamp</span>((x - <span class=\"number\">0.0</span>) / (<span class=\"number\">1.0</span> - <span class=\"number\">0.0</span>), <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"><span class=\"type\">float</span> result = t * t * (<span class=\"number\">3.0</span> - <span class=\"number\">2.0</span> * t);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-预计算优化\"><a href=\"#2-预计算优化\" class=\"headerlink\" title=\"2. 预计算优化\"></a>2. 预计算优化</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于常量参数，可以预计算</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> precomputedRange; <span class=\"comment\">// = 1.0 / (edge1 - edge0)</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> precomputedOffset; <span class=\"comment\">// = -edge0 / (edge1 - edge0)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> optimizedSmoothstep(<span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> t = <span class=\"built_in\">clamp</span>(x * precomputedRange + precomputedOffset, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t * t * (<span class=\"number\">3.0</span> - <span class=\"number\">2.0</span> * t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"调试技巧\"><a href=\"#调试技巧\" class=\"headerlink\" title=\"调试技巧\"></a>调试技巧</h3><h4 id=\"1-可视化smoothstep曲线\"><a href=\"#1-可视化smoothstep曲线\" class=\"headerlink\" title=\"1. 可视化smoothstep曲线\"></a>1. 可视化smoothstep曲线</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> uv = <span class=\"built_in\">gl_FragCoord</span>.xy / resolution.xy;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 绘制函数曲线</span></span><br><span class=\"line\">    <span class=\"type\">float</span> x = uv.x;</span><br><span class=\"line\">    <span class=\"type\">float</span> y = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.2</span>, <span class=\"number\">0.8</span>, x);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 显示曲线</span></span><br><span class=\"line\">    <span class=\"type\">float</span> line = <span class=\"built_in\">abs</span>(uv.y - y) &lt; <span class=\"number\">0.01</span> ? <span class=\"number\">1.0</span> : <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(<span class=\"type\">vec3</span>(line), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-参数调试\"><a href=\"#2-参数调试\" class=\"headerlink\" title=\"2. 参数调试\"></a>2. 参数调试</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> debugEdge0;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> debugEdge1;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> debugInput;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> result = <span class=\"built_in\">smoothstep</span>(debugEdge0, debugEdge1, debugInput);</span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(<span class=\"type\">vec3</span>(result), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常见问题和解决方案\"><a href=\"#常见问题和解决方案\" class=\"headerlink\" title=\"常见问题和解决方案\"></a>常见问题和解决方案</h3><h4 id=\"1-边界值相等\"><a href=\"#1-边界值相等\" class=\"headerlink\" title=\"1. 边界值相等\"></a>1. 边界值相等</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误：edge0 == edge1会导致除零</span></span><br><span class=\"line\"><span class=\"type\">float</span> bad = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解决：确保边界值不同</span></span><br><span class=\"line\"><span class=\"type\">float</span> safe = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span> + <span class=\"number\">0.001</span>, x);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-参数顺序\"><a href=\"#2-参数顺序\" class=\"headerlink\" title=\"2. 参数顺序\"></a>2. 参数顺序</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意：edge0应该小于edge1</span></span><br><span class=\"line\"><span class=\"type\">float</span> correct = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.2</span>, <span class=\"number\">0.8</span>, x);   <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"type\">float</span> incorrect = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.8</span>, <span class=\"number\">0.2</span>, x); <span class=\"comment\">// 结果会反转</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>smoothstep函数是GLSL中一个强大而优雅的工具，它提供了：</p>\n<ol>\n<li><strong>数学上的优美性</strong>: S形曲线确保平滑过渡</li>\n<li><strong>实用性</strong>: 广泛适用于各种图形效果</li>\n<li><strong>性能</strong>: 硬件优化的内置实现</li>\n<li><strong>灵活性</strong>: 支持标量和向量操作</li>\n</ol>\n<p>掌握smoothstep函数的使用技巧，能够显著提升shader编程的效果和效率。无论是创建艺术效果还是解决实际的渲染问题，smoothstep都是不可或缺的工具。</p>\n<h3 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h3><ul>\n<li><a href=\"https://www.khronos.org/registry/OpenGL-Refpages/\">OpenGL官方文档 - smoothstep</a></li>\n<li><a href=\"https://www.shadertoy.com/\">Shadertoy</a> - 在线shader编辑器</li>\n<li><a href=\"https://thebookofshaders.com/\">The Book of Shaders</a> - shader学习资源</li>\n<li><a href=\"https://www.khronos.org/files/opengles_shading_language.pdf\">GLSL规范</a> </li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在GLSL(OpenGL Shading Language)编程中，<code>smoothstep</code>函数是一个非常有用且常用的内置函数。它能够在两个值之间创建平滑的插值，广泛应用于边缘软化、渐变效果、动画过渡等场景。本文将深入介绍smoothstep函数的用法、数学原理和实际应用。</p>","more":"<h3 id=\"smoothstep函数基础\"><a href=\"#smoothstep函数基础\" class=\"headerlink\" title=\"smoothstep函数基础\"></a>smoothstep函数基础</h3><h4 id=\"函数签名\"><a href=\"#函数签名\" class=\"headerlink\" title=\"函数签名\"></a>函数签名</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本形式</span></span><br><span class=\"line\"><span class=\"type\">float</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">float</span> x)</span><br><span class=\"line\"><span class=\"type\">vec2</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">vec2</span> edge0, <span class=\"type\">vec2</span> edge1, <span class=\"type\">vec2</span> x)</span><br><span class=\"line\"><span class=\"type\">vec3</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">vec3</span> edge0, <span class=\"type\">vec3</span> edge1, <span class=\"type\">vec3</span> x)</span><br><span class=\"line\"><span class=\"type\">vec4</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">vec4</span> edge0, <span class=\"type\">vec4</span> edge1, <span class=\"type\">vec4</span> x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 混合形式</span></span><br><span class=\"line\"><span class=\"type\">vec2</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">vec2</span> x)</span><br><span class=\"line\"><span class=\"type\">vec3</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">vec3</span> x)</span><br><span class=\"line\"><span class=\"type\">vec4</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">vec4</span> x)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h4><ul>\n<li><code>edge0</code>: 下边界值，当x &lt;= edge0时返回0.0</li>\n<li><code>edge1</code>: 上边界值，当x &gt;= edge1时返回1.0  </li>\n<li><code>x</code>: 输入值</li>\n<li>返回值: 在[0.0, 1.0]范围内的平滑插值结果</li>\n</ul>\n<h3 id=\"数学原理\"><a href=\"#数学原理\" class=\"headerlink\" title=\"数学原理\"></a>数学原理</h3><p>smoothstep函数实现的是一个S形的平滑插值曲线，其数学公式为：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// smoothstep的等价实现</span></span><br><span class=\"line\"><span class=\"type\">float</span> mySmooth(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将x规范化到[0,1]范围</span></span><br><span class=\"line\">    <span class=\"type\">float</span> t = <span class=\"built_in\">clamp</span>((x - edge0) / (edge1 - edge0), <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Hermite插值: 3t² - 2t³</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> t * t * (<span class=\"number\">3.0</span> - <span class=\"number\">2.0</span> * t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"函数特性\"><a href=\"#函数特性\" class=\"headerlink\" title=\"函数特性\"></a>函数特性</h4><ol>\n<li><strong>平滑性</strong>: 在边界处一阶导数为0，确保平滑过渡</li>\n<li><strong>单调性</strong>: 在[edge0, edge1]区间内严格递增</li>\n<li><strong>边界行为</strong>: 在边界外返回0或1，无超调</li>\n</ol>\n<h4 id=\"与其他插值函数对比\"><a href=\"#与其他插值函数对比\" class=\"headerlink\" title=\"与其他插值函数对比\"></a>与其他插值函数对比</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线性插值 - 存在尖锐边界</span></span><br><span class=\"line\"><span class=\"type\">float</span> linearStep(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">clamp</span>((x - edge0) / (edge1 - edge0), <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// smoothstep - S形平滑曲线</span></span><br><span class=\"line\"><span class=\"type\">float</span> smoothStep(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> t = <span class=\"built_in\">clamp</span>((x - edge0) / (edge1 - edge0), <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t * t * (<span class=\"number\">3.0</span> - <span class=\"number\">2.0</span> * t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// smootherstep - 更平滑的曲线</span></span><br><span class=\"line\"><span class=\"type\">float</span> smootherStep(<span class=\"type\">float</span> edge0, <span class=\"type\">float</span> edge1, <span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> t = <span class=\"built_in\">clamp</span>((x - edge0) / (edge1 - edge0), <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t * t * t * (t * (t * <span class=\"number\">6.0</span> - <span class=\"number\">15.0</span>) + <span class=\"number\">10.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本用法示例\"><a href=\"#基本用法示例\" class=\"headerlink\" title=\"基本用法示例\"></a>基本用法示例</h3><h4 id=\"1-简单的边缘软化\"><a href=\"#1-简单的边缘软化\" class=\"headerlink\" title=\"1. 简单的边缘软化\"></a>1. 简单的边缘软化</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fragment Shader - 软化圆形边缘</span></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> center = <span class=\"type\">vec2</span>(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">    <span class=\"type\">float</span> dist = <span class=\"built_in\">distance</span>(<span class=\"built_in\">gl_FragCoord</span>.xy / resolution.xy, center);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 硬边缘</span></span><br><span class=\"line\">    <span class=\"type\">float</span> hardCircle = <span class=\"built_in\">step</span>(<span class=\"number\">0.3</span>, dist);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 软边缘</span></span><br><span class=\"line\">    <span class=\"type\">float</span> softCircle = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.25</span>, <span class=\"number\">0.35</span>, dist);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(<span class=\"type\">vec3</span>(<span class=\"number\">1.0</span> - softCircle), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-渐变效果\"><a href=\"#2-渐变效果\" class=\"headerlink\" title=\"2. 渐变效果\"></a>2. 渐变效果</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 水平渐变</span></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> uv = <span class=\"built_in\">gl_FragCoord</span>.xy / resolution.xy;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 线性渐变</span></span><br><span class=\"line\">    <span class=\"type\">float</span> linear = uv.x;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 平滑渐变</span></span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"keyword\">smooth</span> = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, uv.x);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(<span class=\"type\">vec3</span>(<span class=\"keyword\">smooth</span>), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实际应用场景\"><a href=\"#实际应用场景\" class=\"headerlink\" title=\"实际应用场景\"></a>实际应用场景</h3><h4 id=\"1-雾效实现\"><a href=\"#1-雾效实现\" class=\"headerlink\" title=\"1. 雾效实现\"></a>1. 雾效实现</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> fogNear;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> fogFar;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">vec3</span> fogColor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> depth = <span class=\"built_in\">gl_FragCoord</span>.z / <span class=\"built_in\">gl_FragCoord</span>.w;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用smoothstep创建平滑的雾效</span></span><br><span class=\"line\">    <span class=\"type\">float</span> fogFactor = <span class=\"built_in\">smoothstep</span>(fogNear, fogFar, depth);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">vec3</span> finalColor = <span class=\"built_in\">mix</span>(objectColor, fogColor, fogFactor);</span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(finalColor, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-材质混合\"><a href=\"#2-材质混合\" class=\"headerlink\" title=\"2. 材质混合\"></a>2. 材质混合</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> texture1;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> texture2;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> mixFactor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> uv = <span class=\"built_in\">gl_FragCoord</span>.xy / resolution.xy;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">vec4</span> color1 = <span class=\"built_in\">texture2D</span>(texture1, uv);</span><br><span class=\"line\">    <span class=\"type\">vec4</span> color2 = <span class=\"built_in\">texture2D</span>(texture2, uv);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 平滑的材质过渡</span></span><br><span class=\"line\">    <span class=\"type\">float</span> factor = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.3</span>, <span class=\"number\">0.7</span>, mixFactor);</span><br><span class=\"line\">    <span class=\"type\">vec4</span> finalColor = <span class=\"built_in\">mix</span>(color1, color2, factor);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = finalColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-动画过渡\"><a href=\"#3-动画过渡\" class=\"headerlink\" title=\"3. 动画过渡\"></a>3. 动画过渡</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> time;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> uv = <span class=\"built_in\">gl_FragCoord</span>.xy / resolution.xy;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建脉动效果</span></span><br><span class=\"line\">    <span class=\"type\">float</span> pulse = <span class=\"built_in\">sin</span>(time * <span class=\"number\">2.0</span>) * <span class=\"number\">0.5</span> + <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    <span class=\"type\">float</span> radius = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, pulse) * <span class=\"number\">0.5</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">float</span> dist = <span class=\"built_in\">distance</span>(uv, <span class=\"type\">vec2</span>(<span class=\"number\">0.5</span>));</span><br><span class=\"line\">    <span class=\"type\">float</span> circle = <span class=\"number\">1.0</span> - <span class=\"built_in\">smoothstep</span>(radius - <span class=\"number\">0.05</span>, radius + <span class=\"number\">0.05</span>, dist);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(<span class=\"type\">vec3</span>(circle), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-边缘检测和轮廓\"><a href=\"#4-边缘检测和轮廓\" class=\"headerlink\" title=\"4. 边缘检测和轮廓\"></a>4. 边缘检测和轮廓</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> inputTexture;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">vec2</span> resolution;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> uv = <span class=\"built_in\">gl_FragCoord</span>.xy / resolution;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 采样周围像素</span></span><br><span class=\"line\">    <span class=\"type\">float</span> tl = <span class=\"built_in\">texture2D</span>(inputTexture, uv + <span class=\"type\">vec2</span>(<span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>) / resolution).r;</span><br><span class=\"line\">    <span class=\"type\">float</span> tr = <span class=\"built_in\">texture2D</span>(inputTexture, uv + <span class=\"type\">vec2</span>(<span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>) / resolution).r;</span><br><span class=\"line\">    <span class=\"type\">float</span> bl = <span class=\"built_in\">texture2D</span>(inputTexture, uv + <span class=\"type\">vec2</span>(<span class=\"number\">-1.0</span>, <span class=\"number\">1.0</span>) / resolution).r;</span><br><span class=\"line\">    <span class=\"type\">float</span> br = <span class=\"built_in\">texture2D</span>(inputTexture, uv + <span class=\"type\">vec2</span>(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>) / resolution).r;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 计算梯度</span></span><br><span class=\"line\">    <span class=\"type\">float</span> gradient = <span class=\"built_in\">abs</span>(tl - br) + <span class=\"built_in\">abs</span>(tr - bl);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用smoothstep创建清晰的边缘</span></span><br><span class=\"line\">    <span class=\"type\">float</span> edge = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.1</span>, <span class=\"number\">0.3</span>, gradient);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(<span class=\"type\">vec3</span>(edge), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高级技巧\"><a href=\"#高级技巧\" class=\"headerlink\" title=\"高级技巧\"></a>高级技巧</h3><h4 id=\"1-多重smoothstep组合\"><a href=\"#1-多重smoothstep组合\" class=\"headerlink\" title=\"1. 多重smoothstep组合\"></a>1. 多重smoothstep组合</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建多段渐变</span></span><br><span class=\"line\"><span class=\"type\">float</span> multiStep(<span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> step1 = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">0.3</span>, x);</span><br><span class=\"line\">    <span class=\"type\">float</span> step2 = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.3</span>, <span class=\"number\">0.7</span>, x);</span><br><span class=\"line\">    <span class=\"type\">float</span> step3 = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.7</span>, <span class=\"number\">1.0</span>, x);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> step1 * <span class=\"number\">0.3</span> + step2 * <span class=\"number\">0.4</span> + step3 * <span class=\"number\">0.3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-自定义缓动函数\"><a href=\"#2-自定义缓动函数\" class=\"headerlink\" title=\"2. 自定义缓动函数\"></a>2. 自定义缓动函数</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 缓入缓出</span></span><br><span class=\"line\"><span class=\"type\">float</span> easeInOut(<span class=\"type\">float</span> t) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, t));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 弹性效果</span></span><br><span class=\"line\"><span class=\"type\">float</span> elastic(<span class=\"type\">float</span> t) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, t) * (<span class=\"number\">1.0</span> + <span class=\"built_in\">sin</span>(t * <span class=\"number\">3.14159</span> * <span class=\"number\">4.0</span>) * <span class=\"number\">0.1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-向量化操作\"><a href=\"#3-向量化操作\" class=\"headerlink\" title=\"3. 向量化操作\"></a>3. 向量化操作</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对RGB通道分别应用smoothstep</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> colorTransition(<span class=\"type\">vec3</span> color, <span class=\"type\">float</span> factor) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">smoothstep</span>(<span class=\"type\">vec3</span>(<span class=\"number\">0.2</span>), <span class=\"type\">vec3</span>(<span class=\"number\">0.8</span>), <span class=\"type\">vec3</span>(factor));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建彩虹效果</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> rainbow(<span class=\"type\">float</span> t) &#123;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> a = <span class=\"type\">vec3</span>(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">    <span class=\"type\">vec3</span> b = <span class=\"type\">vec3</span>(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">    <span class=\"type\">vec3</span> c = <span class=\"type\">vec3</span>(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    <span class=\"type\">vec3</span> d = <span class=\"type\">vec3</span>(<span class=\"number\">0.0</span>, <span class=\"number\">0.33</span>, <span class=\"number\">0.67</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b * <span class=\"built_in\">cos</span>(<span class=\"number\">6.28318</span> * (c * t + d));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"性能考虑\"><a href=\"#性能考虑\" class=\"headerlink\" title=\"性能考虑\"></a>性能考虑</h3><h4 id=\"1-内置函数优势\"><a href=\"#1-内置函数优势\" class=\"headerlink\" title=\"1. 内置函数优势\"></a>1. 内置函数优势</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 推荐：使用内置smoothstep</span></span><br><span class=\"line\"><span class=\"type\">float</span> result = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不推荐：手动实现（除非需要自定义行为）</span></span><br><span class=\"line\"><span class=\"type\">float</span> t = <span class=\"built_in\">clamp</span>((x - <span class=\"number\">0.0</span>) / (<span class=\"number\">1.0</span> - <span class=\"number\">0.0</span>), <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"><span class=\"type\">float</span> result = t * t * (<span class=\"number\">3.0</span> - <span class=\"number\">2.0</span> * t);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-预计算优化\"><a href=\"#2-预计算优化\" class=\"headerlink\" title=\"2. 预计算优化\"></a>2. 预计算优化</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于常量参数，可以预计算</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> precomputedRange; <span class=\"comment\">// = 1.0 / (edge1 - edge0)</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> precomputedOffset; <span class=\"comment\">// = -edge0 / (edge1 - edge0)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> optimizedSmoothstep(<span class=\"type\">float</span> x) &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> t = <span class=\"built_in\">clamp</span>(x * precomputedRange + precomputedOffset, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t * t * (<span class=\"number\">3.0</span> - <span class=\"number\">2.0</span> * t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"调试技巧\"><a href=\"#调试技巧\" class=\"headerlink\" title=\"调试技巧\"></a>调试技巧</h3><h4 id=\"1-可视化smoothstep曲线\"><a href=\"#1-可视化smoothstep曲线\" class=\"headerlink\" title=\"1. 可视化smoothstep曲线\"></a>1. 可视化smoothstep曲线</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">vec2</span> uv = <span class=\"built_in\">gl_FragCoord</span>.xy / resolution.xy;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 绘制函数曲线</span></span><br><span class=\"line\">    <span class=\"type\">float</span> x = uv.x;</span><br><span class=\"line\">    <span class=\"type\">float</span> y = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.2</span>, <span class=\"number\">0.8</span>, x);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 显示曲线</span></span><br><span class=\"line\">    <span class=\"type\">float</span> line = <span class=\"built_in\">abs</span>(uv.y - y) &lt; <span class=\"number\">0.01</span> ? <span class=\"number\">1.0</span> : <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(<span class=\"type\">vec3</span>(line), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-参数调试\"><a href=\"#2-参数调试\" class=\"headerlink\" title=\"2. 参数调试\"></a>2. 参数调试</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> debugEdge0;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> debugEdge1;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> debugInput;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> result = <span class=\"built_in\">smoothstep</span>(debugEdge0, debugEdge1, debugInput);</span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(<span class=\"type\">vec3</span>(result), <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常见问题和解决方案\"><a href=\"#常见问题和解决方案\" class=\"headerlink\" title=\"常见问题和解决方案\"></a>常见问题和解决方案</h3><h4 id=\"1-边界值相等\"><a href=\"#1-边界值相等\" class=\"headerlink\" title=\"1. 边界值相等\"></a>1. 边界值相等</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误：edge0 == edge1会导致除零</span></span><br><span class=\"line\"><span class=\"type\">float</span> bad = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解决：确保边界值不同</span></span><br><span class=\"line\"><span class=\"type\">float</span> safe = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span> + <span class=\"number\">0.001</span>, x);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-参数顺序\"><a href=\"#2-参数顺序\" class=\"headerlink\" title=\"2. 参数顺序\"></a>2. 参数顺序</h4><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意：edge0应该小于edge1</span></span><br><span class=\"line\"><span class=\"type\">float</span> correct = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.2</span>, <span class=\"number\">0.8</span>, x);   <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"type\">float</span> incorrect = <span class=\"built_in\">smoothstep</span>(<span class=\"number\">0.8</span>, <span class=\"number\">0.2</span>, x); <span class=\"comment\">// 结果会反转</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>smoothstep函数是GLSL中一个强大而优雅的工具，它提供了：</p>\n<ol>\n<li><strong>数学上的优美性</strong>: S形曲线确保平滑过渡</li>\n<li><strong>实用性</strong>: 广泛适用于各种图形效果</li>\n<li><strong>性能</strong>: 硬件优化的内置实现</li>\n<li><strong>灵活性</strong>: 支持标量和向量操作</li>\n</ol>\n<p>掌握smoothstep函数的使用技巧，能够显著提升shader编程的效果和效率。无论是创建艺术效果还是解决实际的渲染问题，smoothstep都是不可或缺的工具。</p>\n<h3 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h3><ul>\n<li><a href=\"https://www.khronos.org/registry/OpenGL-Refpages/\">OpenGL官方文档 - smoothstep</a></li>\n<li><a href=\"https://www.shadertoy.com/\">Shadertoy</a> - 在线shader编辑器</li>\n<li><a href=\"https://thebookofshaders.com/\">The Book of Shaders</a> - shader学习资源</li>\n<li><a href=\"https://www.khronos.org/files/opengles_shading_language.pdf\">GLSL规范</a> </li>\n</ul>"},{"title":"C++11 委托构造函数和继承构造函数","date":"2025-06-24T08:30:00.000Z","_content":"\n## C++11 委托构造函数和继承构造函数\n\nC++11 引入了两个重要的构造函数特性：委托构造函数（Delegating Constructors）和继承构造函数（Inheriting Constructors）。这两个特性都旨在减少代码重复，提高代码的可维护性和可读性。\n\n### 委托构造函数（Delegating Constructors）\n\n委托构造函数允许一个构造函数调用同一个类的另一个构造函数，从而避免在多个构造函数中重复相同的初始化代码。\n\n#### 基本语法\n\n```cpp\nclass MyClass {\nprivate:\n    int x, y;\n    std::string name;\n\npublic:\n    // 主构造函数\n    MyClass(int x, int y, const std::string& name) \n        : x(x), y(y), name(name) {\n        std::cout << \"主构造函数被调用\" << std::endl;\n        // 其他复杂的初始化逻辑\n    }\n    \n    // 委托构造函数 - 委托给主构造函数\n    MyClass(int x, int y) : MyClass(x, y, \"default\") {\n        std::cout << \"委托构造函数1被调用\" << std::endl;\n    }\n    \n    // 委托构造函数 - 委托给主构造函数\n    MyClass() : MyClass(0, 0, \"empty\") {\n        std::cout << \"委托构造函数2被调用\" << std::endl;\n    }\n};\n```\n\n#### 委托构造函数的执行顺序\n\n```cpp\nclass Example {\nprivate:\n    int value;\n\npublic:\n    Example(int v) : value(v) {\n        std::cout << \"1. 目标构造函数执行完成\" << std::endl;\n    }\n    \n    Example() : Example(42) {  // 委托给 Example(int)\n        std::cout << \"2. 委托构造函数体执行\" << std::endl;\n    }\n};\n\n// 使用示例\nExample obj;  // 输出：\n              // 1. 目标构造函数执行完成\n              // 2. 委托构造函数体执行\n```\n\n#### 注意事项\n\n1. **不能形成循环委托**：\n```cpp\nclass Bad {\npublic:\n    Bad(int x) : Bad() {}      // 错误：形成循环委托\n    Bad() : Bad(10) {}         // 错误：形成循环委托\n};\n```\n\n2. **委托构造函数不能同时使用成员初始化列表**：\n```cpp\nclass Invalid {\nprivate:\n    int x, y;\n\npublic:\n    Invalid(int a) : x(a), Invalid() {}  // 错误：不能同时委托和初始化成员\n};\n```\n\n#### 实际应用场景\n\n委托构造函数特别适用于需要多种初始化方式的类：\n\n```cpp\nclass Rectangle {\nprivate:\n    double width, height;\n    std::string color;\n\npublic:\n    // 完整构造函数\n    Rectangle(double w, double h, const std::string& c) \n        : width(w), height(h), color(c) {\n        validateDimensions();\n        initializeDefaults();\n    }\n    \n    // 正方形构造函数\n    Rectangle(double side) : Rectangle(side, side, \"white\") {}\n    \n    // 默认构造函数\n    Rectangle() : Rectangle(1.0, 1.0, \"white\") {}\n    \n    // 只指定颜色的构造函数\n    Rectangle(const std::string& c) : Rectangle(1.0, 1.0, c) {}\n\nprivate:\n    void validateDimensions() {\n        if (width <= 0 || height <= 0) {\n            throw std::invalid_argument(\"尺寸必须为正数\");\n        }\n    }\n    \n    void initializeDefaults() {\n        // 其他初始化逻辑\n    }\n};\n```\n\n### 继承构造函数（Inheriting Constructors）\n\n继承构造函数允许派生类直接继承基类的构造函数，而不需要在派生类中重新声明和定义它们。\n\n#### 基本语法\n\n```cpp\nclass Base {\npublic:\n    Base(int x) {\n        std::cout << \"Base(int): \" << x << std::endl;\n    }\n    \n    Base(int x, double y) {\n        std::cout << \"Base(int, double): \" << x << \", \" << y << std::endl;\n    }\n    \n    Base(const std::string& s) {\n        std::cout << \"Base(string): \" << s << std::endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    // 继承所有基类构造函数\n    using Base::Base;\n    \n    // 也可以定义自己的构造函数\n    Derived(bool flag) : Base(flag ? 1 : 0) {\n        std::cout << \"Derived(bool): \" << flag << std::endl;\n    }\n};\n\n// 使用示例\nint main() {\n    Derived d1(42);          // 调用继承的 Base(int)\n    Derived d2(3, 3.14);     // 调用继承的 Base(int, double)\n    Derived d3(\"hello\");     // 调用继承的 Base(string)\n    Derived d4(true);        // 调用 Derived(bool)\n    \n    return 0;\n}\n```\n\n#### 继承构造函数的特点\n\n1. **选择性继承**：\n```cpp\nclass Base {\npublic:\n    Base(int x) {}\n    Base(double y) {}\n    Base(int x, int y) {}\n};\n\nclass Derived : public Base {\npublic:\n    using Base::Base;  // 继承所有构造函数\n    \n    // 如果定义了相同签名的构造函数，会覆盖继承的版本\n    Derived(int x) : Base(x) {\n        std::cout << \"Derived 的 int 构造函数\" << std::endl;\n    }\n};\n```\n\n2. **与默认构造函数的关系**：\n```cpp\nclass Base {\npublic:\n    Base(int x) {}\n    // 注意：没有默认构造函数\n};\n\nclass Derived : public Base {\npublic:\n    using Base::Base;\n    // Derived 也不会有默认构造函数\n};\n\n// Derived d;  // 错误：没有默认构造函数\nDerived d(42);  // 正确\n```\n\n#### 实际应用场景\n\n继承构造函数在扩展现有类时特别有用：\n\n```cpp\n// 基础日志类\nclass Logger {\nprotected:\n    std::string prefix;\n    std::ofstream logFile;\n\npublic:\n    Logger(const std::string& filename) : logFile(filename) {}\n    \n    Logger(const std::string& filename, const std::string& prefix) \n        : logFile(filename), prefix(prefix) {}\n    \n    void log(const std::string& message) {\n        logFile << prefix << message << std::endl;\n    }\n};\n\n// 带时间戳的日志类\nclass TimestampLogger : public Logger {\npublic:\n    using Logger::Logger;  // 继承所有构造函数\n    \n    void log(const std::string& message) override {\n        auto now = std::chrono::system_clock::now();\n        auto time_t = std::chrono::system_clock::to_time_t(now);\n        \n        logFile << \"[\" << std::put_time(std::localtime(&time_t), \"%Y-%m-%d %H:%M:%S\") \n                << \"] \" << prefix << message << std::endl;\n    }\n};\n\n// 使用示例\nTimestampLogger logger1(\"app.log\");\nTimestampLogger logger2(\"debug.log\", \"[DEBUG] \");\n```\n\n### 组合使用委托构造函数和继承构造函数\n\n```cpp\nclass Base {\npublic:\n    Base(int x, int y) {\n        std::cout << \"Base(\" << x << \", \" << y << \")\" << std::endl;\n    }\n    \n    Base(int x) : Base(x, 0) {  // 委托构造函数\n        std::cout << \"Base(int) 委托完成\" << std::endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    using Base::Base;  // 继承构造函数\n    \n    // 自己的委托构造函数\n    Derived(const std::string& s) : Derived(std::stoi(s)) {\n        std::cout << \"Derived(string) 委托完成\" << std::endl;\n    }\n};\n\n// 使用示例\nDerived d1(42);        // 继承的构造函数 + 基类委托\nDerived d2(\"123\");     // 派生类委托 + 继承构造函数 + 基类委托\n```\n\n### 总结\n\n- **委托构造函数**：减少同一类中多个构造函数的代码重复\n- **继承构造函数**：简化派生类对基类构造函数的继承\n- 两者都提高了代码的可维护性和可读性\n- 在现代 C++ 开发中，应该充分利用这些特性来编写更清洁的代码\n\n这些特性使得 C++11 在构造函数设计方面更加灵活和强大，是现代 C++ 编程的重要工具。 ","source":"_posts/C++11委托构造函数和继承构造函数.md","raw":"---\ntitle: C++11 委托构造函数和继承构造函数\ndate: 2025-06-24 16:30:00\ntags: [C++11, 构造函数]\n---\n\n## C++11 委托构造函数和继承构造函数\n\nC++11 引入了两个重要的构造函数特性：委托构造函数（Delegating Constructors）和继承构造函数（Inheriting Constructors）。这两个特性都旨在减少代码重复，提高代码的可维护性和可读性。\n\n### 委托构造函数（Delegating Constructors）\n\n委托构造函数允许一个构造函数调用同一个类的另一个构造函数，从而避免在多个构造函数中重复相同的初始化代码。\n\n#### 基本语法\n\n```cpp\nclass MyClass {\nprivate:\n    int x, y;\n    std::string name;\n\npublic:\n    // 主构造函数\n    MyClass(int x, int y, const std::string& name) \n        : x(x), y(y), name(name) {\n        std::cout << \"主构造函数被调用\" << std::endl;\n        // 其他复杂的初始化逻辑\n    }\n    \n    // 委托构造函数 - 委托给主构造函数\n    MyClass(int x, int y) : MyClass(x, y, \"default\") {\n        std::cout << \"委托构造函数1被调用\" << std::endl;\n    }\n    \n    // 委托构造函数 - 委托给主构造函数\n    MyClass() : MyClass(0, 0, \"empty\") {\n        std::cout << \"委托构造函数2被调用\" << std::endl;\n    }\n};\n```\n\n#### 委托构造函数的执行顺序\n\n```cpp\nclass Example {\nprivate:\n    int value;\n\npublic:\n    Example(int v) : value(v) {\n        std::cout << \"1. 目标构造函数执行完成\" << std::endl;\n    }\n    \n    Example() : Example(42) {  // 委托给 Example(int)\n        std::cout << \"2. 委托构造函数体执行\" << std::endl;\n    }\n};\n\n// 使用示例\nExample obj;  // 输出：\n              // 1. 目标构造函数执行完成\n              // 2. 委托构造函数体执行\n```\n\n#### 注意事项\n\n1. **不能形成循环委托**：\n```cpp\nclass Bad {\npublic:\n    Bad(int x) : Bad() {}      // 错误：形成循环委托\n    Bad() : Bad(10) {}         // 错误：形成循环委托\n};\n```\n\n2. **委托构造函数不能同时使用成员初始化列表**：\n```cpp\nclass Invalid {\nprivate:\n    int x, y;\n\npublic:\n    Invalid(int a) : x(a), Invalid() {}  // 错误：不能同时委托和初始化成员\n};\n```\n\n#### 实际应用场景\n\n委托构造函数特别适用于需要多种初始化方式的类：\n\n```cpp\nclass Rectangle {\nprivate:\n    double width, height;\n    std::string color;\n\npublic:\n    // 完整构造函数\n    Rectangle(double w, double h, const std::string& c) \n        : width(w), height(h), color(c) {\n        validateDimensions();\n        initializeDefaults();\n    }\n    \n    // 正方形构造函数\n    Rectangle(double side) : Rectangle(side, side, \"white\") {}\n    \n    // 默认构造函数\n    Rectangle() : Rectangle(1.0, 1.0, \"white\") {}\n    \n    // 只指定颜色的构造函数\n    Rectangle(const std::string& c) : Rectangle(1.0, 1.0, c) {}\n\nprivate:\n    void validateDimensions() {\n        if (width <= 0 || height <= 0) {\n            throw std::invalid_argument(\"尺寸必须为正数\");\n        }\n    }\n    \n    void initializeDefaults() {\n        // 其他初始化逻辑\n    }\n};\n```\n\n### 继承构造函数（Inheriting Constructors）\n\n继承构造函数允许派生类直接继承基类的构造函数，而不需要在派生类中重新声明和定义它们。\n\n#### 基本语法\n\n```cpp\nclass Base {\npublic:\n    Base(int x) {\n        std::cout << \"Base(int): \" << x << std::endl;\n    }\n    \n    Base(int x, double y) {\n        std::cout << \"Base(int, double): \" << x << \", \" << y << std::endl;\n    }\n    \n    Base(const std::string& s) {\n        std::cout << \"Base(string): \" << s << std::endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    // 继承所有基类构造函数\n    using Base::Base;\n    \n    // 也可以定义自己的构造函数\n    Derived(bool flag) : Base(flag ? 1 : 0) {\n        std::cout << \"Derived(bool): \" << flag << std::endl;\n    }\n};\n\n// 使用示例\nint main() {\n    Derived d1(42);          // 调用继承的 Base(int)\n    Derived d2(3, 3.14);     // 调用继承的 Base(int, double)\n    Derived d3(\"hello\");     // 调用继承的 Base(string)\n    Derived d4(true);        // 调用 Derived(bool)\n    \n    return 0;\n}\n```\n\n#### 继承构造函数的特点\n\n1. **选择性继承**：\n```cpp\nclass Base {\npublic:\n    Base(int x) {}\n    Base(double y) {}\n    Base(int x, int y) {}\n};\n\nclass Derived : public Base {\npublic:\n    using Base::Base;  // 继承所有构造函数\n    \n    // 如果定义了相同签名的构造函数，会覆盖继承的版本\n    Derived(int x) : Base(x) {\n        std::cout << \"Derived 的 int 构造函数\" << std::endl;\n    }\n};\n```\n\n2. **与默认构造函数的关系**：\n```cpp\nclass Base {\npublic:\n    Base(int x) {}\n    // 注意：没有默认构造函数\n};\n\nclass Derived : public Base {\npublic:\n    using Base::Base;\n    // Derived 也不会有默认构造函数\n};\n\n// Derived d;  // 错误：没有默认构造函数\nDerived d(42);  // 正确\n```\n\n#### 实际应用场景\n\n继承构造函数在扩展现有类时特别有用：\n\n```cpp\n// 基础日志类\nclass Logger {\nprotected:\n    std::string prefix;\n    std::ofstream logFile;\n\npublic:\n    Logger(const std::string& filename) : logFile(filename) {}\n    \n    Logger(const std::string& filename, const std::string& prefix) \n        : logFile(filename), prefix(prefix) {}\n    \n    void log(const std::string& message) {\n        logFile << prefix << message << std::endl;\n    }\n};\n\n// 带时间戳的日志类\nclass TimestampLogger : public Logger {\npublic:\n    using Logger::Logger;  // 继承所有构造函数\n    \n    void log(const std::string& message) override {\n        auto now = std::chrono::system_clock::now();\n        auto time_t = std::chrono::system_clock::to_time_t(now);\n        \n        logFile << \"[\" << std::put_time(std::localtime(&time_t), \"%Y-%m-%d %H:%M:%S\") \n                << \"] \" << prefix << message << std::endl;\n    }\n};\n\n// 使用示例\nTimestampLogger logger1(\"app.log\");\nTimestampLogger logger2(\"debug.log\", \"[DEBUG] \");\n```\n\n### 组合使用委托构造函数和继承构造函数\n\n```cpp\nclass Base {\npublic:\n    Base(int x, int y) {\n        std::cout << \"Base(\" << x << \", \" << y << \")\" << std::endl;\n    }\n    \n    Base(int x) : Base(x, 0) {  // 委托构造函数\n        std::cout << \"Base(int) 委托完成\" << std::endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    using Base::Base;  // 继承构造函数\n    \n    // 自己的委托构造函数\n    Derived(const std::string& s) : Derived(std::stoi(s)) {\n        std::cout << \"Derived(string) 委托完成\" << std::endl;\n    }\n};\n\n// 使用示例\nDerived d1(42);        // 继承的构造函数 + 基类委托\nDerived d2(\"123\");     // 派生类委托 + 继承构造函数 + 基类委托\n```\n\n### 总结\n\n- **委托构造函数**：减少同一类中多个构造函数的代码重复\n- **继承构造函数**：简化派生类对基类构造函数的继承\n- 两者都提高了代码的可维护性和可读性\n- 在现代 C++ 开发中，应该充分利用这些特性来编写更清洁的代码\n\n这些特性使得 C++11 在构造函数设计方面更加灵活和强大，是现代 C++ 编程的重要工具。 ","slug":"C++11委托构造函数和继承构造函数","published":1,"updated":"2025-06-24T09:01:16.877Z","_id":"cmca8bv4200007ofyb87c6yek","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"C-11-委托构造函数和继承构造函数\"><a href=\"#C-11-委托构造函数和继承构造函数\" class=\"headerlink\" title=\"C++11 委托构造函数和继承构造函数\"></a>C++11 委托构造函数和继承构造函数</h2><p>C++11 引入了两个重要的构造函数特性：委托构造函数（Delegating Constructors）和继承构造函数（Inheriting Constructors）。这两个特性都旨在减少代码重复，提高代码的可维护性和可读性。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"委托构造函数（Delegating-Constructors）\"><a href=\"#委托构造函数（Delegating-Constructors）\" class=\"headerlink\" title=\"委托构造函数（Delegating Constructors）\"></a>委托构造函数（Delegating Constructors）</h3><p>委托构造函数允许一个构造函数调用同一个类的另一个构造函数，从而避免在多个构造函数中重复相同的初始化代码。</p>\n<h4 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    std::string name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 主构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">const</span> std::string&amp; name) </span><br><span class=\"line\">        : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y), <span class=\"built_in\">name</span>(name) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;主构造函数被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"comment\">// 其他复杂的初始化逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 委托构造函数 - 委托给主构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) : <span class=\"built_in\">MyClass</span>(x, y, <span class=\"string\">&quot;default&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;委托构造函数1被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 委托构造函数 - 委托给主构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>() : <span class=\"built_in\">MyClass</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;empty&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;委托构造函数2被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"委托构造函数的执行顺序\"><a href=\"#委托构造函数的执行顺序\" class=\"headerlink\" title=\"委托构造函数的执行顺序\"></a>委托构造函数的执行顺序</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Example</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Example</span>(<span class=\"type\">int</span> v) : <span class=\"built_in\">value</span>(v) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;1. 目标构造函数执行完成&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Example</span>() : <span class=\"built_in\">Example</span>(<span class=\"number\">42</span>) &#123;  <span class=\"comment\">// 委托给 Example(int)</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;2. 委托构造函数体执行&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用示例</span></span><br><span class=\"line\">Example obj;  <span class=\"comment\">// 输出：</span></span><br><span class=\"line\">              <span class=\"comment\">// 1. 目标构造函数执行完成</span></span><br><span class=\"line\">              <span class=\"comment\">// 2. 委托构造函数体执行</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ol>\n<li><p><strong>不能形成循环委托</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bad</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Bad</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">Bad</span>() &#123;&#125;      <span class=\"comment\">// 错误：形成循环委托</span></span><br><span class=\"line\">    <span class=\"built_in\">Bad</span>() : <span class=\"built_in\">Bad</span>(<span class=\"number\">10</span>) &#123;&#125;         <span class=\"comment\">// 错误：形成循环委托</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>委托构造函数不能同时使用成员初始化列表</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Invalid</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Invalid</span>(<span class=\"type\">int</span> a) : <span class=\"built_in\">x</span>(a), <span class=\"built_in\">Invalid</span>() &#123;&#125;  <span class=\"comment\">// 错误：不能同时委托和初始化成员</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"实际应用场景\"><a href=\"#实际应用场景\" class=\"headerlink\" title=\"实际应用场景\"></a>实际应用场景</h4><p>委托构造函数特别适用于需要多种初始化方式的类：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">double</span> width, height;</span><br><span class=\"line\">    std::string color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 完整构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Rectangle</span>(<span class=\"type\">double</span> w, <span class=\"type\">double</span> h, <span class=\"type\">const</span> std::string&amp; c) </span><br><span class=\"line\">        : <span class=\"built_in\">width</span>(w), <span class=\"built_in\">height</span>(h), <span class=\"built_in\">color</span>(c) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">validateDimensions</span>();</span><br><span class=\"line\">        <span class=\"built_in\">initializeDefaults</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 正方形构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Rectangle</span>(<span class=\"type\">double</span> side) : <span class=\"built_in\">Rectangle</span>(side, side, <span class=\"string\">&quot;white&quot;</span>) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Rectangle</span>() : <span class=\"built_in\">Rectangle</span>(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"string\">&quot;white&quot;</span>) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 只指定颜色的构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Rectangle</span>(<span class=\"type\">const</span> std::string&amp; c) : <span class=\"built_in\">Rectangle</span>(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, c) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">validateDimensions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (width &lt;= <span class=\"number\">0</span> || height &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> std::<span class=\"built_in\">invalid_argument</span>(<span class=\"string\">&quot;尺寸必须为正数&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">initializeDefaults</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 其他初始化逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承构造函数（Inheriting-Constructors）\"><a href=\"#继承构造函数（Inheriting-Constructors）\" class=\"headerlink\" title=\"继承构造函数（Inheriting Constructors）\"></a>继承构造函数（Inheriting Constructors）</h3><p>继承构造函数允许派生类直接继承基类的构造函数，而不需要在派生类中重新声明和定义它们。</p>\n<h4 id=\"基本语法-1\"><a href=\"#基本语法-1\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Base(int): &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x, <span class=\"type\">double</span> y) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Base(int, double): &quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">const</span> std::string&amp; s) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Base(string): &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 继承所有基类构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::Base;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 也可以定义自己的构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>(<span class=\"type\">bool</span> flag) : <span class=\"built_in\">Base</span>(flag ? <span class=\"number\">1</span> : <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Derived(bool): &quot;</span> &lt;&lt; flag &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用示例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d1</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;          <span class=\"comment\">// 调用继承的 Base(int)</span></span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d2</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">3.14</span>)</span></span>;     <span class=\"comment\">// 调用继承的 Base(int, double)</span></span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d3</span><span class=\"params\">(<span class=\"string\">&quot;hello&quot;</span>)</span></span>;     <span class=\"comment\">// 调用继承的 Base(string)</span></span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d4</span><span class=\"params\">(<span class=\"literal\">true</span>)</span></span>;        <span class=\"comment\">// 调用 Derived(bool)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"继承构造函数的特点\"><a href=\"#继承构造函数的特点\" class=\"headerlink\" title=\"继承构造函数的特点\"></a>继承构造函数的特点</h4><ol>\n<li><p><strong>选择性继承</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">double</span> y) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::Base;  <span class=\"comment\">// 继承所有构造函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果定义了相同签名的构造函数，会覆盖继承的版本</span></span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">Base</span>(x) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Derived 的 int 构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>与默认构造函数的关系</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x) &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：没有默认构造函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::Base;</span><br><span class=\"line\">    <span class=\"comment\">// Derived 也不会有默认构造函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Derived d;  // 错误：没有默认构造函数</span></span><br><span class=\"line\"><span class=\"function\">Derived <span class=\"title\">d</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;  <span class=\"comment\">// 正确</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"实际应用场景-1\"><a href=\"#实际应用场景-1\" class=\"headerlink\" title=\"实际应用场景\"></a>实际应用场景</h4><p>继承构造函数在扩展现有类时特别有用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基础日志类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    std::string prefix;</span><br><span class=\"line\">    std::ofstream logFile;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Logger</span>(<span class=\"type\">const</span> std::string&amp; filename) : <span class=\"built_in\">logFile</span>(filename) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Logger</span>(<span class=\"type\">const</span> std::string&amp; filename, <span class=\"type\">const</span> std::string&amp; prefix) </span><br><span class=\"line\">        : <span class=\"built_in\">logFile</span>(filename), <span class=\"built_in\">prefix</span>(prefix) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">log</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class=\"line\">        logFile &lt;&lt; prefix &lt;&lt; message &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 带时间戳的日志类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TimestampLogger</span> : <span class=\"keyword\">public</span> Logger &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Logger::Logger;  <span class=\"comment\">// 继承所有构造函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">log</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; message)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> now = std::chrono::system_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> <span class=\"type\">time_t</span> = std::chrono::system_clock::<span class=\"built_in\">to_time_t</span>(now);</span><br><span class=\"line\">        </span><br><span class=\"line\">        logFile &lt;&lt; <span class=\"string\">&quot;[&quot;</span> &lt;&lt; std::<span class=\"built_in\">put_time</span>(std::<span class=\"built_in\">localtime</span>(&amp;<span class=\"type\">time_t</span>), <span class=\"string\">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) </span><br><span class=\"line\">                &lt;&lt; <span class=\"string\">&quot;] &quot;</span> &lt;&lt; prefix &lt;&lt; message &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用示例</span></span><br><span class=\"line\"><span class=\"function\">TimestampLogger <span class=\"title\">logger1</span><span class=\"params\">(<span class=\"string\">&quot;app.log&quot;</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">TimestampLogger <span class=\"title\">logger2</span><span class=\"params\">(<span class=\"string\">&quot;debug.log&quot;</span>, <span class=\"string\">&quot;[DEBUG] &quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组合使用委托构造函数和继承构造函数\"><a href=\"#组合使用委托构造函数和继承构造函数\" class=\"headerlink\" title=\"组合使用委托构造函数和继承构造函数\"></a>组合使用委托构造函数和继承构造函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Base(&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class=\"string\">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">Base</span>(x, <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 委托构造函数</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Base(int) 委托完成&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::Base;  <span class=\"comment\">// 继承构造函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 自己的委托构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>(<span class=\"type\">const</span> std::string&amp; s) : <span class=\"built_in\">Derived</span>(std::<span class=\"built_in\">stoi</span>(s)) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Derived(string) 委托完成&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用示例</span></span><br><span class=\"line\"><span class=\"function\">Derived <span class=\"title\">d1</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;        <span class=\"comment\">// 继承的构造函数 + 基类委托</span></span><br><span class=\"line\"><span class=\"function\">Derived <span class=\"title\">d2</span><span class=\"params\">(<span class=\"string\">&quot;123&quot;</span>)</span></span>;     <span class=\"comment\">// 派生类委托 + 继承构造函数 + 基类委托</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>委托构造函数</strong>：减少同一类中多个构造函数的代码重复</li>\n<li><strong>继承构造函数</strong>：简化派生类对基类构造函数的继承</li>\n<li>两者都提高了代码的可维护性和可读性</li>\n<li>在现代 C++ 开发中，应该充分利用这些特性来编写更清洁的代码</li>\n</ul>\n<p>这些特性使得 C++11 在构造函数设计方面更加灵活和强大，是现代 C++ 编程的重要工具。 </p>\n","site":{"data":{}},"excerpt":"<h2 id=\"C-11-委托构造函数和继承构造函数\"><a href=\"#C-11-委托构造函数和继承构造函数\" class=\"headerlink\" title=\"C++11 委托构造函数和继承构造函数\"></a>C++11 委托构造函数和继承构造函数</h2><p>C++11 引入了两个重要的构造函数特性：委托构造函数（Delegating Constructors）和继承构造函数（Inheriting Constructors）。这两个特性都旨在减少代码重复，提高代码的可维护性和可读性。</p>","more":"<h3 id=\"委托构造函数（Delegating-Constructors）\"><a href=\"#委托构造函数（Delegating-Constructors）\" class=\"headerlink\" title=\"委托构造函数（Delegating Constructors）\"></a>委托构造函数（Delegating Constructors）</h3><p>委托构造函数允许一个构造函数调用同一个类的另一个构造函数，从而避免在多个构造函数中重复相同的初始化代码。</p>\n<h4 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    std::string name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 主构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">const</span> std::string&amp; name) </span><br><span class=\"line\">        : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y), <span class=\"built_in\">name</span>(name) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;主构造函数被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"comment\">// 其他复杂的初始化逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 委托构造函数 - 委托给主构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) : <span class=\"built_in\">MyClass</span>(x, y, <span class=\"string\">&quot;default&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;委托构造函数1被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 委托构造函数 - 委托给主构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>() : <span class=\"built_in\">MyClass</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;empty&quot;</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;委托构造函数2被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"委托构造函数的执行顺序\"><a href=\"#委托构造函数的执行顺序\" class=\"headerlink\" title=\"委托构造函数的执行顺序\"></a>委托构造函数的执行顺序</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Example</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Example</span>(<span class=\"type\">int</span> v) : <span class=\"built_in\">value</span>(v) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;1. 目标构造函数执行完成&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Example</span>() : <span class=\"built_in\">Example</span>(<span class=\"number\">42</span>) &#123;  <span class=\"comment\">// 委托给 Example(int)</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;2. 委托构造函数体执行&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用示例</span></span><br><span class=\"line\">Example obj;  <span class=\"comment\">// 输出：</span></span><br><span class=\"line\">              <span class=\"comment\">// 1. 目标构造函数执行完成</span></span><br><span class=\"line\">              <span class=\"comment\">// 2. 委托构造函数体执行</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ol>\n<li><p><strong>不能形成循环委托</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bad</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Bad</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">Bad</span>() &#123;&#125;      <span class=\"comment\">// 错误：形成循环委托</span></span><br><span class=\"line\">    <span class=\"built_in\">Bad</span>() : <span class=\"built_in\">Bad</span>(<span class=\"number\">10</span>) &#123;&#125;         <span class=\"comment\">// 错误：形成循环委托</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>委托构造函数不能同时使用成员初始化列表</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Invalid</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Invalid</span>(<span class=\"type\">int</span> a) : <span class=\"built_in\">x</span>(a), <span class=\"built_in\">Invalid</span>() &#123;&#125;  <span class=\"comment\">// 错误：不能同时委托和初始化成员</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"实际应用场景\"><a href=\"#实际应用场景\" class=\"headerlink\" title=\"实际应用场景\"></a>实际应用场景</h4><p>委托构造函数特别适用于需要多种初始化方式的类：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">double</span> width, height;</span><br><span class=\"line\">    std::string color;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 完整构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Rectangle</span>(<span class=\"type\">double</span> w, <span class=\"type\">double</span> h, <span class=\"type\">const</span> std::string&amp; c) </span><br><span class=\"line\">        : <span class=\"built_in\">width</span>(w), <span class=\"built_in\">height</span>(h), <span class=\"built_in\">color</span>(c) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">validateDimensions</span>();</span><br><span class=\"line\">        <span class=\"built_in\">initializeDefaults</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 正方形构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Rectangle</span>(<span class=\"type\">double</span> side) : <span class=\"built_in\">Rectangle</span>(side, side, <span class=\"string\">&quot;white&quot;</span>) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Rectangle</span>() : <span class=\"built_in\">Rectangle</span>(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"string\">&quot;white&quot;</span>) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 只指定颜色的构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Rectangle</span>(<span class=\"type\">const</span> std::string&amp; c) : <span class=\"built_in\">Rectangle</span>(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, c) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">validateDimensions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (width &lt;= <span class=\"number\">0</span> || height &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> std::<span class=\"built_in\">invalid_argument</span>(<span class=\"string\">&quot;尺寸必须为正数&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">initializeDefaults</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 其他初始化逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承构造函数（Inheriting-Constructors）\"><a href=\"#继承构造函数（Inheriting-Constructors）\" class=\"headerlink\" title=\"继承构造函数（Inheriting Constructors）\"></a>继承构造函数（Inheriting Constructors）</h3><p>继承构造函数允许派生类直接继承基类的构造函数，而不需要在派生类中重新声明和定义它们。</p>\n<h4 id=\"基本语法-1\"><a href=\"#基本语法-1\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Base(int): &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x, <span class=\"type\">double</span> y) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Base(int, double): &quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">const</span> std::string&amp; s) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Base(string): &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 继承所有基类构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::Base;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 也可以定义自己的构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>(<span class=\"type\">bool</span> flag) : <span class=\"built_in\">Base</span>(flag ? <span class=\"number\">1</span> : <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Derived(bool): &quot;</span> &lt;&lt; flag &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用示例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d1</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;          <span class=\"comment\">// 调用继承的 Base(int)</span></span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d2</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">3.14</span>)</span></span>;     <span class=\"comment\">// 调用继承的 Base(int, double)</span></span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d3</span><span class=\"params\">(<span class=\"string\">&quot;hello&quot;</span>)</span></span>;     <span class=\"comment\">// 调用继承的 Base(string)</span></span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d4</span><span class=\"params\">(<span class=\"literal\">true</span>)</span></span>;        <span class=\"comment\">// 调用 Derived(bool)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"继承构造函数的特点\"><a href=\"#继承构造函数的特点\" class=\"headerlink\" title=\"继承构造函数的特点\"></a>继承构造函数的特点</h4><ol>\n<li><p><strong>选择性继承</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">double</span> y) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::Base;  <span class=\"comment\">// 继承所有构造函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果定义了相同签名的构造函数，会覆盖继承的版本</span></span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">Base</span>(x) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Derived 的 int 构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>与默认构造函数的关系</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x) &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：没有默认构造函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::Base;</span><br><span class=\"line\">    <span class=\"comment\">// Derived 也不会有默认构造函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Derived d;  // 错误：没有默认构造函数</span></span><br><span class=\"line\"><span class=\"function\">Derived <span class=\"title\">d</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;  <span class=\"comment\">// 正确</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"实际应用场景-1\"><a href=\"#实际应用场景-1\" class=\"headerlink\" title=\"实际应用场景\"></a>实际应用场景</h4><p>继承构造函数在扩展现有类时特别有用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基础日志类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    std::string prefix;</span><br><span class=\"line\">    std::ofstream logFile;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Logger</span>(<span class=\"type\">const</span> std::string&amp; filename) : <span class=\"built_in\">logFile</span>(filename) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Logger</span>(<span class=\"type\">const</span> std::string&amp; filename, <span class=\"type\">const</span> std::string&amp; prefix) </span><br><span class=\"line\">        : <span class=\"built_in\">logFile</span>(filename), <span class=\"built_in\">prefix</span>(prefix) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">log</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class=\"line\">        logFile &lt;&lt; prefix &lt;&lt; message &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 带时间戳的日志类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TimestampLogger</span> : <span class=\"keyword\">public</span> Logger &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Logger::Logger;  <span class=\"comment\">// 继承所有构造函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">log</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; message)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> now = std::chrono::system_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> <span class=\"type\">time_t</span> = std::chrono::system_clock::<span class=\"built_in\">to_time_t</span>(now);</span><br><span class=\"line\">        </span><br><span class=\"line\">        logFile &lt;&lt; <span class=\"string\">&quot;[&quot;</span> &lt;&lt; std::<span class=\"built_in\">put_time</span>(std::<span class=\"built_in\">localtime</span>(&amp;<span class=\"type\">time_t</span>), <span class=\"string\">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) </span><br><span class=\"line\">                &lt;&lt; <span class=\"string\">&quot;] &quot;</span> &lt;&lt; prefix &lt;&lt; message &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用示例</span></span><br><span class=\"line\"><span class=\"function\">TimestampLogger <span class=\"title\">logger1</span><span class=\"params\">(<span class=\"string\">&quot;app.log&quot;</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">TimestampLogger <span class=\"title\">logger2</span><span class=\"params\">(<span class=\"string\">&quot;debug.log&quot;</span>, <span class=\"string\">&quot;[DEBUG] &quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组合使用委托构造函数和继承构造函数\"><a href=\"#组合使用委托构造函数和继承构造函数\" class=\"headerlink\" title=\"组合使用委托构造函数和继承构造函数\"></a>组合使用委托构造函数和继承构造函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Base(&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class=\"string\">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">Base</span>(x, <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 委托构造函数</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Base(int) 委托完成&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::Base;  <span class=\"comment\">// 继承构造函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 自己的委托构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>(<span class=\"type\">const</span> std::string&amp; s) : <span class=\"built_in\">Derived</span>(std::<span class=\"built_in\">stoi</span>(s)) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Derived(string) 委托完成&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用示例</span></span><br><span class=\"line\"><span class=\"function\">Derived <span class=\"title\">d1</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;        <span class=\"comment\">// 继承的构造函数 + 基类委托</span></span><br><span class=\"line\"><span class=\"function\">Derived <span class=\"title\">d2</span><span class=\"params\">(<span class=\"string\">&quot;123&quot;</span>)</span></span>;     <span class=\"comment\">// 派生类委托 + 继承构造函数 + 基类委托</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>委托构造函数</strong>：减少同一类中多个构造函数的代码重复</li>\n<li><strong>继承构造函数</strong>：简化派生类对基类构造函数的继承</li>\n<li>两者都提高了代码的可维护性和可读性</li>\n<li>在现代 C++ 开发中，应该充分利用这些特性来编写更清洁的代码</li>\n</ul>\n<p>这些特性使得 C++11 在构造函数设计方面更加灵活和强大，是现代 C++ 编程的重要工具。 </p>"},{"title":"HSV颜色空间和插值优势详解","date":"2025-06-24T09:00:00.000Z","_content":"\n## HSV颜色空间和插值优势详解\n\n在计算机图形学和图像处理中，颜色空间的选择对最终效果有着重要影响。本文将深入探讨 HSV 颜色空间的特点，以及为什么在颜色插值时，HSV 比传统的 RGB 能产生更自然、更符合人眼感知的效果。\n\n### 什么是HSV颜色空间\n\nHSV 颜色空间是一种基于人类视觉感知设计的颜色模型，它将颜色分解为三个组件：\n\n- **H (Hue) - 色相**：表示颜色的基本色调，取值范围 0°-360°\n- **S (Saturation) - 饱和度**：表示颜色的纯度，取值范围 0-100%\n- **V (Value) - 明度**：表示颜色的亮度，取值范围 0-100%\n\n#### HSV的几何表示\n\n![HSV颜色空间圆柱体](https://upload.wikimedia.org/wikipedia/commons/4/4e/HSV_color_solid_cylinder.png)\n\n*图：HSV 颜色空间的圆柱体表示法*\n\nHSV 颜色空间通常用圆柱体来表示，具有以下特征：\n\n- **垂直轴（明度轴）**：从底部的黑色（V=0%）到顶部的白色（V=100%）\n- **角度（色相环）**：围绕中心轴的角度表示不同色相\n- **半径（饱和度）**：从中心轴到边缘的距离表示饱和度\n\n#### HSV各分量的意义\n\n1. **色相 (Hue)**：\n   - 0° = 红色\n   - 60° = 黄色\n   - 120° = 绿色\n   - 180° = 青色\n   - 240° = 蓝色\n   - 300° = 洋红色\n\n2. **饱和度 (Saturation)**：\n   - 0% = 灰色（无彩色）\n   - 100% = 纯色（最鲜艳）\n\n3. **明度 (Value)**：\n   - 0% = 黑色\n   - 100% = 最亮状态\n\n### RGB vs HSV：直观对比\n\n```cpp\n// RGB 表示法\nstruct RGB {\n    float r, g, b;  // 范围 [0, 1]\n};\n\n// HSV 表示法\nstruct HSV {\n    float h;  // 色相，范围 [0, 360]\n    float s;  // 饱和度，范围 [0, 1]\n    float v;  // 明度，范围 [0, 1]\n};\n\n// 一些颜色的对比\nRGB red = {1.0f, 0.0f, 0.0f};\nHSV red_hsv = {0.0f, 1.0f, 1.0f};\n\nRGB green = {0.0f, 1.0f, 0.0f};\nHSV green_hsv = {120.0f, 1.0f, 1.0f};\n\nRGB blue = {0.0f, 0.0f, 1.0f};\nHSV blue_hsv = {240.0f, 1.0f, 1.0f};\n```\n\n### RGB颜色插值的问题\n\n#### 问题1：路径不直观\n\n当我们在 RGB 空间中从红色插值到绿色时：\n\n```cpp\n// RGB 插值：从红色到绿色\nRGB interpolateRGB(float t) {\n    RGB red = {1.0f, 0.0f, 0.0f};\n    RGB green = {0.0f, 1.0f, 0.0f};\n    \n    return {\n        red.r + t * (green.r - red.r),  // 1.0 → 0.0\n        red.g + t * (green.g - red.g),  // 0.0 → 1.0\n        red.b + t * (green.b - red.b)   // 0.0 → 0.0\n    };\n}\n```\n\n在 RGB 空间中，从红色到绿色的插值路径会经过暗色区域，产生不自然的中间色：\n\n```\nt=0.0: RGB(1.0, 0.0, 0.0) → 鲜红色\nt=0.5: RGB(0.5, 0.5, 0.0) → 暗黄色 (不理想!)\nt=1.0: RGB(0.0, 1.0, 0.0) → 鲜绿色\n```\n\n#### 问题2：亮度变化不均匀\n\nRGB 插值可能导致中间颜色的亮度出现非预期的变化，因为 RGB 三个分量对人眼亮度的贡献不相等。\n\n#### 问题3：违反人眼感知\n\n人眼对颜色的感知更接近 HSV 模型，RGB 插值产生的中间色可能看起来不自然。\n\n### HSV颜色插值的优势\n\n#### 优势1：符合直觉的颜色过渡\n\n```cpp\n// HSV 插值：从红色到绿色\nHSV interpolateHSV(float t) {\n    HSV red = {0.0f, 1.0f, 1.0f};\n    HSV green = {120.0f, 1.0f, 1.0f};\n    \n    // 色相插值需要考虑圆形特性\n    float hue = red.h + t * (green.h - red.h);\n    \n    return {\n        hue,                                    // 0° → 120°\n        red.s + t * (green.s - red.s),         // 1.0 → 1.0 (不变)\n        red.v + t * (green.v - red.v)          // 1.0 → 1.0 (不变)\n    };\n}\n```\n\nHSV 插值的结果：\n```\nt=0.0: HSV(0°, 100%, 100%) → 鲜红色\nt=0.5: HSV(60°, 100%, 100%) → 鲜黄色 (自然!)\nt=1.0: HSV(120°, 100%, 100%) → 鲜绿色\n```\n\n#### 优势2：可控的亮度变化\n\n在 HSV 空间中，我们可以独立控制亮度，确保过渡过程中亮度变化符合预期：\n\n```cpp\nHSV interpolateHSVWithBrightness(float t, float startV, float endV) {\n    HSV start = {0.0f, 1.0f, startV};\n    HSV end = {120.0f, 1.0f, endV};\n    \n    return {\n        start.h + t * (end.h - start.h),\n        start.s + t * (end.s - start.s),\n        start.v + t * (end.v - start.v)  // 可控的亮度变化\n    };\n}\n```\n\n#### 优势3：处理色相环的连续性\n\n色相是圆形的，从 350° 到 10° 应该是短路径，而不是经过整个色相环：\n\n```cpp\nfloat interpolateHue(float h1, float h2, float t) {\n    float diff = h2 - h1;\n    \n    // 处理色相环的连续性\n    if (diff > 180.0f) {\n        diff -= 360.0f;\n    } else if (diff < -180.0f) {\n        diff += 360.0f;\n    }\n    \n    float result = h1 + t * diff;\n    \n    // 确保结果在 [0, 360) 范围内\n    if (result < 0.0f) result += 360.0f;\n    if (result >= 360.0f) result -= 360.0f;\n    \n    return result;\n}\n```\n\n### 实用的HSV插值实现\n\n#### 完整的HSV插值函数\n\n```cpp\n#include <cmath>\n#include <algorithm>\n\n// RGB 到 HSV 转换\nHSV rgbToHsv(const RGB& rgb) {\n    float max_val = std::max({rgb.r, rgb.g, rgb.b});\n    float min_val = std::min({rgb.r, rgb.g, rgb.b});\n    float delta = max_val - min_val;\n    \n    HSV hsv;\n    hsv.v = max_val;\n    hsv.s = (max_val == 0.0f) ? 0.0f : delta / max_val;\n    \n    if (delta == 0.0f) {\n        hsv.h = 0.0f;\n    } else {\n        if (max_val == rgb.r) {\n            hsv.h = 60.0f * (fmod((rgb.g - rgb.b) / delta, 6.0f));\n        } else if (max_val == rgb.g) {\n            hsv.h = 60.0f * ((rgb.b - rgb.r) / delta + 2.0f);\n        } else {\n            hsv.h = 60.0f * ((rgb.r - rgb.g) / delta + 4.0f);\n        }\n    }\n    \n    if (hsv.h < 0.0f) hsv.h += 360.0f;\n    \n    return hsv;\n}\n\n// HSV 到 RGB 转换\nRGB hsvToRgb(const HSV& hsv) {\n    float c = hsv.v * hsv.s;\n    float x = c * (1.0f - abs(fmod(hsv.h / 60.0f, 2.0f) - 1.0f));\n    float m = hsv.v - c;\n    \n    RGB rgb;\n    \n    if (hsv.h >= 0.0f && hsv.h < 60.0f) {\n        rgb = {c, x, 0.0f};\n    } else if (hsv.h >= 60.0f && hsv.h < 120.0f) {\n        rgb = {x, c, 0.0f};\n    } else if (hsv.h >= 120.0f && hsv.h < 180.0f) {\n        rgb = {0.0f, c, x};\n    } else if (hsv.h >= 180.0f && hsv.h < 240.0f) {\n        rgb = {0.0f, x, c};\n    } else if (hsv.h >= 240.0f && hsv.h < 300.0f) {\n        rgb = {x, 0.0f, c};\n    } else {\n        rgb = {c, 0.0f, x};\n    }\n    \n    rgb.r += m;\n    rgb.g += m;\n    rgb.b += m;\n    \n    return rgb;\n}\n\n// HSV 空间中的插值\nHSV interpolateHSV(const HSV& start, const HSV& end, float t) {\n    HSV result;\n    \n    // 色相插值（考虑圆形特性）\n    result.h = interpolateHue(start.h, end.h, t);\n    \n    // 饱和度和明度的线性插值\n    result.s = start.s + t * (end.s - start.s);\n    result.v = start.v + t * (end.v - start.v);\n    \n    return result;\n}\n\n// 便利函数：RGB 空间的 HSV 插值\nRGB interpolateRGBviaHSV(const RGB& start, const RGB& end, float t) {\n    HSV startHSV = rgbToHsv(start);\n    HSV endHSV = rgbToHsv(end);\n    HSV interpolatedHSV = interpolateHSV(startHSV, endHSV, t);\n    return hsvToRgb(interpolatedHSV);\n}\n```\n\n### 实际应用场景\n\n#### 1. 用户界面渐变\n\n```cpp\n// 创建彩虹渐变\nstd::vector<RGB> createRainbowGradient(int steps) {\n    std::vector<RGB> gradient;\n    \n    for (int i = 0; i < steps; ++i) {\n        float t = static_cast<float>(i) / (steps - 1);\n        HSV hsv = {t * 360.0f, 1.0f, 1.0f};  // 遍历整个色相环\n        gradient.push_back(hsvToRgb(hsv));\n    }\n    \n    return gradient;\n}\n```\n\n#### 2. 数据可视化\n\n```cpp\n// 热力图颜色映射\nRGB getHeatmapColor(float value) {  // value 在 [0, 1] 范围内\n    HSV cold = {240.0f, 1.0f, 1.0f};  // 蓝色\n    HSV hot = {0.0f, 1.0f, 1.0f};     // 红色\n    \n    HSV interpolated = interpolateHSV(cold, hot, value);\n    return hsvToRgb(interpolated);\n}\n```\n\n#### 3. 游戏开发中的颜色效果\n\n```cpp\n// 日夜循环颜色变化\nRGB getDayNightColor(float timeOfDay) {  // 0.0 = 午夜, 0.5 = 正午\n    HSV night = {240.0f, 0.8f, 0.2f};    // 深蓝色\n    HSV day = {60.0f, 0.3f, 1.0f};       // 明黄色\n    \n    float t = 0.5f * (1.0f + sin(timeOfDay * 2.0f * M_PI));\n    HSV current = interpolateHSV(night, day, t);\n    return hsvToRgb(current);\n}\n```\n\n### 性能考虑\n\n虽然 HSV 插值在视觉效果上更优，但需要额外的颜色空间转换：\n\n```cpp\n// 优化：预计算 HSV 值\nclass ColorInterpolator {\nprivate:\n    HSV startHSV, endHSV;\n    \npublic:\n    ColorInterpolator(const RGB& start, const RGB& end) \n        : startHSV(rgbToHsv(start)), endHSV(rgbToHsv(end)) {}\n    \n    RGB interpolate(float t) const {\n        HSV interpolated = interpolateHSV(startHSV, endHSV, t);\n        return hsvToRgb(interpolated);\n    }\n};\n```\n\n### 总结\n\nHSV 颜色空间相比 RGB 在插值应用中具有明显优势：\n\n1. **更自然的过渡**：符合人眼对颜色变化的感知\n2. **可控的亮度**：可以独立控制亮度变化\n3. **直观的参数**：色相、饱和度、明度更容易理解和调整\n4. **更好的视觉效果**：避免了 RGB 插值中的暗色区域问题\n\n在需要高质量颜色过渡的应用中，如用户界面设计、数据可视化、游戏开发等领域，HSV 插值是比 RGB 插值更好的选择。虽然需要额外的计算开销，但现代硬件的性能足以支持这种转换，而获得的视觉效果提升是非常值得的。 ","source":"_posts/HSV颜色空间和插值优势详解.md","raw":"---\ntitle: HSV颜色空间和插值优势详解\ndate: 2025-06-24 17:00:00\ntags: [计算机图形学, 颜色空间, 插值算法]\n---\n\n## HSV颜色空间和插值优势详解\n\n在计算机图形学和图像处理中，颜色空间的选择对最终效果有着重要影响。本文将深入探讨 HSV 颜色空间的特点，以及为什么在颜色插值时，HSV 比传统的 RGB 能产生更自然、更符合人眼感知的效果。\n\n### 什么是HSV颜色空间\n\nHSV 颜色空间是一种基于人类视觉感知设计的颜色模型，它将颜色分解为三个组件：\n\n- **H (Hue) - 色相**：表示颜色的基本色调，取值范围 0°-360°\n- **S (Saturation) - 饱和度**：表示颜色的纯度，取值范围 0-100%\n- **V (Value) - 明度**：表示颜色的亮度，取值范围 0-100%\n\n#### HSV的几何表示\n\n![HSV颜色空间圆柱体](https://upload.wikimedia.org/wikipedia/commons/4/4e/HSV_color_solid_cylinder.png)\n\n*图：HSV 颜色空间的圆柱体表示法*\n\nHSV 颜色空间通常用圆柱体来表示，具有以下特征：\n\n- **垂直轴（明度轴）**：从底部的黑色（V=0%）到顶部的白色（V=100%）\n- **角度（色相环）**：围绕中心轴的角度表示不同色相\n- **半径（饱和度）**：从中心轴到边缘的距离表示饱和度\n\n#### HSV各分量的意义\n\n1. **色相 (Hue)**：\n   - 0° = 红色\n   - 60° = 黄色\n   - 120° = 绿色\n   - 180° = 青色\n   - 240° = 蓝色\n   - 300° = 洋红色\n\n2. **饱和度 (Saturation)**：\n   - 0% = 灰色（无彩色）\n   - 100% = 纯色（最鲜艳）\n\n3. **明度 (Value)**：\n   - 0% = 黑色\n   - 100% = 最亮状态\n\n### RGB vs HSV：直观对比\n\n```cpp\n// RGB 表示法\nstruct RGB {\n    float r, g, b;  // 范围 [0, 1]\n};\n\n// HSV 表示法\nstruct HSV {\n    float h;  // 色相，范围 [0, 360]\n    float s;  // 饱和度，范围 [0, 1]\n    float v;  // 明度，范围 [0, 1]\n};\n\n// 一些颜色的对比\nRGB red = {1.0f, 0.0f, 0.0f};\nHSV red_hsv = {0.0f, 1.0f, 1.0f};\n\nRGB green = {0.0f, 1.0f, 0.0f};\nHSV green_hsv = {120.0f, 1.0f, 1.0f};\n\nRGB blue = {0.0f, 0.0f, 1.0f};\nHSV blue_hsv = {240.0f, 1.0f, 1.0f};\n```\n\n### RGB颜色插值的问题\n\n#### 问题1：路径不直观\n\n当我们在 RGB 空间中从红色插值到绿色时：\n\n```cpp\n// RGB 插值：从红色到绿色\nRGB interpolateRGB(float t) {\n    RGB red = {1.0f, 0.0f, 0.0f};\n    RGB green = {0.0f, 1.0f, 0.0f};\n    \n    return {\n        red.r + t * (green.r - red.r),  // 1.0 → 0.0\n        red.g + t * (green.g - red.g),  // 0.0 → 1.0\n        red.b + t * (green.b - red.b)   // 0.0 → 0.0\n    };\n}\n```\n\n在 RGB 空间中，从红色到绿色的插值路径会经过暗色区域，产生不自然的中间色：\n\n```\nt=0.0: RGB(1.0, 0.0, 0.0) → 鲜红色\nt=0.5: RGB(0.5, 0.5, 0.0) → 暗黄色 (不理想!)\nt=1.0: RGB(0.0, 1.0, 0.0) → 鲜绿色\n```\n\n#### 问题2：亮度变化不均匀\n\nRGB 插值可能导致中间颜色的亮度出现非预期的变化，因为 RGB 三个分量对人眼亮度的贡献不相等。\n\n#### 问题3：违反人眼感知\n\n人眼对颜色的感知更接近 HSV 模型，RGB 插值产生的中间色可能看起来不自然。\n\n### HSV颜色插值的优势\n\n#### 优势1：符合直觉的颜色过渡\n\n```cpp\n// HSV 插值：从红色到绿色\nHSV interpolateHSV(float t) {\n    HSV red = {0.0f, 1.0f, 1.0f};\n    HSV green = {120.0f, 1.0f, 1.0f};\n    \n    // 色相插值需要考虑圆形特性\n    float hue = red.h + t * (green.h - red.h);\n    \n    return {\n        hue,                                    // 0° → 120°\n        red.s + t * (green.s - red.s),         // 1.0 → 1.0 (不变)\n        red.v + t * (green.v - red.v)          // 1.0 → 1.0 (不变)\n    };\n}\n```\n\nHSV 插值的结果：\n```\nt=0.0: HSV(0°, 100%, 100%) → 鲜红色\nt=0.5: HSV(60°, 100%, 100%) → 鲜黄色 (自然!)\nt=1.0: HSV(120°, 100%, 100%) → 鲜绿色\n```\n\n#### 优势2：可控的亮度变化\n\n在 HSV 空间中，我们可以独立控制亮度，确保过渡过程中亮度变化符合预期：\n\n```cpp\nHSV interpolateHSVWithBrightness(float t, float startV, float endV) {\n    HSV start = {0.0f, 1.0f, startV};\n    HSV end = {120.0f, 1.0f, endV};\n    \n    return {\n        start.h + t * (end.h - start.h),\n        start.s + t * (end.s - start.s),\n        start.v + t * (end.v - start.v)  // 可控的亮度变化\n    };\n}\n```\n\n#### 优势3：处理色相环的连续性\n\n色相是圆形的，从 350° 到 10° 应该是短路径，而不是经过整个色相环：\n\n```cpp\nfloat interpolateHue(float h1, float h2, float t) {\n    float diff = h2 - h1;\n    \n    // 处理色相环的连续性\n    if (diff > 180.0f) {\n        diff -= 360.0f;\n    } else if (diff < -180.0f) {\n        diff += 360.0f;\n    }\n    \n    float result = h1 + t * diff;\n    \n    // 确保结果在 [0, 360) 范围内\n    if (result < 0.0f) result += 360.0f;\n    if (result >= 360.0f) result -= 360.0f;\n    \n    return result;\n}\n```\n\n### 实用的HSV插值实现\n\n#### 完整的HSV插值函数\n\n```cpp\n#include <cmath>\n#include <algorithm>\n\n// RGB 到 HSV 转换\nHSV rgbToHsv(const RGB& rgb) {\n    float max_val = std::max({rgb.r, rgb.g, rgb.b});\n    float min_val = std::min({rgb.r, rgb.g, rgb.b});\n    float delta = max_val - min_val;\n    \n    HSV hsv;\n    hsv.v = max_val;\n    hsv.s = (max_val == 0.0f) ? 0.0f : delta / max_val;\n    \n    if (delta == 0.0f) {\n        hsv.h = 0.0f;\n    } else {\n        if (max_val == rgb.r) {\n            hsv.h = 60.0f * (fmod((rgb.g - rgb.b) / delta, 6.0f));\n        } else if (max_val == rgb.g) {\n            hsv.h = 60.0f * ((rgb.b - rgb.r) / delta + 2.0f);\n        } else {\n            hsv.h = 60.0f * ((rgb.r - rgb.g) / delta + 4.0f);\n        }\n    }\n    \n    if (hsv.h < 0.0f) hsv.h += 360.0f;\n    \n    return hsv;\n}\n\n// HSV 到 RGB 转换\nRGB hsvToRgb(const HSV& hsv) {\n    float c = hsv.v * hsv.s;\n    float x = c * (1.0f - abs(fmod(hsv.h / 60.0f, 2.0f) - 1.0f));\n    float m = hsv.v - c;\n    \n    RGB rgb;\n    \n    if (hsv.h >= 0.0f && hsv.h < 60.0f) {\n        rgb = {c, x, 0.0f};\n    } else if (hsv.h >= 60.0f && hsv.h < 120.0f) {\n        rgb = {x, c, 0.0f};\n    } else if (hsv.h >= 120.0f && hsv.h < 180.0f) {\n        rgb = {0.0f, c, x};\n    } else if (hsv.h >= 180.0f && hsv.h < 240.0f) {\n        rgb = {0.0f, x, c};\n    } else if (hsv.h >= 240.0f && hsv.h < 300.0f) {\n        rgb = {x, 0.0f, c};\n    } else {\n        rgb = {c, 0.0f, x};\n    }\n    \n    rgb.r += m;\n    rgb.g += m;\n    rgb.b += m;\n    \n    return rgb;\n}\n\n// HSV 空间中的插值\nHSV interpolateHSV(const HSV& start, const HSV& end, float t) {\n    HSV result;\n    \n    // 色相插值（考虑圆形特性）\n    result.h = interpolateHue(start.h, end.h, t);\n    \n    // 饱和度和明度的线性插值\n    result.s = start.s + t * (end.s - start.s);\n    result.v = start.v + t * (end.v - start.v);\n    \n    return result;\n}\n\n// 便利函数：RGB 空间的 HSV 插值\nRGB interpolateRGBviaHSV(const RGB& start, const RGB& end, float t) {\n    HSV startHSV = rgbToHsv(start);\n    HSV endHSV = rgbToHsv(end);\n    HSV interpolatedHSV = interpolateHSV(startHSV, endHSV, t);\n    return hsvToRgb(interpolatedHSV);\n}\n```\n\n### 实际应用场景\n\n#### 1. 用户界面渐变\n\n```cpp\n// 创建彩虹渐变\nstd::vector<RGB> createRainbowGradient(int steps) {\n    std::vector<RGB> gradient;\n    \n    for (int i = 0; i < steps; ++i) {\n        float t = static_cast<float>(i) / (steps - 1);\n        HSV hsv = {t * 360.0f, 1.0f, 1.0f};  // 遍历整个色相环\n        gradient.push_back(hsvToRgb(hsv));\n    }\n    \n    return gradient;\n}\n```\n\n#### 2. 数据可视化\n\n```cpp\n// 热力图颜色映射\nRGB getHeatmapColor(float value) {  // value 在 [0, 1] 范围内\n    HSV cold = {240.0f, 1.0f, 1.0f};  // 蓝色\n    HSV hot = {0.0f, 1.0f, 1.0f};     // 红色\n    \n    HSV interpolated = interpolateHSV(cold, hot, value);\n    return hsvToRgb(interpolated);\n}\n```\n\n#### 3. 游戏开发中的颜色效果\n\n```cpp\n// 日夜循环颜色变化\nRGB getDayNightColor(float timeOfDay) {  // 0.0 = 午夜, 0.5 = 正午\n    HSV night = {240.0f, 0.8f, 0.2f};    // 深蓝色\n    HSV day = {60.0f, 0.3f, 1.0f};       // 明黄色\n    \n    float t = 0.5f * (1.0f + sin(timeOfDay * 2.0f * M_PI));\n    HSV current = interpolateHSV(night, day, t);\n    return hsvToRgb(current);\n}\n```\n\n### 性能考虑\n\n虽然 HSV 插值在视觉效果上更优，但需要额外的颜色空间转换：\n\n```cpp\n// 优化：预计算 HSV 值\nclass ColorInterpolator {\nprivate:\n    HSV startHSV, endHSV;\n    \npublic:\n    ColorInterpolator(const RGB& start, const RGB& end) \n        : startHSV(rgbToHsv(start)), endHSV(rgbToHsv(end)) {}\n    \n    RGB interpolate(float t) const {\n        HSV interpolated = interpolateHSV(startHSV, endHSV, t);\n        return hsvToRgb(interpolated);\n    }\n};\n```\n\n### 总结\n\nHSV 颜色空间相比 RGB 在插值应用中具有明显优势：\n\n1. **更自然的过渡**：符合人眼对颜色变化的感知\n2. **可控的亮度**：可以独立控制亮度变化\n3. **直观的参数**：色相、饱和度、明度更容易理解和调整\n4. **更好的视觉效果**：避免了 RGB 插值中的暗色区域问题\n\n在需要高质量颜色过渡的应用中，如用户界面设计、数据可视化、游戏开发等领域，HSV 插值是比 RGB 插值更好的选择。虽然需要额外的计算开销，但现代硬件的性能足以支持这种转换，而获得的视觉效果提升是非常值得的。 ","slug":"HSV颜色空间和插值优势详解","published":1,"updated":"2025-06-24T09:01:19.878Z","_id":"cmcaalwxr00002ocoba583r7u","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"HSV颜色空间和插值优势详解\"><a href=\"#HSV颜色空间和插值优势详解\" class=\"headerlink\" title=\"HSV颜色空间和插值优势详解\"></a>HSV颜色空间和插值优势详解</h2><p>在计算机图形学和图像处理中，颜色空间的选择对最终效果有着重要影响。本文将深入探讨 HSV 颜色空间的特点，以及为什么在颜色插值时，HSV 比传统的 RGB 能产生更自然、更符合人眼感知的效果。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"什么是HSV颜色空间\"><a href=\"#什么是HSV颜色空间\" class=\"headerlink\" title=\"什么是HSV颜色空间\"></a>什么是HSV颜色空间</h3><p>HSV 颜色空间是一种基于人类视觉感知设计的颜色模型，它将颜色分解为三个组件：</p>\n<ul>\n<li><strong>H (Hue) - 色相</strong>：表示颜色的基本色调，取值范围 0°-360°</li>\n<li><strong>S (Saturation) - 饱和度</strong>：表示颜色的纯度，取值范围 0-100%</li>\n<li><strong>V (Value) - 明度</strong>：表示颜色的亮度，取值范围 0-100%</li>\n</ul>\n<h4 id=\"HSV的几何表示\"><a href=\"#HSV的几何表示\" class=\"headerlink\" title=\"HSV的几何表示\"></a>HSV的几何表示</h4><p><img src=\"https://upload.wikimedia.org/wikipedia/commons/4/4e/HSV_color_solid_cylinder.png\" alt=\"HSV颜色空间圆柱体\"></p>\n<p><em>图：HSV 颜色空间的圆柱体表示法</em></p>\n<p>HSV 颜色空间通常用圆柱体来表示，具有以下特征：</p>\n<ul>\n<li><strong>垂直轴（明度轴）</strong>：从底部的黑色（V=0%）到顶部的白色（V=100%）</li>\n<li><strong>角度（色相环）</strong>：围绕中心轴的角度表示不同色相</li>\n<li><strong>半径（饱和度）</strong>：从中心轴到边缘的距离表示饱和度</li>\n</ul>\n<h4 id=\"HSV各分量的意义\"><a href=\"#HSV各分量的意义\" class=\"headerlink\" title=\"HSV各分量的意义\"></a>HSV各分量的意义</h4><ol>\n<li><p>**色相 (Hue)**：</p>\n<ul>\n<li>0° = 红色</li>\n<li>60° = 黄色</li>\n<li>120° = 绿色</li>\n<li>180° = 青色</li>\n<li>240° = 蓝色</li>\n<li>300° = 洋红色</li>\n</ul>\n</li>\n<li><p>**饱和度 (Saturation)**：</p>\n<ul>\n<li>0% = 灰色（无彩色）</li>\n<li>100% = 纯色（最鲜艳）</li>\n</ul>\n</li>\n<li><p>**明度 (Value)**：</p>\n<ul>\n<li>0% = 黑色</li>\n<li>100% = 最亮状态</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"RGB-vs-HSV：直观对比\"><a href=\"#RGB-vs-HSV：直观对比\" class=\"headerlink\" title=\"RGB vs HSV：直观对比\"></a>RGB vs HSV：直观对比</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// RGB 表示法</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">RGB</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> r, g, b;  <span class=\"comment\">// 范围 [0, 1]</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HSV 表示法</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">HSV</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> h;  <span class=\"comment\">// 色相，范围 [0, 360]</span></span><br><span class=\"line\">    <span class=\"type\">float</span> s;  <span class=\"comment\">// 饱和度，范围 [0, 1]</span></span><br><span class=\"line\">    <span class=\"type\">float</span> v;  <span class=\"comment\">// 明度，范围 [0, 1]</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一些颜色的对比</span></span><br><span class=\"line\">RGB red = &#123;<span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>&#125;;</span><br><span class=\"line\">HSV red_hsv = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">RGB green = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>&#125;;</span><br><span class=\"line\">HSV green_hsv = &#123;<span class=\"number\">120.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">RGB blue = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br><span class=\"line\">HSV blue_hsv = &#123;<span class=\"number\">240.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RGB颜色插值的问题\"><a href=\"#RGB颜色插值的问题\" class=\"headerlink\" title=\"RGB颜色插值的问题\"></a>RGB颜色插值的问题</h3><h4 id=\"问题1：路径不直观\"><a href=\"#问题1：路径不直观\" class=\"headerlink\" title=\"问题1：路径不直观\"></a>问题1：路径不直观</h4><p>当我们在 RGB 空间中从红色插值到绿色时：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// RGB 插值：从红色到绿色</span></span><br><span class=\"line\"><span class=\"function\">RGB <span class=\"title\">interpolateRGB</span><span class=\"params\">(<span class=\"type\">float</span> t)</span> </span>&#123;</span><br><span class=\"line\">    RGB red = &#123;<span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>&#125;;</span><br><span class=\"line\">    RGB green = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        red.r + t * (green.r - red.r),  <span class=\"comment\">// 1.0 → 0.0</span></span><br><span class=\"line\">        red.g + t * (green.g - red.g),  <span class=\"comment\">// 0.0 → 1.0</span></span><br><span class=\"line\">        red.b + t * (green.b - red.b)   <span class=\"comment\">// 0.0 → 0.0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 RGB 空间中，从红色到绿色的插值路径会经过暗色区域，产生不自然的中间色：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t=0.0: RGB(1.0, 0.0, 0.0) → 鲜红色</span><br><span class=\"line\">t=0.5: RGB(0.5, 0.5, 0.0) → 暗黄色 (不理想!)</span><br><span class=\"line\">t=1.0: RGB(0.0, 1.0, 0.0) → 鲜绿色</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"问题2：亮度变化不均匀\"><a href=\"#问题2：亮度变化不均匀\" class=\"headerlink\" title=\"问题2：亮度变化不均匀\"></a>问题2：亮度变化不均匀</h4><p>RGB 插值可能导致中间颜色的亮度出现非预期的变化，因为 RGB 三个分量对人眼亮度的贡献不相等。</p>\n<h4 id=\"问题3：违反人眼感知\"><a href=\"#问题3：违反人眼感知\" class=\"headerlink\" title=\"问题3：违反人眼感知\"></a>问题3：违反人眼感知</h4><p>人眼对颜色的感知更接近 HSV 模型，RGB 插值产生的中间色可能看起来不自然。</p>\n<h3 id=\"HSV颜色插值的优势\"><a href=\"#HSV颜色插值的优势\" class=\"headerlink\" title=\"HSV颜色插值的优势\"></a>HSV颜色插值的优势</h3><h4 id=\"优势1：符合直觉的颜色过渡\"><a href=\"#优势1：符合直觉的颜色过渡\" class=\"headerlink\" title=\"优势1：符合直觉的颜色过渡\"></a>优势1：符合直觉的颜色过渡</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HSV 插值：从红色到绿色</span></span><br><span class=\"line\"><span class=\"function\">HSV <span class=\"title\">interpolateHSV</span><span class=\"params\">(<span class=\"type\">float</span> t)</span> </span>&#123;</span><br><span class=\"line\">    HSV red = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br><span class=\"line\">    HSV green = &#123;<span class=\"number\">120.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 色相插值需要考虑圆形特性</span></span><br><span class=\"line\">    <span class=\"type\">float</span> hue = red.h + t * (green.h - red.h);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        hue,                                    <span class=\"comment\">// 0° → 120°</span></span><br><span class=\"line\">        red.s + t * (green.s - red.s),         <span class=\"comment\">// 1.0 → 1.0 (不变)</span></span><br><span class=\"line\">        red.v + t * (green.v - red.v)          <span class=\"comment\">// 1.0 → 1.0 (不变)</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>HSV 插值的结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t=0.0: HSV(0°, 100%, 100%) → 鲜红色</span><br><span class=\"line\">t=0.5: HSV(60°, 100%, 100%) → 鲜黄色 (自然!)</span><br><span class=\"line\">t=1.0: HSV(120°, 100%, 100%) → 鲜绿色</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"优势2：可控的亮度变化\"><a href=\"#优势2：可控的亮度变化\" class=\"headerlink\" title=\"优势2：可控的亮度变化\"></a>优势2：可控的亮度变化</h4><p>在 HSV 空间中，我们可以独立控制亮度，确保过渡过程中亮度变化符合预期：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">HSV <span class=\"title\">interpolateHSVWithBrightness</span><span class=\"params\">(<span class=\"type\">float</span> t, <span class=\"type\">float</span> startV, <span class=\"type\">float</span> endV)</span> </span>&#123;</span><br><span class=\"line\">    HSV start = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, startV&#125;;</span><br><span class=\"line\">    HSV end = &#123;<span class=\"number\">120.0f</span>, <span class=\"number\">1.0f</span>, endV&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        start.h + t * (end.h - start.h),</span><br><span class=\"line\">        start.s + t * (end.s - start.s),</span><br><span class=\"line\">        start.v + t * (end.v - start.v)  <span class=\"comment\">// 可控的亮度变化</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"优势3：处理色相环的连续性\"><a href=\"#优势3：处理色相环的连续性\" class=\"headerlink\" title=\"优势3：处理色相环的连续性\"></a>优势3：处理色相环的连续性</h4><p>色相是圆形的，从 350° 到 10° 应该是短路径，而不是经过整个色相环：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">interpolateHue</span><span class=\"params\">(<span class=\"type\">float</span> h1, <span class=\"type\">float</span> h2, <span class=\"type\">float</span> t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> diff = h2 - h1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 处理色相环的连续性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (diff &gt; <span class=\"number\">180.0f</span>) &#123;</span><br><span class=\"line\">        diff -= <span class=\"number\">360.0f</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (diff &lt; <span class=\"number\">-180.0f</span>) &#123;</span><br><span class=\"line\">        diff += <span class=\"number\">360.0f</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">float</span> result = h1 + t * diff;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 确保结果在 [0, 360) 范围内</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result &lt; <span class=\"number\">0.0f</span>) result += <span class=\"number\">360.0f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result &gt;= <span class=\"number\">360.0f</span>) result -= <span class=\"number\">360.0f</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实用的HSV插值实现\"><a href=\"#实用的HSV插值实现\" class=\"headerlink\" title=\"实用的HSV插值实现\"></a>实用的HSV插值实现</h3><h4 id=\"完整的HSV插值函数\"><a href=\"#完整的HSV插值函数\" class=\"headerlink\" title=\"完整的HSV插值函数\"></a>完整的HSV插值函数</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RGB 到 HSV 转换</span></span><br><span class=\"line\"><span class=\"function\">HSV <span class=\"title\">rgbToHsv</span><span class=\"params\">(<span class=\"type\">const</span> RGB&amp; rgb)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> max_val = std::<span class=\"built_in\">max</span>(&#123;rgb.r, rgb.g, rgb.b&#125;);</span><br><span class=\"line\">    <span class=\"type\">float</span> min_val = std::<span class=\"built_in\">min</span>(&#123;rgb.r, rgb.g, rgb.b&#125;);</span><br><span class=\"line\">    <span class=\"type\">float</span> delta = max_val - min_val;</span><br><span class=\"line\">    </span><br><span class=\"line\">    HSV hsv;</span><br><span class=\"line\">    hsv.v = max_val;</span><br><span class=\"line\">    hsv.s = (max_val == <span class=\"number\">0.0f</span>) ? <span class=\"number\">0.0f</span> : delta / max_val;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delta == <span class=\"number\">0.0f</span>) &#123;</span><br><span class=\"line\">        hsv.h = <span class=\"number\">0.0f</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (max_val == rgb.r) &#123;</span><br><span class=\"line\">            hsv.h = <span class=\"number\">60.0f</span> * (<span class=\"built_in\">fmod</span>((rgb.g - rgb.b) / delta, <span class=\"number\">6.0f</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (max_val == rgb.g) &#123;</span><br><span class=\"line\">            hsv.h = <span class=\"number\">60.0f</span> * ((rgb.b - rgb.r) / delta + <span class=\"number\">2.0f</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            hsv.h = <span class=\"number\">60.0f</span> * ((rgb.r - rgb.g) / delta + <span class=\"number\">4.0f</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hsv.h &lt; <span class=\"number\">0.0f</span>) hsv.h += <span class=\"number\">360.0f</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> hsv;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HSV 到 RGB 转换</span></span><br><span class=\"line\"><span class=\"function\">RGB <span class=\"title\">hsvToRgb</span><span class=\"params\">(<span class=\"type\">const</span> HSV&amp; hsv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> c = hsv.v * hsv.s;</span><br><span class=\"line\">    <span class=\"type\">float</span> x = c * (<span class=\"number\">1.0f</span> - <span class=\"built_in\">abs</span>(<span class=\"built_in\">fmod</span>(hsv.h / <span class=\"number\">60.0f</span>, <span class=\"number\">2.0f</span>) - <span class=\"number\">1.0f</span>));</span><br><span class=\"line\">    <span class=\"type\">float</span> m = hsv.v - c;</span><br><span class=\"line\">    </span><br><span class=\"line\">    RGB rgb;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hsv.h &gt;= <span class=\"number\">0.0f</span> &amp;&amp; hsv.h &lt; <span class=\"number\">60.0f</span>) &#123;</span><br><span class=\"line\">        rgb = &#123;c, x, <span class=\"number\">0.0f</span>&#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hsv.h &gt;= <span class=\"number\">60.0f</span> &amp;&amp; hsv.h &lt; <span class=\"number\">120.0f</span>) &#123;</span><br><span class=\"line\">        rgb = &#123;x, c, <span class=\"number\">0.0f</span>&#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hsv.h &gt;= <span class=\"number\">120.0f</span> &amp;&amp; hsv.h &lt; <span class=\"number\">180.0f</span>) &#123;</span><br><span class=\"line\">        rgb = &#123;<span class=\"number\">0.0f</span>, c, x&#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hsv.h &gt;= <span class=\"number\">180.0f</span> &amp;&amp; hsv.h &lt; <span class=\"number\">240.0f</span>) &#123;</span><br><span class=\"line\">        rgb = &#123;<span class=\"number\">0.0f</span>, x, c&#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hsv.h &gt;= <span class=\"number\">240.0f</span> &amp;&amp; hsv.h &lt; <span class=\"number\">300.0f</span>) &#123;</span><br><span class=\"line\">        rgb = &#123;x, <span class=\"number\">0.0f</span>, c&#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        rgb = &#123;c, <span class=\"number\">0.0f</span>, x&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    rgb.r += m;</span><br><span class=\"line\">    rgb.g += m;</span><br><span class=\"line\">    rgb.b += m;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> rgb;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HSV 空间中的插值</span></span><br><span class=\"line\"><span class=\"function\">HSV <span class=\"title\">interpolateHSV</span><span class=\"params\">(<span class=\"type\">const</span> HSV&amp; start, <span class=\"type\">const</span> HSV&amp; end, <span class=\"type\">float</span> t)</span> </span>&#123;</span><br><span class=\"line\">    HSV result;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 色相插值（考虑圆形特性）</span></span><br><span class=\"line\">    result.h = <span class=\"built_in\">interpolateHue</span>(start.h, end.h, t);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 饱和度和明度的线性插值</span></span><br><span class=\"line\">    result.s = start.s + t * (end.s - start.s);</span><br><span class=\"line\">    result.v = start.v + t * (end.v - start.v);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 便利函数：RGB 空间的 HSV 插值</span></span><br><span class=\"line\"><span class=\"function\">RGB <span class=\"title\">interpolateRGBviaHSV</span><span class=\"params\">(<span class=\"type\">const</span> RGB&amp; start, <span class=\"type\">const</span> RGB&amp; end, <span class=\"type\">float</span> t)</span> </span>&#123;</span><br><span class=\"line\">    HSV startHSV = <span class=\"built_in\">rgbToHsv</span>(start);</span><br><span class=\"line\">    HSV endHSV = <span class=\"built_in\">rgbToHsv</span>(end);</span><br><span class=\"line\">    HSV interpolatedHSV = <span class=\"built_in\">interpolateHSV</span>(startHSV, endHSV, t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">hsvToRgb</span>(interpolatedHSV);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实际应用场景\"><a href=\"#实际应用场景\" class=\"headerlink\" title=\"实际应用场景\"></a>实际应用场景</h3><h4 id=\"1-用户界面渐变\"><a href=\"#1-用户界面渐变\" class=\"headerlink\" title=\"1. 用户界面渐变\"></a>1. 用户界面渐变</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建彩虹渐变</span></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;RGB&gt; <span class=\"title\">createRainbowGradient</span><span class=\"params\">(<span class=\"type\">int</span> steps)</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;RGB&gt; gradient;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; steps; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> t = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">float</span>&gt;(i) / (steps - <span class=\"number\">1</span>);</span><br><span class=\"line\">        HSV hsv = &#123;t * <span class=\"number\">360.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;  <span class=\"comment\">// 遍历整个色相环</span></span><br><span class=\"line\">        gradient.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">hsvToRgb</span>(hsv));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> gradient;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-数据可视化\"><a href=\"#2-数据可视化\" class=\"headerlink\" title=\"2. 数据可视化\"></a>2. 数据可视化</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 热力图颜色映射</span></span><br><span class=\"line\"><span class=\"function\">RGB <span class=\"title\">getHeatmapColor</span><span class=\"params\">(<span class=\"type\">float</span> value)</span> </span>&#123;  <span class=\"comment\">// value 在 [0, 1] 范围内</span></span><br><span class=\"line\">    HSV cold = &#123;<span class=\"number\">240.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;  <span class=\"comment\">// 蓝色</span></span><br><span class=\"line\">    HSV hot = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;     <span class=\"comment\">// 红色</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    HSV interpolated = <span class=\"built_in\">interpolateHSV</span>(cold, hot, value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">hsvToRgb</span>(interpolated);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-游戏开发中的颜色效果\"><a href=\"#3-游戏开发中的颜色效果\" class=\"headerlink\" title=\"3. 游戏开发中的颜色效果\"></a>3. 游戏开发中的颜色效果</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 日夜循环颜色变化</span></span><br><span class=\"line\"><span class=\"function\">RGB <span class=\"title\">getDayNightColor</span><span class=\"params\">(<span class=\"type\">float</span> timeOfDay)</span> </span>&#123;  <span class=\"comment\">// 0.0 = 午夜, 0.5 = 正午</span></span><br><span class=\"line\">    HSV night = &#123;<span class=\"number\">240.0f</span>, <span class=\"number\">0.8f</span>, <span class=\"number\">0.2f</span>&#125;;    <span class=\"comment\">// 深蓝色</span></span><br><span class=\"line\">    HSV day = &#123;<span class=\"number\">60.0f</span>, <span class=\"number\">0.3f</span>, <span class=\"number\">1.0f</span>&#125;;       <span class=\"comment\">// 明黄色</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">float</span> t = <span class=\"number\">0.5f</span> * (<span class=\"number\">1.0f</span> + <span class=\"built_in\">sin</span>(timeOfDay * <span class=\"number\">2.0f</span> * M_PI));</span><br><span class=\"line\">    HSV current = <span class=\"built_in\">interpolateHSV</span>(night, day, t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">hsvToRgb</span>(current);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"性能考虑\"><a href=\"#性能考虑\" class=\"headerlink\" title=\"性能考虑\"></a>性能考虑</h3><p>虽然 HSV 插值在视觉效果上更优，但需要额外的颜色空间转换：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 优化：预计算 HSV 值</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ColorInterpolator</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    HSV startHSV, endHSV;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">ColorInterpolator</span>(<span class=\"type\">const</span> RGB&amp; start, <span class=\"type\">const</span> RGB&amp; end) </span><br><span class=\"line\">        : <span class=\"built_in\">startHSV</span>(<span class=\"built_in\">rgbToHsv</span>(start)), <span class=\"built_in\">endHSV</span>(<span class=\"built_in\">rgbToHsv</span>(end)) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">RGB <span class=\"title\">interpolate</span><span class=\"params\">(<span class=\"type\">float</span> t)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        HSV interpolated = <span class=\"built_in\">interpolateHSV</span>(startHSV, endHSV, t);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">hsvToRgb</span>(interpolated);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>HSV 颜色空间相比 RGB 在插值应用中具有明显优势：</p>\n<ol>\n<li><strong>更自然的过渡</strong>：符合人眼对颜色变化的感知</li>\n<li><strong>可控的亮度</strong>：可以独立控制亮度变化</li>\n<li><strong>直观的参数</strong>：色相、饱和度、明度更容易理解和调整</li>\n<li><strong>更好的视觉效果</strong>：避免了 RGB 插值中的暗色区域问题</li>\n</ol>\n<p>在需要高质量颜色过渡的应用中，如用户界面设计、数据可视化、游戏开发等领域，HSV 插值是比 RGB 插值更好的选择。虽然需要额外的计算开销，但现代硬件的性能足以支持这种转换，而获得的视觉效果提升是非常值得的。 </p>\n","site":{"data":{}},"excerpt":"<h2 id=\"HSV颜色空间和插值优势详解\"><a href=\"#HSV颜色空间和插值优势详解\" class=\"headerlink\" title=\"HSV颜色空间和插值优势详解\"></a>HSV颜色空间和插值优势详解</h2><p>在计算机图形学和图像处理中，颜色空间的选择对最终效果有着重要影响。本文将深入探讨 HSV 颜色空间的特点，以及为什么在颜色插值时，HSV 比传统的 RGB 能产生更自然、更符合人眼感知的效果。</p>","more":"<h3 id=\"什么是HSV颜色空间\"><a href=\"#什么是HSV颜色空间\" class=\"headerlink\" title=\"什么是HSV颜色空间\"></a>什么是HSV颜色空间</h3><p>HSV 颜色空间是一种基于人类视觉感知设计的颜色模型，它将颜色分解为三个组件：</p>\n<ul>\n<li><strong>H (Hue) - 色相</strong>：表示颜色的基本色调，取值范围 0°-360°</li>\n<li><strong>S (Saturation) - 饱和度</strong>：表示颜色的纯度，取值范围 0-100%</li>\n<li><strong>V (Value) - 明度</strong>：表示颜色的亮度，取值范围 0-100%</li>\n</ul>\n<h4 id=\"HSV的几何表示\"><a href=\"#HSV的几何表示\" class=\"headerlink\" title=\"HSV的几何表示\"></a>HSV的几何表示</h4><p><img src=\"https://upload.wikimedia.org/wikipedia/commons/4/4e/HSV_color_solid_cylinder.png\" alt=\"HSV颜色空间圆柱体\"></p>\n<p><em>图：HSV 颜色空间的圆柱体表示法</em></p>\n<p>HSV 颜色空间通常用圆柱体来表示，具有以下特征：</p>\n<ul>\n<li><strong>垂直轴（明度轴）</strong>：从底部的黑色（V=0%）到顶部的白色（V=100%）</li>\n<li><strong>角度（色相环）</strong>：围绕中心轴的角度表示不同色相</li>\n<li><strong>半径（饱和度）</strong>：从中心轴到边缘的距离表示饱和度</li>\n</ul>\n<h4 id=\"HSV各分量的意义\"><a href=\"#HSV各分量的意义\" class=\"headerlink\" title=\"HSV各分量的意义\"></a>HSV各分量的意义</h4><ol>\n<li><p>**色相 (Hue)**：</p>\n<ul>\n<li>0° = 红色</li>\n<li>60° = 黄色</li>\n<li>120° = 绿色</li>\n<li>180° = 青色</li>\n<li>240° = 蓝色</li>\n<li>300° = 洋红色</li>\n</ul>\n</li>\n<li><p>**饱和度 (Saturation)**：</p>\n<ul>\n<li>0% = 灰色（无彩色）</li>\n<li>100% = 纯色（最鲜艳）</li>\n</ul>\n</li>\n<li><p>**明度 (Value)**：</p>\n<ul>\n<li>0% = 黑色</li>\n<li>100% = 最亮状态</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"RGB-vs-HSV：直观对比\"><a href=\"#RGB-vs-HSV：直观对比\" class=\"headerlink\" title=\"RGB vs HSV：直观对比\"></a>RGB vs HSV：直观对比</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// RGB 表示法</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">RGB</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> r, g, b;  <span class=\"comment\">// 范围 [0, 1]</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HSV 表示法</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">HSV</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> h;  <span class=\"comment\">// 色相，范围 [0, 360]</span></span><br><span class=\"line\">    <span class=\"type\">float</span> s;  <span class=\"comment\">// 饱和度，范围 [0, 1]</span></span><br><span class=\"line\">    <span class=\"type\">float</span> v;  <span class=\"comment\">// 明度，范围 [0, 1]</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一些颜色的对比</span></span><br><span class=\"line\">RGB red = &#123;<span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>&#125;;</span><br><span class=\"line\">HSV red_hsv = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">RGB green = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>&#125;;</span><br><span class=\"line\">HSV green_hsv = &#123;<span class=\"number\">120.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">RGB blue = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br><span class=\"line\">HSV blue_hsv = &#123;<span class=\"number\">240.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RGB颜色插值的问题\"><a href=\"#RGB颜色插值的问题\" class=\"headerlink\" title=\"RGB颜色插值的问题\"></a>RGB颜色插值的问题</h3><h4 id=\"问题1：路径不直观\"><a href=\"#问题1：路径不直观\" class=\"headerlink\" title=\"问题1：路径不直观\"></a>问题1：路径不直观</h4><p>当我们在 RGB 空间中从红色插值到绿色时：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// RGB 插值：从红色到绿色</span></span><br><span class=\"line\"><span class=\"function\">RGB <span class=\"title\">interpolateRGB</span><span class=\"params\">(<span class=\"type\">float</span> t)</span> </span>&#123;</span><br><span class=\"line\">    RGB red = &#123;<span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>&#125;;</span><br><span class=\"line\">    RGB green = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        red.r + t * (green.r - red.r),  <span class=\"comment\">// 1.0 → 0.0</span></span><br><span class=\"line\">        red.g + t * (green.g - red.g),  <span class=\"comment\">// 0.0 → 1.0</span></span><br><span class=\"line\">        red.b + t * (green.b - red.b)   <span class=\"comment\">// 0.0 → 0.0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 RGB 空间中，从红色到绿色的插值路径会经过暗色区域，产生不自然的中间色：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t=0.0: RGB(1.0, 0.0, 0.0) → 鲜红色</span><br><span class=\"line\">t=0.5: RGB(0.5, 0.5, 0.0) → 暗黄色 (不理想!)</span><br><span class=\"line\">t=1.0: RGB(0.0, 1.0, 0.0) → 鲜绿色</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"问题2：亮度变化不均匀\"><a href=\"#问题2：亮度变化不均匀\" class=\"headerlink\" title=\"问题2：亮度变化不均匀\"></a>问题2：亮度变化不均匀</h4><p>RGB 插值可能导致中间颜色的亮度出现非预期的变化，因为 RGB 三个分量对人眼亮度的贡献不相等。</p>\n<h4 id=\"问题3：违反人眼感知\"><a href=\"#问题3：违反人眼感知\" class=\"headerlink\" title=\"问题3：违反人眼感知\"></a>问题3：违反人眼感知</h4><p>人眼对颜色的感知更接近 HSV 模型，RGB 插值产生的中间色可能看起来不自然。</p>\n<h3 id=\"HSV颜色插值的优势\"><a href=\"#HSV颜色插值的优势\" class=\"headerlink\" title=\"HSV颜色插值的优势\"></a>HSV颜色插值的优势</h3><h4 id=\"优势1：符合直觉的颜色过渡\"><a href=\"#优势1：符合直觉的颜色过渡\" class=\"headerlink\" title=\"优势1：符合直觉的颜色过渡\"></a>优势1：符合直觉的颜色过渡</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HSV 插值：从红色到绿色</span></span><br><span class=\"line\"><span class=\"function\">HSV <span class=\"title\">interpolateHSV</span><span class=\"params\">(<span class=\"type\">float</span> t)</span> </span>&#123;</span><br><span class=\"line\">    HSV red = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br><span class=\"line\">    HSV green = &#123;<span class=\"number\">120.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 色相插值需要考虑圆形特性</span></span><br><span class=\"line\">    <span class=\"type\">float</span> hue = red.h + t * (green.h - red.h);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        hue,                                    <span class=\"comment\">// 0° → 120°</span></span><br><span class=\"line\">        red.s + t * (green.s - red.s),         <span class=\"comment\">// 1.0 → 1.0 (不变)</span></span><br><span class=\"line\">        red.v + t * (green.v - red.v)          <span class=\"comment\">// 1.0 → 1.0 (不变)</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>HSV 插值的结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t=0.0: HSV(0°, 100%, 100%) → 鲜红色</span><br><span class=\"line\">t=0.5: HSV(60°, 100%, 100%) → 鲜黄色 (自然!)</span><br><span class=\"line\">t=1.0: HSV(120°, 100%, 100%) → 鲜绿色</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"优势2：可控的亮度变化\"><a href=\"#优势2：可控的亮度变化\" class=\"headerlink\" title=\"优势2：可控的亮度变化\"></a>优势2：可控的亮度变化</h4><p>在 HSV 空间中，我们可以独立控制亮度，确保过渡过程中亮度变化符合预期：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">HSV <span class=\"title\">interpolateHSVWithBrightness</span><span class=\"params\">(<span class=\"type\">float</span> t, <span class=\"type\">float</span> startV, <span class=\"type\">float</span> endV)</span> </span>&#123;</span><br><span class=\"line\">    HSV start = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, startV&#125;;</span><br><span class=\"line\">    HSV end = &#123;<span class=\"number\">120.0f</span>, <span class=\"number\">1.0f</span>, endV&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        start.h + t * (end.h - start.h),</span><br><span class=\"line\">        start.s + t * (end.s - start.s),</span><br><span class=\"line\">        start.v + t * (end.v - start.v)  <span class=\"comment\">// 可控的亮度变化</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"优势3：处理色相环的连续性\"><a href=\"#优势3：处理色相环的连续性\" class=\"headerlink\" title=\"优势3：处理色相环的连续性\"></a>优势3：处理色相环的连续性</h4><p>色相是圆形的，从 350° 到 10° 应该是短路径，而不是经过整个色相环：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">interpolateHue</span><span class=\"params\">(<span class=\"type\">float</span> h1, <span class=\"type\">float</span> h2, <span class=\"type\">float</span> t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> diff = h2 - h1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 处理色相环的连续性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (diff &gt; <span class=\"number\">180.0f</span>) &#123;</span><br><span class=\"line\">        diff -= <span class=\"number\">360.0f</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (diff &lt; <span class=\"number\">-180.0f</span>) &#123;</span><br><span class=\"line\">        diff += <span class=\"number\">360.0f</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">float</span> result = h1 + t * diff;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 确保结果在 [0, 360) 范围内</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result &lt; <span class=\"number\">0.0f</span>) result += <span class=\"number\">360.0f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result &gt;= <span class=\"number\">360.0f</span>) result -= <span class=\"number\">360.0f</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实用的HSV插值实现\"><a href=\"#实用的HSV插值实现\" class=\"headerlink\" title=\"实用的HSV插值实现\"></a>实用的HSV插值实现</h3><h4 id=\"完整的HSV插值函数\"><a href=\"#完整的HSV插值函数\" class=\"headerlink\" title=\"完整的HSV插值函数\"></a>完整的HSV插值函数</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RGB 到 HSV 转换</span></span><br><span class=\"line\"><span class=\"function\">HSV <span class=\"title\">rgbToHsv</span><span class=\"params\">(<span class=\"type\">const</span> RGB&amp; rgb)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> max_val = std::<span class=\"built_in\">max</span>(&#123;rgb.r, rgb.g, rgb.b&#125;);</span><br><span class=\"line\">    <span class=\"type\">float</span> min_val = std::<span class=\"built_in\">min</span>(&#123;rgb.r, rgb.g, rgb.b&#125;);</span><br><span class=\"line\">    <span class=\"type\">float</span> delta = max_val - min_val;</span><br><span class=\"line\">    </span><br><span class=\"line\">    HSV hsv;</span><br><span class=\"line\">    hsv.v = max_val;</span><br><span class=\"line\">    hsv.s = (max_val == <span class=\"number\">0.0f</span>) ? <span class=\"number\">0.0f</span> : delta / max_val;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delta == <span class=\"number\">0.0f</span>) &#123;</span><br><span class=\"line\">        hsv.h = <span class=\"number\">0.0f</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (max_val == rgb.r) &#123;</span><br><span class=\"line\">            hsv.h = <span class=\"number\">60.0f</span> * (<span class=\"built_in\">fmod</span>((rgb.g - rgb.b) / delta, <span class=\"number\">6.0f</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (max_val == rgb.g) &#123;</span><br><span class=\"line\">            hsv.h = <span class=\"number\">60.0f</span> * ((rgb.b - rgb.r) / delta + <span class=\"number\">2.0f</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            hsv.h = <span class=\"number\">60.0f</span> * ((rgb.r - rgb.g) / delta + <span class=\"number\">4.0f</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hsv.h &lt; <span class=\"number\">0.0f</span>) hsv.h += <span class=\"number\">360.0f</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> hsv;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HSV 到 RGB 转换</span></span><br><span class=\"line\"><span class=\"function\">RGB <span class=\"title\">hsvToRgb</span><span class=\"params\">(<span class=\"type\">const</span> HSV&amp; hsv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> c = hsv.v * hsv.s;</span><br><span class=\"line\">    <span class=\"type\">float</span> x = c * (<span class=\"number\">1.0f</span> - <span class=\"built_in\">abs</span>(<span class=\"built_in\">fmod</span>(hsv.h / <span class=\"number\">60.0f</span>, <span class=\"number\">2.0f</span>) - <span class=\"number\">1.0f</span>));</span><br><span class=\"line\">    <span class=\"type\">float</span> m = hsv.v - c;</span><br><span class=\"line\">    </span><br><span class=\"line\">    RGB rgb;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hsv.h &gt;= <span class=\"number\">0.0f</span> &amp;&amp; hsv.h &lt; <span class=\"number\">60.0f</span>) &#123;</span><br><span class=\"line\">        rgb = &#123;c, x, <span class=\"number\">0.0f</span>&#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hsv.h &gt;= <span class=\"number\">60.0f</span> &amp;&amp; hsv.h &lt; <span class=\"number\">120.0f</span>) &#123;</span><br><span class=\"line\">        rgb = &#123;x, c, <span class=\"number\">0.0f</span>&#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hsv.h &gt;= <span class=\"number\">120.0f</span> &amp;&amp; hsv.h &lt; <span class=\"number\">180.0f</span>) &#123;</span><br><span class=\"line\">        rgb = &#123;<span class=\"number\">0.0f</span>, c, x&#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hsv.h &gt;= <span class=\"number\">180.0f</span> &amp;&amp; hsv.h &lt; <span class=\"number\">240.0f</span>) &#123;</span><br><span class=\"line\">        rgb = &#123;<span class=\"number\">0.0f</span>, x, c&#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hsv.h &gt;= <span class=\"number\">240.0f</span> &amp;&amp; hsv.h &lt; <span class=\"number\">300.0f</span>) &#123;</span><br><span class=\"line\">        rgb = &#123;x, <span class=\"number\">0.0f</span>, c&#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        rgb = &#123;c, <span class=\"number\">0.0f</span>, x&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    rgb.r += m;</span><br><span class=\"line\">    rgb.g += m;</span><br><span class=\"line\">    rgb.b += m;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> rgb;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HSV 空间中的插值</span></span><br><span class=\"line\"><span class=\"function\">HSV <span class=\"title\">interpolateHSV</span><span class=\"params\">(<span class=\"type\">const</span> HSV&amp; start, <span class=\"type\">const</span> HSV&amp; end, <span class=\"type\">float</span> t)</span> </span>&#123;</span><br><span class=\"line\">    HSV result;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 色相插值（考虑圆形特性）</span></span><br><span class=\"line\">    result.h = <span class=\"built_in\">interpolateHue</span>(start.h, end.h, t);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 饱和度和明度的线性插值</span></span><br><span class=\"line\">    result.s = start.s + t * (end.s - start.s);</span><br><span class=\"line\">    result.v = start.v + t * (end.v - start.v);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 便利函数：RGB 空间的 HSV 插值</span></span><br><span class=\"line\"><span class=\"function\">RGB <span class=\"title\">interpolateRGBviaHSV</span><span class=\"params\">(<span class=\"type\">const</span> RGB&amp; start, <span class=\"type\">const</span> RGB&amp; end, <span class=\"type\">float</span> t)</span> </span>&#123;</span><br><span class=\"line\">    HSV startHSV = <span class=\"built_in\">rgbToHsv</span>(start);</span><br><span class=\"line\">    HSV endHSV = <span class=\"built_in\">rgbToHsv</span>(end);</span><br><span class=\"line\">    HSV interpolatedHSV = <span class=\"built_in\">interpolateHSV</span>(startHSV, endHSV, t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">hsvToRgb</span>(interpolatedHSV);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实际应用场景\"><a href=\"#实际应用场景\" class=\"headerlink\" title=\"实际应用场景\"></a>实际应用场景</h3><h4 id=\"1-用户界面渐变\"><a href=\"#1-用户界面渐变\" class=\"headerlink\" title=\"1. 用户界面渐变\"></a>1. 用户界面渐变</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建彩虹渐变</span></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;RGB&gt; <span class=\"title\">createRainbowGradient</span><span class=\"params\">(<span class=\"type\">int</span> steps)</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;RGB&gt; gradient;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; steps; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> t = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">float</span>&gt;(i) / (steps - <span class=\"number\">1</span>);</span><br><span class=\"line\">        HSV hsv = &#123;t * <span class=\"number\">360.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;  <span class=\"comment\">// 遍历整个色相环</span></span><br><span class=\"line\">        gradient.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">hsvToRgb</span>(hsv));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> gradient;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-数据可视化\"><a href=\"#2-数据可视化\" class=\"headerlink\" title=\"2. 数据可视化\"></a>2. 数据可视化</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 热力图颜色映射</span></span><br><span class=\"line\"><span class=\"function\">RGB <span class=\"title\">getHeatmapColor</span><span class=\"params\">(<span class=\"type\">float</span> value)</span> </span>&#123;  <span class=\"comment\">// value 在 [0, 1] 范围内</span></span><br><span class=\"line\">    HSV cold = &#123;<span class=\"number\">240.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;  <span class=\"comment\">// 蓝色</span></span><br><span class=\"line\">    HSV hot = &#123;<span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>&#125;;     <span class=\"comment\">// 红色</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    HSV interpolated = <span class=\"built_in\">interpolateHSV</span>(cold, hot, value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">hsvToRgb</span>(interpolated);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-游戏开发中的颜色效果\"><a href=\"#3-游戏开发中的颜色效果\" class=\"headerlink\" title=\"3. 游戏开发中的颜色效果\"></a>3. 游戏开发中的颜色效果</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 日夜循环颜色变化</span></span><br><span class=\"line\"><span class=\"function\">RGB <span class=\"title\">getDayNightColor</span><span class=\"params\">(<span class=\"type\">float</span> timeOfDay)</span> </span>&#123;  <span class=\"comment\">// 0.0 = 午夜, 0.5 = 正午</span></span><br><span class=\"line\">    HSV night = &#123;<span class=\"number\">240.0f</span>, <span class=\"number\">0.8f</span>, <span class=\"number\">0.2f</span>&#125;;    <span class=\"comment\">// 深蓝色</span></span><br><span class=\"line\">    HSV day = &#123;<span class=\"number\">60.0f</span>, <span class=\"number\">0.3f</span>, <span class=\"number\">1.0f</span>&#125;;       <span class=\"comment\">// 明黄色</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">float</span> t = <span class=\"number\">0.5f</span> * (<span class=\"number\">1.0f</span> + <span class=\"built_in\">sin</span>(timeOfDay * <span class=\"number\">2.0f</span> * M_PI));</span><br><span class=\"line\">    HSV current = <span class=\"built_in\">interpolateHSV</span>(night, day, t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">hsvToRgb</span>(current);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"性能考虑\"><a href=\"#性能考虑\" class=\"headerlink\" title=\"性能考虑\"></a>性能考虑</h3><p>虽然 HSV 插值在视觉效果上更优，但需要额外的颜色空间转换：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 优化：预计算 HSV 值</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ColorInterpolator</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    HSV startHSV, endHSV;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">ColorInterpolator</span>(<span class=\"type\">const</span> RGB&amp; start, <span class=\"type\">const</span> RGB&amp; end) </span><br><span class=\"line\">        : <span class=\"built_in\">startHSV</span>(<span class=\"built_in\">rgbToHsv</span>(start)), <span class=\"built_in\">endHSV</span>(<span class=\"built_in\">rgbToHsv</span>(end)) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">RGB <span class=\"title\">interpolate</span><span class=\"params\">(<span class=\"type\">float</span> t)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        HSV interpolated = <span class=\"built_in\">interpolateHSV</span>(startHSV, endHSV, t);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">hsvToRgb</span>(interpolated);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>HSV 颜色空间相比 RGB 在插值应用中具有明显优势：</p>\n<ol>\n<li><strong>更自然的过渡</strong>：符合人眼对颜色变化的感知</li>\n<li><strong>可控的亮度</strong>：可以独立控制亮度变化</li>\n<li><strong>直观的参数</strong>：色相、饱和度、明度更容易理解和调整</li>\n<li><strong>更好的视觉效果</strong>：避免了 RGB 插值中的暗色区域问题</li>\n</ol>\n<p>在需要高质量颜色过渡的应用中，如用户界面设计、数据可视化、游戏开发等领域，HSV 插值是比 RGB 插值更好的选择。虽然需要额外的计算开销，但现代硬件的性能足以支持这种转换，而获得的视觉效果提升是非常值得的。 </p>"}],"PostAsset":[{"_id":"source/_posts/add-Image/sharedptr1.png","slug":"sharedptr1.png","post":"cmbt3hg8f001c1xcobj6ldrrw","modified":0,"renderable":0},{"_id":"source/_posts/add-Image/sharedptr2.png","slug":"sharedptr2.png","post":"cmbt3hg8f001c1xcobj6ldrrw","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cmbt3hg8b000f1xco9wpc4r9o","category_id":"cmbt3hg8c000j1xco0eks2nrq","_id":"cmbt3hg8e000v1xco8csu4ucm"},{"post_id":"cmbt3hg8l002t1xco5mc5h917","category_id":"cmbt3hg8l002v1xco71ef3hq8","_id":"cmbt3hg8m00311xcoczou1j32"},{"post_id":"cmbt3hg8l002u1xco9as712um","category_id":"cmbt3hg8l002v1xco71ef3hq8","_id":"cmbt3hg8m00331xco7r1d4n1e"},{"post_id":"cmbx3as1h000096j2gvwo9lbp","category_id":"cmbt3hg8c000j1xco0eks2nrq","_id":"cmbx3as1k000496j27fp9a5by"},{"post_id":"cmbx3as1h000096j2gvwo9lbp","category_id":"cmbx3as1k000296j228qz6x25","_id":"cmbx3as1k000696j2f5afeyeq"},{"post_id":"cmbx4ojeh0000h2j28xxnh5y2","category_id":"cmbt3hg8c000j1xco0eks2nrq","_id":"cmbx4ojek0004h2j282r39g2b"},{"post_id":"cmbx4ojei0001h2j2307y18ps","category_id":"cmbx4ojek0003h2j201ki8sc6","_id":"cmbx4ojel0007h2j26tzz95xu"}],"PostTag":[{"post_id":"cmbt3hg8a00091xcobzvue3wu","tag_id":"cmbt3hg8900071xco1b5bg5fg","_id":"cmbt3hg8b000c1xco2k7w45as"},{"post_id":"cmbt3hg8900051xco6kod505d","tag_id":"cmbt3hg8900071xco1b5bg5fg","_id":"cmbt3hg8b000e1xco6ou69uee"},{"post_id":"cmbt3hg8a000a1xco1wra0wlm","tag_id":"cmbt3hg8900071xco1b5bg5fg","_id":"cmbt3hg8c000h1xco5c2u9lni"},{"post_id":"cmbt3hg8900061xco90fj7rdu","tag_id":"cmbt3hg8900071xco1b5bg5fg","_id":"cmbt3hg8c000k1xcogueg2krq"},{"post_id":"cmbt3hg8a00081xco47ufaezy","tag_id":"cmbt3hg8900071xco1b5bg5fg","_id":"cmbt3hg8d000n1xcofrqj1u8p"},{"post_id":"cmbt3hg8d000o1xcodwug80sc","tag_id":"cmbt3hg8d000m1xcogwif9mq3","_id":"cmbt3hg8d000r1xcoa1qi3nup"},{"post_id":"cmbt3hg8b000d1xcoc3k1bb2k","tag_id":"cmbt3hg8d000m1xcogwif9mq3","_id":"cmbt3hg8d000t1xcohgqv2cr5"},{"post_id":"cmbt3hg8b000f1xco9wpc4r9o","tag_id":"cmbt3hg8d000q1xcog2vuawbc","_id":"cmbt3hg8f00141xco2jy6eh9z"},{"post_id":"cmbt3hg8b000f1xco9wpc4r9o","tag_id":"cmbt3hg8e000w1xcobagc3ww5","_id":"cmbt3hg8f00161xco5voe7p68"},{"post_id":"cmbt3hg8b000f1xco9wpc4r9o","tag_id":"cmbt3hg8e000z1xco23i888jd","_id":"cmbt3hg8f00191xco2hg94ydt"},{"post_id":"cmbt3hg8c000i1xcocjjuebc0","tag_id":"cmbt3hg8d000m1xcogwif9mq3","_id":"cmbt3hg8f001b1xcoapy29zye"},{"post_id":"cmbt3hg8c000l1xco7qe4er45","tag_id":"cmbt3hg8d000m1xcogwif9mq3","_id":"cmbt3hg8f001e1xco4v5d4do0"},{"post_id":"cmbt3hg8d000p1xco4tjo1o5h","tag_id":"cmbt3hg8d000m1xcogwif9mq3","_id":"cmbt3hg8g001j1xco039k1q7n"},{"post_id":"cmbt3hg8d000p1xco4tjo1o5h","tag_id":"cmbt3hg8f001d1xco9dw63f76","_id":"cmbt3hg8g001l1xcoaobn9sop"},{"post_id":"cmbt3hg8d000s1xcodbay8bm5","tag_id":"cmbt3hg8g001h1xcoa6nmfgqw","_id":"cmbt3hg8g001o1xcohbskextv"},{"post_id":"cmbt3hg8g001k1xcoeunp5srb","tag_id":"cmbt3hg8d000m1xcogwif9mq3","_id":"cmbt3hg8g001q1xcogqj35lih"},{"post_id":"cmbt3hg8g001n1xcoc8sbamxg","tag_id":"cmbt3hg8d000m1xcogwif9mq3","_id":"cmbt3hg8g001t1xcoakws8jeg"},{"post_id":"cmbt3hg8d000u1xcog582f3ip","tag_id":"cmbt3hg8g001h1xcoa6nmfgqw","_id":"cmbt3hg8i001v1xcoa52f58cw"},{"post_id":"cmbt3hg8g001p1xco1aux70vz","tag_id":"cmbt3hg8d000m1xcogwif9mq3","_id":"cmbt3hg8j001y1xco2zbidab7"},{"post_id":"cmbt3hg8e000x1xco28iu75za","tag_id":"cmbt3hg8g001h1xcoa6nmfgqw","_id":"cmbt3hg8j00201xco8ae5gflp"},{"post_id":"cmbt3hg8g001u1xcocjvp0lls","tag_id":"cmbt3hg8d000m1xcogwif9mq3","_id":"cmbt3hg8j00231xcodlk2bktg"},{"post_id":"cmbt3hg8e000y1xco25oa8bxh","tag_id":"cmbt3hg8g001h1xcoa6nmfgqw","_id":"cmbt3hg8j00251xcogj3dfnnk"},{"post_id":"cmbt3hg8e000y1xco25oa8bxh","tag_id":"cmbt3hg8d000m1xcogwif9mq3","_id":"cmbt3hg8j00281xco0ygo4amq"},{"post_id":"cmbt3hg8e00101xcoek332mgo","tag_id":"cmbt3hg8g001h1xcoa6nmfgqw","_id":"cmbt3hg8j002a1xcoeq9r7ouj"},{"post_id":"cmbt3hg8f00151xco9c94b8pe","tag_id":"cmbt3hg8g001h1xcoa6nmfgqw","_id":"cmbt3hg8k002d1xcobky0fhvo"},{"post_id":"cmbt3hg8f001c1xcobj6ldrrw","tag_id":"cmbt3hg8j002b1xco2v6bcise","_id":"cmbt3hg8k002h1xco1rrb1klx"},{"post_id":"cmbt3hg8k002g1xco5p3ef87q","tag_id":"cmbt3hg8d000m1xcogwif9mq3","_id":"cmbt3hg8k002j1xcobeqhhiam"},{"post_id":"cmbt3hg8k002i1xco7bla199r","tag_id":"cmbt3hg8d000m1xcogwif9mq3","_id":"cmbt3hg8k002l1xco2lv5errb"},{"post_id":"cmbt3hg8f001f1xco36cqfgp1","tag_id":"cmbt3hg8k002f1xcoeu3y53ei","_id":"cmbt3hg8k002n1xco7d3j8iwg"},{"post_id":"cmbt3hg8l002t1xco5mc5h917","tag_id":"cmbt3hg8l002w1xcoeks7h02c","_id":"cmbt3hg8m00361xco52vzd784"},{"post_id":"cmbt3hg8l002t1xco5mc5h917","tag_id":"cmbt3hg8l00301xcog20d680z","_id":"cmbt3hg8m00371xco6773e3ei"},{"post_id":"cmbt3hg8l002t1xco5mc5h917","tag_id":"cmbt3hg8m00321xco56vd8jyi","_id":"cmbt3hg8m00391xco9tzbej4r"},{"post_id":"cmbt3hg8l002t1xco5mc5h917","tag_id":"cmbt3hg8m00341xco6s1f5jhe","_id":"cmbt3hg8m003a1xcogilqe4oq"},{"post_id":"cmbt3hg8l002u1xco9as712um","tag_id":"cmbt3hg8m00321xco56vd8jyi","_id":"cmbt3hg8m003d1xcoevlv5pj5"},{"post_id":"cmbt3hg8l002u1xco9as712um","tag_id":"cmbt3hg8m00381xcob6tnez3d","_id":"cmbt3hg8m003e1xco71e8aady"},{"post_id":"cmbt3hg8l002u1xco9as712um","tag_id":"cmbt3hg8m003b1xco6k4h2icy","_id":"cmbt3hg8m003f1xcoalwa6wgc"},{"post_id":"cmbt3hg8l002u1xco9as712um","tag_id":"cmbt3hg8l00301xcog20d680z","_id":"cmbt3hg8m003g1xco1cr08xvt"},{"post_id":"cmbx3as1h000096j2gvwo9lbp","tag_id":"cmbt3hg8d000q1xcog2vuawbc","_id":"cmbx3as1k000796j200cu3dte"},{"post_id":"cmbx3as1h000096j2gvwo9lbp","tag_id":"cmbx3as1i000196j20i4ecxhj","_id":"cmbx3as1k000896j21a3n199x"},{"post_id":"cmbx3as1h000096j2gvwo9lbp","tag_id":"cmbx3as1k000396j26kn7bsub","_id":"cmbx3as1k000996j22m355ww4"},{"post_id":"cmbx3as1h000096j2gvwo9lbp","tag_id":"cmbx3as1k000596j2b3qsej9i","_id":"cmbx3as1k000a96j2ceu966nd"},{"post_id":"cmbx4ojeh0000h2j28xxnh5y2","tag_id":"cmbt3hg8d000q1xcog2vuawbc","_id":"cmbx4ojel0008h2j2fi5v1e4m"},{"post_id":"cmbx4ojeh0000h2j28xxnh5y2","tag_id":"cmbx4ojei0002h2j24ejs8jug","_id":"cmbx4ojel0009h2j2fh131wkz"},{"post_id":"cmbx4ojeh0000h2j28xxnh5y2","tag_id":"cmbx4ojek0005h2j288n9eumx","_id":"cmbx4ojel000bh2j25fz1gilf"},{"post_id":"cmbx4ojei0001h2j2307y18ps","tag_id":"cmbx4ojel0006h2j2f3s53psg","_id":"cmbx4ojel000dh2j2fcxd6sdx"},{"post_id":"cmbx4ojei0001h2j2307y18ps","tag_id":"cmbx4ojel000ah2j2egbofrs1","_id":"cmbx4ojel000eh2j2frd672mu"},{"post_id":"cmbx4ojei0001h2j2307y18ps","tag_id":"cmbx4ojel000ch2j251nk88h5","_id":"cmbx4ojel000fh2j29c60394v"},{"post_id":"cmc9xgo8p00005tco0slledk0","tag_id":"cmc9xgo8r00025tco56sc6gw4","_id":"cmc9xgo8u00065tcoep0pg29r"},{"post_id":"cmc9xgo8p00005tco0slledk0","tag_id":"cmc9xgo8u00035tcoe2flc6ta","_id":"cmc9xgo8u00075tco6lwthxzs"},{"post_id":"cmc9xgo8p00005tco0slledk0","tag_id":"cmc9xgo8u00045tcoal4b7q5r","_id":"cmc9xgo8u00095tcock9s66aa"},{"post_id":"cmc9xgo8q00015tcobfgv3v1s","tag_id":"cmc9xgo8u00055tco5vzbd631","_id":"cmc9xgo8v000c5tco10ov1juk"},{"post_id":"cmc9xgo8q00015tcobfgv3v1s","tag_id":"cmc9xgo8u00085tco2zrn1v4e","_id":"cmc9xgo8v000d5tco5qfufhek"},{"post_id":"cmc9xgo8q00015tcobfgv3v1s","tag_id":"cmc9xgo8u000a5tco3fp43gq4","_id":"cmc9xgo8v000e5tco2k7727oc"},{"post_id":"cmc9xgo8q00015tcobfgv3v1s","tag_id":"cmc9xgo8v000b5tco0ptw5vg1","_id":"cmc9xgo8v000f5tcofpyfagpr"},{"post_id":"cmca8bv4200007ofyb87c6yek","tag_id":"cmbt3hg8900071xco1b5bg5fg","_id":"cmca8bv4600027ofyb272a6na"},{"post_id":"cmca8bv4200007ofyb87c6yek","tag_id":"cmca8bv4300017ofy186oa0gy","_id":"cmca8bv4600037ofy2xw27n3n"},{"post_id":"cmcaalwxr00002ocoba583r7u","tag_id":"cmc9xgo8v000b5tco0ptw5vg1","_id":"cmcaalwxw00032ocogxku77p4"},{"post_id":"cmcaalwxr00002ocoba583r7u","tag_id":"cmcaalwxt00012oco85d89ehh","_id":"cmcaalwxw00042ococehm4chq"},{"post_id":"cmcaalwxr00002ocoba583r7u","tag_id":"cmcaalwxw00022ocodcbagxkb","_id":"cmcaalwxw00052oco19msfnmc"}],"Tag":[{"name":"C++11","_id":"cmbt3hg8900071xco1b5bg5fg"},{"name":"iOS","_id":"cmbt3hg8d000m1xcogwif9mq3"},{"name":"C++","_id":"cmbt3hg8d000q1xcog2vuawbc"},{"name":"编程陷阱","_id":"cmbt3hg8e000w1xcobagc3ww5"},{"name":"类型转换","_id":"cmbt3hg8e000z1xco23i888jd"},{"name":"ruby","_id":"cmbt3hg8f001d1xco9dw63f76"},{"name":"openGL","_id":"cmbt3hg8g001h1xcoa6nmfgqw"},{"name":"test","_id":"cmbt3hg8j002b1xco2v6bcise"},{"name":"c++11","_id":"cmbt3hg8k002f1xcoeu3y53ei"},{"name":"教育","_id":"cmbt3hg8l002w1xcoeks7h02c"},{"name":"亲子","_id":"cmbt3hg8l00301xcog20d680z"},{"name":"阅读","_id":"cmbt3hg8m00321xco56vd8jyi"},{"name":"手机成瘾","_id":"cmbt3hg8m00341xco6s1f5jhe"},{"name":"书单","_id":"cmbt3hg8m00381xcob6tnez3d"},{"name":"儿童教育","_id":"cmbt3hg8m003b1xco6k4h2icy"},{"name":"宏定义","_id":"cmbx3as1i000196j20i4ecxhj"},{"name":"预处理器","_id":"cmbx3as1k000396j26kn7bsub"},{"name":"播客","_id":"cmbx3as1k000596j2b3qsej9i"},{"name":"字符串","_id":"cmbx4ojei0002h2j24ejs8jug"},{"name":"性能优化","_id":"cmbx4ojek0005h2j288n9eumx"},{"name":"图形学","_id":"cmbx4ojel0006h2j2f3s53psg"},{"name":"SSAO","_id":"cmbx4ojel000ah2j2egbofrs1"},{"name":"移动端优化","_id":"cmbx4ojel000ch2j251nk88h5"},{"name":"Android","_id":"cmc9xgo8r00025tco56sc6gw4"},{"name":"JNI","_id":"cmc9xgo8u00035tcoe2flc6ta"},{"name":"动态库","_id":"cmc9xgo8u00045tcoal4b7q5r"},{"name":"GLSL","_id":"cmc9xgo8u00055tco5vzbd631"},{"name":"Shader","_id":"cmc9xgo8u00085tco2zrn1v4e"},{"name":"图形编程","_id":"cmc9xgo8u000a5tco3fp43gq4"},{"name":"计算机图形学","_id":"cmc9xgo8v000b5tco0ptw5vg1"},{"name":"构造函数","_id":"cmca8bv4300017ofy186oa0gy"},{"name":"颜色空间","_id":"cmcaalwxt00012oco85d89ehh"},{"name":"插值算法","_id":"cmcaalwxw00022ocodcbagxkb"}]}}