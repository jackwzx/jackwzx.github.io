<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>移动端部光源延迟渲染和阴影计算共用同一个Framebuffer 会提升性能吗</title>
      <link href="/2025/12/09/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E4%B8%93%E4%B8%9A%E4%B8%94%E5%88%87%E4%B8%AD%E8%A6%81%E5%AE%B3%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2025/12/09/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E4%B8%93%E4%B8%9A%E4%B8%94%E5%88%87%E4%B8%AD%E8%A6%81%E5%AE%B3%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>这是一个非常专业且切中要害的问题。直接回答你的结论：</p><p><strong>在绝大多数情况下，尝试让“阴影生成（Shadow Calculation）”和“延迟渲染的光照计算（Lighting Pass）”共用同一个 Framebuffer Object (FBO) 是不可行的，且不会带来性能提升，反而可能导致严重的逻辑错误或性能下降。</strong></p><span id="more"></span><p>但如果你是指 <strong>“共用显存（Memory Aliasing）”</strong> 或者利用 <strong>“Tile-Based 架构特性（Subpasses/PLS）”</strong>，则有优化的空间。</p><p>我们需要把这个问题拆解开来，从原理和移动端硬件架构（TBDR）两个角度来分析。</p><hr><h3 id="1-为什么不能简单共用-FBO？（逻辑与物理限制）"><a href="#1-为什么不能简单共用-FBO？（逻辑与物理限制）" class="headerlink" title="1. 为什么不能简单共用 FBO？（逻辑与物理限制）"></a>1. 为什么不能简单共用 FBO？（逻辑与物理限制）</h3><p>首先要明确两个阶段的工作内容：</p><ul><li>  <strong>阴影计算 (Shadow Gen):</strong> 从<strong>光源视角</strong>渲染场景，输出到<strong>深度纹理</strong> (Shadow Map)。</li><li>  <strong>光照计算 (Lighting Pass):</strong> 从<strong>相机视角</strong>渲染全屏 Quad（或光体积），读取 G-Buffer 和 Shadow Map，输出<strong>颜色</strong>。</li></ul><h4 id="A-视角不同-View-Matrices"><a href="#A-视角不同-View-Matrices" class="headerlink" title="A. 视角不同 (View Matrices)"></a>A. 视角不同 (View Matrices)</h4><ul><li>  <strong>冲突：</strong> Framebuffer 对应一个特定的渲染视角。你不能在一个 Pass 里同时既从“相机”看，又从“灯光”看。</li><li>  <strong>后果：</strong> 你必须切换 View Matrix 和 Projection Matrix。这意味着你必须结束当前的 Draw Call 序列，这本质上就是两个独立的渲染流程。</li></ul><h4 id="B-分辨率不同-Resolution-Mismatch"><a href="#B-分辨率不同-Resolution-Mismatch" class="headerlink" title="B. 分辨率不同 (Resolution Mismatch)"></a>B. 分辨率不同 (Resolution Mismatch)</h4><ul><li><strong>冲突：</strong> <ul><li>  <strong>Deferred Lighting:</strong> 必须和屏幕分辨率一致（例如 $1920 \times 1080$），或者是其缩放版（如 0.5x）。</li><li>  <strong>Shadow Map:</strong> 通常是正方形的幂次方大小（例如 $1024 \times 1024$ 或 $2048 \times 2048$）。</li></ul></li><li>  <strong>后果：</strong> 每次切换用途，你都需要调用 <code>glViewport</code> 并重新 Attach 只有特定大小的纹理。这比直接切换两个预设好的 FBO 开销更大（驱动层校验状态的成本）。</li></ul><h4 id="C-附件需求不同-Attachments"><a href="#C-附件需求不同-Attachments" class="headerlink" title="C. 附件需求不同 (Attachments)"></a>C. 附件需求不同 (Attachments)</h4><ul><li>  <strong>Shadow Gen:</strong> 只需要 Depth Attachment（不需要 Color）。</li><li>  <strong>Lighting Pass:</strong> 需要 Color Attachment（累积光照），且通常以 Texture 的形式<strong>读取</strong> Shadow Gen 生成的 Depth Texture。</li><li>  <strong>死锁：</strong> 你不能一边往纹理 A 里写深度（生成阴影），一边在同一个 FBO 的 Shader 里采样纹理 A（计算光照）。这会触发 **Texture Loop (Feedback Loop)**，在 OpenGL ES 中是未定义行为，结果通常是黑屏或闪烁。</li></ul><hr><h3 id="2-移动端的真正痛点：带宽-Bandwidth"><a href="#2-移动端的真正痛点：带宽-Bandwidth" class="headerlink" title="2. 移动端的真正痛点：带宽 (Bandwidth)"></a>2. 移动端的真正痛点：带宽 (Bandwidth)</h3><p>在移动端（Adreno, Mali, Apple GPU），性能杀手通常不是 Draw Call 数量，而是 <strong>System Memory Bandwidth（系统内存带宽）</strong>。</p><h4 id="标准延迟渲染-阴影的流程："><a href="#标准延迟渲染-阴影的流程：" class="headerlink" title="标准延迟渲染 + 阴影的流程："></a>标准延迟渲染 + 阴影的流程：</h4><ol><li> <strong>Shadow Pass (FBO A):</strong> 渲染几何 -&gt; 写出深度到显存 (Store Action)。</li><li> <strong>G-Buffer Pass (FBO B):</strong> 渲染几何 -&gt; 写出 Albedo/Normal/Depth 到显存 (Store Action)。</li><li> <strong>Lighting Pass (FBO B 或 C):</strong> 从显存读取 ShadowMap + G-Buffer (Load Action) -&gt; 计算 -&gt; 写出最终颜色。</li></ol><p><strong>共用 FBO 无法减少这些 Load/Store 操作</strong>，因为阴影图必须生成完，才能被光照阶段读取。</p><hr><h3 id="3-可行的优化方向（你可能想问的是这些）"><a href="#3-可行的优化方向（你可能想问的是这些）" class="headerlink" title="3. 可行的优化方向（你可能想问的是这些）"></a>3. 可行的优化方向（你可能想问的是这些）</h3><p>虽然“共用 FBO”不可行，但在移动端做延迟渲染和阴影，有以下几种真正有效的“共用”或“合并”优化技术：</p><h4 id="方案-A：显存别名-Memory-Aliasing-Transient-Attachments"><a href="#方案-A：显存别名-Memory-Aliasing-Transient-Attachments" class="headerlink" title="方案 A：显存别名 (Memory Aliasing / Transient Attachments)"></a>方案 A：显存别名 (Memory Aliasing / Transient Attachments)</h4><p>如果你想省内存（显存占用），而不是省 FBO 对象：</p><ul><li>  <strong>原理：</strong> G-Buffer 的纹理通常很大（全屏）。如果 Shadow Map 生成后，在 Lighting Pass 使用完之后就不再需要了，你可以复用显存。</li><li>  <strong>但在延迟渲染中很难：</strong> 因为 Lighting Pass <strong>同时</strong> 需要采样 G-Buffer 和 Shadow Map。你不能覆盖掉其中任何一个。</li><li><strong>唯一机会：</strong> 如果你有多个光源，且是串行计算的。<ul><li>  计算 Light 1 的 Shadow Map -&gt; 累积 Light 1 光照 -&gt; <strong>丢弃</strong> Shadow Map 1。</li><li>  复用这块显存给 Light 2 的 Shadow Map。</li><li>  <em>缺点：</em> 频繁的渲染目标切换（Context Switch）在移动端是大忌，打断了 Tiler 的流水线，性能通常不如一次性生成好所有 Shadow Map。</li></ul></li></ul><h4 id="方案-B：利用-TBDR-特性的-Subpasses-Vulkan-PLS-OpenGL-ES-ext"><a href="#方案-B：利用-TBDR-特性的-Subpasses-Vulkan-PLS-OpenGL-ES-ext" class="headerlink" title="方案 B：利用 TBDR 特性的 Subpasses (Vulkan) / PLS (OpenGL ES ext)"></a>方案 B：利用 TBDR 特性的 Subpasses (Vulkan) / PLS (OpenGL ES ext)</h4><p>这是移动端延迟渲染的核心优化，但主要针对 G-Buffer 和 Lighting 的合并，而非阴影生成。</p><ul><li>  <strong>技术：</strong> Pixel Local Storage (PLS) 或 Vulkan Subpasses。</li><li><strong>做法：</strong> <ul><li>  G-Buffer 生成后，<strong>不写出到系统内存</strong>，而是直接保留在 GPU 的 Tile Memory (On-chip buffer) 中。</li><li>  紧接着在同一个 Tile 上执行 Lighting Pass。</li></ul></li><li><strong>对阴影的影响：</strong> <ul><li>  阴影贴图（Shadow Map）<strong>依然必须</strong> 先在另一个独立的 Render Pass 中生成并写出到内存。因为阴影需要全局几何信息，而 Tile Memory 只能看到当前 Tile 的像素。</li><li>  <strong>提升点：</strong> 这样做节省了 G-Buffer 的 Load/Store 带宽，留给读取 Shadow Map 的带宽就更充裕了。</li></ul></li></ul><h4 id="方案-C：聚光灯-点光源的阴影优化-Shadow-Mask"><a href="#方案-C：聚光灯-点光源的阴影优化-Shadow-Mask" class="headerlink" title="方案 C：聚光灯/点光源的阴影优化 (Shadow Mask)"></a>方案 C：聚光灯/点光源的阴影优化 (Shadow Mask)</h4><p>如果你的场景有很多灯光。</p><ul><li>  不要为每个灯光都在 Lighting Pass 里采样一遍 Shadow Map。</li><li>  <strong>优化：</strong> 先在一个屏幕空间的单通道纹理（Screen-space Shadow Mask）上，把所有阴影的遮挡关系算好（0 或 1）。</li><li>  <strong>共用：</strong> 这个 Shadow Mask 可以复用 G-Buffer 的一个通道（比如 Specular 的 Alpha 通道，如果没用的话），但这极度依赖具体实现。</li></ul><hr><h3 id="4-总结与建议"><a href="#4-总结与建议" class="headerlink" title="4. 总结与建议"></a>4. 总结与建议</h3><p><strong>结论：</strong><br>不要尝试让“阴影生成”和“光照计算”共用同一个 FBO。由于视角、分辨率和读写依赖的冲突，这是<strong>不可行</strong>的。</p><p><strong>推荐的移动端高性能方案：</strong></p><ol><li><p><strong>独立的 Shadow Pass FBO：</strong></p><ul><li>  使用 16-bit Depth (<code>GL_DEPTH_COMPONENT16</code>) 而非 24/32 位，减少带宽。</li><li>  如果可能，使用较小的分辨率（512/1024）。</li><li>  开启 <strong>Variance Shadow Map (VSM)</strong> 或 <strong>EVSM</strong> 可以尝试避免一些高频的 PCF 采样开销，但显存占用会变大，需权衡。</li></ul></li><li><p><strong>利用 Subpasses (Vulkan) / Framebuffer Fetch (GLES)：</strong></p><ul><li>  将 <strong>G-Buffer Pass</strong> 和 <strong>Lighting Pass</strong> 合并。这是提升移动端延迟渲染性能的“银弹”。</li><li>  Shadow Map 依然作为外部纹理（Texture Input）被 Lighting Pass 读取。</li></ul></li><li><p><strong>剔除与级联 (Culling &amp; Cascades)：</strong></p><ul><li>  严格控制 Shadow Pass 绘制的物体数量（Shadow Culling）。</li><li>  移动端尽量只用 1 级级联（CSM），或者仅对主角/近处物体产生阴影。</li></ul></li></ol><p>通过<strong>合并 G-Buffer 和 Lighting 阶段</strong>（利用片上内存），并<strong>精简 Shadow Map 的生成开销</strong>（分辨率、位数、物体数量），才是移动端正确的优化路径。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端模板测试与Eary-z分析</title>
      <link href="/2025/12/09/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%83%A8%E5%85%89%E6%BA%90%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E5%92%8C%E9%98%B4%E5%BD%B1%E8%AE%A1%E7%AE%97%E5%85%B1%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AAFramebuffer%20%E4%BC%9A%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E5%90%97/"/>
      <url>/2025/12/09/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%83%A8%E5%85%89%E6%BA%90%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E5%92%8C%E9%98%B4%E5%BD%B1%E8%AE%A1%E7%AE%97%E5%85%B1%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AAFramebuffer%20%E4%BC%9A%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E5%90%97/</url>
      
        <content type="html"><![CDATA[<p>在移动端（特别是基于 TBDR 架构的 GPU，如 Adreno, Mali, Apple GPU）使用模版缓存（Stencil Buffer）时，导致 Early-Z 失效并引起 Fragment Shader（片元着色器）占用率上升，主要原因是 <strong>GPU 无法在着色器执行前确定深度和模版测试的最终结果，从而被迫回退到 Late-Z（后期深度测试）模式。</strong></p><span id="more"></span><p>以下是底层的技术原因分析以及解决方案：</p><h3 id="1-核心原因：数据依赖与管线顺序-Data-Dependency-amp-Pipeline-Order"><a href="#1-核心原因：数据依赖与管线顺序-Data-Dependency-amp-Pipeline-Order" class="headerlink" title="1. 核心原因：数据依赖与管线顺序 (Data Dependency &amp; Pipeline Order)"></a>1. 核心原因：数据依赖与管线顺序 (Data Dependency &amp; Pipeline Order)</h3><h4 id="标准管线-vs-硬件优化"><a href="#标准管线-vs-硬件优化" class="headerlink" title="标准管线 vs. 硬件优化"></a>标准管线 vs. 硬件优化</h4><ul><li>  <strong>逻辑上的 OpenGL 管线：</strong> 顶点着色器 -&gt; 光栅化 -&gt; 片元着色器 -&gt; <strong>模版测试</strong> -&gt; <strong>深度测试</strong> -&gt; 混合。</li><li>  <strong>Early-Z 优化：</strong> 为了性能，GPU 尝试将 <strong>深度测试</strong> 提前到 片元着色器 <strong>之前</strong>。如果 Early-Z 失败，直接丢弃该像素，不运行昂贵的片元着色器。</li></ul><h4 id="Stencil-的破坏力"><a href="#Stencil-的破坏力" class="headerlink" title="Stencil 的破坏力"></a>Stencil 的破坏力</h4><p>当你启用了模版测试，尤其是当你 <strong>写入模版值</strong>（例如 <code>glStencilOp</code> 设置为 <code>GL_REPLACE</code> 或 <code>GL_INCR</code> 等非 <code>GL_KEEP</code> 操作）时，会发生以下冲突：</p><ol><li> <strong>模版写入导致的不确定性：</strong> 如果你的绘制调用会修改模版缓冲区，硬件会认为当前的深度/模版状态是“易变的”。为了保证渲染结果的逻辑正确性（即符合 OpenGL 标准管线顺序），GPU 可能会保守地禁用 Early-Z。</li><li><strong>复合测试依赖：</strong> 深度测试和模版测试在硬件层面通常是绑定在一起的一个单元（Depth/Stencil Unit）。<ul><li>  如果 <strong>深度测试依赖于模版测试的结果</strong>（比如模版测试挂了，深度就不应该写入），而模版值又是在 Late Stage 确定的，那么深度测试也必须推迟到 Fragment Shader 之后（Late-Z）。</li><li>  一旦回退到 Late-Z，所有的片元着色器都会被执行，计算出的颜色最后才会被扔掉，导致 Fragment 占用率飙升。</li></ul></li></ol><h3 id="2-移动端-TBDR-架构的特殊性"><a href="#2-移动端-TBDR-架构的特殊性" class="headerlink" title="2. 移动端 TBDR 架构的特殊性"></a>2. 移动端 TBDR 架构的特殊性</h3><p>移动端 GPU（Tile-Based Deferred Rendering）非常依赖 Early-Z 来减少 Overdraw（过度绘制）。</p><ul><li>  <strong>Tile Memory 限制：</strong> 深度和模版数据都存储在片上高速缓存（On-chip Memory）中。</li><li><strong>Early-Z/Stencil 单元：</strong> 现代移动 GPU 实际上有专门的 “Early-Z/Stencil” 单元。<ul><li>  <strong>情况 A（纯读取）：</strong> 如果你只是 <strong>读取</strong> 模版（<code>glStencilMask(0x00)</code> 或 <code>glStencilOp(GL_KEEP, ...)</code>），大多数现代 GPU（如 Mali-G7x 系列, Adreno 6xx+）通常 <strong>可以</strong> 保持 Early-Z 开启。</li><li>  <strong>情况 B（写入/修改）：</strong> 如果你在 Draw Call 中 <strong>写入</strong> 模版，硬件往往无法预测后续像素对该模版的依赖关系，为了安全起见，它会关闭 Early-Z。</li></ul></li></ul><h3 id="3-重复绘制-Mesh-的场景分析"><a href="#3-重复绘制-Mesh-的场景分析" class="headerlink" title="3. 重复绘制 Mesh 的场景分析"></a>3. 重复绘制 Mesh 的场景分析</h3><p>你提到的“重复绘制 Mesh”通常是这种 Shader Effect 流程（例如描边、遮罩、透视效果）：</p><ol><li> <strong>Pass 1:</strong> 绘制 Mesh，<strong>写入 Stencil</strong>（标记区域），关闭 Color Write。</li><li> <strong>Pass 2:</strong> 再次绘制 Mesh，<strong>读取 Stencil</strong>，进行着色。</li></ol><p><strong>为什么 Pass 2 也无法被 Early-Z 优化？</strong></p><ul><li>  如果 Pass 1 和 Pass 2 在同一个 Render Pass 中（中间没有 <code>glFlush</code> 或显式的依赖屏障），并且 Pass 1 写入了 Stencil，GPU 的光栅化队列可能会因为状态切换或数据竞争风险，使得 Pass 2 也无法利用之前的 Z-Buffer 进行剔除，或者 Pass 2 本身因为开启了复杂的 Stencil Test 导致硬件决定采用 Late-Z。</li><li>  更常见的情况是：<strong>Pass 2 的深度比较函数设置问题</strong>。如果 Pass 2 的深度设置为 <code>GL_LEQUAL</code> 或 <code>GL_EQUAL</code>，且 Pass 1 已经写入了深度，理论上 Early-Z 应该生效。但如果 Pass 2 为了根据 Stencil 剔除像素而开启了 <code>discard</code> 或者是 Alpha Test，这会 100% 强制关闭 Early-Z。</li></ul><h3 id="4-解决方案与优化建议"><a href="#4-解决方案与优化建议" class="headerlink" title="4. 解决方案与优化建议"></a>4. 解决方案与优化建议</h3><p>要解决这个问题，重新获得 Early-Z 的性能收益，可以尝试以下方案：</p><h4 id="方案一：分离“写”与“读”（最推荐）"><a href="#方案一：分离“写”与“读”（最推荐）" class="headerlink" title="方案一：分离“写”与“读”（最推荐）"></a>方案一：分离“写”与“读”（最推荐）</h4><p>将模版写入和复杂的着色计算彻底分开，并确保状态明确。</p><ol><li><p><strong>Stencil Pre-pass (极简 Shader):</strong></p><ul><li>  只开启 Stencil Write。</li><li>  关闭 Color Write (<code>glColorMask(false,...)</code>)。</li><li>  关闭 Depth Write (如果不需要更新深度)。</li><li>  <strong>Shader 极其简单</strong>（甚至可以使用空 Fragment Shader），这样即使发生了 Late-Z，开销也极低。</li></ul></li><li><p><strong>Color Pass (复杂 Shader):</strong></p><ul><li>  开启 Stencil Test (<strong>只读模式</strong>: <code>glStencilMask(0x00)</code>，<code>glStencilOp(GL_KEEP...)</code>)。</li><li>  <strong>重要：</strong> 因为是只读 Stencil，现代 GPU 大概率会重新启用 Early-Z/Early-Stencil 剔除。</li><li>  执行复杂的 Fragment Shader。</li></ul></li></ol><h4 id="方案二：利用-Depth-Pre-pass"><a href="#方案二：利用-Depth-Pre-pass" class="headerlink" title="方案二：利用 Depth Pre-pass"></a>方案二：利用 Depth Pre-pass</h4><p>如果你是因为 Overdraw 严重才关注 Early-Z，可以使用标准的 Depth Pre-pass 技术：</p><ol><li> 先绘制所有不透明物体的深度（关闭颜色写入）。</li><li> 再绘制不透明物体（开启颜色写入，深度测试设为 <code>GL_LEQUAL</code> 或 <code>GL_EQUAL</code>）。</li><li> 在此流程中插入模版逻辑时，尽量遵循“方案一”的只读原则。</li></ol><h4 id="方案三：检查-Shader-代码中的陷阱"><a href="#方案三：检查-Shader-代码中的陷阱" class="headerlink" title="方案三：检查 Shader 代码中的陷阱"></a>方案三：检查 Shader 代码中的陷阱</h4><p>检查你的 Fragment Shader 中是否有以下操作，它们会直接杀死 Early-Z，无论模版设置如何：</p><ul><li>  <code>discard</code> (GLSL) / <code>clip</code> (HLSL)</li><li>  写入 <code>gl_FragDepth</code></li><li>  开启 Alpha to Coverage</li></ul><p>如果 Shader 包含 <code>discard</code>，GPU 无法预知深度（因为深度可能会被扔掉），必须运行 Shader。<br><strong>优化技巧：</strong> 如果必须用 <code>discard</code>，尝试使用 <strong>Alpha Testing</strong>（在某些硬件上有固定功能优化）或尽量减少 <code>discard</code> 的使用范围。</p><h4 id="方案四：调整绘制顺序"><a href="#方案四：调整绘制顺序" class="headerlink" title="方案四：调整绘制顺序"></a>方案四：调整绘制顺序</h4><p>确保你的物体是 <strong>从前向后 (Front-to-Back)</strong> 绘制的。虽然这听起来是老生常谈，但在结合 Stencil 时尤为重要。让最靠近摄像机的物体先写入 Z-Buffer，后续被遮挡的物体（即使有 Stencil 逻辑）也能在 Z-Test 阶段（如果是只读 Stencil）被快速剔除。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>重复绘制 Mesh 导致 Fragment 占用率高的核心原因是 <strong>Stencil Write 操作迫使 GPU 关闭了 Early-Z 优化</strong>。</p><p><strong>最佳实践：</strong><br>将操作拆分为两个 Pass。第一个 Pass <strong>只写 Stencil（和深度）</strong>，使用最廉价的 Shader；第二个 Pass <strong>只读 Stencil</strong> 并进行着色。只要在着色 Pass 中不修改 Stencil 且不使用 <code>discard</code>，Early-Stencil/Early-Z 通常就能正常工作，大幅降低 Fragment Shader 的执行次数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高通骁龙性能分析器指标解读</title>
      <link href="/2025/12/08/%E9%AB%98%E9%80%9A%E9%AA%81%E9%BE%99%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%99%A8%E6%8C%87%E6%A0%87%E8%A7%A3%E8%AF%BB/"/>
      <url>/2025/12/08/%E9%AB%98%E9%80%9A%E9%AA%81%E9%BE%99%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%99%A8%E6%8C%87%E6%A0%87%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>这是一个关于 <strong>Qualcomm Snapdragon Profiler</strong> (高通骁龙性能分析器) 中各项性能指标的详细中文解释。这些指标对于分析 Android 游戏或图形应用的 GPU 瓶颈（Bottleneck）至关重要。</p><span id="more"></span><p>为了方便理解，我将这些杂乱的指标按<strong>逻辑类别</strong>进行了分类整理和解释。</p><hr><h3 id="一、-纹理与缓存访问-Texture-amp-Cache-Access"><a href="#一、-纹理与缓存访问-Texture-amp-Cache-Access" class="headerlink" title="一、 纹理与缓存访问 (Texture &amp; Cache Access)"></a>一、 纹理与缓存访问 (Texture &amp; Cache Access)</h3><p>这部分指标主要反映 GPU 读取贴图（纹理）时的效率。<strong>这是移动端 GPU 常见的瓶颈来源。</strong></p><ul><li><strong>% Texture L1 Miss (L1 纹理缓存缺失率)</strong><ul><li>  <strong>定义</strong>: L1 缓存缺失次数 / L1 缓存总请求次数。</li><li>  <strong>解释</strong>: L1 缓存非常小且快。如果不命中，GPU 就要去 L2 找。该值高通常意味着纹理采样局部性差（比如采样跨度大）。</li></ul></li><li><strong>% Texture L2 Miss (L2 纹理缓存缺失率)</strong><ul><li>  <strong>定义</strong>: L2 缓存缺失次数 / L2 缓存总请求次数。</li><li>  <strong>解释</strong>: <strong>关键指标</strong>。如果 L2 也没命中，GPU 就必须去读取缓慢的系统内存（DDR）。这会导致严重的性能下降和功耗增加。</li></ul></li><li><strong>L1 Texture Cache Miss Per Pixel (每像素 L1 缺失数)</strong><ul><li>  <strong>定义</strong>: 平均每个像素渲染时发生的 L1 缺失次数。</li><li>  <strong>解释</strong>: 值越低越好。如果该值很高，建议使用压缩纹理（ETC2/ASTC），或者检查 UV 映射是否过于混乱。</li></ul></li><li><strong>% Texture Fetch Stall (纹理读取停顿率)</strong><ul><li>  <strong>定义</strong>: 着色器（Shader）因为等待纹理数据而无法继续工作的时钟周期百分比。</li><li>  <strong>解释</strong>: <strong>高值意味着由于纹理读取慢，导致 GPU 算力被浪费</strong>。通常是由高 L2 Miss 或显存带宽不足引起的。</li></ul></li><li><strong>% Stalled on System Memory (系统内存停顿率)</strong><ul><li>  <strong>定义</strong>: L2 缓存为了等待系统内存（DRAM）的数据而停顿的周期百分比。</li><li>  <strong>解释</strong>: 这是最严重的停顿。说明显存带宽不够用了，或者缓存完全失效。</li></ul></li><li><strong>% Non-Base Level Textures (非基础级纹理采样率)</strong><ul><li>  <strong>解释</strong>: 采样的纹理像素来自 Mipmap 层级（非 Level 0）的比例。</li><li>  <strong>意义</strong>: 正常场景下应该有较高比例。如果通过 Mipmap 采样，能显著降低 L2 Miss。如果该值为 0 且物体很远，说明没开 Mipmap，性能会很差。</li></ul></li><li><strong>纹理过滤方式占比</strong>:<ul><li>  <strong>% Nearest Filtered</strong>: 最近邻过滤（最快，马赛克感）。</li><li>  <strong>% Linear Filtered</strong>: 线性过滤（标准质量）。</li><li>  <strong>% Anisotropic Filtered</strong>: 各向异性过滤（高质量，消耗最大）。</li></ul></li></ul><hr><h3 id="二、-几何与光栅化-Geometry-amp-Rasterization"><a href="#二、-几何与光栅化-Geometry-amp-Rasterization" class="headerlink" title="二、 几何与光栅化 (Geometry &amp; Rasterization)"></a>二、 几何与光栅化 (Geometry &amp; Rasterization)</h3><p>这部分关注顶点处理、多边形裁剪和剔除。</p><ul><li><strong>% Vertex Fetch Stall (顶点读取停顿率)</strong><ul><li>  <strong>定义</strong>: GPU 因为无法及时获取顶点数据而停顿的时间百分比。</li><li>  <strong>解释</strong>: 如果高，说明顶点数据量过大（顶点属性太多），或者顶点缓冲（VBO）布局不合理。</li></ul></li><li><strong>Pre-clipped Polygons / Second (裁剪前多边形数)</strong><ul><li>  <strong>解释</strong>: 提交给 GPU 的原始多边形数量。</li></ul></li><li><strong>% Prims Trivially Rejected (图元由于在视口外被剔除率)</strong><ul><li>  <strong>定义</strong>: 图元完全在屏幕可视范围之外，被光栅化器直接丢弃的比例。</li><li>  <strong>解释</strong>: <strong>越高越好</strong>（前提是确实看不见）。这是一种廉价的剔除，不需要复杂的计算。</li></ul></li><li><strong>% Prims Clipped (图元裁剪率)</strong><ul><li>  <strong>定义</strong>: 图元一部分在屏幕内，一部分在屏幕外，需要硬件生成新顶点进行裁剪的比例。</li><li>  <strong>解释</strong>: <strong>裁剪是很昂贵的操作</strong>。应该利用 Guardband（保护带，视口外的一圈区域）来减少裁剪发生。</li></ul></li><li><strong>Average Vertices / Polygon (每多边形平均顶点数)</strong><ul><li>  <strong>解释</strong>: 三角形列表（Triangle List）通常是 3，三角带（Triangle Strip）接近 1。接近 1 说明模型导出优化得好，共享了顶点。</li></ul></li><li><strong>Reused Vertices / Second (顶点复用率)</strong><ul><li>  <strong>解释</strong>: 顶点着色器计算后的顶点被缓存复用的次数。</li><li>  <strong>意义</strong>: 高值表示顶点索引（Indices）设置得当，减少了 Vertex Shader 的重复计算。</li></ul></li><li><strong>Average Polygon Area (平均多边形面积)</strong><ul><li>  <strong>解释</strong>: 每个多边形覆盖的像素数。</li><li>  <strong>意义</strong>: 对于 Adreno 这种分块渲染（Binning）架构，如果多边形极小（Micro-triangles），会导致分块效率低下，性能受损。</li></ul></li></ul><hr><h3 id="三、-着色器性能-Shader-Performance"><a href="#三、-着色器性能-Shader-Performance" class="headerlink" title="三、 着色器性能 (Shader Performance)"></a>三、 着色器性能 (Shader Performance)</h3><p>这部分反映 Vertex Shader (VS) 和 Fragment Shader (FS) 的计算负载。</p><ul><li><strong>% Shaders Busy (着色器忙碌率)</strong><ul><li>  <strong>解释</strong>: 所有 Shader 核心都在工作的百分比。如果接近 100%，说明 GPU 瓶颈在于计算（ALU Bound）。</li></ul></li><li><strong>ALU vs EFU (算术单元 vs 特殊函数单元)</strong><ul><li>  <strong>ALU (Arithmetic Logic Unit)</strong>: 处理加减乘除等基础运算。</li><li>  <strong>EFU (Elementary Function Unit)</strong>: 处理 <code>sin</code>, <code>cos</code>, <code>pow</code>, <code>sqrt</code>, <code>log</code> 等复杂数学函数。EFU 指令通常比 ALU 慢且少。</li></ul></li><li><strong>Full Precision vs Half Precision (全精度 vs 半精度)</strong><ul><li>  <strong>Full (Highp)</strong>: 32位浮点。</li><li>  <strong>Half (Mediump)</strong>: 16位浮点。</li><li>  <strong>关键点</strong>: 在移动端，<strong>2 个半精度指令通常等同于 1 个全精度指令的开销</strong>。尽量使用 Half (mediump) 能大幅提升性能。</li></ul></li><li><strong>指令数密度指标</strong>:<ul><li>  <strong>ALU / Fragment</strong>: 每个片元执行的 ALU 指令平均数。越高说明 Shader 越复杂。</li><li>  <strong>EFU / Fragment</strong>: 每个片元执行的 EFU 指令平均数。应尽量减少 EFU 使用。</li><li>  <strong>Textures / Fragment</strong>: 每个片元采样的纹理数。</li></ul></li><li><strong>Vertices/Fragments Shaded (着色顶点/片元总数)</strong><ul><li>  <strong>解释</strong>: GPU 实际处理的数量。</li></ul></li></ul><hr><h3 id="四、-带宽与内存-Bandwidth-amp-Memory"><a href="#四、-带宽与内存-Bandwidth-amp-Memory" class="headerlink" title="四、 带宽与内存 (Bandwidth &amp; Memory)"></a>四、 带宽与内存 (Bandwidth &amp; Memory)</h3><p>直接反映数据传输量。</p><ul><li>  <strong>Read/Write Total (Bytes/sec)</strong>: GPU 读写显存的总带宽。</li><li>  <strong>Texture Memory Read BW</strong>: 专门用于读取纹理的带宽。</li><li>  <strong>Vertex Memory Read</strong>: 专门用于读取顶点的带宽。</li><li>  <strong>Avg Bytes / Fragment</strong>: 平均每个片元消耗的带宽。如果过高，说明 Overdraw 严重或者纹理未压缩。</li></ul><hr><h3 id="五、-CPU-与系统状态-CPU-amp-System"><a href="#五、-CPU-与系统状态-CPU-amp-System" class="headerlink" title="五、 CPU 与系统状态 (CPU &amp; System)"></a>五、 CPU 与系统状态 (CPU &amp; System)</h3><ul><li>  <strong>Temperature (Die/GPU Temperature)</strong>: 芯片温度。温度过高会触发降频（Throttling）。</li><li>  <strong>CPU Utilization / Frequency</strong>: CPU 使用率和频率。用于判断是否是 CPU 瓶颈（比如 CPU 没喂饱 GPU）。</li><li><strong>Preemptions / second (每秒抢占次数)</strong><ul><li>  <strong>解释</strong>: GPU 任务被系统打断（如切换上下文）的次数。过高会导致 GPU 流水线气泡，降低效率。</li></ul></li></ul><hr><h3 id="六、-总结：如何利用这些数据？"><a href="#六、-总结：如何利用这些数据？" class="headerlink" title="六、 总结：如何利用这些数据？"></a>六、 总结：如何利用这些数据？</h3><ol><li><p><strong>卡顿分析</strong>:</p><ul><li>  看 <strong>% Stalled on System Memory</strong> 和 <strong>% Texture Fetch Stall</strong>。如果高，说明卡在内存读取上。</li><li>  看 <strong>Texture L2 Miss</strong>，如果高，检查 Mipmap 和纹理压缩。</li></ul></li><li><p><strong>发热/耗电分析</strong>:</p><ul><li>  看 <strong>Memory Read/Write Total</strong>。读写内存最耗电。</li><li>  看 **ALU / Fragment (Full)**。全精度计算比半精度耗电。</li></ul></li><li><p><strong>几何瓶颈</strong>:</p><ul><li>  看 <strong>% Prims Clipped</strong>。裁剪太多说明模型在视口边缘处理得不好。</li><li>  看 <strong>Average Polygon Area</strong>。如果面积很小（&lt; 5-10 像素），说明模型面数过高，对当前屏幕分辨率是浪费。</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Transform Feedback计算蒙皮技术</title>
      <link href="/2025/12/07/Transform%20Feedback%E8%AE%A1%E7%AE%97%E8%92%99%E7%9A%AE%E6%8A%80%E6%9C%AF/"/>
      <url>/2025/12/07/Transform%20Feedback%E8%AE%A1%E7%AE%97%E8%92%99%E7%9A%AE%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p><strong>Transform Feedback (变换反馈)</strong> 进行蒙皮计算，是一种利用 GPU 的 <strong>Vertex Shader (顶点着色器)</strong> 计算蒙皮，并将计算后的顶点位置<strong>写回显存（Buffer）</strong>，而不是直接拿去渲染像素的技术。</p><span id="more"></span><p>在 DirectX 中，这个技术被称为 <strong>Stream Output</strong>。</p><p>为了让你透彻理解，我们对比一下<strong>传统流程</strong>和<strong>Transform Feedback流程</strong>。</p><hr><h3 id="一、-为什么要这么做？（痛点分析）"><a href="#一、-为什么要这么做？（痛点分析）" class="headerlink" title="一、 为什么要这么做？（痛点分析）"></a>一、 为什么要这么做？（痛点分析）</h3><h4 id="1-传统蒙皮渲染流程"><a href="#1-传统蒙皮渲染流程" class="headerlink" title="1. 传统蒙皮渲染流程"></a>1. 传统蒙皮渲染流程</h4><p>在普通的渲染管线中：</p><ul><li>  <strong>输入</strong>：静态的 T-Pose 顶点 + 骨骼矩阵。</li><li>  <strong>VS 计算</strong>：Vertex Shader 根据骨骼矩阵算出当前帧的顶点位置。</li><li>  <strong>光栅化</strong>：算好的顶点直接传给光栅化器，变成屏幕上的像素。</li><li>  <strong>遗忘</strong>：<strong>一旦这一帧画完，GPU 就把刚才算好的顶点位置丢弃了。</strong></li></ul><p><strong>痛点</strong>：<br>如果你要渲染同一个角色多次（比如：一次画进 Shadow Map 投射阴影，一次画进 G-Buffer，一次画进水面反射），<strong>GPU 必须在每一次 DrawCall 里都重新计算一遍蒙皮公式</strong>。这是巨大的算力浪费。</p><h4 id="2-Transform-Feedback-的核心思想"><a href="#2-Transform-Feedback-的核心思想" class="headerlink" title="2. Transform Feedback 的核心思想"></a>2. Transform Feedback 的核心思想</h4><ul><li>  <strong>一次计算，多次复用</strong>：我们专门跑一次 Pass，只计算蒙皮，把算好的顶点存到一个新的 Buffer 里（Cache 起来）。</li><li>  <strong>后续渲染</strong>：之后的阴影Pass、主渲染Pass，直接把这个 Buffer 当作一个普通的静态 Mesh 来渲染。</li></ul><hr><h3 id="二、-Transform-Feedback-蒙皮的工作流程"><a href="#二、-Transform-Feedback-蒙皮的工作流程" class="headerlink" title="二、 Transform Feedback 蒙皮的工作流程"></a>二、 Transform Feedback 蒙皮的工作流程</h3><h4 id="步骤-1：准备两个-Buffer"><a href="#步骤-1：准备两个-Buffer" class="headerlink" title="步骤 1：准备两个 Buffer"></a>步骤 1：准备两个 Buffer</h4><ol><li> <strong>Source Buffer</strong>：存原始模型的 T-Pose 顶点、骨骼索引、权重。</li><li> **Destination Buffer (TFO)**：一块空的显存，大小和顶点数量一致，用来存计算后的结果。</li></ol><h4 id="步骤-2：蒙皮计算-Pass-Pre-pass"><a href="#步骤-2：蒙皮计算-Pass-Pre-pass" class="headerlink" title="步骤 2：蒙皮计算 Pass (Pre-pass)"></a>步骤 2：蒙皮计算 Pass (Pre-pass)</h4><ul><li>  <strong>Shader</strong>：编写一个特殊的 Vertex Shader，里面只做蒙皮计算（矩阵乘法）。</li><li>  <strong>开关</strong>：开启 <code>GL_RASTERIZER_DISCARD</code>。这意味着我们告诉 GPU：“我只要顶点数据，不要帮我画成像素，别走光栅化，省点电。”</li><li>  <strong>绑定</strong>：绑定 Destination Buffer 到 Transform Feedback 绑定点。</li><li>  <strong>执行</strong>：调用 <code>glDrawArrays</code>。</li><li>  <strong>结果</strong>：现在 Destination Buffer 里存的就是<strong>当前姿势下</strong>真实的顶点坐标（World Space Positions）。</li></ul><h4 id="步骤-3：真正的渲染-Pass"><a href="#步骤-3：真正的渲染-Pass" class="headerlink" title="步骤 3：真正的渲染 Pass"></a>步骤 3：真正的渲染 Pass</h4><ul><li>  <strong>Shader</strong>：使用普通的 Shader。</li><li>  <strong>输入</strong>：直接把 Destination Buffer 绑定为 <code>GL_ARRAY_BUFFER</code>（顶点属性）。</li><li>  <strong>执行</strong>：渲染。此时对于 GPU 来说，<strong>它在渲染一个静态模型</strong>（因为位置已经是最终位置了，不需要再乘骨骼矩阵了）。</li></ul><hr><h3 id="三、-主要应用场景"><a href="#三、-主要应用场景" class="headerlink" title="三、 主要应用场景"></a>三、 主要应用场景</h3><p>除了优化多 Pass 渲染，Transform Feedback 蒙皮还有两个高级用法：</p><h4 id="1-GPU-粒子系统-GPU-Particles"><a href="#1-GPU-粒子系统-GPU-Particles" class="headerlink" title="1. GPU 粒子系统 (GPU Particles)"></a>1. GPU 粒子系统 (GPU Particles)</h4><p>这是最酷的用法。</p><ul><li>  <strong>需求</strong>：你想让粒子（比如火焰、火花）从角色的<strong>皮肤表面</strong>发射出来。</li><li>  <strong>难题</strong>：粒子系统通常需要知道发射点的坐标。但在传统流程中，蒙皮后的坐标只有 GPU 知道，CPU 不知道（也不想读回来，太慢）。</li><li><strong>TF 方案</strong>：<ol><li>用 TF 算出蒙皮后的顶点位置存入 Buffer。</li><li>粒子系统的 Shader 直接读取这个 Buffer。</li><li>粒子就能完美地吸附在正在运动的角色身上发射了。</li></ol></li></ul><h4 id="2-布料与物理模拟"><a href="#2-布料与物理模拟" class="headerlink" title="2. 布料与物理模拟"></a>2. 布料与物理模拟</h4><ul><li>  如果你需要在 GPU 上做简单的布料模拟（比如披风随风飘动），你需要上一帧计算后的顶点位置作为下一帧的输入。Transform Feedback 天然支持这种“乒乓（Ping-Pong）”操作（输出作为下一次的输入）。</li></ul><hr><h3 id="四、-优缺点分析"><a href="#四、-优缺点分析" class="headerlink" title="四、 优缺点分析"></a>四、 优缺点分析</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li> <strong>减少重复计算</strong>：对于多 Pass 渲染（CSM 阴影、反射、延迟渲染 G-Buffer），只需要计算一次蒙皮。</li><li> <strong>数据复用</strong>：算好的顶点可以被其他 Shader（如粒子、物理）读取。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>**显存带宽压力 (Bandwidth Heavy)**：这是最大的坑。<ul><li>  蒙皮计算是 ALU（算术逻辑单元）密集型，现在的 GPU 算数很快。</li><li>  Transform Feedback 是 Memory（显存）密集型。你需要把几万个 float3 写回显存，再读出来。</li><li>  <strong>在移动端（手机），带宽通常比算力更宝贵。</strong> 写回显存产生的发热和耗电，有时甚至超过了重新计算蒙皮的开销。</li></ul></li><li> <strong>显存占用</strong>：需要额外的显存来存一整份顶点副本。</li><li> <strong>动画插值限制</strong>：如果使用了 TF，顶点位置是锁死的。如果在两帧之间需要极高的平滑度（Motion Blur），可能需要特殊处理。</li></ol><hr><h3 id="五、-现代替代方案：Compute-Shader"><a href="#五、-现代替代方案：Compute-Shader" class="headerlink" title="五、 现代替代方案：Compute Shader"></a>五、 现代替代方案：Compute Shader</h3><p>虽然 Transform Feedback 很有用，但在现代图形 API（Vulkan, DirectX 12, Metal, OpenGL ES 3.1+）中，<strong>Compute Shader (计算着色器)</strong> 正在取代 TF 蒙皮。</p><p><strong>Compute Shader 蒙皮的优势：</strong></p><ul><li>  <strong>更灵活</strong>：TF 必须走图形管线，必须有“顶点”的概念。Compute Shader 是纯粹的通用计算，可以随意读写 Buffer，逻辑更自由。</li><li>  <strong>性能更好</strong>：Compute Shader 可以利用 Shared Memory 优化读写，且不需要走 Vertex Setup 等固定管线阶段。</li></ul><p><strong>总结：</strong></p><ul><li>  <strong>Transform Feedback 蒙皮</strong> 是 OpenGL ES 3.0 时代的经典技术，用于缓存蒙皮结果以供复用或特效使用。</li><li>  在现代高性能渲染中，如果设备支持，通常优先选择 <strong>Compute Shader</strong> 来完成同样的任务。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>invalidDepth FrameBuffer之后提交同一个framebuffer draw 性能问题</title>
      <link href="/2025/12/07/invalidDepth%20FrameBuffer%E4%B9%8B%E5%90%8E%E6%8F%90%E4%BA%A4%E5%90%8C%E4%B8%80%E4%B8%AAframebuffer%20draw%20%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/"/>
      <url>/2025/12/07/invalidDepth%20FrameBuffer%E4%B9%8B%E5%90%8E%E6%8F%90%E4%BA%A4%E5%90%8C%E4%B8%80%E4%B8%AAframebuffer%20draw%20%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>这是一个非常经典且深度的移动端图形优化问题。你观察到的现象（CPU 飙升 7%、开销与 DrawCall 数据量无关）直指移动端 GPU 架构的核心痛点：<strong>Tile-Based Rendering (TBR) 架构下的 Render Pass 打断（Render Pass Split）</strong>。</p><span id="more"></span><p>简单来说，你的操作迫使 GPU 驱动将本来可以一次做完的事情，强行拆成了两次，不仅增加了 GPU 的负担（带宽），更重要的是极大地增加了 <strong>CPU 端的驱动开销</strong>。</p><p>以下是详细的原理分析：</p><hr><h3 id="1-核心背景：移动端-GPU-是如何工作的？"><a href="#1-核心背景：移动端-GPU-是如何工作的？" class="headerlink" title="1. 核心背景：移动端 GPU 是如何工作的？"></a>1. 核心背景：移动端 GPU 是如何工作的？</h3><p>移动端 GPU（高通 Adreno, ARM Mali, PowerVR）几乎都是 <strong>TBR (Tile-Based Rendering)</strong> 或 <strong>TBDR</strong> 架构。</p><ul><li>  **GMEM (On-Chip Memory)**：GPU 内部有一块极快但很小的显存。</li><li>  **Tile (图块)**：屏幕被切分成小块（如 16x16 或 32x32）。</li><li>  **Render Pass (渲染通道)**：绘制流程是先把所有 DrawCall 记录下来，然后对每个 Tile 进行：<code>Load（读入数据）</code> -&gt; <code>Rendering（绘制）</code> -&gt; <code>Store（写回系统内存）</code>。</li></ul><p><strong>最理想的性能</strong>来自于：</p><ol><li> <strong>Clear/Don’t Care</strong>：开始时不需要从系统内存读取数据（LoadOp = Clear/DontCare）。</li><li> **Draw…**：所有绘制都在 GMEM 中完成。</li><li> <strong>Store/Discard</strong>：结束时只写回需要的颜色，丢弃不需要的深度（StoreOp = Store Color, Discard Depth）。</li></ol><h3 id="2-你的操作发生了什么？（Render-Pass-被打断）"><a href="#2-你的操作发生了什么？（Render-Pass-被打断）" class="headerlink" title="2. 你的操作发生了什么？（Render Pass 被打断）"></a>2. 你的操作发生了什么？（Render Pass 被打断）</h3><p>你描述的序列是：<code>Invalidate Depth</code> -&gt; <code>DrawCall</code> -&gt; <code>Blit</code>。</p><h4 id="正常的高效流程（如果你把-Draw-放在前面）："><a href="#正常的高效流程（如果你把-Draw-放在前面）：" class="headerlink" title="正常的高效流程（如果你把 Draw 放在前面）："></a>正常的高效流程（如果你把 Draw 放在前面）：</h4><ul><li>  <strong>Draw All</strong> -&gt; <strong>Invalidate Depth</strong> -&gt; <strong>Blit (End)</strong></li><li>  <strong>CPU/驱动</strong>：只需要构建<strong>一个</strong> Render Pass 的命令。</li><li><strong>GPU</strong>：<ol><li> Load Color (或者 Clear)。</li><li> 绘制所有三角形。</li><li> <strong>Invalidate Depth</strong>：告诉 GPU “深度数据我不要了”。</li><li> <strong>End/Blit</strong>：将颜色写回内存（Store Color），<strong>深度数据直接丢弃，不写回内存</strong>（节省带宽）。</li></ol>  <em>这是最完美的路径。</em></li></ul><h4 id="你的低效流程（Invalidate-插在中间）："><a href="#你的低效流程（Invalidate-插在中间）：" class="headerlink" title="你的低效流程（Invalidate 插在中间）："></a>你的低效流程（Invalidate 插在中间）：</h4><p>序列：<code>...Previous Draws...</code> -&gt; <strong><code>Invalidate Depth</code></strong> -&gt; <strong><code>DrawCall</code></strong> -&gt; <strong><code>Blit</code></strong></p><p>这个序列被驱动解释为：</p><ol><li><p><strong>Phase 1 (前半段绘制)</strong>:</p><ul><li>  驱动检测到 <code>Invalidate Depth</code>。这对 TBR 架构来说是一个明确的信号：<strong>“当前的 Render Pass 结束了，立刻处理数据！”</strong></li><li>  <strong>GPU 行为</strong>：Color 写回内存，Depth 丢弃。</li></ul></li><li><p><strong>The “Gap” (灾难发生点)</strong>:</p><ul><li>  紧接着你又提交了一个 <code>DrawCall</code>。</li><li>  驱动会想：“哎？你不是刚结束了吗？怎么又要画？”</li><li>  驱动必须**强制开启一个新的 Render Pass (Phase 2)**。</li></ul></li><li><p><strong>Phase 2 (那个多余的 DrawCall)</strong>:</p><ul><li>  为了保证画面正确，因为是画在同一张图上，GPU 必须把刚才写回内存的 Color 数据，**重新从系统内存读回 GMEM (System Memory -&gt; GMEM)**。这就是 <strong>Load Action: Load</strong>。</li><li>  然后执行你的那个小小的 <code>DrawCall</code>。</li><li>  最后 <code>Blit</code> 再次触发 Store 操作。</li></ul></li></ol><h3 id="3-为什么-CPU-占用率会上升-7-？"><a href="#3-为什么-CPU-占用率会上升-7-？" class="headerlink" title="3. 为什么 CPU 占用率会上升 7%？"></a>3. 为什么 CPU 占用率会上升 7%？</h3><p>你可能会问：“重新读写内存是 GPU 的事，为什么 CPU 会累？”</p><p>这正是问题的关键。<strong>开销与 DrawCall 数据量无关</strong>，是因为这是<strong>纯粹的驱动管理开销（Driver Overhead）</strong>：</p><ol><li><p>**命令缓冲区重建 (Command Buffer Submission)**：</p><ul><li>  <code>Invalidate</code> 往往会触发驱动将当前积攒的命令流（Command Buffer）强制提交给内核/GPU，因为这标志着一个阶段的完成。</li><li>  随后的 <code>DrawCall</code> 迫使驱动分配新的命令缓冲区结构。频繁的 Submit 和 Setup 是非常消耗 CPU 的。</li></ul></li><li><p>**状态验证与同步 (Validation &amp; Synchronization)**：</p><ul><li>  驱动必须确保 Phase 1 的写入已经完成，Phase 2 才能开始读取（虽然硬件可能自动处理，但在驱动层需要插入 Pipeline Barrier 或 Fence）。</li><li>  这种状态追踪和依赖管理在驱动层是纯 CPU 逻辑。</li></ul></li><li><p><strong>Render Pass 描述符构建</strong>：</p><ul><li>  在 Vulkan/Metal 时代，我们手动创建 Render Pass。但在 OpenGL ES 中，驱动要在后台猜你的意图并动态构建 Render Pass。</li><li>  当你“打断”了流程，驱动需要销毁前一个 Pass 的上下文，并初始化一个新的 Pass 上下文（配置 Load/Store Ops，分配内部数据结构）。这个<strong>“上下文切换”</strong>是固定开销，不管你画一个三角形还是一万个，CPU 都要做这一套动作。</li></ul></li></ol><h3 id="4-为什么和-DrawCall-数据量无关？"><a href="#4-为什么和-DrawCall-数据量无关？" class="headerlink" title="4. 为什么和 DrawCall 数据量无关？"></a>4. 为什么和 DrawCall 数据量无关？</h3><p>因为这个 7% 的 CPU 不是用来处理顶点的，而是用来<strong>处理“打断”这个行为本身的</strong>。</p><ul><li><strong>比喻</strong>：<ul><li>  <strong>正常流程</strong>：你把 100 份文件一次性交给快递员（1 次沟通成本）。</li><li>  <strong>你的流程</strong>：你把 99 份文件给他，让他出发（Invalidate）；然后你突然想起还有 1 份，把他叫回来（Load 成本），把那 1 份给他，再让他出发（第二次沟通成本）。</li><li>  无论那“第 100 份文件”是一张纸还是一箱书，<strong>“把他叫回来并重新发单”</strong> 这个沟通流程（CPU 管理成本）是固定的且昂贵的。</li></ul></li></ul><h3 id="5-总结与建议"><a href="#5-总结与建议" class="headerlink" title="5. 总结与建议"></a>5. 总结与建议</h3><p><strong>现象解释</strong>：<br><code>Invalidate Depth</code> 在 OpenGL ES 驱动看来是一个强烈的<strong>“结束当前渲染并丢弃深度”</strong>的信号。在此之后继续 Draw，迫使驱动<strong>分割 Render Pass</strong>，导致了额外的 CPU 状态管理开销（7% CPU）和 GPU 带宽浪费（多余的 Load/Store）。</p><p><strong>结论</strong>：<br>正如你测试发现的那样，<strong>必须严格遵守 TBR 架构的黄金法则</strong>：</p><ol><li> <strong>Start</strong>：Clear (LoadOp: Clear)</li><li> <strong>Draw</strong>：所有不透明物体</li><li> <strong>Draw</strong>：所有透明物体</li><li> <strong>…其他所有绘制…</strong></li><li> <strong>Invalidate</strong>：<code>glInvalidateFramebuffer(Depth | Stencil)</code> —— <strong>这必须是 SwapBuffer 或 Blit 之前的最后一步操作。</strong></li><li> <strong>End</strong>：Swap / Blit</li></ol><p>不要在 Invalidate 之后进行任何针对同一 FBO 的绘制操作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在 Bash Shell 中，单引号和双引号的主要区别</title>
      <link href="/2025/12/04/Shell%E4%B8%AD%E5%8D%95%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/12/04/Shell%E4%B8%AD%E5%8D%95%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>在 Bash Shell 中，单引号 (<code>&#39; &#39;</code>) 和双引号 (<code>&quot; &quot;</code>) 的主要区别在于 <strong>对特殊字符和变量的处理方式</strong>。</p><p>简单总结：</p><ul><li>  <strong>单引号 (强引用)<strong>：</strong>所见即所得</strong>。单引号内的所有内容都会被当作普通字符，<strong>不进行</strong>变量替换或命令执行。</li><li>  <strong>双引号 (弱引用)<strong>：</strong>允许解析</strong>。双引号内的内容大部分被当作普通字符，但会<strong>保留</strong>变量 (<code>$</code>)、命令替换 (<code>`</code> 或 <code>$()</code>) 和转义符 (<code>\</code>) 的功能。</li></ul><span id="more"></span><hr><h3 id="详细对比"><a href="#详细对比" class="headerlink" title="详细对比"></a>详细对比</h3><h4 id="1-单引号-39-39-——-全封闭"><a href="#1-单引号-39-39-——-全封闭" class="headerlink" title="1. 单引号 (&#39; &#39;) —— 全封闭"></a>1. 单引号 (<code>&#39; &#39;</code>) —— 全封闭</h4><ul><li>  <strong>特性</strong>：最严格的引用。</li><li>  <strong>变量</strong>：不会解析变量，<code>$name</code> 仅仅是字符串 “$name”。</li><li>  <strong>转义</strong>：反斜杠 <code>\</code> 也会被当作普通字符（即无法在单引号内部转义单引号）。</li><li>  <strong>限制</strong>：单引号字符串中不能包含单引号（即使加了反斜杠也不行）。</li></ul><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Hello $name&#x27;</span></span><br><span class="line"><span class="comment"># 输出: Hello $name</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;C:\Windows\System32&#x27;</span></span><br><span class="line"><span class="comment"># 输出: C:\Windows\System32 （反斜杠保留原样）</span></span><br></pre></td></tr></table></figure><h4 id="2-双引号-quot-quot-——-半开放"><a href="#2-双引号-quot-quot-——-半开放" class="headerlink" title="2. 双引号 (&quot; &quot;) —— 半开放"></a>2. 双引号 (<code>&quot; &quot;</code>) —— 半开放</h4><ul><li>  <strong>特性</strong>：较宽松的引用。</li><li>  <strong>变量</strong>：会解析变量，<code>$name</code> 会被替换成变量的值。</li><li>  <strong>命令</strong>：会执行反引号 <code>`command`</code> 或 <code>$(command)</code> 中的命令。</li><li>  <strong>转义</strong>：可以使用反斜杠 <code>\</code> 来转义特殊字符（如 <code>&quot;</code>、<code>$</code>、<code>\</code>、换行符）。</li><li>  <strong>作用</strong>：通常用于防止字符串被空格切分（Word Splitting），同时又需要使用变量的场景。</li></ul><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$name</span>&quot;</span></span><br><span class="line"><span class="comment"># 输出: Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Today is <span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="comment"># 输出: Today is 2023年 10月... (执行了date命令)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;He said: \&quot;Hi\&quot;&quot;</span></span><br><span class="line"><span class="comment"># 输出: He said: &quot;Hi&quot; （使用了转义符）</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-核心区别演示表"><a href="#3-核心区别演示表" class="headerlink" title="3. 核心区别演示表"></a>3. 核心区别演示表</h3><p>假设 <code>var=&quot;test&quot;</code>：</p><table><thead><tr><th align="left">输入代码</th><th align="left">输出结果</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>echo $var</code></td><td align="left"><code>test</code></td><td align="left">无引号，直接展开</td></tr><tr><td align="left"><code>echo &#39;$var&#39;</code></td><td align="left"><code>$var</code></td><td align="left"><strong>单引号</strong>，原样输出字符串</td></tr><tr><td align="left"><code>echo &quot;$var&quot;</code></td><td align="left"><code>test</code></td><td align="left"><strong>双引号</strong>，解析变量值</td></tr><tr><td align="left"><code>echo &#39;Val: $var&#39;</code></td><td align="left"><code>Val: $var</code></td><td align="left">单引号内 <code>$</code> 失效</td></tr><tr><td align="left"><code>echo &quot;Val: $var&quot;</code></td><td align="left"><code>Val: test</code></td><td align="left">双引号内 <code>$</code> 生效</td></tr><tr><td align="left"><code>echo &#39;</code>date<code>&#39;</code></td><td align="left"><code>`date`</code></td><td align="left">原样输出反引号</td></tr><tr><td align="left"><code>echo &quot;</code>date<code>&quot;</code></td><td align="left"><code>Mon Dec...</code></td><td align="left">执行 date 命令</td></tr></tbody></table><hr><h3 id="4-常见问题与技巧"><a href="#4-常见问题与技巧" class="headerlink" title="4. 常见问题与技巧"></a>4. 常见问题与技巧</h3><h4 id="Q-如果我需要在单引号里打印单引号怎么办？"><a href="#Q-如果我需要在单引号里打印单引号怎么办？" class="headerlink" title="Q: 如果我需要在单引号里打印单引号怎么办？"></a>Q: 如果我需要在单引号里打印单引号怎么办？</h4><p>由于单引号内不能转义单引号，你需要用一种“拼接”的技巧：<code>&#39;It&#39;\&#39;&#39;s ok&#39;</code>。</p><ul><li>  解释：第一个 <code>&#39;</code> 结束引用，<code>\&#39;</code> 输出一个转义的单引号，第二个 <code>&#39;</code> 重新开始引用。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;It&#x27;</span>\<span class="string">&#x27;&#x27;</span>s a <span class="built_in">nice</span> day<span class="string">&#x27;</span></span><br><span class="line"><span class="string"># 输出: It&#x27;</span>s a <span class="built_in">nice</span> day</span><br></pre></td></tr></table></figure></li></ul><h4 id="Q-什么时候必须用双引号？"><a href="#Q-什么时候必须用双引号？" class="headerlink" title="Q: 什么时候必须用双引号？"></a>Q: 什么时候必须用双引号？</h4><p>当你需要把一个包含空格的变量作为一个整体参数传给命令时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filename=<span class="string">&quot;My File.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$filename</span>   </span><br><span class="line"><span class="comment"># 错误！这等同于 rm My File.txt (删除了两个文件：My 和 File.txt)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> </span><br><span class="line"><span class="comment"># 正确！这等同于 rm &quot;My File.txt&quot; (删除了一个文件)</span></span><br></pre></td></tr></table></figure><h3 id="总结建议"><a href="#总结建议" class="headerlink" title="总结建议"></a>总结建议</h3><ol><li> 如果字符串里包含 <strong>变量</strong> 或 <strong>命令</strong> 需要被解析，使用 <strong>双引号</strong>。</li><li> 如果字符串里包含很多 <strong>特殊符号</strong>（如 <code>!</code>, <code>$</code>, <code>\</code>, <code>*</code>）且你不希望它们起作用，使用 <strong>单引号</strong>。</li><li> 如果不确定，且字符串包含空格，通常优先使用 <strong>双引号</strong> 来包裹变量。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>存储浮点数</title>
      <link href="/2025/12/04/%E5%AD%98%E5%82%A8%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
      <url>/2025/12/04/%E5%AD%98%E5%82%A8%E6%B5%AE%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>我们要彻底理解这个问题，需要深入到计算机底层是如何存储浮点数（Floating Point）的。这里涉及到一个核心概念：<strong>科学计数法（Scientific Notation）的二进制版本</strong>。</p><p>我们把这个问题拆解成三个部分：<strong>结构解析</strong>、<strong>为什么是 1024 个刻度</strong>、<strong>为什么范围不同精度不同</strong>。</p><span id="more"></span><hr><h3 id="1-结构解析：计算机怎么存小数？"><a href="#1-结构解析：计算机怎么存小数？" class="headerlink" title="1. 结构解析：计算机怎么存小数？"></a>1. 结构解析：计算机怎么存小数？</h3><p><code>mediump</code> (FP16) 只有 16 个格子（bits）来存数字。它不可能把所有数字都存下来，所以它采用了“滑动窗口”的策略。</p><p>结构如下：</p><ul><li>  <strong>符号位 (1 bit)</strong>: 正数还是负数。</li><li>  <strong>指数位 (5 bits, Exponent)</strong>: 决定了数字的<strong>量级</strong>（是几十、几千、还是零点几）。你可以把它理解为<strong>标尺的缩放倍率</strong>。</li><li>  <strong>尾数位 (10 bits, Mantissa)</strong>: 决定了在这个量级下的<strong>精度</strong>。你可以把它理解为<strong>标尺上的刻度线</strong>。</li></ul><h4 id="类比："><a href="#类比：" class="headerlink" title="类比："></a>类比：</h4><p>想象你有一把尺子，这把尺子<strong>只有 1024 个刻度</strong>（由 10 bits 尾数决定，$2^{10}=1024$）。</p><ul><li>  当你测量<strong>蚂蚁</strong>时（指数小），你把尺子缩得很短，这 1024 个刻度非常密集，能测得很准。</li><li>  当你测量<strong>大楼</strong>时（指数大），你把尺子拉得很长，这 1024 个刻度就被拉稀疏了，精度就变差了。</li></ul><hr><h3 id="2-为什么在-1-0-2-0-区间只有-1024-个刻度？"><a href="#2-为什么在-1-0-2-0-区间只有-1024-个刻度？" class="headerlink" title="2. 为什么在 [1.0, 2.0) 区间只有 1024 个刻度？"></a>2. 为什么在 [1.0, 2.0) 区间只有 1024 个刻度？</h3><p>这是由浮点数的标准公式决定的（IEEE 754）。<br>一个归一化（Normalized）的浮点数的值是这样计算的：</p><p>$$ \text{数值} = 2^{\text{指数}} \times (1 + \text{尾数}) $$</p><ul><li>  注意那个 **$1 +$**：这是计算机的一个“聪明设计”。因为二进制下的科学计数法，首位永远是 1（就像十进制科学计数法首位不能是 0 一样，比如 $1.23 \times 10^5$），所以计算机默认省略了这个 1，只存小数点后面的部分，这样能多白嫖 1 bit 的精度。</li></ul><h4 id="让我们来看看-1-0-2-0-这个区间发生了什么："><a href="#让我们来看看-1-0-2-0-这个区间发生了什么：" class="headerlink" title="让我们来看看 [1.0, 2.0) 这个区间发生了什么："></a>让我们来看看 [1.0, 2.0) 这个区间发生了什么：</h4><p>要表示 <strong>1.0 到 1.999…</strong> 之间的数，<strong>指数（Exponent）必须固定为 0</strong>（因为 $2^0 = 1$）。</p><ul><li>  <strong>基准值</strong>: $2^0 = 1$。</li><li>  <strong>变化部分</strong>: 全靠那 <strong>10 bits 的尾数</strong> 来微调。</li></ul><p>尾数有 10 位，每一位可以是 0 或 1。</p><ul><li>  最小的尾数是 <code>0000000000</code> (十进制 0)</li><li>  最大的尾数是 <code>1111111111</code> (十进制 1023)</li><li>  总共有 $2^{10} = 1024$ 种组合。</li></ul><p>因此，在 $1 \times (1 + \text{尾数})$ 这个公式里，尾数把 $[0, 1)$ 这个范围切成了 1024 份。</p><ul><li>  <strong>第 0 个刻度 (1.0)</strong>: $1 \times (1 + \frac{0}{1024}) = 1.000000$</li><li>  <strong>第 1 个刻度</strong>: $1 \times (1 + \frac{1}{1024}) \approx 1.000976$</li><li>  <strong>第 2 个刻度</strong>: $1 \times (1 + \frac{2}{1024}) \approx 1.001953$</li><li>  …</li><li>  <strong>第 1023 个刻度</strong>: $1 \times (1 + \frac{1023}{1024}) \approx 1.999023$</li></ul><p><strong>结论：</strong><br>在 1.0 到 2.0 之间，你<strong>无法</strong>表示 1.0005 这样的数。你只能选择 1.0000 或者 1.000976。<br>这就是所谓的<strong>分辨率（Resolution）</strong>为 $1/1024$。</p><hr><h3 id="3-为什么“大约-3-位十进制精度”？"><a href="#3-为什么“大约-3-位十进制精度”？" class="headerlink" title="3. 为什么“大约 3 位十进制精度”？"></a>3. 为什么“大约 3 位十进制精度”？</h3><p>这只是一个换算估值。<br>我们常用的十进制，3 位数字（000~999）能提供 1000 个刻度。<br>二进制的 10 bits 提供了 1024 个刻度。<br>因为 $1024 \approx 1000$，所以我们常说 FP16 的精度大约相当于十进制的 3 位有效数字。</p><p>这意味着：</p><ul><li>  $1.234$ (4位) 可能存不准。</li><li>  $1.23$ (3位) 通常能存准。</li></ul><hr><h3 id="4-扩展：为什么数值越大，精度越差？（关键点）"><a href="#4-扩展：为什么数值越大，精度越差？（关键点）" class="headerlink" title="4. 扩展：为什么数值越大，精度越差？（关键点）"></a>4. 扩展：为什么数值越大，精度越差？（关键点）</h3><p>刚才我们看的是指数为 $2^0=1$ 的情况（[1, 2]区间）。<br>如果我们把数值变大，比如到了 <strong>[2048, 4096]</strong> 这个区间，会发生什么？</p><p>此时指数变成了 $2^{11} = 2048$。<br>公式变成了：<br>$$ \text{数值} = 2048 \times (1 + \text{尾数}) $$</p><p>尾数依然只能切分 1024 份。<br>也就是把 2048 到 4096 中间这段长度为 2048 的距离，切成 1024 份。</p><ul><li>  <strong>每一步的步长（精度）</strong> = $\frac{\text{区间长度}}{\text{刻度数量}} = \frac{2048}{1024} = 2.0$</li></ul><p><strong>恐怖的结论：</strong><br>在 [2048, 4096] 这个范围内，<strong>mediump 无法表示奇数！</strong><br>它只能表示 2048, 2050, 2052…<br>如果你想存 2049，它会被强制舍入到 2048 或 2050。</p><p>这就是为什么我在上一个回答中说，如果你的 UV 坐标通过 Tiling 变得很大（比如 uv * 100），mediump 精度会崩坏，因为“尺子的刻度”变得非常稀疏，已经大于一个像素的宽度了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mediump（中精度）和 highp（高精度）对比分析</title>
      <link href="/2025/12/03/mediump%EF%BC%88%E4%B8%AD%E7%B2%BE%E5%BA%A6%EF%BC%89%E5%92%8C%20highp%EF%BC%88%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%89%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/"/>
      <url>/2025/12/03/mediump%EF%BC%88%E4%B8%AD%E7%B2%BE%E5%BA%A6%EF%BC%89%E5%92%8C%20highp%EF%BC%88%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%89%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>在移动端渲染开发中（OpenGL ES / Vulkan / Metal），<code>mediump</code>（中精度）和 <code>highp</code>（高精度）的选择对性能和画质影响巨大。</p><p>对于 <strong>UV 坐标（纹理坐标）</strong> 而言，精度的选择直接决定了<strong>纹理采样的准确性</strong>。如果精度不足，会导致画面出现<strong>抖动、锯齿、马赛克或拉伸</strong>。</p><span id="more"></span><p>以下是深度分析：</p><hr><h3 id="1-基础硬指标：FP16-vs-FP32"><a href="#1-基础硬指标：FP16-vs-FP32" class="headerlink" title="1. 基础硬指标：FP16 vs FP32"></a>1. 基础硬指标：FP16 vs FP32</h3><p>首先我们需要知道这两种修饰符在硬件层面通常对应的数据格式（尽管具体实现取决于 GPU）：</p><ul><li><p><strong>mediump (半精度浮点数, FP16)</strong></p><ul><li>  <strong>结构</strong>: 1 bit 符号 + 5 bits 指数 + <strong>10 bits 尾数 (Mantissa)</strong></li><li>  <strong>有效精度</strong>: 约 3 位十进制数字。</li><li>  <strong>分辨率</strong>: $2^{-10} = \frac{1}{1024}$。这意味着在 <code>[1.0, 2.0)</code> 区间内，它只能区分 1024 个刻度。</li></ul></li><li><p><strong>highp (单精度浮点数, FP32)</strong></p><ul><li>  <strong>结构</strong>: 1 bit 符号 + 8 bits 指数 + <strong>23 bits 尾数 (Mantissa)</strong></li><li>  <strong>有效精度</strong>: 约 7 位十进制数字。</li><li>  <strong>分辨率</strong>: $2^{-23} \approx \frac{1}{8,388,608}$。精度极高，远超当前屏幕像素密度。</li></ul></li></ul><hr><h3 id="2-不同数据范围下的表现分析"><a href="#2-不同数据范围下的表现分析" class="headerlink" title="2. 不同数据范围下的表现分析"></a>2. 不同数据范围下的表现分析</h3><p>UV 精度问题的核心在于：<strong>浮点数的精度随着数值绝对值的增大而降低</strong>。<br>我们将场景分为三种情况：标准范围、平铺/大坐标、动态滚动。</p><h4 id="情况一：标准-UV-范围-0-0-1-0"><a href="#情况一：标准-UV-范围-0-0-1-0" class="headerlink" title="情况一：标准 UV 范围 $[0.0, 1.0]$"></a>情况一：标准 UV 范围 $[0.0, 1.0]$</h4><p>这是最常见的模型贴图或 UI 贴图范围。</p><ul><li><p><strong>纹理尺寸 512x512</strong>：</p><ul><li>  单像素宽度：$1/512 \approx 0.0019$</li><li>  <strong>mediump 精度</strong>：在 $0 \sim 1$ 范围内，步长约为 $1/1024 \approx 0.00097$。</li><li>  <strong>结果</strong>：$0.00097 &lt; 0.0019$，<strong>精度足够</strong>。每个纹理像素都能被准确索引。</li></ul></li><li><p><strong>纹理尺寸 1024x1024</strong>：</p><ul><li>  单像素宽度：$1/1024 \approx 0.00097$</li><li>  <strong>mediump 精度</strong>：约为 $0.00097$。</li><li>  <strong>结果</strong>：<strong>临界状态</strong>。FP16 的采样步长刚好等于纹理像素大小。可能会出现轻微的采样偏移，但在双线性插值下通常肉眼难以察觉。</li></ul></li><li><p><strong>纹理尺寸 2048x2048 及以上</strong>：</p><ul><li>  单像素宽度：$1/2048 \approx 0.00048$</li><li>  <strong>mediump 精度</strong>：依然是 $0.00097$。</li><li>  <strong>结果</strong>：<strong>精度不足</strong>。FP16 的最小步长已经是 2 个像素宽了。你会看到纹理变得模糊，或者在缓慢移动视角时纹理出现“跳动”（Snapping）。</li></ul></li></ul><h4 id="情况二：平铺纹理-大坐标范围-0-0-10-0-或更大"><a href="#情况二：平铺纹理-大坐标范围-0-0-10-0-或更大" class="headerlink" title="情况二：平铺纹理 / 大坐标范围 $[0.0, 10.0]$ 或更大"></a>情况二：平铺纹理 / 大坐标范围 $[0.0, 10.0]$ 或更大</h4><p>这是地面重复贴图、墙面平铺的常见场景。UV 值可能达到 10、20 甚至 100。</p><ul><li><p><strong>原理</strong>：浮点数在数值越大时，刻度越稀疏。</p><ul><li>  在 $[0, 1)$ 范围，FP16 精度是 $1/1024$。</li><li>  在 $[1, 2)$ 范围，FP16 精度是 $1/512$。</li><li>  在 $[2, 4)$ 范围，FP16 精度是 $1/256$。</li><li>  在 $[8, 16)$ 范围，FP16 精度是 $1/64$。</li></ul></li><li><p><strong>灾难推演</strong>：</p><ul><li>  假设你的 UV 是 <code>u_tiling * v_uv</code>，结果范围到了 $[8.0, 16.0]$。</li><li>  此时 <code>mediump</code> 的最小分辨单位是 $1/64$。</li><li>  如果你的贴图还是 1024x1024 的，你需要 $1/1024$ 的精度。</li><li>  <strong>差距</strong>：你需要的精度是现有精度的 16 倍。</li><li>  <strong>视觉效果</strong>：严重的<strong>马赛克化</strong>。原本平滑的直线会变成阶梯状，纹理看起来像是被强制缩小了分辨率（Pixelated）。</li></ul></li></ul><h4 id="情况三：动态滚动-时间累加-Flow-map-Water"><a href="#情况三：动态滚动-时间累加-Flow-map-Water" class="headerlink" title="情况三：动态滚动 / 时间累加 (Flow map, Water)"></a>情况三：动态滚动 / 时间累加 (Flow map, Water)</h4><p>在 Shader 中常见代码：<code>vec2 uv = v_uv + vec2(time * speed, 0.0);</code></p><ul><li>  <strong>问题</strong>：随着 <code>time</code> 的增加，UV 的整数部分越来越大。</li><li><strong>现象</strong>：<ul><li>  游戏刚开始运行（Time &lt; 100）：水面流动正常。</li><li>  游戏运行 10 分钟后（Time &gt; 1000）：水面流动开始出现卡顿、跳变。</li><li>  游戏运行久了：水面纹理完全静止不动，因为 <code>time</code> 增加的微小量（Delta Time）已经小于 FP16 在那个数值下的最小精度（Machine Epsilon），导致加法无效。</li></ul></li></ul><hr><h3 id="3-Vertex-Shader-vs-Fragment-Shader-的陷阱"><a href="#3-Vertex-Shader-vs-Fragment-Shader-的陷阱" class="headerlink" title="3. Vertex Shader vs Fragment Shader 的陷阱"></a>3. Vertex Shader vs Fragment Shader 的陷阱</h3><p>这是一个极其容易被忽视的环节：<strong>Varying 插值精度</strong>。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex Shader</span></span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">mediump</span> <span class="type">vec2</span> v_uv; <span class="comment">// 坑点在这里！</span></span><br><span class="line"><span class="type">void</span> main() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fragment Shader</span></span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">mediump</span> <span class="type">vec2</span> v_uv;</span><br></pre></td></tr></table></figure><p>即使你在 Fragment Shader 中使用了 <code>highp</code> 进行纹理采样，<strong>如果 Varying 变量（从 VS 传到 FS）被声明为 <code>mediump</code>，那么插值过程就是低精度的。</strong></p><ul><li>  <strong>现象</strong>：当摄像机贴近物体表面观察时，纹理会随着视角的微小移动而发生剧烈的形变或抖动（Wobble）。这是因为光栅化插值时的坐标精度不够，导致 UV 坐标在像素之间“乱跳”。</li></ul><hr><h3 id="4-总结与最佳实践建议"><a href="#4-总结与最佳实践建议" class="headerlink" title="4. 总结与最佳实践建议"></a>4. 总结与最佳实践建议</h3><table><thead><tr><th align="left">场景</th><th align="left">推荐精度</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left"><strong>UI 贴图 / 2D 精灵</strong></td><td align="left"><code>mediump</code></td><td align="left">通常坐标在 0-1 之间，且纹理通常不会过大（&lt;1024）。</td></tr><tr><td align="left"><strong>3D 模型 (UV 0-1)</strong></td><td align="left"><code>mediump</code> / <code>highp</code></td><td align="left">1024以下纹理可用 mediump；2048以上或对画质要求高必须用 highp。</td></tr><tr><td align="left"><strong>地形 / 地面 / 墙壁</strong></td><td align="left"><strong><code>highp</code></strong></td><td align="left">只要涉及 UV Tiling (uv * 10.0)，mediump 必死无疑。</td></tr><tr><td align="left"><strong>纹理动画 / 滚动</strong></td><td align="left"><strong><code>highp</code></strong></td><td align="left">避免随时间推移产生精度丢失导致的卡顿。</td></tr><tr><td align="left"><strong>法线贴图 / 视差映射</strong></td><td align="left"><strong><code>highp</code></strong></td><td align="left">法线对精度极其敏感，UV 的微小抖动会导致光照剧烈闪烁。</td></tr><tr><td align="left"><strong>Varying 传递</strong></td><td align="left"><strong><code>highp</code></strong></td><td align="left">现代 GPU highp 性能开销通常可接受，建议默认 v_uv 使用 highp 以避免插值抖动。</td></tr></tbody></table><h4 id="快速判断公式-针对-mediump"><a href="#快速判断公式-针对-mediump" class="headerlink" title="快速判断公式 (针对 mediump)"></a>快速判断公式 (针对 mediump)</h4><p>如果你想用 <code>mediump</code>，请确保满足以下条件：</p><p>$$ \text{MaxUV} \times \text{TextureSize} &lt; 1024 $$</p><ul><li>  <em>MaxUV</em>: UV 坐标的最大值（例如 Tiling 是 4，则为 4）。</li><li>  <em>TextureSize</em>: 纹理分辨率（例如 512）。</li></ul><p><strong>例子</strong>：</p><ul><li>  512px 纹理，UV Tiling = 2.0 $\rightarrow 512 \times 2 = 1024$ (勉强可用)</li><li>  1024px 纹理，UV Tiling = 1.0 $\rightarrow 1024 \times 1 = 1024$ (勉强可用)</li><li>  1024px 纹理，UV Tiling = 4.0 $\rightarrow 4096 \gg 1024$ (<strong>不可用，会出现严重马赛克</strong>)</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在移动端现代 GPU（Adreno 5xx/6xx, Mali G-series, Apple GPU）上，<code>highp</code> 的性能损耗已经非常小了。</p><p><strong>黄金法则：</strong><br>除非你是在做极端的性能优化（针对低端机）且确定 UV 永远在 [0,1] 范围内且纹理很小，否则**UV 相关的计算和 Varying 传递请无脑使用 <code>highp</code>**。这能帮你省去无数排查“为什么纹理在抖”或“为什么有锯齿”的时间。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于preA精度损失分析</title>
      <link href="/2025/12/03/%E5%85%B3%E4%BA%8EpreA%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E5%88%86%E6%9E%90/"/>
      <url>/2025/12/03/%E5%85%B3%E4%BA%8EpreA%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>这是一份关于 <strong>RGBA8888</strong> 格式下，<strong>Pre-multiplied Alpha (预乘 Alpha, 简称 PreA)</strong> 与 <strong>Straight Alpha (非预乘 Alpha/直通 Alpha, 简称 Non-PreA)</strong> 在精度损失和不同颜色数据范围内表现的深度分析。</p><span id="more"></span><hr><h3 id="1-基本定义与存储差异"><a href="#1-基本定义与存储差异" class="headerlink" title="1. 基本定义与存储差异"></a>1. 基本定义与存储差异</h3><p>在 <strong>RGBA8888</strong> 格式中，每个通道（R, G, B, A）占用 8 bits，取值范围为 $[0, 255]$。</p><ul><li><p><strong>Non-PreA (Straight Alpha):</strong></p><ul><li>  存储原始颜色值。</li><li>  $R, G, B$ 的取值与 $A$ 无关。</li><li>  <strong>公式</strong>: $(R, G, B, A)$</li><li>  <strong>约束</strong>: $R, G, B \in [0, 255]$</li></ul></li><li><p><strong>PreA (Premultiplied Alpha):</strong></p><ul><li>  存储颜色值乘以 Alpha 后的结果。</li><li>  <strong>公式</strong>: $(R \times \frac{A}{255}, G \times \frac{A}{255}, B \times \frac{A}{255}, A)$</li><li>  <strong>约束</strong>: 存储的 RGB 值通常不能大于 A（在整数运算中）。即 $R_{pre} \le A$。</li></ul></li></ul><hr><h3 id="2-精度损失分析-The-Precision-Loss"><a href="#2-精度损失分析-The-Precision-Loss" class="headerlink" title="2. 精度损失分析 (The Precision Loss)"></a>2. 精度损失分析 (The Precision Loss)</h3><p>精度损失的核心原因在于：<strong>我们是在有限的整数空间（0-255）内进行乘法和除法运算，必然涉及舍入（Rounding）或截断。</strong></p><h4 id="2-1-从-Non-PreA-转换到-PreA"><a href="#2-1-从-Non-PreA-转换到-PreA" class="headerlink" title="2.1 从 Non-PreA 转换到 PreA"></a>2.1 从 Non-PreA 转换到 PreA</h4><p>这是一个<strong>有损</strong>过程，特别是当 Alpha 值很小时。</p><ul><li>  <strong>计算</strong>: $C_{pre} = \text{Round}(C_{src} \times \frac{A}{255})$</li><li><strong>现象</strong>:<ul><li>  当 $A = 255$ 时：无损失。</li><li>  当 $A = 128$ 时：颜色空间从 256 阶被压缩到 129 阶（0-128），损失 1 bit 精度。</li><li>  当 $A = 10$ 时：原始 0-255 的颜色范围被强行压缩到 0-10 的范围内。</li><li>  当 $A = 0$ 时：所有 RGB 信息被强制置为 0，颜色信息<strong>完全丢失</strong>。</li></ul></li></ul><h4 id="2-2-从-PreA-还原到-Non-PreA-Un-premultiply"><a href="#2-2-从-PreA-还原到-Non-PreA-Un-premultiply" class="headerlink" title="2.2 从 PreA 还原到 Non-PreA (Un-premultiply)"></a>2.2 从 PreA 还原到 Non-PreA (Un-premultiply)</h4><p>这是对精度损失的放大过程。</p><ul><li>  <strong>计算</strong>: $C_{dst} = \text{Round}(C_{pre} \times \frac{255}{A})$</li><li><strong>现象</strong>: 如果你拿到一张 PreA 的图片，且某个像素 $A=10, R_{pre}=5$。<ul><li>  还原时，$R = 5 \times 25.5 = 127.5 \approx 128$。</li><li>  但是，原始的 Non-PreA 值可能是 115 到 140 之间的任何数，在这个过程中，细节已经不可逆地丢失了。这会导致直方图出现巨大的断层（Banding）。</li></ul></li></ul><hr><h3 id="3-不同颜色-Alpha-数据范围内的表现"><a href="#3-不同颜色-Alpha-数据范围内的表现" class="headerlink" title="3. 不同颜色/Alpha 数据范围内的表现"></a>3. 不同颜色/Alpha 数据范围内的表现</h3><p>我们将情况分为三个区段来分析：完全不透明、半透明、完全透明。</p><h4 id="3-1-高-Alpha-区段-A-approx-255"><a href="#3-1-高-Alpha-区段-A-approx-255" class="headerlink" title="3.1 高 Alpha 区段 ($A \approx 255$)"></a>3.1 高 Alpha 区段 ($A \approx 255$)</h4><ul><li>  <strong>范围</strong>: $A \in [240, 255]$</li><li><strong>分析</strong>:<ul><li>  <strong>Non-PreA</strong>: 完美保留。</li><li>  <strong>PreA</strong>: 精度损失极小，肉眼几乎无法察觉。RGB 的有效值域依然接近 0-255。</li></ul></li><li>  <strong>结论</strong>: 此时两者表现基本一致。</li></ul><h4 id="3-2-低-Alpha-区段-A-in-1-50-——-精度灾难区"><a href="#3-2-低-Alpha-区段-A-in-1-50-——-精度灾难区" class="headerlink" title="3.2 低 Alpha 区段 ($A \in [1, 50]$) —— 精度灾难区"></a>3.2 低 Alpha 区段 ($A \in [1, 50]$) —— <strong>精度灾难区</strong></h4><ul><li>  <strong>范围</strong>: 淡淡的阴影、玻璃的反光、几乎透明的特效。</li><li><strong>分析</strong>:<ul><li>  <strong>Non-PreA</strong>: 依然可以存储纯正的红色 $(255, 0, 0, 10)$。虽然看不清，但数据是高精度的。</li><li><strong>PreA</strong>: 必须将红色存储为 $(10, 0, 0, 10)$。<ul><li>  原始的 $RGB(255)$ 被压缩为 $10$。</li><li>  原始的 $RGB(24)$ 被压缩为 $0$ 或 $1$。</li></ul></li></ul></li><li><strong>后果</strong>:<ul><li>  如果在渲染管线后期需要对这个低 Alpha 图像进行 <strong>Color Balance（色彩平衡）</strong> 或 <strong>Gamma 校正</strong>，PreA 格式由于只有很少的几个台阶（Quantization steps），会出现严重的<strong>色带（Banding）</strong>。</li><li>  <strong>混合运算</strong>: PreA 虽然存储精度低，但在混合（Composing）时通常是数学正确的。而 Non-PreA 如果直接混合，精度高但计算量大。</li></ul></li></ul><h4 id="3-3-Zero-Alpha-区段-A-0-——-信息毁灭区"><a href="#3-3-Zero-Alpha-区段-A-0-——-信息毁灭区" class="headerlink" title="3.3 Zero Alpha 区段 ($A = 0$) —— 信息毁灭区"></a>3.3 Zero Alpha 区段 ($A = 0$) —— <strong>信息毁灭区</strong></h4><ul><li>  <strong>范围</strong>: 完全透明区域。</li><li><strong>分析</strong>:<ul><li>  <strong>Non-PreA</strong>: 可以存储 “隐藏颜色”。例如 $(255, 0, 0, 0)$。这在游戏开发中很有用，用于存储一些额外数据（如法线、遮罩），或者为了在纹理过滤（Bilinear Filtering）时不产生黑边。</li><li>  <strong>PreA</strong>: 强制变为 $(0, 0, 0, 0)$。</li></ul></li><li><strong>后果</strong>:<ul><li>  PreA 无法在完全透明的像素中携带颜色信息。</li><li>  <strong>黑边问题（Dark Halo）的逆向思考</strong>: 如果使用 Non-PreA 且透明区域是黑色 $(0,0,0,0)$，线性插值到不透明白色 $(255,255,255,255)$ 时，中间值会变黑。<strong>PreA 天生解决了插值黑边问题</strong>，因为它在插值前已经把颜色和 Alpha 绑定了。</li></ul></li></ul><hr><h3 id="4-综合对比总结表"><a href="#4-综合对比总结表" class="headerlink" title="4. 综合对比总结表"></a>4. 综合对比总结表</h3><table><thead><tr><th align="left">特性</th><th align="left">Non-PreA (RGBA)</th><th align="left">PreA (RGBA)</th><th align="left">精度/效果评价</th></tr></thead><tbody><tr><td align="left"><strong>存储空间</strong></td><td align="left">RGBA 各自独立</td><td align="left">RGB $\le$ A</td><td align="left">PreA 有效颜色空间随 Alpha 减小而呈线性衰减。</td></tr><tr><td align="left"><strong>A=255 精度</strong></td><td align="left">100% (8-bit)</td><td align="left">100% (8-bit)</td><td align="left">一致。</td></tr><tr><td align="left"><strong>A=10 精度</strong></td><td align="left">100% (8-bit)</td><td align="left"><strong>&lt; 4%</strong> (约 3-4 bits)</td><td align="left"><strong>PreA 严重丢失颜色精度</strong>。</td></tr><tr><td align="left"><strong>A=0 数据</strong></td><td align="left">保留原始 RGB</td><td align="left"><strong>丢失</strong> (强制 RGB=0)</td><td align="left">PreA 无法存储透明像素的颜色。</td></tr><tr><td align="left"><strong>线性插值 (缩放)</strong></td><td align="left"><strong>错误</strong> (容易产生黑边/白边)</td><td align="left"><strong>正确</strong> (物理上符合光线叠加)</td><td align="left"><strong>PreA 在渲染质量上完胜</strong>。</td></tr><tr><td align="left"><strong>混合公式</strong></td><td align="left">$Src \times A + Dst \times (1-A)$</td><td align="left">$Src + Dst \times (1-A)$</td><td align="left">PreA 也就是少了一次乘法，效率略高。</td></tr><tr><td align="left"><strong>色彩调整</strong></td><td align="left">安全</td><td align="left"><strong>危险</strong></td><td align="left">对 PreA 图片做亮度/对比度调整会放大量化误差。</td></tr></tbody></table><h3 id="5-结论与建议"><a href="#5-结论与建议" class="headerlink" title="5. 结论与建议"></a>5. 结论与建议</h3><ol><li><p><strong>作为存储格式 (Assets on Disk)</strong>:</p><ul><li>  <strong>推荐 Non-PreA</strong> (如 PNG)。</li><li>  原因：最大限度保留颜色精度，不破坏原始数据。如果设计师画了一个透明度为 1% 的红色光晕，Non-PreA 能保留它是“红色”的事实，而 PreA 存盘后再读出来可能就变成黑色或极低精度的噪点了。</li></ul></li><li><p><strong>作为渲染纹理 (Texture in GPU)</strong>:</p><ul><li>  <strong>推荐 PreA</strong>。</li><li>原因：<ol><li> <strong>插值正确性</strong>：GPU 进行双线性插值（Bilinear Interpolation）或生成 Mipmap 时，PreA 才是数学上正确的。Non-PreA 会导致透明物体边缘出现脏边。</li><li> <strong>混合效率</strong>：无需在 Shader 中每像素执行一次乘法。</li></ol></li></ul></li><li><p><strong>特殊情况</strong>:</p><ul><li>  如果利用 RGB 通道做非颜色数据存储（如法线贴图、数据包），<strong>绝对不能</strong>使用 PreA，否则 Alpha 通道的变化会破坏数据。</li></ul></li></ol><p><strong>一句话总结：</strong><br><strong>Non-PreA 赢在存储精度（特别是低 Alpha 时），PreA 赢在渲染正确性和混合效率。转换过程（Non-PreA -&gt; PreA）是不可逆的精度丢失过程。</strong></p><p>这是一个非常经典且反直觉的问题。要理解“脏边”（Dark Halo / Artifacts），我们需要深入到<strong>线性插值（Linear Interpolation）</strong>的数学计算步骤中去。</p><p>核心原因可以一句话概括：<strong>非 PreA 模式下，插值算法把“透明像素的RGB值”也算进去了，而绝大多数透明像素的 RGB 默认是黑色（0,0,0）。</strong></p><p>我们通过一个具体的<strong>数值推演</strong>来演示这个“灾难”是如何发生的。</p><hr><h3 id="1-场景设定：白色的边缘"><a href="#1-场景设定：白色的边缘" class="headerlink" title="1. 场景设定：白色的边缘"></a>1. 场景设定：白色的边缘</h3><p>假设你有一张图片，里面有一个<strong>纯白色的圆</strong>，边缘是平滑过渡到透明背景的。<br>我们在纹理（Texture）上选取相邻的两个像素：</p><ul><li><strong>像素 A (前景)</strong>: 纯白，完全不透明。<ul><li>  数据: <code>R=255, G=255, B=255, A=255</code> (归一化为 1.0)</li></ul></li><li><strong>像素 B (背景)</strong>: 完全透明。<ul><li>  <strong>关键点</strong>: 在通常的图片格式（如 PNG）中，完全透明的像素通常被存储为 <code>R=0, G=0, B=0, A=0</code>。虽然它看不见，但它的 RGB 数据确实是黑色。</li></ul></li></ul><hr><h3 id="2-渲染时的插值过程"><a href="#2-渲染时的插值过程" class="headerlink" title="2. 渲染时的插值过程"></a>2. 渲染时的插值过程</h3><p>当你在屏幕上绘制这张图，且进行了缩放或正好采样到 A 和 B 中间的位置时，GPU 会进行<strong>线性插值</strong>（Bilinear Filtering）。GPU 会分别对 R, G, B, A 四个通道取平均值（假设采样位置正好在正中间，权重各 50%）。</p><h4 id="情况一：非-PreA-Straight-Alpha-的插值灾难"><a href="#情况一：非-PreA-Straight-Alpha-的插值灾难" class="headerlink" title="情况一：非 PreA (Straight Alpha) 的插值灾难"></a>情况一：非 PreA (Straight Alpha) 的插值灾难</h4><p>GPU 并不懂 RGB 和 A 的逻辑关系，它只是无脑地对四个通道做数学平均：</p><ol><li> <strong>R 通道插值</strong>: $(255 \times 0.5) + (0 \times 0.5) = 127.5$</li><li> <strong>G 通道插值</strong>: $(255 \times 0.5) + (0 \times 0.5) = 127.5$</li><li> <strong>B 通道插值</strong>: $(255 \times 0.5) + (0 \times 0.5) = 127.5$</li><li> <strong>A 通道插值</strong>: $(255 \times 0.5) + (0 \times 0.5) = 127.5$ (即 0.5 的透明度)</li></ol><p><strong>得到的结果像素 P</strong>:<br><code>R=127.5, G=127.5, B=127.5, A=127.5</code> (即 0.5)</p><p><strong>渲染混合阶段 (Composing Stage)</strong>:<br>现在的显卡要根据 Alpha 混合这个像素。公式通常是 <code>Src.rgb * Src.a + Dst.rgb * (1 - Src.a)</code>。<br>注意：因为是非 PreA，Shader 中需要先乘一次 Alpha。</p><ul><li>  <strong>最终显示的颜色贡献</strong> = $P.rgb \times P.a$</li><li>  <strong>计算</strong>: $127.5 \times 0.5 \approx 63.75$</li></ul><p><strong>结果分析</strong>:<br>我们期望的是“50% 透明度的<strong>白色</strong>”，也就是亮度应该约为 <strong>127.5</strong>。<br>但实际算出来的是亮度为 <strong>63.75</strong> 的颜色。<br><strong>63.75 是什么颜色？是深灰色！</strong></p><p><strong>结论</strong>：原本应该呈现“半透明白色”的地方，显示成了“半透明灰色”。这就是<strong>黑边/脏边</strong>。</p><hr><h4 id="情况二：PreA-Premultiplied-Alpha-的完美表现"><a href="#情况二：PreA-Premultiplied-Alpha-的完美表现" class="headerlink" title="情况二：PreA (Premultiplied Alpha) 的完美表现"></a>情况二：PreA (Premultiplied Alpha) 的完美表现</h4><p>在 PreA 格式下，像素存储时 RGB 已经乘过 Alpha 了。</p><ul><li>  <strong>像素 A</strong>: <code>(255, 255, 255, 255)</code> (因为 A=1，RGB不变)</li><li>  <strong>像素 B</strong>: <code>(0, 0, 0, 0)</code> (因为 A=0，RGB必须是0)</li></ul><p>看起来数据一样？别急，看混合。</p><p><strong>插值过程</strong>:</p><ol><li> <strong>R 通道</strong>: $(255 + 0) / 2 = 127.5$</li><li> <strong>A 通道</strong>: $(255 + 0) / 2 = 127.5$<br>得到像素 P: <code>(127.5, 127.5, 127.5, 127.5)</code></li></ol><p><strong>渲染混合阶段</strong>:<br>PreA 的混合公式是 <code>One, OneMinusSrcAlpha</code>，也就是 <code>Src.rgb + Dst.rgb * (1 - Src.a)</code>。<strong>不需要再乘一次 Alpha</strong>，因为插值出来的 <code>127.5</code> 已经是物理上的光强了。</p><ul><li>  <strong>最终显示的颜色贡献</strong> = $P.rgb$ (直接使用)</li><li>  <strong>数值</strong>: <strong>127.5</strong></li></ul><p><strong>结果分析</strong>:<br>我们期望亮度 127.5，实际得到 127.5。<br><strong>结果是完美的“半透明白色”。</strong></p><hr><h3 id="3-为什么会这样？（直观理解）"><a href="#3-为什么会这样？（直观理解）" class="headerlink" title="3. 为什么会这样？（直观理解）"></a>3. 为什么会这样？（直观理解）</h3><p>问题的本质在于：<strong>插值（Interpolation）和 预乘（Premultiplication）的顺序不能颠倒。</strong></p><ul><li>  <strong>正确的物理逻辑</strong>: 先计算出每个点发出的光强（Pre-multiply），再把光强混合起来（Interpolate）。这就是 <strong>PreA</strong>。</li><li>  <strong>错误的逻辑 (Non-PreA)</strong>: 先把颜色混合起来，再根据透明度去衰减它。</li></ul><p>在 Non-PreA 的例子中：<br>你把<strong>白色 (255)</strong> 和 <strong>黑色 (0)</strong> 进行了混合，得到了 **灰色 (128)**。<br>然后你告诉 GPU：“这个灰色是半透明的”。<br>于是 GPU 就画了一个半透明的灰色。</p><p>但在物理上，那个 <strong>黑色 (0)</strong> 是完全透明的，它<strong>不应该贡献任何颜色信息</strong>。但是线性插值愚蠢地把它的“黑色成分”拉进了平均值里，稀释了原本纯净的白色。</p><h3 id="4-只有黑色会导致脏边吗？（扩展知识）"><a href="#4-只有黑色会导致脏边吗？（扩展知识）" class="headerlink" title="4. 只有黑色会导致脏边吗？（扩展知识）"></a>4. 只有黑色会导致脏边吗？（扩展知识）</h3><p>不一定。<br>如果你的透明背景不是黑色 <code>(0,0,0,0)</code>，而是白色 <code>(255,255,255,0)</code>（这叫 “Bleeding” 处理），那么 Non-PreA 插值时：<br><code>(255+255)/2 = 255</code>。<br>最终得到半透明白色，就没有黑边。</p><p><strong>但是</strong>，在实际的游戏引擎和压缩格式中，为了节省空间或默认行为，透明区域的 RGB 通道几乎总是会被清零或压缩成乱码，所以<strong>黑边问题在 Non-PreA 中几乎是必然发生的</strong>。</p><p><strong>总结：</strong><br>非 PreA 出现脏边，是因为它让<strong>透明像素的 RGB 值（通常是黑色）</strong>错误地参与了颜色的混合，把边缘的颜色“染黑”了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SRGB 和gamma校正</title>
      <link href="/2025/12/03/SRGB%20%E5%92%8Cgamma%E6%A0%A1%E6%AD%A3/"/>
      <url>/2025/12/03/SRGB%20%E5%92%8Cgamma%E6%A0%A1%E6%AD%A3/</url>
      
        <content type="html"><![CDATA[<p>为了让你直观地感受到 <strong>Gamma 校正（Gamma Encoding）</strong> 的威力，我们来做一次具体的数值对比。</p><p>我们假设使用的标准 Gamma 值为 <strong>2.2</strong>。<br>公式为：<br>$$ \text{Gamma值} = \text{线性值}^{(1 / 2.2)} \approx \text{线性值}^{0.4545} $$</p><span id="more"></span><p>这里我们将对比 <strong>线性空间（Linear，物理真实亮度）</strong> 和 <strong>Gamma 空间（sRGB，存入图片或屏幕显示的数值）</strong>。为了方便理解，我同时列出了 <strong>0.0 - 1.0 (浮点数)</strong> 和 <strong>0 - 255 (8位整数)</strong> 的对应值。</p><h3 id="1-数值对比表"><a href="#1-数值对比表" class="headerlink" title="1. 数值对比表"></a>1. 数值对比表</h3><p>请特别注意<strong>暗部</strong>的变化幅度：</p><table><thead><tr><th align="left">描述</th><th align="left">线性值 (Linear) <br>物理光照强度</th><th align="left">线性 8-bit <br>(如果直接存)</th><th align="left"><strong>Gamma 校正后 (sRGB)</strong> <br>存入显存/图片的数值</th><th align="left">sRGB 8-bit <br>(最终色值)</th><th align="left"><strong>变化分析</strong></th></tr></thead><tbody><tr><td align="left"><strong>纯黑</strong></td><td align="left">0.0</td><td align="left">0</td><td align="left"><strong>0.0</strong></td><td align="left"><strong>0</strong></td><td align="left">无变化</td></tr><tr><td align="left"><strong>极暗部</strong></td><td align="left">0.01 (1% 亮度)</td><td align="left">2</td><td align="left"><strong>0.123</strong></td><td align="left"><strong>31</strong></td><td align="left"><strong>暴增 12 倍！</strong> 保留了暗部细节</td></tr><tr><td align="left"><strong>暗影</strong></td><td align="left">0.1 (10% 亮度)</td><td align="left">25</td><td align="left"><strong>0.351</strong></td><td align="left"><strong>90</strong></td><td align="left">提升约 3.5 倍，从几乎看不见变成了深灰</td></tr><tr><td align="left"><strong>物理中灰</strong></td><td align="left">0.218 (21.8% 亮度)</td><td align="left">55</td><td align="left"><strong>0.500</strong></td><td align="left"><strong>128</strong></td><td align="left"><strong>关键点</strong>：物理亮度的 21% 对应数据上的 50%</td></tr><tr><td align="left"><strong>中间色</strong></td><td align="left">0.5 (50% 亮度)</td><td align="left">128</td><td align="left"><strong>0.730</strong></td><td align="left"><strong>186</strong></td><td align="left">提升显著，物理的一半亮度看起来像 73% 的白</td></tr><tr><td align="left"><strong>亮部</strong></td><td align="left">0.8 (80% 亮度)</td><td align="left">204</td><td align="left"><strong>0.903</strong></td><td align="left"><strong>230</strong></td><td align="left">提升幅度变小</td></tr><tr><td align="left"><strong>纯白</strong></td><td align="left">1.0</td><td align="left">255</td><td align="left"><strong>1.0</strong></td><td align="left"><strong>255</strong></td><td align="left">无变化</td></tr></tbody></table><hr><h3 id="2-核心观察与图解分析"><a href="#2-核心观察与图解分析" class="headerlink" title="2. 核心观察与图解分析"></a>2. 核心观察与图解分析</h3><h4 id="A-暗部的“扩容”-最重要的作用"><a href="#A-暗部的“扩容”-最重要的作用" class="headerlink" title="A. 暗部的“扩容” (最重要的作用)"></a>A. 暗部的“扩容” (最重要的作用)</h4><p>看表格中的第二行（极暗部）：</p><ul><li>  <strong>线性世界</strong>：亮度只有 <code>0.01</code>。如果在 0-255 的整数中，它对应 <code>2</code>。这意味着如果你不做 Gamma 校正直接存，0 到 1% 的亮度之间只有 0, 1, 2 这三个台阶，会出现极度明显的<strong>色带</strong>，暗部细节全部丢失（死黑）。</li><li>  <strong>Gamma 校正后</strong>：数值变成了 <code>0.123</code> (对应 8-bit 的 <code>31</code>)。</li><li>  <strong>结论</strong>：Gamma 校正把暗部极小的一段物理亮度，强行“拉伸”到了较大的数据空间中。<strong>它把宝贵的 8-bit 存储空间更多地分配给了人眼敏感的暗部。</strong></li></ul><h4 id="B-著名的“中灰”-Middle-Gray"><a href="#B-著名的“中灰”-Middle-Gray" class="headerlink" title="B. 著名的“中灰” (Middle Gray)"></a>B. 著名的“中灰” (Middle Gray)</h4><p>看表格中的第四行：</p><ul><li>  在摄影和渲染中，有一个经典的认知：<strong>18%~22% 的物理反射率，人眼看起来是 50% 的灰色。</strong></li><li>  <strong>线性值 0.218</strong> $\rightarrow$ <strong>Gamma 值 0.5</strong>。</li><li>  这就是为什么如果你错误地使用了线性工作流（比如忘记做 Gamma 校正），直接把 0.218 输出到屏幕，屏幕会显示出很暗的颜色（物理上的 21%），而你原本期望的是一种“正中间的灰色”。</li></ul><h4 id="C-为什么不用-SRGBA8-会导致画面“黑死”？"><a href="#C-为什么不用-SRGBA8-会导致画面“黑死”？" class="headerlink" title="C. 为什么不用 SRGBA8 会导致画面“黑死”？"></a>C. 为什么不用 SRGBA8 会导致画面“黑死”？</h4><p>如果你在 Shader 里算出的光照是 <code>0.1</code> (线性)：</p><ol><li>**错误做法 (用 RGBA8)**：写入 <code>0.1</code> $\rightarrow$ 屏幕收到 <code>0.1</code> $\rightarrow$ 屏幕 Gamma 2.2 压暗 $\rightarrow$ 最终人眼看到亮度 $0.1^{2.2} \approx 0.006$。<ul><li>  <strong>结果</strong>：本来该有影子的细节，直接变成了纯黑，画面对比度极高，像烧焦了一样。</li></ul></li><li>**正确做法 (用 SRGBA8)**：写入 <code>0.1</code> $\rightarrow$ 硬件自动转为 <code>0.35</code> (存入显存) $\rightarrow$ 屏幕收到 <code>0.35</code> $\rightarrow$ 屏幕 Gamma 2.2 压暗 ($0.35^{2.2} \approx 0.1$) $\rightarrow$ 人眼看到亮度 <code>0.1</code>。<ul><li>  <strong>结果</strong>：所算即所见，光影柔和自然。</li></ul></li></ol><h3 id="3-代码模拟"><a href="#3-代码模拟" class="headerlink" title="3. 代码模拟"></a>3. 代码模拟</h3><p>如果把这个过程写成 Shader 代码，区别就是这样：</p><p><strong>假设我们计算出的颜色是 <code>vec3 linearColor = vec3(0.218, 0.218, 0.218);</code></strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况 1: 设置了 kEAGLColorFormatRGBA8 (普通格式)</span></span><br><span class="line"><span class="comment">// 你必须自己手动写代码进行 Gamma 校正，否则画面会非常暗</span></span><br><span class="line"><span class="type">vec3</span> finalColor = <span class="built_in">pow</span>(linearColor, <span class="type">vec3</span>(<span class="number">1.0</span>/<span class="number">2.2</span>)); <span class="comment">// 手动校正：变成 0.5</span></span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(finalColor, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况 2: 设置了 kEAGLColorFormatSRGBA8 (sRGB 格式)</span></span><br><span class="line"><span class="comment">// 硬件自动处理，你只需要输出线性值</span></span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(linearColor, <span class="number">1.0</span>); <span class="comment">// 写入时硬件自动变成 0.5</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Gamma 校正本质上是一个<strong>“劫富济贫”</strong>的过程：它压缩了亮部的数据精度，极大地扩充了暗部的数据精度，以符合人眼对暗部细节敏感的生理特性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GLSurfaceView源码分析</title>
      <link href="/2025/12/03/GLSurfaceView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2025/12/03/GLSurfaceView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>基于 Android Open Source Project (AOSP) 的 <code>GLSurfaceView.java</code> 源码，我为你深入梳理了各个核心事件的内部实现细节。</p><span id="more"></span><p><code>GLSurfaceView</code> 的核心机制是 <strong>生产者-消费者模式</strong>。它内部维护了一个 **<code>GLThread</code>**（渲染线程），而 <code>GLSurfaceView</code> 本身（主线程）负责监听系统回调，并通过 <strong>Monitor 锁 (synchronize)</strong> 修改状态变量，通知 <code>GLThread</code> 进行相应的 EGL 操作。</p><p>以下是各个关键事件的源码实现细节拆解：</p><p>—v</p><h3 id="1-构造与初始化-Initialization"><a href="#1-构造与初始化-Initialization" class="headerlink" title="1. 构造与初始化 (Initialization)"></a>1. 构造与初始化 (Initialization)</h3><p>当你创建一个 <code>GLSurfaceView</code> 时，它首先做的是通过 <code>SurfaceView</code> 的机制注册回调。</p><ul><li><strong>源码行为：</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GLSurfaceView.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    getHolder().addCallback(<span class="built_in">this</span>); <span class="comment">// 注册 SurfaceHolder.Callback</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>  <strong>细节：</strong> 此时 <code>GLThread</code> 可能还没创建，或者处于 <code>State.DETACHED</code> 状态。直到你调用 <code>setRenderer()</code>，线程才会启动（调用 <code>start()</code>）。</li></ul><hr><h3 id="2-onAttachedToWindow-View-添加到窗口"><a href="#2-onAttachedToWindow-View-添加到窗口" class="headerlink" title="2. onAttachedToWindow (View 添加到窗口)"></a>2. onAttachedToWindow (View 添加到窗口)</h3><ul><li>  <strong>触发时机：</strong> View 被添加到 Activity 的 Window 树中。</li><li><strong>源码逻辑：</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onAttachedToWindow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onAttachedToWindow();</span><br><span class="line">    <span class="comment">// 如果之前 detached 导致线程退出了，这里会尝试重新 attach</span></span><br><span class="line">    <span class="keyword">if</span> (mDetached &amp;&amp; (mRenderer != <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">renderMode</span> <span class="operator">=</span> RENDERMODE_CONTINUOUSLY;</span><br><span class="line">        <span class="keyword">if</span> (mGLThread != <span class="literal">null</span>) &#123;</span><br><span class="line">            renderMode = mGLThread.getRenderMode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个新的 GLThread！旧的线程在 detach 时已经销毁了。</span></span><br><span class="line">        mGLThread = <span class="keyword">new</span> <span class="title class_">GLThread</span>(mWeakThis); </span><br><span class="line">        <span class="keyword">if</span> (renderMode != RENDERMODE_CONTINUOUSLY) &#123;</span><br><span class="line">            mGLThread.setRenderMode(renderMode);</span><br><span class="line">        &#125;</span><br><span class="line">        mGLThread.start(); <span class="comment">// 启动渲染线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    mDetached = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>  <strong>核心细节：</strong> <code>GLThread</code> 是不可重用的。一旦退出（Detached），必须 <code>new</code> 一个新的。</li></ul><hr><h3 id="3-surfaceCreated-Surface-准备就绪"><a href="#3-surfaceCreated-Surface-准备就绪" class="headerlink" title="3. surfaceCreated (Surface 准备就绪)"></a>3. surfaceCreated (Surface 准备就绪)</h3><p>这是 GL 环境建立的起点。</p><ul><li>  <strong>触发时机：</strong> <code>SurfaceHolder.Callback.surfaceCreated</code> 被系统调用。</li><li><strong>主线程 (UI) 行为：</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> &#123;</span><br><span class="line">    mGLThread.surfaceCreated(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>GLThread (渲染线程) 行为：</strong><br>  <code>mGLThread.surfaceCreated()</code> 只是设置了一个标志位并唤醒线程，真正的逻辑在 <code>guardedRun()</code> 循环中：<ol><li> <strong>加锁：</strong> <code>synchronized(sGLThreadManager)</code></li><li> <strong>设置状态：</strong> <code>mHasSurface = true;</code></li><li> <strong>唤醒：</strong> <code>sGLThreadManager.notifyAll();</code></li><li> <strong>循环执行：</strong> 线程循环检测到 <code>mHasSurface</code> 且 <code>mHaveEglContext</code> 为 false 时，调用 <code>mEglHelper.createSurface()</code> 和 <code>createContext()</code>。</li><li> <strong>回调 Renderer：</strong> 执行 <code>renderer.onSurfaceCreated()</code>。</li></ol></li></ul><hr><h3 id="4-surfaceChanged-尺寸变更"><a href="#4-surfaceChanged-尺寸变更" class="headerlink" title="4. surfaceChanged (尺寸变更)"></a>4. surfaceChanged (尺寸变更)</h3><ul><li>  <strong>触发时机：</strong> 屏幕旋转、分屏或初始化布局完成。</li><li><strong>主线程行为：</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="type">int</span> format, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    mGLThread.onWindowResize(w, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>GLThread 行为：</strong><ol><li> <strong>设置状态：</strong> <code>mWidth = w; mHeight = h; mSizeChanged = true;</code></li><li> <strong>唤醒：</strong> <code>sGLThreadManager.notifyAll();</code></li><li> <strong>循环执行：</strong> <code>guardedRun()</code> 循环检测到 <code>mSizeChanged</code> 为 true。</li><li> <strong>执行 GL 指令：</strong> 调用 <code>glViewport(0, 0, w, h)</code>。</li><li> <strong>回调 Renderer：</strong> 执行 <code>renderer.onSurfaceChanged()</code>。</li></ol></li></ul><hr><h3 id="5-onDrawFrame-渲染循环"><a href="#5-onDrawFrame-渲染循环" class="headerlink" title="5. onDrawFrame (渲染循环)"></a>5. onDrawFrame (渲染循环)</h3><p>这是源码中最核心的死循环：<code>GLThread.run()</code> -&gt; <code>guardedRun()</code>。</p><ul><li><strong>源码逻辑 (简化版)：</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">guardedRun</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sGLThreadManager) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 1. 处理 queueEvent 进来的 Runnable</span></span><br><span class="line">                <span class="keyword">if</span> (!mEventQueue.isEmpty()) &#123;</span><br><span class="line">                    event = mEventQueue.remove(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 跳出内层锁去执行 event</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 2. 检查暂停、Surface丢失等状态</span></span><br><span class="line">                <span class="keyword">if</span> (mPaused || !mHasSurface) &#123;</span><br><span class="line">                    sGLThreadManager.wait(); <span class="comment">// 阻塞等待</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 3. 如果 Surface 刚创建或重建</span></span><br><span class="line">                <span class="keyword">if</span> (!mHaveEglContext) &#123;</span><br><span class="line">                    mEglHelper.start(); <span class="comment">// 创建 EGLContext</span></span><br><span class="line">                    view.mRenderer.onSurfaceCreated(...);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 4. 如果大小改变</span></span><br><span class="line">                <span class="keyword">if</span> (mSizeChanged) &#123;</span><br><span class="line">                    view.mRenderer.onSurfaceChanged(...);</span><br><span class="line">                    mSizeChanged = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 准备好绘制了！</span></span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 释放锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行 Runnable (queueEvent)</span></span><br><span class="line">        <span class="keyword">if</span> (event != <span class="literal">null</span>) &#123;</span><br><span class="line">            event.run();</span><br><span class="line">            event = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 核心绘制</span></span><br><span class="line">        view.mRenderer.onDrawFrame(...);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换缓冲区 (显示到屏幕)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">swapError</span> <span class="operator">=</span> mEglHelper.swap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>  <strong>核心细节：</strong> <strong>Monitor 锁 (sGLThreadManager)</strong> 保护了所有状态。在执行 <code>onDrawFrame</code> 时，<strong>锁是释放的</strong>，这允许主线程在渲染时进行 <code>onPause</code> 等操作（虽然 <code>onPause</code> 会在下一次循环时生效）。</li></ul><hr><h3 id="6-surfaceDestroyed-Surface-销毁"><a href="#6-surfaceDestroyed-Surface-销毁" class="headerlink" title="6. surfaceDestroyed (Surface 销毁)"></a>6. surfaceDestroyed (Surface 销毁)</h3><ul><li>  <strong>触发时机：</strong> 按 Home 键回到后台、切换 Activity。</li><li><strong>主线程行为：</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> &#123;</span><br><span class="line">    mGLThread.surfaceDestroyed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>GLThread 行为：</strong><ol><li> <strong>设置状态：</strong> <code>synchronized</code> 块中设置 <code>mHasSurface = false;</code></li><li> <strong>唤醒：</strong> <code>sGLThreadManager.notifyAll();</code></li><li> <strong>循环响应：</strong> <code>guardedRun</code> 发现 <code>!mHasSurface</code>。</li><li> <strong>销毁 EGL Surface：</strong> 调用 <code>stopEglSurfaceLocked()</code> -&gt; <code>eglDestroySurface()</code>。</li><li> <strong>保留 Context：</strong> 默认情况下，<strong>不会</strong>销毁 EGLContext（除非调用了 <code>setPreserveEGLContextOnPause(false)</code>）。这意味着纹理 ID 依然保留。</li><li> <strong>阻塞等待：</strong> 线程进入 <code>wait()</code> 状态，不再消耗 CPU，直到 <code>surfaceCreated</code> 再次被调用。</li></ol></li></ul><hr><h3 id="7-onDetachedFromWindow-View-移除-销毁"><a href="#7-onDetachedFromWindow-View-移除-销毁" class="headerlink" title="7. onDetachedFromWindow (View 移除/销毁)"></a>7. onDetachedFromWindow (View 移除/销毁)</h3><p>这是最严格的清理步骤，也是你之前遇到 Crash 的关键点。</p><ul><li>  <strong>触发时机：</strong> <code>Activity.onDestroy()</code> 或 <code>ViewGroup.removeView()</code>。</li><li><strong>源码逻辑：</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDetachedFromWindow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mGLThread != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 请求退出，并阻塞等待！</span></span><br><span class="line">        mGLThread.requestExitAndWait();</span><br><span class="line">    &#125;</span><br><span class="line">    mDetached = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">super</span>.onDetachedFromWindow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>GLThread.requestExitAndWait() 实现：</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestExitAndWait</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(sGLThreadManager) &#123;</span><br><span class="line">        mShouldExit = <span class="literal">true</span>; <span class="comment">// 设置退出标志</span></span><br><span class="line">        sGLThreadManager.notifyAll(); <span class="comment">// 唤醒 GL 线程</span></span><br><span class="line">        <span class="keyword">while</span> (!mExited) &#123; <span class="comment">// 循环等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sGLThreadManager.wait(); <span class="comment">// 主线程在此死等！</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>核心细节 (非常重要)：</strong><br>  <code>GLSurfaceView</code> 在销毁时，**主线程会挂起 (Wait)**，直到渲染线程跑完最后一次循环，执行完清理工作（<code>eglDestroyContext</code>），并将 <code>mExited</code> 设为 true 后，主线程才会继续执行。<br>  <strong>这正是为什么 GLSurfaceView 不容易崩的原因：它强制实现了线程同步退出。</strong> 如果你自己写 EGL 环境，往往忘记了这一步 <code>wait</code>，导致主线程把 Surface 销毁了，渲染线程还在 <code>swapBuffers</code>，从而引发 Crash。</li></ul><hr><h3 id="8-onPause-onResume-生命周期管理"><a href="#8-onPause-onResume-生命周期管理" class="headerlink" title="8. onPause / onResume (生命周期管理)"></a>8. onPause / onResume (生命周期管理)</h3><ul><li><strong>实现：</strong><ul><li>  <code>onPause()</code> 设置 <code>mRequestPaused = true</code>，并 <code>notifyAll</code>。GL 线程检测到该标志后，释放 EGLSurface 并进入 wait。</li><li>  <code>onResume()</code> 设置 <code>mRequestPaused = false</code>，并 <code>notifyAll</code>。GL 线程醒来，重建 EGLSurface，继续渲染。</li></ul></li></ul><hr><h3 id="总结：对自定义-GLBaseMapView-的启示"><a href="#总结：对自定义-GLBaseMapView-的启示" class="headerlink" title="总结：对自定义 GLBaseMapView 的启示"></a>总结：对自定义 GLBaseMapView 的启示</h3><p>通过分析源码，如果你要写 <code>GLBaseMapView</code>，必须模仿 <code>GLSurfaceView</code> 的以下行为：</p><ol><li> <strong>使用一把大锁 (Monitor Lock)：</strong> 所有的状态变量（Surface 是否存在、宽高、是否暂停、是否退出）的读写，必须在同一个对象锁（<code>synchronized</code>）的保护下。</li><li> <strong>退出同步 (Exit Sync)：</strong> 在 <code>onDetachedFromWindow</code> 中，<strong>必须阻塞等待</strong> 渲染线程彻底结束。不要仅仅发一个 boolean 标志就走了。</li><li> <strong>Surface 状态分离：</strong> 区分 <code>EGLContext</code> (资源) 和 <code>EGLSurface</code> (窗口)。Activity 暂停时销毁 Surface 但保留 Context（避免重载纹理）；Activity 销毁时才销毁 Context。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>针对 RGBA8888（32位）和 RGB565（16位）这两种格式 分析</title>
      <link href="/2025/12/02/RGBA8888%E5%92%8CRGB565%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/12/02/RGBA8888%E5%92%8CRGB565%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>针对 <strong>RGBA8888</strong>（32位）和 <strong>RGB565</strong>（16位）这两种格式，在<strong>蓝色（Blue）</strong>显示的差异上，核心在于<strong>色彩精度（Color Depth）</strong>的不同。</p><p>简单总结：<strong>RGB565 下的蓝色会出现明显的“色阶（Banding）”现象，渐变不平滑，且色彩还原度不如 RGBA8888。</strong></p><span id="more"></span><p>以下是详细的分析：</p><h3 id="1-数据结构的差异"><a href="#1-数据结构的差异" class="headerlink" title="1. 数据结构的差异"></a>1. 数据结构的差异</h3><ul><li><p><strong>RGBA8888 (True Color)</strong></p><ul><li>  R=8 bit, G=8 bit, <strong>B=8 bit</strong>, A=8 bit。</li><li>  蓝色的取值范围是 $0 \sim 255$ ($2^8$)。</li><li>  拥有 <strong>256 个</strong> 不同的蓝色亮度级别。</li></ul></li><li><p><strong>RGB565 (High Color)</strong></p><ul><li>  R=5 bit, G=6 bit, <strong>B=5 bit</strong> (无Alpha通道)。</li><li>  蓝色的取值范围是 $0 \sim 31$ ($2^5$)。</li><li>  仅拥有 <strong>32 个</strong> 不同的蓝色亮度级别。</li><li>  <em>注：绿色给6位是因为人眼对绿色最敏感，蓝色和红色只有5位。</em></li></ul></li></ul><h3 id="2-视觉差异分析（重点）"><a href="#2-视觉差异分析（重点）" class="headerlink" title="2. 视觉差异分析（重点）"></a>2. 视觉差异分析（重点）</h3><h4 id="A-色阶与波纹现象-Color-Banding-——-最明显的差异"><a href="#A-色阶与波纹现象-Color-Banding-——-最明显的差异" class="headerlink" title="A. 色阶与波纹现象 (Color Banding) —— 最明显的差异"></a>A. 色阶与波纹现象 (Color Banding) —— 最明显的差异</h4><p>这是最容易被肉眼察觉的问题，特别是在显示<strong>蓝色渐变</strong>（如天空、海洋、UI背景）时。</p><ul><li>  <strong>RGBA8888：</strong> 也就是通常说的“平滑过渡”。从深蓝到浅蓝，中间有256个台阶，台阶很密，肉眼看不出断层。</li><li><strong>RGB565：</strong> 只有32个台阶。当需要表现一个从 $0 \to 255$ 的渐变时，每隔约 8 个数值（255/32）才会变化一次颜色。<ul><li>  <strong>现象：</strong> 你会看到明显的<strong>条纹状</strong>或<strong>环状</strong>的色块边界，就像等高线地图一样，而不是丝般顺滑的过渡。</li></ul></li></ul><h4 id="B-色彩准确度偏差-Color-Accuracy"><a href="#B-色彩准确度偏差-Color-Accuracy" class="headerlink" title="B. 色彩准确度偏差 (Color Accuracy)"></a>B. 色彩准确度偏差 (Color Accuracy)</h4><p>RGB565 无法精准还原设计稿中的颜色，因为它必须进行“截断”或“舍入”。</p><ul><li><strong>举例：</strong> 假设设计稿需要一种蓝色，RGB值为 <code>Blue = 200</code> (在0-255体系下)。<ul><li>  <strong>在 RGBA8888 中：</strong> 直接显示 <code>200</code>，完美还原。</li><li><strong>在 RGB565 中：</strong> 系统需要将其映射到 0-31 的范围。<ul><li>  计算：$200 / 255 \times 31 \approx 24.31$</li><li>  取整：只能取 <code>24</code>。</li><li>  还原回屏幕显示：$24 / 31 \times 255 \approx 197$。</li></ul></li><li>  <strong>结果：</strong> 屏幕实际显示的蓝色是 197，而不是 200。虽然肉眼可能很难区分 197 和 200 的单点差异，但在对比时会有轻微色差。</li></ul></li></ul><h4 id="C-暗部细节丢失-Black-Crush"><a href="#C-暗部细节丢失-Black-Crush" class="headerlink" title="C. 暗部细节丢失 (Black Crush)"></a>C. 暗部细节丢失 (Black Crush)</h4><p>在非常暗的蓝色场景下（例如夜空），RGB565 的表现会很糟糕。</p><ul><li>  RGB565 的蓝色最低一档（1）对应 RGBA8888 的 8。这意味着 $0 \sim 7$ 之间的微弱蓝色细节，在 RGB565 中要么变成纯黑，要么突然跳变为亮度为 8 的蓝。这种“跳跃感”在暗部非常明显。</li></ul><h3 id="3-为什么是蓝色？-人眼感知"><a href="#3-为什么是蓝色？-人眼感知" class="headerlink" title="3. 为什么是蓝色？(人眼感知)"></a>3. 为什么是蓝色？(人眼感知)</h3><p>虽然红色在 RGB565 中也是 5 位，但<strong>人眼对蓝色的感知比较特殊</strong>：</p><ol><li> <strong>亮度敏感度低：</strong> 人眼对蓝色的亮度变化不如绿色敏感，所以在复杂的纹理图片中（如照片），RGB565 的蓝色损失可能不明显。</li><li> <strong>渐变敏感度高：</strong> 在 Android UI 或扁平化设计中，大面积的纯色或线性渐变非常常见。此时蓝色的 5-bit 精度（32级）缺陷就会被无限放大，<strong>色阶问题在蓝色渐变背景上通常比红色背景看起来更脏、更明显。</strong></li></ol><h3 id="4-解决方案与建议"><a href="#4-解决方案与建议" class="headerlink" title="4. 解决方案与建议"></a>4. 解决方案与建议</h3><p>如果你在使用 EGL 创建 Framebuffer 时遇到了性能问题想切 RGB565，或者因为格式错误导致了 RGB565，请注意以下点：</p><ol><li><p><strong>Dithering（抖动算法）：</strong><br> 如果必须使用 RGB565（为了省内存，内存占用减半），必须开启 <strong>Dithering</strong>。</p><ul><li>  <code>glEnable(GL_DITHER)</code></li><li>  抖动算法通过在像素间引入噪点，骗过人眼，让 32 级颜色看起来像更多级。虽然会增加颗粒感，但消除了明显的色阶条纹。</li></ul></li><li><p><strong>排查崩溃与格式的关系：</strong><br> 回到你上一个问题（glDraw崩溃），<strong>格式不匹配</strong>也是常见原因。</p><ul><li>  如果 EGLConfig 选了 RGB565，但 Shader 输出或 FBO 附件按 RGBA8888 处理，虽然 OpenGL 允许转换，但在某些特定驱动或 Hardware Layer合成时可能引发异常。</li><li>  <strong>强烈建议：</strong> 在现代手机上，除非极其严苛的内存限制，否则<strong>始终使用 RGBA8888</strong>。RGB565 是 Android 2.3 时代的产物，现在的 GPU 带宽和显存处理 RGBA8888 绰绰有余。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你的 framebuffer 是 RGB565 格式，蓝色显示会变得<strong>“不平滑，有条纹，暗部细节丢失”</strong>。如果你的应用场景包含大量蓝色渐变背景（天空、科技风背景），RGB565 会带来显著的画质下降。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Android中的SurfaceFlinger</title>
      <link href="/2025/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84SurfaceFlinger/"/>
      <url>/2025/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84SurfaceFlinger/</url>
      
        <content type="html"><![CDATA[<p>这是一篇关于 Android 图形系统核心——<strong>SurfaceFlinger</strong> 的深度解析。</p><p>既然你已经掌握了如何使用 <code>EGLContext</code> 和独立线程进行渲染，那么理解 SurfaceFlinger 将帮助你打通从 <code>swapBuffers</code> 到屏幕显示的“最后一公里”。</p><span id="more"></span><hr><h3 id="1-什么是-SurfaceFlinger？"><a href="#1-什么是-SurfaceFlinger？" class="headerlink" title="1. 什么是 SurfaceFlinger？"></a>1. 什么是 SurfaceFlinger？</h3><p>用一句话概括：<strong>SurfaceFlinger 是 Android 系统级的“合成器” (Compositor)。</strong></p><p>你的 App（包括状态栏、导航栏、壁纸）各自都在画画，每个人都有一块自己的画布（Surface）。但是手机屏幕只有一个。<br>SurfaceFlinger 的工作就是：<strong>把所有 App 绘制产生的“图层”，按照位置、层级（Z-order）、透明度，合成（Composite）为一张最终的图像，然后交给屏幕显示。</strong></p><h3 id="2-核心架构：生产者与消费者模型"><a href="#2-核心架构：生产者与消费者模型" class="headerlink" title="2. 核心架构：生产者与消费者模型"></a>2. 核心架构：生产者与消费者模型</h3><p>理解 SurfaceFlinger 最好的方式是通过 <strong>BufferQueue</strong>（缓冲队列）。</p><ul><li><strong>生产者 (Producer)</strong>: 你的 App（或者说你的 OpenGL 线程）。<ul><li>  当你调用 <code>eglSwapBuffers</code> 时，你产生了一帧数据。</li></ul></li><li>  <strong>缓冲队列 (BufferQueue)</strong>: 连接 App 和 SurfaceFlinger 的管道。</li><li><strong>消费者 (Consumer)</strong>: SurfaceFlinger。<ul><li>  它从队列里取出你画好的 Buffer，拿去合成。</li></ul></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[你的 App (OpenGL)]  --&gt;  [BufferQueue]  --&gt;  [SurfaceFlinger]  --&gt;  [屏幕 (Display)]</span><br><span class="line">(eglSwapBuffers)          (入队)              (合成 &amp; 输送)</span><br></pre></td></tr></table></figure><h3 id="3-SurfaceFlinger-的三大核心机制"><a href="#3-SurfaceFlinger-的三大核心机制" class="headerlink" title="3. SurfaceFlinger 的三大核心机制"></a>3. SurfaceFlinger 的三大核心机制</h3><h4 id="A-VSYNC-垂直同步信号"><a href="#A-VSYNC-垂直同步信号" class="headerlink" title="A. VSYNC (垂直同步信号)"></a>A. VSYNC (垂直同步信号)</h4><p>SurfaceFlinger 不是随叫随到的，它是跟着心跳走的。这个心跳就是 <strong>VSYNC</strong>。</p><ul><li>  屏幕通常以 60Hz（或 90/120Hz）刷新。</li><li>  每隔 16.6ms，硬件会发出一个 VSYNC 信号。</li><li>  SurfaceFlinger 收到信号后，才会醒过来工作：“嘿，各个 App 们，把你们最新的 Buffer 给我，我要开始合成了！”</li><li>  <strong>Choreographer</strong>: App 端接收 VSYNC 的组件。它告诉你的 App：“快点画，下一帧合成马上要开始了”。</li></ul><h4 id="B-Layer-图层"><a href="#B-Layer-图层" class="headerlink" title="B. Layer (图层)"></a>B. Layer (图层)</h4><p>在 SurfaceFlinger 内部，每一个应用窗口对应一个 <strong>Layer</strong>。</p><ul><li>  你的 <code>SurfaceView</code> 是一个 Layer。</li><li>  <code>TextView</code>、<code>Button</code> 所在的 UI 窗口也是一个 Layer。</li><li>  状态栏是一个 Layer。</li><li>  SurfaceFlinger 持有这些 Layer 的列表，并根据 Z-order（谁在上面谁在下面）来决定遮挡关系。</li></ul><h4 id="C-HWC-Hardware-Composer-——-性能优化的关键"><a href="#C-HWC-Hardware-Composer-——-性能优化的关键" class="headerlink" title="C. HWC (Hardware Composer) —— 性能优化的关键"></a>C. HWC (Hardware Composer) —— 性能优化的关键</h4><p>这是 Android 图形流畅的关键。<br>合成图层有两种方式：</p><ol><li> <strong>GLES 合成 (Client Composition)</strong>: SurfaceFlinger 使用 GPU (OpenGL) 把各个图层画到一张大图上。这很费电，也占用 GPU 资源。</li><li> <strong>HWC 合成 (Device Composition)</strong>: 现代手机的处理芯片（SoC）里有一个专门的 2D 硬件合成单元（Display Subsystem）。它能非常高效地把几个 Buffer 叠加在一起，<strong>完全不需要 GPU 参与</strong>。</li></ol><p><strong>工作流程</strong>：<br>SurfaceFlinger 会问 HWC：“这几个图层你能处理吗？”</p><ul><li>  **HWC 说能 (Overlay)**：SF 直接把 Buffer 句柄丢给 HWC，SF 自己这就休息了。（最省电，最快）</li><li>  <strong>HWC 说不能</strong>（比如图层做了复杂的 3D 变换，或者图层超过了硬件支持数量）：SF 就唤醒 GPU，用 OpenGL 把这些图层画成一张图，再交给 HWC。</li></ul><h3 id="4-结合你的-Demo：数据是如何流转的？"><a href="#4-结合你的-Demo：数据是如何流转的？" class="headerlink" title="4. 结合你的 Demo：数据是如何流转的？"></a>4. 结合你的 Demo：数据是如何流转的？</h3><p>让我们回到你写的 OpenGL Demo，看看 <code>swapBuffers</code> 之后发生了什么：</p><ol><li><p><strong>应用层 (Render Thread)</strong>:</p><ul><li>  你调用 <code>eglSwapBuffers()</code>。</li><li>  EGL 驱动将当前显存中的 FrameBuffer 放入 <strong>BufferQueue</strong>。</li><li>  BufferQueue 通知 SurfaceFlinger：“有新货了”。</li></ul></li><li><p><strong>系统层 (SurfaceFlinger)</strong>:</p><ul><li>  等待下一个 VSYNC 信号到来。</li><li>  信号一来，SurfaceFlinger 锁定当前所有 Layer 的状态。</li><li>  它从你的 BufferQueue 中取出这个 Buffer (Acquire Buffer)。</li></ul></li><li><p><strong>合成决策</strong>:</p><ul><li>  SF 看着你的 Surface 和上面的状态栏。</li><li>  它告诉 HWC：“把 App 的 Buffer 放在底层，状态栏的 Buffer 盖在上面”。</li></ul></li><li><p><strong>显示</strong>:</p><ul><li>  HWC 读取内存中的数据，合成电信号，发送给显示屏（LCD/OLED）。</li><li>  Buffer 被显示后，SF 会释放它，把它还给 BufferQueue。</li></ul></li><li><p><strong>回收</strong>:</p><ul><li>  你的 App 下次 <code>eglSwapBuffers</code> 时，或者是 <code>dequeueBuffer</code> 时，就能复用这块已经显示过的内存（这就是<strong>双缓冲/三缓冲</strong>的循环）。</li></ul></li></ol><h3 id="5-为什么会有“撕裂-Tearing-”和“卡顿-Jank-”？"><a href="#5-为什么会有“撕裂-Tearing-”和“卡顿-Jank-”？" class="headerlink" title="5. 为什么会有“撕裂 (Tearing)”和“卡顿 (Jank)”？"></a>5. 为什么会有“撕裂 (Tearing)”和“卡顿 (Jank)”？</h3><ul><li>  <strong>撕裂 (Tearing)</strong>: 如果没有 VSYNC，SurfaceFlinger 在屏幕扫描到一半时突然换了一张新图，屏幕上半部分是旧帧，下半部分是新帧。Android 4.1 之后通过 Project Butter 强制开启 VSYNC 解决了这个问题。</li><li><strong>卡顿 (Jank)</strong>:<ul><li>  <strong>掉帧</strong>: 你的 <code>RenderThread</code> 绘制太慢，超过了 16.6ms。</li><li>  VSYNC 到了，SF 问你要 Buffer，结果 BufferQueue 是空的（你还没画完）。</li><li>  SF 只能拿上一帧的画面继续显示（画面静止不动）。</li><li>  用户感觉到“卡了一下”。</li></ul></li></ul><h3 id="6-开发者视角的-SurfaceFlinger"><a href="#6-开发者视角的-SurfaceFlinger" class="headerlink" title="6. 开发者视角的 SurfaceFlinger"></a>6. 开发者视角的 SurfaceFlinger</h3><p>作为开发者，你通常接触不到 SF 的代码（它是 C++ 写的 Native 服务），但你的几个操作直接影响它：</p><ol><li><p><strong>SurfaceView vs TextureView</strong>:</p><ul><li>  <strong>SurfaceView</strong>: 拥有独立的 Surface。SurfaceFlinger 直接通过 HWC 合成它。<strong>性能最高，但无法做 View 动画（平移、缩放）</strong>，因为它不在 View 树里，是一个独立的图层挖了个洞。</li><li>  <strong>TextureView</strong>: 没有独立的 Surface。它劫持了 OpenGL 的渲染结果，变成一个普通的 OpenGL 纹理，交给 App 的 UI 线程去绘制。<strong>性能稍差，但可以像普通 View 一样做动画</strong>。</li></ul></li><li><p><strong><code>surfaceDestroyed</code> 的真相</strong>:</p><ul><li>  当这个回调触发时，意味着 SurfaceFlinger 里的这个 Layer 被移除了。</li><li>  BufferQueue 断开了。</li><li>  如果你还在往里 <code>queueBuffer</code> (swapBuffers)，就会报错或丢失。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>  <strong>SurfaceFlinger</strong> 是 Android 的画师，负责把所有 App 的画稿拼在一起。</li><li>  <strong>BufferQueue</strong> 是传输画稿的传送带。</li><li>  <strong>HWC</strong> 是画师的强力助手（硬件加速），能不用 GPU 就不拥 GPU。</li><li>  你在 Demo 中做的 <code>eglSwapBuffers</code>，本质上就是向 SurfaceFlinger 提交作业。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Surface 延迟释放策略</title>
      <link href="/2025/11/30/Android%20Surface%20%E5%BB%B6%E8%BF%9F%E9%87%8A%E6%94%BE%E7%AD%96%E7%95%A5/"/>
      <url>/2025/11/30/Android%20Surface%20%E5%BB%B6%E8%BF%9F%E9%87%8A%E6%94%BE%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>你的这个思路非常棒！这就是所谓的 <strong>“延迟销毁 (Lazy/Deferred Destruction)”</strong> 或者 <strong>“Surface 缓存”</strong> 策略。</p><p>这在很多高性能渲染引擎（如游戏、地图SDK）中是常见的做法。</p><span id="more"></span><h3 id="你的方案分析"><a href="#你的方案分析" class="headerlink" title="你的方案分析"></a>你的方案分析</h3><p><strong>核心逻辑：</strong></p><ol><li>**切后台 (<code>surfaceDestroyed</code>)**：<ul><li>  停止渲染 (<code>swapBuffers</code>)。</li><li>  <strong>不销毁</strong> <code>EGLSurface</code>。</li><li>  <strong>不销毁</strong> <code>EGLContext</code>。</li><li>  线程进入等待。</li></ul></li><li>**切回前台 (<code>surfaceCreated</code>)**：<ul><li>  检测到已经存在旧的 <code>EGLSurface</code>。</li><li>  销毁旧的 <code>EGLSurface</code>（因为它绑定的 NativeWindow 已经失效了）。</li><li>  使用新的 <code>Surface</code> 创建新的 <code>EGLSurface</code>。</li><li>  恢复渲染。</li></ul></li><li>**彻底退出 (<code>quit</code>)**：<ul><li>  此时 <code>EGLSurface</code> 还在（虽然底层的 Window 没了）。</li><li>  尝试 <code>makeCurrent</code>。</li><li>  调用 <code>nativeDestroy</code> (释放 C++ 资源)。</li><li>  最后销毁 Surface 和 Context。</li></ul></li></ol><p><strong>这样做的好处：</strong></p><ol><li> <strong>解决了 Context 丢失问题</strong>：Context 一直活着，纹理不需要重新加载。</li><li> <strong>解决了 <code>nativeDestroy</code> 的环境问题</strong>：在退出时，因为 <code>EGLSurface</code> 对象还在，调用 <code>eglMakeCurrent</code> <strong>通常</strong>是成功的（取决于 GPU 驱动实现），这让你可以合法地调用 <code>glDelete*</code>。</li><li> <strong>无缝切换</strong>：如果是屏幕旋转（导致 Surface 销毁重建），这种方式切换速度最快。</li></ol><hr><h3 id="修改后的代码实现-支持延迟释放"><a href="#修改后的代码实现-支持延迟释放" class="headerlink" title="修改后的代码实现 (支持延迟释放)"></a>修改后的代码实现 (支持延迟释放)</h3><p>我们需要修改 <code>CustomGLRenderThread</code> 的逻辑。</p><h4 id="1-状态控制变量"><a href="#1-状态控制变量" class="headerlink" title="1. 状态控制变量"></a>1. 状态控制变量</h4><p>我们需要区分“是否应该渲染”和“是否持有 Surface”。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有当持有有效的 Android Window 时，才为 true，才能 swapBuffers</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> hasValidWindow = <span class="literal">false</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录是否已经创建了 EGLSurface 对象（哪怕底层的 Window 已经销毁了，这个对象可能还在）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> hasEglSurface = <span class="literal">false</span> </span><br></pre></td></tr></table></figure><h4 id="2-线程主循环-Run-Method"><a href="#2-线程主循环-Run-Method" class="headerlink" title="2. 线程主循环 (Run Method)"></a>2. 线程主循环 (Run Method)</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    initEGL()</span><br><span class="line">    initGLContext()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化 C++ 引擎（此时还没有 Surface，先不调 OpenGL 相关的 setup，或者创建一个 Pbuffer）</span></span><br><span class="line">    <span class="comment">// 通常建议：把 C++ 的 init 放到第一次 createEGLSurface 之后，或者这里先不做 GL 操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            <span class="comment">// 只要没有有效的 Window，就等待 (延迟销毁策略的核心：不在这里销毁 EGLSurface)</span></span><br><span class="line">            <span class="keyword">while</span> (isRunning &amp;&amp; !hasValidWindow) &#123;</span><br><span class="line">                lock.wait()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!isRunning) <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 核心修改：Surface 替换逻辑 ---</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 如果有新的 Window 来了，但我们手里还捏着旧的 EGLSurface</span></span><br><span class="line">        <span class="keyword">if</span> (hasEglSurface &amp;&amp; (surface != currentBoundSurface)) &#123;</span><br><span class="line">            <span class="comment">// 必须先销毁旧的，因为它绑定的是上一个无效的 Window</span></span><br><span class="line">            releaseEGLSurface() </span><br><span class="line">            Log.d(<span class="string">&quot;GLThread&quot;</span>, <span class="string">&quot;Releasing old EGLSurface (Lazy Release)&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 如果当前没有 EGLSurface，就创建一个新的</span></span><br><span class="line">        <span class="keyword">if</span> (!hasEglSurface &amp;&amp; surface?.isValid == <span class="literal">true</span>) &#123;</span><br><span class="line">            createEGLSurface(surface!!)</span><br><span class="line">            makeCurrent()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果是第一次启动，初始化 C++ 引擎</span></span><br><span class="line">            <span class="keyword">if</span> (!isEngineInitialized) &#123;</span><br><span class="line">                nativeCreate()</span><br><span class="line">                isEngineInitialized = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            currentBoundSurface = surface <span class="comment">// 记录当前绑定的 Surface 对象</span></span><br><span class="line">            Log.d(<span class="string">&quot;GLThread&quot;</span>, <span class="string">&quot;Created new EGLSurface&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 渲染</span></span><br><span class="line">        nativeRender()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 交换缓冲</span></span><br><span class="line">        <span class="keyword">if</span> (!swapBuffers()) &#123;</span><br><span class="line">            Log.w(<span class="string">&quot;GLThread&quot;</span>, <span class="string">&quot;Swap failed, window might be lost&quot;</span>)</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                hasValidWindow = <span class="literal">false</span> <span class="comment">// 标记 Window 失效，下次循环进入 wait</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 退出逻辑 (Destruction) ---</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时我们要退出了。</span></span><br><span class="line">    <span class="comment">// 如果 EGLSurface 还在（说明是延迟释放的），我们可以尝试 MakeCurrent 来清理资源</span></span><br><span class="line">    <span class="keyword">if</span> (hasEglSurface) &#123;</span><br><span class="line">        <span class="comment">// 尝试绑定。即使底层 Window 销毁了，EGLSurface 句柄通常还能用于 MakeCurrent</span></span><br><span class="line">        <span class="comment">// 注意：这里不能 SwapBuffers，只能做 glDelete 等操作</span></span><br><span class="line">        <span class="keyword">if</span> (makeCurrent()) &#123;</span><br><span class="line">            nativeDestroy() <span class="comment">// 完美：在 GL 环境中销毁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 极端情况：驱动不允许绑定失效 Surface，只能强行清理 C++ 内存</span></span><br><span class="line">            nativeDestroy() </span><br><span class="line">        &#125;</span><br><span class="line">        releaseEGLSurface()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 连 Surface 都没有，直接盲调（主要为了释放 C++ 内存）</span></span><br><span class="line">        nativeDestroy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    releaseEGL()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-外部回调的配合-MyGLSurfaceView"><a href="#3-外部回调的配合-MyGLSurfaceView" class="headerlink" title="3. 外部回调的配合 (MyGLSurfaceView)"></a>3. 外部回调的配合 (MyGLSurfaceView)</h4><p>View 层的逻辑变得更简单了，只需要控制开关。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部调用：当 Surface 创建/重建</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceCreated</span><span class="params">(surface: <span class="type">Surface</span>)</span></span> &#123;</span><br><span class="line">    synchronized(lock) &#123;</span><br><span class="line">        <span class="keyword">this</span>.surface = surface</span><br><span class="line">        <span class="keyword">this</span>.hasValidWindow = <span class="literal">true</span> <span class="comment">// 允许渲染</span></span><br><span class="line">        lock.notifyAll()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部调用：当 Surface 销毁</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onSurfaceDestroyed</span><span class="params">()</span></span> &#123;</span><br><span class="line">    synchronized(lock) &#123;</span><br><span class="line">        <span class="comment">// 关键点：只标记 Window 不可用，不销毁 EGLSurface！</span></span><br><span class="line">        <span class="keyword">this</span>.hasValidWindow = <span class="literal">false</span> </span><br><span class="line">        <span class="comment">// 注意：这里不需要设置 surface = null，保留引用以便对比</span></span><br><span class="line">        <span class="comment">// 线程会在下一次循环因为 !hasValidWindow 而进入 wait</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="这个方案的唯一风险点"><a href="#这个方案的唯一风险点" class="headerlink" title="这个方案的唯一风险点"></a>这个方案的唯一风险点</h3><p>你需要注意一个底层的技术细节：**<code>EGL_BAD_NATIVE_WINDOW</code>**。</p><p>当你调用 <code>onSurfaceDestroyed</code> 时，Android 系统会销毁底层的 Window BufferQueue。<br>在你的方案中，<code>EGLSurface</code> 还活着，但它背后的 Window 死了。</p><p>在 <code>quit()</code> 阶段：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasEglSurface) &#123;</span><br><span class="line">    makeCurrent() <span class="comment">// &lt;--- 这里</span></span><br><span class="line">    nativeDestroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  **大多数 GPU 驱动 (Adreno, Mali)**：允许这么做。只要你不调用 <code>swapBuffers</code>，仅仅是 <code>makeCurrent</code> 和 <code>glDeleteTextures</code> 是可以的。</li><li>  <strong>少数严格的驱动</strong>：可能会在 <code>makeCurrent</code> 时检测到底层 Window 已失效，返回 <code>EGL_FALSE</code>。</li></ul><p><strong>解决办法</strong>：<br>在 <code>nativeDestroy</code> 的 C++ 代码中，以及 Java 调用处，要做好<strong>容错</strong>。<br>即：如果 <code>makeCurrent</code> 失败了，也要强行调用 <code>nativeDestroy</code> 来释放 C++ 的 <code>std::vector</code> 等内存，只是跳过 <code>glDelete</code> 而已（反正 Context 马上要被销毁了，显存会自动回收，不会造成永久泄漏）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>你的“延迟释放”思路是<strong>完全可行且推荐</strong>的。</p><ol><li> <strong>暂停时</strong>：保留 <code>EGLSurface</code>，停止 <code>Swap</code>，线程休眠。</li><li> <strong>恢复时</strong>：对比 Surface 对象，不同则 <code>Release Old</code> -&gt; <code>Create New</code>。</li><li> <strong>退出时</strong>：利用残留的 <code>EGLSurface</code> 恢复环境进行清理。</li></ol><p>这比每次都销毁重建要优雅得多，尤其是在处理屏幕旋转等配置变更时。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在 C++ 中，条件变量和信号量对比</title>
      <link href="/2025/11/30/%E5%9C%A8%20C++%20%E4%B8%AD%EF%BC%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AF%B9%E6%AF%94/"/>
      <url>/2025/11/30/%E5%9C%A8%20C++%20%E4%B8%AD%EF%BC%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中，<strong>信号量（Semaphore）</strong> 提供了一种基于“计数器”的同步机制。</p><p>需要注意的是，标准的信号量 <code>std::counting_semaphore</code> 和 <code>std::binary_semaphore</code> 是在 <strong>C++20</strong> 才正式引入的。如果你严格限制在 <strong>C++11</strong> 环境，通常需要自己封装 POSIX 信号量（<code>sem_t</code>）或 Windows 信号量，或者使用 Boost 库。</p><span id="more"></span><p>为了方便讲解原理，下面的代码使用 <strong>C++20 标准</strong> 的写法（逻辑在 C++11 下是一样的，只是 API 不同）。</p><hr><h3 id="1-信号量的核心逻辑"><a href="#1-信号量的核心逻辑" class="headerlink" title="1. 信号量的核心逻辑"></a>1. 信号量的核心逻辑</h3><p>信号量本质上是一个整数计数器，包含两个原子操作：</p><ol><li> **<code>acquire()</code> (P 操作 / Wait)**：计数器减 1。如果计数器为 0，线程阻塞，直到大于 0。</li><li> **<code>release()</code> (V 操作 / Signal / Post)**：计数器加 1。如果有线程在阻塞，唤醒其中一个。</li></ol><p><strong>与条件变量最大的区别：</strong></p><ul><li>  <strong>条件变量是无状态的</strong>：如果没有线程在 <code>wait</code>，你调用 <code>notify</code>，这个信号就<strong>丢了</strong>。</li><li>  <strong>信号量是有状态的</strong>：如果没有线程在 <code>acquire</code>，你调用 <code>release</code>，计数器会<strong>累加</strong>，信号被<strong>保存</strong>下来，下一个线程来 <code>acquire</code> 时会直接通过，不用等待。</li></ul><hr><h3 id="2-代码实现：使用信号量的生产者-消费者"><a href="#2-代码实现：使用信号量的生产者-消费者" class="headerlink" title="2. 代码实现：使用信号量的生产者-消费者"></a>2. 代码实现：使用信号量的生产者-消费者</h3><p>在这个方案中，我们使用两个核心组件：</p><ol><li> <code>std::mutex</code>：仅用于保护 <code>std::queue</code> 的数据完整性（防止 push/pop 冲突）。</li><li> <code>std::counting_semaphore</code>：用来代表“队列中可用数据的数量”。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span> <span class="comment">// C++20 需要此头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; dataQueue;</span><br><span class="line">std::mutex mtx; <span class="comment">// 仅保护队列操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量：初始计数为0，代表队列一开始是空的</span></span><br><span class="line"><span class="comment">// 模板参数是最大计数值，通常设很大</span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;1000&gt; <span class="title">items_sem</span><span class="params">(<span class="number">0</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= count; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            dataQueue.<span class="built_in">push</span>(i);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Producer] Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产了一个数据，信号量 +1</span></span><br><span class="line">        <span class="comment">// 如果有消费者在等，它会被唤醒；没人等，计数器保留为1</span></span><br><span class="line">        items_sem.<span class="built_in">release</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 等待信号量（计数器 -1）</span></span><br><span class="line">        <span class="comment">// 如果计数器为0，这里会阻塞。</span></span><br><span class="line">        <span class="comment">// 注意：这里不需要持有 mutex！这是和条件变量最大的区别。</span></span><br><span class="line">        items_sem.<span class="built_in">acquire</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 2. 只有在取数据的一瞬间才加锁</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!dataQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                val = dataQueue.<span class="built_in">front</span>();</span><br><span class="line">                dataQueue.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 模拟处理结束逻辑（简单处理：如果是 -1 就退出）</span></span><br><span class="line">        <span class="keyword">if</span> (val == <span class="number">-1</span>) <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;] Processed: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">p</span><span class="params">(producer, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c1</span><span class="params">(consumer, <span class="number">1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    p.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 毒药丸 (Poison Pill) 模式：</span></span><br><span class="line">    <span class="comment">// 信号量很难像条件变量那样通过一个 bool finished 变量来广播退出，</span></span><br><span class="line">    <span class="comment">// 因为消费者阻塞在 acquire() 上，看不到 bool 变量的变化。</span></span><br><span class="line">    <span class="comment">// 所以通常往队列里塞一个特殊值（比如 -1）来通知退出。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        dataQueue.<span class="built_in">push</span>(<span class="number">-1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    items_sem.<span class="built_in">release</span>(); <span class="comment">// 增加信号量让消费者醒来读到 -1</span></span><br><span class="line"></span><br><span class="line">    c1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-条件变量-vs-信号量：详细对比"><a href="#3-条件变量-vs-信号量：详细对比" class="headerlink" title="3. 条件变量 vs. 信号量：详细对比"></a>3. 条件变量 vs. 信号量：详细对比</h3><table><thead><tr><th align="left">特性</th><th align="left">条件变量 (Condition Variable)</th><th align="left">信号量 (Semaphore)</th></tr></thead><tbody><tr><td align="left"><strong>核心逻辑</strong></td><td align="left"><strong>基于状态检查</strong>。等待某个复杂的条件（谓词）成立。</td><td align="left"><strong>基于计数</strong>。等待资源的数量 &gt; 0。</td></tr><tr><td align="left"><strong>是否有记忆</strong></td><td align="left"><strong>无记忆</strong>。如果在 <code>wait</code> 之前 <code>notify</code>，信号丢失。</td><td align="left"><strong>有记忆</strong>。<code>release</code> 会增加计数，后续的 <code>acquire</code> 会立即成功。</td></tr><tr><td align="left"><strong>互斥锁依赖</strong></td><td align="left"><strong>必须配合</strong> <code>unique_lock&lt;mutex&gt;</code>。等待时自动释放锁，醒来自动加锁。</td><td align="left"><strong>独立</strong>。信号量本身是原子的，不需要外部锁。但在操作共享容器时仍需锁。</td></tr><tr><td align="left"><strong>灵活性</strong></td><td align="left"><strong>极高</strong>。条件可以是 `!queue.empty() &amp;&amp; x &gt; 5</td><td align="left"></td></tr><tr><td align="left"><strong>广播能力</strong></td><td align="left"><code>notify_all()</code> 可以轻松唤醒所有线程。</td><td align="left">没有直接的 <code>release_all</code>。通常需要循环调用 <code>release</code> 或者由被唤醒的线程级联唤醒。</td></tr><tr><td align="left"><strong>典型场景</strong></td><td align="left">复杂的业务逻辑同步、状态机变化、一次性通知。</td><td align="left">资源池限制（如连接池）、有界缓冲区的空槽/满槽计数。</td></tr></tbody></table><h3 id="4-为什么-C-11-只有条件变量没有信号量？"><a href="#4-为什么-C-11-只有条件变量没有信号量？" class="headerlink" title="4. 为什么 C++11 只有条件变量没有信号量？"></a>4. 为什么 C++11 只有条件变量没有信号量？</h3><p>这是一个有趣的设计哲学问题。C++ 标准委员会当时认为：</p><ol><li> <strong>条件变量是更底层的原语</strong>：你可以用“互斥锁 + 条件变量 + 计数器整数”轻松实现一个信号量。</li><li> <strong>表达能力</strong>：条件变量能表达任意复杂的条件，而信号量只能表达计数。</li><li> <strong>易错性</strong>：信号量在复杂的逻辑中容易导致死锁（比如忘记 release），或者是编程意图不清晰（只有数字，不知道代表什么）。</li></ol><p><strong>如何用 C++11 的条件变量实现一个信号量？</strong><br>(这也是面试常考题)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Semaphore</span>(<span class="type">int</span> count_ = <span class="number">0</span>) : <span class="built_in">count</span>(count_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        count++;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒一个等待者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="comment">// 使用条件变量实现信号量的等待逻辑</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> count &gt; <span class="number">0</span>; &#125;);</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-什么时候该选哪一个？"><a href="#5-什么时候该选哪一个？" class="headerlink" title="5. 什么时候该选哪一个？"></a>5. 什么时候该选哪一个？</h3><ul><li><p><strong>选条件变量</strong>：</p><ul><li>  你需要检查的条件<strong>不仅仅是计数</strong>（例如：队列不为空 <strong>且</strong> 生产未结束）。</li><li>  你需要<strong>广播</strong>（通知所有线程，例如“程序退出”信号）。</li><li>  你需要更严格的临界区控制（醒来时必须持有锁）。</li></ul></li><li><p><strong>选信号量</strong>：</p><ul><li>  主要为了<strong>限制并发数量</strong>（例如：限制最多 5 个线程同时访问数据库连接池）。</li><li>  <strong>有界缓冲区（Bounded Buffer）</strong>：需要两个信号量，一个表示“空槽数量”，一个表示“数据数量”。这种场景下信号量代码非常优雅，不需要手动检查 <code>queue.size() &lt; MAX</code>。</li><li>  轻量级的通知机制，且发送通知时并不持有锁。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果不使用条件变量，使用信号量实现生产者-消费者模型是完全可行的，甚至在“纯粹计数”的场景下代码更少。</p><p>但信号量的<strong>局限性</strong>在于处理“非计数类”的状态变化（比如程序停止标志 <code>finished</code>）时比较麻烦，通常需要特殊的“毒药丸”策略来唤醒阻塞的线程，而条件变量只需要修改判断谓词即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>std::condition_variable使用介绍</title>
      <link href="/2025/11/30/c++%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/11/30/c++%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>C++11 引入的 <code>std::condition_variable</code>（条件变量）是多线程编程中用于<strong>线程间同步</strong>和<strong>通信</strong>的重要机制。它允许一个线程挂起（阻塞），直到另一个线程通知它某个特定的条件已经满足。</p><span id="more"></span><p>相比于“忙等待”（Busy Waiting，即在一个循环里不停地检查变量），条件变量能节省 CPU 资源，因为线程在等待时会真正进入休眠状态。</p><p>下面我将从<strong>基本概念、核心机制、虚假唤醒、应用场景</strong>以及<strong>代码示例</strong>五个方面详细讲解。</p><hr><h3 id="1-基本概念与头文件"><a href="#1-基本概念与头文件" class="headerlink" title="1. 基本概念与头文件"></a>1. 基本概念与头文件</h3><p>要使用条件变量，需要包含头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br></pre></td></tr></table></figure><p>通常，条件变量需要配合以下两个组件一起工作：</p><ol><li> **<code>std::mutex</code>**：用于保护共享数据。</li><li> **<code>std::unique_lock&lt;std::mutex&gt;</code>**：用于在等待期间自动解锁和重新加锁（注意：必须是 <code>unique_lock</code>，不能是 <code>lock_guard</code>，原因后面会讲）。</li></ol><h3 id="2-核心操作"><a href="#2-核心操作" class="headerlink" title="2. 核心操作"></a>2. 核心操作</h3><p><code>std::condition_variable</code> 主要有三个核心动作：</p><ul><li>**<code>wait(lock, predicate)</code>**：<ul><li>  <strong>阻塞</strong>：当前线程释放锁，并进入休眠状态（不占用 CPU）。</li><li>  <strong>唤醒</strong>：当收到通知或系统虚假唤醒时，线程解除阻塞。</li><li>  <strong>重获锁</strong>：线程重新获取互斥锁。</li><li>  <strong>检查条件</strong>：如果有 <code>predicate</code>（一个返回 bool 的函数或 lambda），它会检查条件是否满足。如果不满足，再次挂起。</li></ul></li><li>  <strong><code>notify_one()</code><strong>：唤醒</strong>一个</strong>正在等待该条件变量的线程。</li><li>  <strong><code>notify_all()</code><strong>：唤醒</strong>所有</strong>正在等待该条件变量的线程。</li></ul><hr><h3 id="3-为什么需要-std-unique-lock？"><a href="#3-为什么需要-std-unique-lock？" class="headerlink" title="3. 为什么需要 std::unique_lock？"></a>3. 为什么需要 <code>std::unique_lock</code>？</h3><p><code>std::lock_guard</code> 是 RAII 风格的锁，一旦创建就锁住，直到销毁才释放。<br>而条件变量在调用 <code>wait()</code> 时，<strong>必须由库内部先解锁</strong>（让其他线程能获取锁并修改共享数据），然后在<strong>唤醒时重新加锁</strong>。<code>std::unique_lock</code> 提供了这种灵活的 <code>lock()</code> 和 <code>unlock()</code> 能力，而 <code>lock_guard</code> 不行。</p><hr><h3 id="4-关键陷阱：虚假唤醒-Spurious-Wakeup"><a href="#4-关键陷阱：虚假唤醒-Spurious-Wakeup" class="headerlink" title="4. 关键陷阱：虚假唤醒 (Spurious Wakeup)"></a>4. 关键陷阱：虚假唤醒 (Spurious Wakeup)</h3><p>这是一个面试常考点。线程在没有收到 <code>notify</code> 的情况下，也可能被操作系统唤醒。这被称为“虚假唤醒”。</p><p><strong>错误写法（使用 <code>if</code>）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock); <span class="comment">// 如果发生虚假唤醒，线程醒来往下执行，但队列其实还是空的 -&gt; 崩溃</span></span><br><span class="line">&#125;</span><br><span class="line">data = queue.<span class="built_in">front</span>();</span><br></pre></td></tr></table></figure><p><strong>正确写法（使用 <code>while</code>）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock); <span class="comment">// 醒来后再次检查条件，如果还是空的，继续睡</span></span><br><span class="line">&#125;</span><br><span class="line">data = queue.<span class="built_in">front</span>();</span><br></pre></td></tr></table></figure><p><strong>C++11 简化写法（推荐）：</strong><br><code>wait</code> 函数支持第二个参数（谓词），自动帮我们处理 <code>while</code> 循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 意思是：直到 lambda 返回 true 时，才停止等待</span></span><br><span class="line">cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !queue.<span class="built_in">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h3><ol><li> <strong>生产者-消费者模型（Producer-Consumer）</strong>：最经典场景。生产者往队列塞数据，通知消费者；消费者取数据，如果队列空则等待。</li><li> <strong>线程池（Thread Pool）</strong>：工作线程在没有任务时挂起，主线程添加任务后通知工作线程“来活了”。</li><li> <strong>读写锁的实现</strong>或<strong>屏障（Barrier）</strong>：等待所有线程到达某个同步点。</li></ol><hr><h3 id="6-代码示例：生产者-消费者模型"><a href="#6-代码示例：生产者-消费者模型" class="headerlink" title="6. 代码示例：生产者-消费者模型"></a>6. 代码示例：生产者-消费者模型</h3><p>这个例子展示了一个生产者线程生产数据，一个消费者线程处理数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; dataQueue;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> finished = <span class="literal">false</span>; <span class="comment">// 标记生产是否结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= count; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// 模拟生产耗时</span></span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 加锁保护共享队列</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            dataQueue.<span class="built_in">push</span>(i);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Producer] Produced: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="comment">// 离开作用域，自动解锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知一个等待的消费者（先解锁再通知通常效率更高，避免消费者醒来立刻撞上锁）</span></span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记生产结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        finished = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>(); <span class="comment">// 通知所有消费者（如果有多给消费者）该下班了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 核心逻辑：等待数据 OR 结束信号</span></span><br><span class="line">        <span class="comment">// 使用 lambda 表达式作为谓词，防止虚假唤醒</span></span><br><span class="line">        <span class="comment">// 含义：当“队列不为空”或者“生产已结束”时，停止等待，继续往下执行</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !dataQueue.<span class="built_in">empty</span>() || finished; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列有数据，取出处理</span></span><br><span class="line">        <span class="keyword">while</span> (!dataQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> val = dataQueue.<span class="built_in">front</span>();</span><br><span class="line">            dataQueue.<span class="built_in">pop</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[Consumer] Processed: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列空了且生产结束，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[Consumer] Done.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer, <span class="number">10</span>)</span></span>; <span class="comment">// 生产10个数据</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码解析："><a href="#代码解析：" class="headerlink" title="代码解析："></a>代码解析：</h4><ol><li>**Consumer 的 <code>cv.wait</code>**：<ul><li>  它首先持有了 <code>mtx</code>。</li><li>  然后检查 lambda <code>!dataQueue.empty() || finished</code>。</li><li>  如果为 <code>false</code>（没数据且没结束）：它<strong>释放锁</strong> <code>mtx</code> 并进入休眠。</li><li>  如果为 <code>true</code>：它继续持有锁往下执行。</li></ul></li><li>**Producer 的 <code>cv.notify_one</code>**：<ul><li>  生产者放入数据后调用 <code>notify_one</code>。</li><li>  操作系统唤醒 Consumer 线程。</li><li>  Consumer 醒来后，尝试<strong>重新获取锁</strong> <code>mtx</code>。</li><li>  拿到锁后，再次执行 lambda 检查，发现队列不为空，于是往下执行取数据逻辑。</li></ul></li></ol><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><ul><li>  <strong><code>std::condition_variable</code></strong> 用于线程因等待某个条件而挂起。</li><li>  必须配合 <strong><code>std::unique_lock&lt;std::mutex&gt;</code></strong> 使用。</li><li>  使用 <strong><code>wait</code></strong> 时必须防范<strong>虚假唤醒</strong>（建议使用带谓词的 <code>wait</code> 版本）。</li><li>  <strong><code>notify_one</code></strong> 唤醒一个，**<code>notify_all</code>** 唤醒所有。</li><li>  它是构建复杂并发模式（如线程池、任务队列）的基石。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java中的布尔类型</title>
      <link href="/2025/11/12/java%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/11/12/java%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Java 中的 <code>boolean</code> 与数值类型（<code>int</code> 等）是不同的原始类型，语言层面既不允许隐式转换，也不允许显式强制转换。</p><ul><li>不允许的示例<ul><li><code>int i = true;</code>、<code>boolean b = 1;</code>、<code>b = (boolean) 1;</code> 都会编译报错</li><li><code>if (1) &#123;&#125;</code> 在 Java 中非法（不同于 C/C++），只能 <code>if (b)</code> 或 <code>if (表达式为 boolean)</code></li></ul></li></ul><span id="more"></span><ul><li><p>设计原因</p><ul><li><code>boolean</code> 仅表示真假，不是 0/1；Java 强类型、拒绝将布尔视为数值，避免隐蔽错误</li></ul></li><li><p>正确的转换方式</p><ul><li><code>boolean → int</code>：<code>int x = b ? 1 : 0;</code></li><li><code>int → boolean</code>：<code>boolean b = x != 0;</code>（或按语义 <code>x &gt; 0</code>、<code>x == 1</code>）</li><li><code>String → boolean</code>：<code>Boolean.parseBoolean(s)</code>（仅当 <code>s.equalsIgnoreCase(&quot;true&quot;)</code> 时为 <code>true</code>）</li></ul></li><li><p>拓展说明</p><ul><li>包装类型也不互转：<code>Boolean</code> 与 <code>Integer</code> 之间无自动或显式转换</li><li>JVM 字节码层面布尔常以 <code>int</code> 形式参与计算栈，但这是实现细节，语言层面仍严格区分类型，不能依赖该细节进行数值运算</li></ul></li></ul><p>如果你在与数据库、NDK 或旧接口对接时需要 0/1 表示布尔，按上面的方式在边界处显式转换即可。        </p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么 ASan 需要 `-fsanitize=address` 编译选项，而不仅仅是替换动态库？</title>
      <link href="/2025/08/05/%E4%B8%BA%E4%BB%80%E4%B9%88ASan%E9%9C%80%E8%A6%81-fsanitize=address%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E6%9B%BF%E6%8D%A2%E5%8A%A8%E6%80%81%E5%BA%93/"/>
      <url>/2025/08/05/%E4%B8%BA%E4%BB%80%E4%B9%88ASan%E9%9C%80%E8%A6%81-fsanitize=address%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E6%9B%BF%E6%8D%A2%E5%8A%A8%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么-ASan-需要-fsanitize-address-编译选项，而不仅仅是替换动态库？"><a href="#为什么-ASan-需要-fsanitize-address-编译选项，而不仅仅是替换动态库？" class="headerlink" title="为什么 ASan 需要 -fsanitize=address 编译选项，而不仅仅是替换动态库？"></a><strong>为什么 ASan 需要 <code>-fsanitize=address</code> 编译选项，而不仅仅是替换动态库？</strong></h3><span id="more"></span><p>ASan（AddressSanitizer）的工作机制不仅仅是 <strong>替换动态库（如 <code>libasan.so</code>）</strong>，它还需要 <strong>编译时插桩（Instrumentation）</strong> 来监控内存访问。以下是详细解释：</p><hr><h2 id="1-ASan-的两大核心机制"><a href="#1-ASan-的两大核心机制" class="headerlink" title="1. ASan 的两大核心机制"></a><strong>1. ASan 的两大核心机制</strong></h2><p>ASan 的完整实现依赖 <strong>两个关键部分</strong>：</p><ol><li><p><strong>编译时插桩（Instrumentation）</strong>  </p><ul><li>在代码中插入额外的检查逻辑，监控 <strong>每一次内存访问</strong>（如数组访问、指针解引用）。  </li><li>例如，<code>array[i]</code> 会被编译器改写成 <code>__asan_check_access(array, i)</code>，检查是否越界。  </li><li><strong>必须通过 <code>-fsanitize=address</code> 启用</strong>，因为编译器需要修改生成的汇编代码。</li></ul></li><li><p><strong>运行时库（<code>libasan.so</code>）</strong>  </p><ul><li>提供 <strong>影子内存（Shadow Memory）</strong> 管理、错误报告、<code>malloc/free</code> 替换等功能。  </li><li>动态库替换（如 <code>LD_PRELOAD=libasan.so</code>）只能处理这部分，但 <strong>无法实现内存访问插桩</strong>。</li></ul></li></ol><hr><h2 id="2-为什么不能仅靠替换动态库实现-ASan？"><a href="#2-为什么不能仅靠替换动态库实现-ASan？" class="headerlink" title="2. 为什么不能仅靠替换动态库实现 ASan？"></a><strong>2. 为什么不能仅靠替换动态库实现 ASan？</strong></h2><p>如果只替换动态库（如 <code>libasan.so</code>），而不进行编译时插桩：</p><ul><li><strong>无法监控栈变量和全局变量的访问</strong>：  <ul><li>ASan 需要插桩来检查 <strong>栈上的数组越界</strong>（如 <code>int buf[10]; buf[11] = 0;</code>）。  </li><li>动态库无法直接修改编译器生成的栈访问指令。</li></ul></li><li><strong>无法监控所有内存读写</strong>：  <ul><li>动态库只能拦截 <strong>显式的函数调用</strong>（如 <code>malloc</code>/<code>free</code>），但无法拦截 <strong>直接的指针操作</strong>（如 <code>*ptr = 10</code>）。  </li><li>ASan 插桩会在每次内存读写前插入检查逻辑。</li></ul></li><li><strong>性能优化</strong>：  <ul><li>插桩可以 <strong>选择性检查</strong>（如跳过某些安全的内存区域），而纯动态库方案无法做到。</li></ul></li></ul><hr><h2 id="3-动态库替换（libasan-so）的作用"><a href="#3-动态库替换（libasan-so）的作用" class="headerlink" title="3. 动态库替换（libasan.so）的作用"></a><strong>3. 动态库替换（<code>libasan.so</code>）的作用</strong></h2><p>ASan 的动态库主要负责：</p><ol><li><strong>替换内存分配函数</strong>（如 <code>malloc</code>、<code>free</code>、<code>calloc</code>），在分配时标记内存状态。  </li><li><strong>管理影子内存</strong>（Shadow Memory），记录哪些内存是合法/非法的。  </li><li><strong>错误报告</strong>，当检测到问题时打印调用栈和错误信息。  </li></ol><p>但如果没有编译时插桩，动态库 <strong>无法知道内存是如何被访问的</strong>。</p><hr><h2 id="4-示例：ASan-如何工作"><a href="#4-示例：ASan-如何工作" class="headerlink" title="4. 示例：ASan 如何工作"></a><strong>4. 示例：ASan 如何工作</strong></h2><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    arr[<span class="number">10</span>] = <span class="number">0</span>;  <span class="comment">// 越界写入</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译时插桩（关键步骤）"><a href="#编译时插桩（关键步骤）" class="headerlink" title="编译时插桩（关键步骤）"></a><strong>编译时插桩（关键步骤）</strong></h3><ol><li><strong>启用 ASan</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fsanitize=address -g test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li><strong>编译器修改代码</strong>（伪代码）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *arr = __asan_malloc(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// ASan 替换的 malloc</span></span><br><span class="line">    __asan_check_access(arr, <span class="number">10</span>);  <span class="comment">// 插入越界检查</span></span><br><span class="line">    arr[<span class="number">10</span>] = <span class="number">0</span>;  <span class="comment">// 如果越界，ASan 会在此处终止程序</span></span><br><span class="line">    __asan_free(arr);  <span class="comment">// ASan 替换的 free</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>运行时检测</strong>：<ul><li><code>__asan_check_access</code> 会查询 <strong>影子内存</strong>，发现 <code>arr[10]</code> 是非法访问，触发错误：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: AddressSanitizer: heap-buffer-overflow</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="5-对比：纯动态库替换方案"><a href="#5-对比：纯动态库替换方案" class="headerlink" title="5. 对比：纯动态库替换方案"></a><strong>5. 对比：纯动态库替换方案</strong></h2><p>假设我们 <strong>不</strong> 使用 <code>-fsanitize=address</code>，仅替换 <code>malloc/free</code>：</p><ul><li><strong>能检测的问题</strong>：<ul><li>部分堆内存错误（如 <code>use-after-free</code>、<code>double-free</code>）。</li></ul></li><li><strong>不能检测的问题</strong>：<ul><li>栈溢出（如 <code>int buf[10]; buf[20] = 0;</code>）。</li><li>全局变量溢出。</li><li>直接指针越界（如 <code>*(ptr + 100) = 0</code>）。</li></ul></li></ul><hr><h2 id="6-为什么其他工具（如-Valgrind）不需要重新编译？"><a href="#6-为什么其他工具（如-Valgrind）不需要重新编译？" class="headerlink" title="6. 为什么其他工具（如 Valgrind）不需要重新编译？"></a><strong>6. 为什么其他工具（如 Valgrind）不需要重新编译？</strong></h2><ul><li><strong>Valgrind</strong> 使用 <strong>动态二进制插桩（DBI）</strong>，在运行时修改程序指令，但性能开销极大（~20x  slowdown）。  </li><li><strong>ASan</strong> 的编译时插桩使得它的性能损失较低（~2x slowdown），但必须重新编译。</li></ul><hr><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h2><table><thead><tr><th>机制</th><th>是否需要 <code>-fsanitize=address</code></th><th>功能</th></tr></thead><tbody><tr><td><strong>编译时插桩</strong></td><td>✅ 必须</td><td>监控所有内存访问（栈/堆/全局变量）</td></tr><tr><td><strong>动态库替换</strong></td><td>❌ 可选（但通常自动链接）</td><td>替换 <code>malloc/free</code>，管理影子内存</td></tr></tbody></table><p><strong>结论</strong>：</p><ul><li><strong>仅替换动态库无法实现完整的 ASan 功能</strong>，必须通过 <code>-fsanitize=address</code> 让编译器插入检查代码。  </li><li>ASan 的高效性依赖于 <strong>编译时插桩 + 运行时库协作</strong>。  </li></ul><p>如果想深入理解 ASan 的插桩逻辑，可以研究 <strong>LLVM 的 ASan 源码</strong>（如 <code>compiler-rt/lib/asan</code>）。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> 数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 3D图形学 </tag>
            
            <tag> 数学 </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3D图形学中的平面方程：从线性代数到Vector4f表示</title>
      <link href="/2025/06/30/3D%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%B3%95%E5%90%91%E9%87%8F%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/06/30/3D%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%B3%95%E5%90%91%E9%87%8F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在3D图形学编程中，平面的数学表示是一个基础且重要的概念。无论是进行碰撞检测、视锥体裁剪，还是实现复杂的渲染算法，理解平面方程的数学原理都至关重要。本文将深入探讨3D空间中平面的各种表示方法，特别是点法式方程和Vector4f表示法，以及法向量朝向的重要性。</p><span id="more"></span><!--more--><h2 id="线性代数基础：什么是平面"><a href="#线性代数基础：什么是平面" class="headerlink" title="线性代数基础：什么是平面"></a>线性代数基础：什么是平面</h2><h3 id="平面的几何定义"><a href="#平面的几何定义" class="headerlink" title="平面的几何定义"></a>平面的几何定义</h3><p>在三维空间中，<strong>平面</strong>是一个二维的几何对象，具有以下特性：</p><ul><li>无限延伸的平坦表面</li><li>任意两点之间的直线完全位于平面内</li><li>由一个点和一个法向量唯一确定</li></ul><h3 id="平面的数学本质"><a href="#平面的数学本质" class="headerlink" title="平面的数学本质"></a>平面的数学本质</h3><p>从线性代数的角度看，三维空间中的平面实际上是一个<strong>线性方程的解集</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax + by + cz + d = 0</span><br></pre></td></tr></table></figure><p>其中 <code>(x, y, z)</code> 是平面上任意一点的坐标，<code>(a, b, c)</code> 构成平面的法向量，<code>d</code> 是常数项。</p><h2 id="点法式方程：平面的经典表示"><a href="#点法式方程：平面的经典表示" class="headerlink" title="点法式方程：平面的经典表示"></a>点法式方程：平面的经典表示</h2><h3 id="什么是点法式方程"><a href="#什么是点法式方程" class="headerlink" title="什么是点法式方程"></a>什么是点法式方程</h3><p><strong>点法式方程</strong>是描述平面最直观的方法之一。如果我们知道：</p><ul><li>平面上的一个已知点 <code>P0(x0, y0, z0)</code></li><li>平面的法向量 <code>n = (a, b, c)</code></li></ul><p>那么平面上任意一点 <code>P(x, y, z)</code> 都满足：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n · (P - P0) = 0</span><br></pre></td></tr></table></figure><h3 id="数学推导过程"><a href="#数学推导过程" class="headerlink" title="数学推导过程"></a>数学推导过程</h3><p>让我们详细推导这个方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设平面上一个已知点为 P0(x0, y0, z0)</span></span><br><span class="line"><span class="comment">// 平面法向量为 n = (a, b, c)</span></span><br><span class="line"><span class="comment">// 平面上任意一点为 P(x, y, z)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量 P0P = P - P0 = (x-x0, y-y0, z-z0)</span></span><br><span class="line"><span class="comment">// 由于 P0P 在平面内，所以它与法向量垂直</span></span><br><span class="line"><span class="comment">// 因此：n · P0P = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开点积：</span></span><br><span class="line"><span class="built_in">a</span>(x - x0) + <span class="built_in">b</span>(y - y0) + <span class="built_in">c</span>(z - z0) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整理得到：</span></span><br><span class="line">ax + by + cz - (ax0 + by0 + cz0) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 令 d = -(ax0 + by0 + cz0)，得到一般式：</span></span><br><span class="line">ax + by + cz + d = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="实际代码示例"><a href="#实际代码示例" class="headerlink" title="实际代码示例"></a>实际代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="type">float</span> x, y, z;</span><br><span class="line">    <span class="built_in">Point3D</span>(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> z) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3D</span> &#123;</span><br><span class="line">    <span class="type">float</span> x, y, z;</span><br><span class="line">    <span class="built_in">Vector3D</span>(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> z) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 点积运算</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">dot</span><span class="params">(<span class="type">const</span> Vector3D&amp; other)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * other.x + y * other.y + z * other.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plane</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vector3D normal;  <span class="comment">// 法向量 (a, b, c)</span></span><br><span class="line">    <span class="type">float</span> d;          <span class="comment">// 常数项</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用点法式构造平面</span></span><br><span class="line">    <span class="built_in">Plane</span>(<span class="type">const</span> Point3D&amp; point, <span class="type">const</span> Vector3D&amp; normal) </span><br><span class="line">        : <span class="built_in">normal</span>(normal) &#123;</span><br><span class="line">        <span class="comment">// 计算 d = -(ax0 + by0 + cz0)</span></span><br><span class="line">        d = -(normal.x * point.x + normal.y * point.y + normal.z * point.z);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查点是否在平面上</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPointOnPlane</span><span class="params">(<span class="type">const</span> Point3D&amp; point, <span class="type">float</span> epsilon = <span class="number">1e-6</span>f)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> result = normal.x * point.x + normal.y * point.y + normal.z * point.z + d;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">abs</span>(result) &lt; epsilon;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算点到平面的距离</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">distanceToPoint</span><span class="params">(<span class="type">const</span> Point3D&amp; point)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> numerator = std::<span class="built_in">abs</span>(normal.x * point.x + normal.y * point.y + normal.z * point.z + d);</span><br><span class="line">        <span class="type">float</span> denominator = std::<span class="built_in">sqrt</span>(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);</span><br><span class="line">        <span class="keyword">return</span> numerator / denominator;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printEquation</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; normal.x &lt;&lt; <span class="string">&quot;x + &quot;</span> &lt;&lt; normal.y &lt;&lt; <span class="string">&quot;y + &quot;</span> &lt;&lt; normal.z &lt;&lt; <span class="string">&quot;z + &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; = 0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个平面：通过点(1, 2, 3)，法向量(1, 0, 0)</span></span><br><span class="line">    <span class="function">Point3D <span class="title">knownPoint</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector3D <span class="title">normalVector</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Plane <span class="title">plane</span><span class="params">(knownPoint, normalVector)</span></span>;</span><br><span class="line">    plane.<span class="built_in">printEquation</span>();  <span class="comment">// 输出：1x + 0y + 0z + -1 = 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试几个点</span></span><br><span class="line">    <span class="function">Point3D <span class="title">testPoint1</span><span class="params">(<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>)</span></span>;  <span class="comment">// 应该在平面上</span></span><br><span class="line">    <span class="function">Point3D <span class="title">testPoint2</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>)</span></span>;  <span class="comment">// 不在平面上</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;点(1,5,8)在平面上: &quot;</span> &lt;&lt; plane.<span class="built_in">isPointOnPlane</span>(testPoint1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;点(2,5,8)到平面距离: &quot;</span> &lt;&lt; plane.<span class="built_in">distanceToPoint</span>(testPoint2) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vector4f表示法：ax-by-cz-d-0"><a href="#Vector4f表示法：ax-by-cz-d-0" class="headerlink" title="Vector4f表示法：ax + by + cz + d = 0"></a>Vector4f表示法：ax + by + cz + d = 0</h2><h3 id="为什么使用Vector4f"><a href="#为什么使用Vector4f" class="headerlink" title="为什么使用Vector4f"></a>为什么使用Vector4f</h3><p>在计算机图形学中，将平面方程 <code>ax + by + cz + d = 0</code> 的系数排列成一个四维向量 <code>(a, b, c, d)</code> 有诸多优势：</p><ol><li><strong>内存紧凑性</strong>：四个浮点数连续存储，便于GPU处理</li><li><strong>计算效率</strong>：可以使用SIMD指令进行向量化计算</li><li><strong>统一接口</strong>：与齐次坐标系统完美配合</li><li><strong>矩阵运算</strong>：便于进行平面变换</li></ol><h3 id="Vector4f的存储格式"><a href="#Vector4f的存储格式" class="headerlink" title="Vector4f的存储格式"></a>Vector4f的存储格式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;immintrin.h&gt;</span>  <span class="comment">// for SIMD</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector4f</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123; <span class="type">float</span> x, y, z, w; &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123; <span class="type">float</span> a, b, c, d; &#125;;  <span class="comment">// 用于平面方程</span></span><br><span class="line">        std::array&lt;<span class="type">float</span>, 4&gt; data;</span><br><span class="line">        __m128 simd;  <span class="comment">// SIMD寄存器</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Vector4f</span>(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> c, <span class="type">float</span> d) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(b), <span class="built_in">c</span>(c), <span class="built_in">d</span>(d) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算点到平面的符号距离</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">signedDistanceToPoint</span><span class="params">(<span class="type">const</span> Point3D&amp; point)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * point.x + b * point.y + c * point.z + d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 归一化法向量（保持d不变）</span></span><br><span class="line">    <span class="function">Vector4f <span class="title">normalized</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> length = std::<span class="built_in">sqrt</span>(a * a + b * b + c * c);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector4f</span>(a / length, b / length, c / length, d / length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用SIMD进行快速计算</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SIMDPlane</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    __m128 plane_eq;  <span class="comment">// 存储 (a, b, c, d)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SIMDPlane</span>(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> c, <span class="type">float</span> d) &#123;</span><br><span class="line">        plane_eq = _mm_set_ps(d, c, b, a);  <span class="comment">// 注意参数顺序</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同时计算多个点到平面的距离</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">distanceToPoints</span><span class="params">(<span class="type">const</span> std::vector&lt;Point3D&gt;&amp; points, std::vector&lt;<span class="type">float</span>&gt;&amp; distances)</span> </span>&#123;</span><br><span class="line">        distances.<span class="built_in">resize</span>(points.<span class="built_in">size</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i += <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">// 加载4个点的坐标</span></span><br><span class="line">            __m128 x = _mm_set_ps(</span><br><span class="line">                i + <span class="number">3</span> &lt; points.<span class="built_in">size</span>() ? points[i + <span class="number">3</span>].x : <span class="number">0</span>,</span><br><span class="line">                i + <span class="number">2</span> &lt; points.<span class="built_in">size</span>() ? points[i + <span class="number">2</span>].x : <span class="number">0</span>,</span><br><span class="line">                i + <span class="number">1</span> &lt; points.<span class="built_in">size</span>() ? points[i + <span class="number">1</span>].x : <span class="number">0</span>,</span><br><span class="line">                points[i].x</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// ... 类似地加载y, z坐标</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行向量化计算</span></span><br><span class="line">            __m128 result = _mm_mul_ps(plane_eq, x);</span><br><span class="line">            <span class="comment">// ... 后续SIMD操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="signedDistanceToPoint函数详解"><a href="#signedDistanceToPoint函数详解" class="headerlink" title="signedDistanceToPoint函数详解"></a>signedDistanceToPoint函数详解</h3><p>这个函数是3D图形学中的核心函数，让我详细解释其实现原理：</p><h4 id="1-数学原理"><a href="#1-数学原理" class="headerlink" title="1. 数学原理"></a>1. 数学原理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">signedDistanceToPoint</span><span class="params">(<span class="type">const</span> Point3D&amp; point)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * point.x + b * point.y + c * point.z + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数直接实现了平面方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax + by + cz + d = 0</span><br></pre></td></tr></table></figure><p>当我们把点 <code>P(x, y, z)</code> 的坐标代入这个方程时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(P) = ax + by + cz + d</span><br></pre></td></tr></table></figure><p>这个值 <code>f(P)</code> 就是我们要的<strong>符号距离</strong>。</p><h4 id="2-为什么叫”符号距离”？"><a href="#2-为什么叫”符号距离”？" class="headerlink" title="2. 为什么叫”符号距离”？"></a>2. 为什么叫”符号距离”？</h4><p>这个函数返回的值有特殊的几何意义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设平面方程为：2x + 3y - z + 5 = 0</span></span><br><span class="line"><span class="comment">// 法向量 n = (2, 3, -1)，指向平面的一侧</span></span><br><span class="line"></span><br><span class="line"><span class="function">Point3D <span class="title">point1</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">float</span> dist1 = plane.<span class="built_in">signedDistanceToPoint</span>(point1);</span><br><span class="line"><span class="comment">// 结果：2*1 + 3*1 + (-1)*1 + 5 = 9 &gt; 0</span></span><br><span class="line"><span class="comment">// 表示点在法向量指向的一侧</span></span><br><span class="line"></span><br><span class="line"><span class="function">Point3D <span class="title">point2</span><span class="params">(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="type">float</span> dist2 = plane.<span class="built_in">signedDistanceToPoint</span>(point2);</span><br><span class="line"><span class="comment">// 结果：2*(-1) + 3*(-1) + (-1)*(-1) + 5 = -1 &lt; 0</span></span><br><span class="line"><span class="comment">// 表示点在法向量指向的反侧</span></span><br><span class="line"></span><br><span class="line"><span class="function">Point3D <span class="title">point3</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>)</span></span>;  <span class="comment">// 这个点在平面上</span></span><br><span class="line"><span class="type">float</span> dist3 = plane.<span class="built_in">signedDistanceToPoint</span>(point3);</span><br><span class="line"><span class="comment">// 结果：2*0 + 3*0 + (-1)*5 + 5 = 0</span></span><br><span class="line"><span class="comment">// 表示点在平面上</span></span><br></pre></td></tr></table></figure><h4 id="3-符号的含义"><a href="#3-符号的含义" class="headerlink" title="3. 符号的含义"></a>3. 符号的含义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于平面方程 ax + by + cz + d = 0：</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 如果 f(P) &gt; 0：点在法向量指向的一侧</span></span><br><span class="line"><span class="comment">// 如果 f(P) = 0：点在平面上</span></span><br><span class="line"><span class="comment">// 如果 f(P) &lt; 0：点在法向量指向的反侧</span></span><br></pre></td></tr></table></figure><h4 id="4-实际应用示例"><a href="#4-实际应用示例" class="headerlink" title="4. 实际应用示例"></a>4. 实际应用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plane</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vector4f equation;  <span class="comment">// (a, b, c, d)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">signedDistanceToPoint</span><span class="params">(<span class="type">const</span> Point3D&amp; point)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> equation.a * point.x + equation.b * point.y + equation.c * point.z + equation.d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用符号距离进行点分类</span></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">PointLocation</span> &#123; Inside, OnPlane, Outside &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">PointLocation <span class="title">classifyPoint</span><span class="params">(<span class="type">const</span> Point3D&amp; point, <span class="type">float</span> epsilon = <span class="number">1e-6</span>f)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> distance = <span class="built_in">signedDistanceToPoint</span>(point);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">abs</span>(distance) &lt; epsilon) &#123;</span><br><span class="line">            <span class="keyword">return</span> PointLocation::OnPlane;  <span class="comment">// 点在平面上</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (distance &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> PointLocation::Inside;   <span class="comment">// 点在&quot;内侧&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> PointLocation::Outside;  <span class="comment">// 点在&quot;外侧&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算点到平面的实际距离（绝对值）</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">distanceToPoint</span><span class="params">(<span class="type">const</span> Point3D&amp; point)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> signedDist = <span class="built_in">signedDistanceToPoint</span>(point);</span><br><span class="line">        <span class="type">float</span> normalLength = std::<span class="built_in">sqrt</span>(</span><br><span class="line">            equation.a * equation.a + </span><br><span class="line">            equation.b * equation.b + </span><br><span class="line">            equation.c * equation.c</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">abs</span>(signedDist) / normalLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-性能优势"><a href="#5-性能优势" class="headerlink" title="5. 性能优势"></a>5. 性能优势</h4><p>这个函数非常高效，因为：</p><ol><li><strong>计算简单</strong>：只需要4次乘法和3次加法</li><li><strong>内存友好</strong>：Vector4f的4个分量连续存储，缓存友好</li><li><strong>SIMD优化</strong>：可以轻松向量化处理多个点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SIMD优化版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testMultiplePoints</span><span class="params">(<span class="type">const</span> Vector4f&amp; plane, </span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> std::vector&lt;Point3D&gt;&amp; points,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::vector&lt;<span class="type">float</span>&gt;&amp; distances)</span> </span>&#123;</span><br><span class="line">    __m128 plane_simd = _mm_load_ps(&amp;plane.a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 加载4个点的坐标</span></span><br><span class="line">        __m128 x = _mm_set_ps(points[i+<span class="number">3</span>].x, points[i+<span class="number">2</span>].x, points[i+<span class="number">1</span>].x, points[i].x);</span><br><span class="line">        __m128 y = _mm_set_ps(points[i+<span class="number">3</span>].y, points[i+<span class="number">2</span>].y, points[i+<span class="number">1</span>].y, points[i].y);</span><br><span class="line">        __m128 z = _mm_set_ps(points[i+<span class="number">3</span>].z, points[i+<span class="number">2</span>].z, points[i+<span class="number">1</span>].z, points[i].z);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算 ax + by + cz + d</span></span><br><span class="line">        __m128 result = _mm_fmadd_ps(_mm_shuffle_ps(plane_simd, plane_simd, _MM_SHUFFLE(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)), x,</span><br><span class="line">                    _mm_fmadd_ps(_mm_shuffle_ps(plane_simd, plane_simd, _MM_SHUFFLE(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)), y,</span><br><span class="line">                    _mm_fmadd_ps(_mm_shuffle_ps(plane_simd, plane_simd, _MM_SHUFFLE(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)), z,</span><br><span class="line">                                _mm_shuffle_ps(plane_simd, plane_simd, _MM_SHUFFLE(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)))));</span><br><span class="line">        </span><br><span class="line">        _mm_store_ps(&amp;distances[i], result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><p>这个 <code>signedDistanceToPoint</code> 函数是3D图形学中的核心函数，它：</p><ol><li><strong>直接实现平面方程</strong>：<code>ax + by + cz + d</code></li><li><strong>提供符号信息</strong>：正负号表示点在平面的哪一侧</li><li><strong>高效计算</strong>：只需要基本的算术运算</li><li><strong>广泛应用</strong>：在碰撞检测、视锥体裁剪、CSG操作中都有重要应用</li></ol><p>理解这个函数的原理对于掌握3D数学和图形编程至关重要。</p><h3 id="齐次坐标中的应用"><a href="#齐次坐标中的应用" class="headerlink" title="齐次坐标中的应用"></a>齐次坐标中的应用</h3><p>在齐次坐标系统中，平面的Vector4f表示尤其有用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 齐次坐标中的点 (x, y, z, w)，其中 w = 1 表示位置</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HomogeneousPoint</span> &#123;</span><br><span class="line">    <span class="type">float</span> x, y, z, w;</span><br><span class="line">    <span class="built_in">HomogeneousPoint</span>(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> z) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z), <span class="built_in">w</span>(<span class="number">1.0f</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平面方程在齐次坐标中的计算</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">planePointTest</span><span class="params">(<span class="type">const</span> Vector4f&amp; plane, <span class="type">const</span> HomogeneousPoint&amp; point)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这就是一个简单的4D点积！</span></span><br><span class="line">    <span class="keyword">return</span> plane.a * point.x + plane.b * point.y + plane.c * point.z + plane.d * point.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵变换平面</span></span><br><span class="line"><span class="function">Vector4f <span class="title">transformPlane</span><span class="params">(<span class="type">const</span> Vector4f&amp; plane, <span class="type">const</span> Matrix4x4&amp; transform)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 平面变换需要使用变换矩阵的逆转置</span></span><br><span class="line">    Matrix4x4 invTranspose = transform.<span class="built_in">inverse</span>().<span class="built_in">transpose</span>();</span><br><span class="line">    <span class="keyword">return</span> invTranspose * plane;  <span class="comment">// 矩阵乘向量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法向量朝向：Inward-Facing-Normals详解"><a href="#法向量朝向：Inward-Facing-Normals详解" class="headerlink" title="法向量朝向：Inward-Facing Normals详解"></a>法向量朝向：Inward-Facing Normals详解</h2><h3 id="什么是Inward-Facing-Normal"><a href="#什么是Inward-Facing-Normal" class="headerlink" title="什么是Inward-Facing Normal"></a>什么是Inward-Facing Normal</h3><p>在用户提到的注释中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Normals(a, b, c) of planes are all facing inward */</span></span><br></pre></td></tr></table></figure><p>这里的”inward-facing”指的是<strong>法向量指向某个几何体或区域的内部</strong>。这在3D图形学中有重要的实际意义。</p><h3 id="为什么需要规定法向量方向"><a href="#为什么需要规定法向量方向" class="headerlink" title="为什么需要规定法向量方向"></a>为什么需要规定法向量方向</h3><h4 id="1-碰撞检测中的应用"><a href="#1-碰撞检测中的应用" class="headerlink" title="1. 碰撞检测中的应用"></a>1. 碰撞检测中的应用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConvexHull</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Vector4f&gt; planes;  <span class="comment">// 所有平面的法向量都指向内部</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 检查点是否在凸包内部</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPointInside</span><span class="params">(<span class="type">const</span> Point3D&amp; point)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; plane : planes) &#123;</span><br><span class="line">            <span class="type">float</span> distance = plane.<span class="built_in">signedDistanceToPoint</span>(point);</span><br><span class="line">            <span class="keyword">if</span> (distance &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果点在任何一个平面的&quot;外侧&quot;，则不在凸包内</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 点在所有平面的&quot;内侧&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算点到凸包边界的最近距离</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">distanceToSurface</span><span class="params">(<span class="type">const</span> Point3D&amp; point)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> maxDistance = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">lowest</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; plane : planes) &#123;</span><br><span class="line">            <span class="type">float</span> distance = plane.<span class="built_in">signedDistanceToPoint</span>(point);</span><br><span class="line">            maxDistance = std::<span class="built_in">max</span>(maxDistance, distance);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxDistance;  <span class="comment">// 正值表示在外部，负值表示在内部</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-视锥体裁剪（Frustum-Culling）"><a href="#2-视锥体裁剪（Frustum-Culling）" class="headerlink" title="2. 视锥体裁剪（Frustum Culling）"></a>2. 视锥体裁剪（Frustum Culling）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ViewFrustum</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 6个平面：近、远、左、右、上、下，法向量都指向视锥体内部</span></span><br><span class="line">    std::array&lt;Vector4f, 6&gt; planes;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateFromCamera</span><span class="params">(<span class="type">const</span> Matrix4x4&amp; viewProjectionMatrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从视图投影矩阵提取裁剪平面</span></span><br><span class="line">        <span class="comment">// 左平面: row4 + row1</span></span><br><span class="line">        planes[<span class="number">0</span>] = <span class="built_in">Vector4f</span>(</span><br><span class="line">            viewProjectionMatrix[<span class="number">3</span>][<span class="number">0</span>] + viewProjectionMatrix[<span class="number">0</span>][<span class="number">0</span>],</span><br><span class="line">            viewProjectionMatrix[<span class="number">3</span>][<span class="number">1</span>] + viewProjectionMatrix[<span class="number">0</span>][<span class="number">1</span>],</span><br><span class="line">            viewProjectionMatrix[<span class="number">3</span>][<span class="number">2</span>] + viewProjectionMatrix[<span class="number">0</span>][<span class="number">2</span>],</span><br><span class="line">            viewProjectionMatrix[<span class="number">3</span>][<span class="number">3</span>] + viewProjectionMatrix[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">        ).<span class="built_in">normalized</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 右平面: row4 - row1</span></span><br><span class="line">        planes[<span class="number">1</span>] = <span class="built_in">Vector4f</span>(</span><br><span class="line">            viewProjectionMatrix[<span class="number">3</span>][<span class="number">0</span>] - viewProjectionMatrix[<span class="number">0</span>][<span class="number">0</span>],</span><br><span class="line">            viewProjectionMatrix[<span class="number">3</span>][<span class="number">1</span>] - viewProjectionMatrix[<span class="number">0</span>][<span class="number">1</span>],</span><br><span class="line">            viewProjectionMatrix[<span class="number">3</span>][<span class="number">2</span>] - viewProjectionMatrix[<span class="number">0</span>][<span class="number">2</span>],</span><br><span class="line">            viewProjectionMatrix[<span class="number">3</span>][<span class="number">3</span>] - viewProjectionMatrix[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">        ).<span class="built_in">normalized</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... 类似地计算其他平面</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查球体是否与视锥体相交</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sphereIntersectsFrustum</span><span class="params">(<span class="type">const</span> Point3D&amp; center, <span class="type">float</span> radius)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; plane : planes) &#123;</span><br><span class="line">            <span class="type">float</span> distance = plane.<span class="built_in">signedDistanceToPoint</span>(center);</span><br><span class="line">            <span class="keyword">if</span> (distance &gt; radius) &#123;</span><br><span class="line">                <span class="comment">// 球心到平面的距离大于半径，球体完全在视锥体外</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查AABB包围盒是否与视锥体相交</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">aabbIntersectsFrustum</span><span class="params">(<span class="type">const</span> Point3D&amp; min, <span class="type">const</span> Point3D&amp; max)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; plane : planes) &#123;</span><br><span class="line">            <span class="comment">// 计算AABB在平面法向量方向上的最远点</span></span><br><span class="line">            <span class="function">Point3D <span class="title">farthestPoint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                plane.a &gt; <span class="number">0</span> ? max.x : min.x,</span></span></span><br><span class="line"><span class="params"><span class="function">                plane.b &gt; <span class="number">0</span> ? max.y : min.y,</span></span></span><br><span class="line"><span class="params"><span class="function">                plane.c &gt; <span class="number">0</span> ? max.z : min.z</span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (plane.<span class="built_in">signedDistanceToPoint</span>(farthestPoint) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 最远点都在平面外侧，整个AABB在视锥体外</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Inward-Facing的数学含义"><a href="#Inward-Facing的数学含义" class="headerlink" title="Inward-Facing的数学含义"></a>Inward-Facing的数学含义</h3><h4 id="符号约定的重要性"><a href="#符号约定的重要性" class="headerlink" title="符号约定的重要性"></a>符号约定的重要性</h4><p>当我们说法向量”facing inward”时，实际上是在建立一个<strong>符号约定</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于inward-facing normal的平面方程 ax + by + cz + d = 0：</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 如果 ax + by + cz + d &lt; 0：点在&quot;内侧&quot;（法向量指向的反方向）</span></span><br><span class="line"><span class="comment">// 如果 ax + by + cz + d = 0：点在平面上</span></span><br><span class="line"><span class="comment">// 如果 ax + by + cz + d &gt; 0：点在&quot;外侧&quot;（法向量指向的方向）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrientedPlane</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vector4f equation;  <span class="comment">// (a, b, c, d)</span></span><br><span class="line">    <span class="type">bool</span> isInwardFacing;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrientedPlane</span>(<span class="type">const</span> Vector4f&amp; eq, <span class="type">bool</span> inward = <span class="literal">true</span>) </span><br><span class="line">        : <span class="built_in">equation</span>(eq), <span class="built_in">isInwardFacing</span>(inward) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取点相对于平面的位置</span></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">PointLocation</span> &#123; Inside, OnPlane, Outside &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">PointLocation <span class="title">classifyPoint</span><span class="params">(<span class="type">const</span> Point3D&amp; point, <span class="type">float</span> epsilon = <span class="number">1e-6</span>f)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> distance = equation.<span class="built_in">signedDistanceToPoint</span>(point);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">abs</span>(distance) &lt; epsilon) &#123;</span><br><span class="line">            <span class="keyword">return</span> PointLocation::OnPlane;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据法向量朝向调整判断逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (isInwardFacing) &#123;</span><br><span class="line">            <span class="keyword">return</span> (distance &lt; <span class="number">0</span>) ? PointLocation::Inside : PointLocation::Outside;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (distance &gt; <span class="number">0</span>) ? PointLocation::Inside : PointLocation::Outside;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 翻转法向量方向</span></span><br><span class="line">    <span class="function">OrientedPlane <span class="title">flip</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">OrientedPlane</span>(<span class="built_in">Vector4f</span>(-equation.a, -equation.b, -equation.c, -equation.d), </span><br><span class="line">                           !isInwardFacing);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><h4 id="1-游戏引擎中的碰撞体"><a href="#1-游戏引擎中的碰撞体" class="headerlink" title="1. 游戏引擎中的碰撞体"></a>1. 游戏引擎中的碰撞体</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CollisionMesh</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Vector4f&gt; inwardFacingPlanes;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 从三角网格构建碰撞平面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildFromTriangles</span><span class="params">(<span class="type">const</span> std::vector&lt;Triangle&gt;&amp; triangles, <span class="type">const</span> Point3D&amp; interiorPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; triangle : triangles) &#123;</span><br><span class="line">            Vector3D normal = triangle.<span class="built_in">calculateNormal</span>();</span><br><span class="line">            Point3D planePoint = triangle.vertices[<span class="number">0</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 构造平面方程</span></span><br><span class="line">            <span class="type">float</span> d = -(normal.x * planePoint.x + normal.y * planePoint.y + normal.z * planePoint.z);</span><br><span class="line">            <span class="function">Vector4f <span class="title">plane</span><span class="params">(normal.x, normal.y, normal.z, d)</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查法向量方向，确保指向内部</span></span><br><span class="line">            <span class="type">float</span> testDistance = plane.<span class="built_in">signedDistanceToPoint</span>(interiorPoint);</span><br><span class="line">            <span class="keyword">if</span> (testDistance &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 法向量指向外部，需要翻转</span></span><br><span class="line">                plane = <span class="built_in">Vector4f</span>(-plane.a, -plane.b, -plane.c, -plane.d);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            inwardFacingPlanes.<span class="built_in">push_back</span>(plane);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsPoint</span><span class="params">(<span class="type">const</span> Point3D&amp; point)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; plane : inwardFacingPlanes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (plane.<span class="built_in">signedDistanceToPoint</span>(point) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 点在某个平面的外侧</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-CSG（Constructive-Solid-Geometry）操作"><a href="#2-CSG（Constructive-Solid-Geometry）操作" class="headerlink" title="2. CSG（Constructive Solid Geometry）操作"></a>2. CSG（Constructive Solid Geometry）操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSGOperation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 两个凸体的交集</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ConvexHull <span class="title">intersection</span><span class="params">(<span class="type">const</span> ConvexHull&amp; a, <span class="type">const</span> ConvexHull&amp; b)</span> </span>&#123;</span><br><span class="line">        ConvexHull result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交集的边界由两个凸体的所有inward-facing平面组成</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; plane : a.<span class="built_in">getPlanes</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">addPlane</span>(plane);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; plane : b.<span class="built_in">getPlanes</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">addPlane</span>(plane);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从凸体A中减去凸体B</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ConvexHull <span class="title">difference</span><span class="params">(<span class="type">const</span> ConvexHull&amp; a, <span class="type">const</span> ConvexHull&amp; b)</span> </span>&#123;</span><br><span class="line">        ConvexHull result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保留A的所有inward-facing平面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; plane : a.<span class="built_in">getPlanes</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">addPlane</span>(plane);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将B的平面翻转为outward-facing，然后添加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; plane : b.<span class="built_in">getPlanes</span>()) &#123;</span><br><span class="line">            <span class="function">Vector4f <span class="title">flippedPlane</span><span class="params">(-plane.a, -plane.b, -plane.c, -plane.d)</span></span>;</span><br><span class="line">            result.<span class="built_in">addPlane</span>(flippedPlane);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="性能优化技巧"><a href="#性能优化技巧" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h2><h3 id="1-SIMD优化"><a href="#1-SIMD优化" class="headerlink" title="1. SIMD优化"></a>1. SIMD优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SIMDPlaneOperations</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 同时测试4个点与平面的关系</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">testFourPoints</span><span class="params">(<span class="type">const</span> Vector4f&amp; plane, </span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> Point3D points[<span class="number">4</span>], </span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">float</span> results[<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加载平面系数</span></span><br><span class="line">        __m128 plane_simd = _mm_load_ps(&amp;plane.a);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载4个点的x坐标</span></span><br><span class="line">        __m128 x_coords = _mm_set_ps(points[<span class="number">3</span>].x, points[<span class="number">2</span>].x, points[<span class="number">1</span>].x, points[<span class="number">0</span>].x);</span><br><span class="line">        __m128 y_coords = _mm_set_ps(points[<span class="number">3</span>].y, points[<span class="number">2</span>].y, points[<span class="number">1</span>].y, points[<span class="number">0</span>].y);</span><br><span class="line">        __m128 z_coords = _mm_set_ps(points[<span class="number">3</span>].z, points[<span class="number">2</span>].z, points[<span class="number">1</span>].z, points[<span class="number">0</span>].z);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算 ax, by, cz</span></span><br><span class="line">        __m128 ax = _mm_mul_ps(_mm_shuffle_ps(plane_simd, plane_simd, _MM_SHUFFLE(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)), x_coords);</span><br><span class="line">        __m128 by = _mm_mul_ps(_mm_shuffle_ps(plane_simd, plane_simd, _MM_SHUFFLE(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)), y_coords);</span><br><span class="line">        __m128 cz = _mm_mul_ps(_mm_shuffle_ps(plane_simd, plane_simd, _MM_SHUFFLE(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)), z_coords);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加上常数项d</span></span><br><span class="line">        __m128 d_term = _mm_shuffle_ps(plane_simd, plane_simd, _MM_SHUFFLE(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算最终结果：ax + by + cz + d</span></span><br><span class="line">        __m128 result = _mm_add_ps(_mm_add_ps(ax, by), _mm_add_ps(cz, d_term));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 存储结果</span></span><br><span class="line">        _mm_store_ps(results, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-预计算优化"><a href="#2-预计算优化" class="headerlink" title="2. 预计算优化"></a>2. 预计算优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OptimizedFrustum</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PrecomputedPlane</span> &#123;</span><br><span class="line">        Vector4f equation;</span><br><span class="line">        Vector3D normal;</span><br><span class="line">        <span class="type">float</span> normalLength;</span><br><span class="line">        <span class="type">float</span> invNormalLength;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::array&lt;PrecomputedPlane, 6&gt; planes;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">precomputePlaneData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; plane : planes) &#123;</span><br><span class="line">            plane.normalLength = std::<span class="built_in">sqrt</span>(</span><br><span class="line">                plane.equation.a * plane.equation.a +</span><br><span class="line">                plane.equation.b * plane.equation.b +</span><br><span class="line">                plane.equation.c * plane.equation.c</span><br><span class="line">            );</span><br><span class="line">            plane.invNormalLength = <span class="number">1.0f</span> / plane.normalLength;</span><br><span class="line">            plane.normal = <span class="built_in">Vector3D</span>(</span><br><span class="line">                plane.equation.a * plane.invNormalLength,</span><br><span class="line">                plane.equation.b * plane.invNormalLength,</span><br><span class="line">                plane.equation.c * plane.invNormalLength</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快速距离计算（避免重复的平方根运算）</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">fastSignedDistance</span><span class="params">(<span class="type">int</span> planeIndex, <span class="type">const</span> Point3D&amp; point)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; plane = planes[planeIndex];</span><br><span class="line">        <span class="type">float</span> unnormalizedDistance = </span><br><span class="line">            plane.equation.a * point.x + </span><br><span class="line">            plane.equation.b * point.y + </span><br><span class="line">            plane.equation.c * point.z + </span><br><span class="line">            plane.equation.d;</span><br><span class="line">        <span class="keyword">return</span> unnormalizedDistance * plane.invNormalLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文深入探讨了3D空间中平面的数学表示和实际应用：</p><ol><li><strong>点法式方程</strong>提供了理解平面几何意义的直观方法</li><li><strong>Vector4f表示法</strong>为计算机图形学提供了高效的数据结构</li><li><strong>Inward-facing normals</strong>的约定在碰撞检测、视锥体裁剪等应用中至关重要</li><li><strong>性能优化</strong>技术可以显著提升大规模几何计算的效率</li></ol><p>理解这些概念不仅有助于掌握3D数学的基础，更能为实际的图形编程项目提供坚实的理论支撑。无论是开发游戏引擎、CAD软件还是科学可视化应用，平面方程都是不可或缺的数学工具。</p><h3 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h3><ul><li><a href="https://www.realtimerendering.com/">Real-Time Rendering, 4th Edition</a> - 第16章：空间数据结构</li><li><a href="https://gamemath.com/">3D Math Primer for Graphics and Game Development</a> - 第9章：平面和半空间</li><li><a href="https://www.cgpp.org/">Computer Graphics: Principles and Practice</a> - 第12章：几何变换</li></ul><h3 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h3><ol><li><strong>动手实现</strong>：尝试自己实现一个简单的3D碰撞检测系统</li><li><strong>可视化调试</strong>：使用图形调试工具来可视化平面和法向量</li><li><strong>性能测试</strong>：比较不同实现方式的性能差异</li><li><strong>数值稳定性</strong>：关注浮点数精度对几何计算的影响 </li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> 数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 3D图形学 </tag>
            
            <tag> 数学 </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++迭代器</title>
      <link href="/2025/06/30/c++%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/"/>
      <url>/2025/06/30/c++%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>C++ 中有 <strong>5 种主要的迭代器类型</strong>，它们形成一个<strong>层次结构</strong>，每种都有不同的功能和限制。</p><hr><span id="more"></span><h2 id="C-迭代器的-5-种类型"><a href="#C-迭代器的-5-种类型" class="headerlink" title="C++ 迭代器的 5 种类型"></a>C++ 迭代器的 5 种类型</h2><h3 id="1-输入迭代器-Input-Iterator"><a href="#1-输入迭代器-Input-Iterator" class="headerlink" title="1. 输入迭代器 (Input Iterator)"></a>1. <strong>输入迭代器 (Input Iterator)</strong></h3><ul><li><strong>只读</strong>，<strong>单向</strong>，<strong>一次性</strong></li><li>只能 <code>++it</code>，不能 <code>--it</code></li><li>只能读取 <code>*it</code>，不能修改</li><li>典型例子：<code>std::istream_iterator</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">it</span><span class="params">(std::cin)</span></span>;</span><br><span class="line"><span class="type">int</span> value = *it;  <span class="comment">// 只读</span></span><br><span class="line">++it;            <span class="comment">// 只能前进</span></span><br><span class="line"><span class="comment">// --it;         // ❌ 不支持</span></span><br></pre></td></tr></table></figure><h3 id="2-输出迭代器-Output-Iterator"><a href="#2-输出迭代器-Output-Iterator" class="headerlink" title="2. 输出迭代器 (Output Iterator)"></a>2. <strong>输出迭代器 (Output Iterator)</strong></h3><ul><li><strong>只写</strong>，<strong>单向</strong>，<strong>一次性</strong></li><li>只能 <code>++it</code>，不能读取</li><li>典型例子：<code>std::ostream_iterator</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">it</span><span class="params">(std::cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">*it = <span class="number">42</span>;        <span class="comment">// 只写</span></span><br><span class="line">++it;            <span class="comment">// 只能前进</span></span><br><span class="line"><span class="comment">// int x = *it;  // ❌ 不能读取</span></span><br></pre></td></tr></table></figure><h3 id="3-前向迭代器-Forward-Iterator-⭐"><a href="#3-前向迭代器-Forward-Iterator-⭐" class="headerlink" title="3. 前向迭代器 (Forward Iterator) ⭐"></a>3. <strong>前向迭代器 (Forward Iterator)</strong> ⭐</h3><ul><li><strong>读写</strong>，<strong>单向</strong>，<strong>可多次遍历</strong></li><li>支持 <code>++it</code>，不支持 <code>--it</code></li><li>可以多次读写同一位置</li><li>典型例子：<code>std::forward_list&lt;T&gt;::iterator</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::forward_list&lt;<span class="type">int</span>&gt; flist = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = flist.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">*it = <span class="number">10</span>;        <span class="comment">// ✅ 可读写</span></span><br><span class="line">++it;            <span class="comment">// ✅ 前进</span></span><br><span class="line"><span class="comment">// --it;         // ❌ 不能后退</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以多次遍历</span></span><br><span class="line"><span class="keyword">auto</span> it2 = flist.<span class="built_in">begin</span>();  <span class="comment">// 重新开始遍历</span></span><br></pre></td></tr></table></figure><h3 id="4-双向迭代器-Bidirectional-Iterator"><a href="#4-双向迭代器-Bidirectional-Iterator" class="headerlink" title="4. 双向迭代器 (Bidirectional Iterator)"></a>4. <strong>双向迭代器 (Bidirectional Iterator)</strong></h3><ul><li><strong>读写</strong>，<strong>双向</strong>，<strong>可多次遍历</strong></li><li>支持 <code>++it</code> 和 <code>--it</code></li><li>典型例子：<code>std::list&lt;T&gt;::iterator</code>, <code>std::set&lt;T&gt;::iterator</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = lst.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">++it;            <span class="comment">// ✅ 前进</span></span><br><span class="line">--it;            <span class="comment">// ✅ 后退</span></span><br><span class="line">*it = <span class="number">100</span>;       <span class="comment">// ✅ 读写</span></span><br></pre></td></tr></table></figure><h3 id="5-随机访问迭代器-Random-Access-Iterator"><a href="#5-随机访问迭代器-Random-Access-Iterator" class="headerlink" title="5. 随机访问迭代器 (Random Access Iterator)"></a>5. <strong>随机访问迭代器 (Random Access Iterator)</strong></h3><ul><li><strong>读写</strong>，<strong>随机访问</strong>，<strong>支持算术运算</strong></li><li>支持 <code>it + n</code>, <code>it - n</code>, <code>it[n]</code>, <code>it1 - it2</code></li><li>典型例子：<code>std::vector&lt;T&gt;::iterator</code>, <code>std::array&lt;T&gt;::iterator</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">it += <span class="number">3</span>;         <span class="comment">// ✅ 跳跃访问</span></span><br><span class="line"><span class="type">int</span> val = it[<span class="number">1</span>]; <span class="comment">// ✅ 下标访问</span></span><br><span class="line"><span class="keyword">auto</span> dist = vec.<span class="built_in">end</span>() - it;  <span class="comment">// ✅ 距离计算</span></span><br></pre></td></tr></table></figure><hr><h2 id="前向迭代器详解"><a href="#前向迭代器详解" class="headerlink" title="前向迭代器详解"></a>前向迭代器详解</h2><h3 id="什么是前向迭代器？"><a href="#什么是前向迭代器？" class="headerlink" title="什么是前向迭代器？"></a><strong>什么是前向迭代器？</strong></h3><p>前向迭代器是<strong>最基础的”真正有用”的迭代器</strong>，它具备：</p><ol><li><strong>可读写</strong>：<code>*it</code> 既可以读取也可以修改</li><li><strong>单向移动</strong>：只支持 <code>++it</code>，不支持 <code>--it</code></li><li><strong>多次遍历</strong>：可以保存迭代器副本，重复访问同一元素</li><li><strong>相等比较</strong>：支持 <code>==</code> 和 <code>!=</code></li></ol><h3 id="前向迭代器的要求"><a href="#前向迭代器的要求" class="headerlink" title="前向迭代器的要求"></a><strong>前向迭代器的要求</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIt&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_iterator_example</span><span class="params">(ForwardIt first, ForwardIt last)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ✅ 支持的操作</span></span><br><span class="line">    ForwardIt it = first;     <span class="comment">// 拷贝构造</span></span><br><span class="line">    ForwardIt it2 = it;       <span class="comment">// 可以保存副本</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (it != last) &#123;</span><br><span class="line">        <span class="keyword">auto</span> value = *it;     <span class="comment">// 读取</span></span><br><span class="line">        *it = value + <span class="number">1</span>;      <span class="comment">// 修改</span></span><br><span class="line">        ++it;                 <span class="comment">// 前进</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可以重复访问</span></span><br><span class="line">        <span class="keyword">if</span> (it2 != last) &#123;</span><br><span class="line">            <span class="keyword">auto</span> same_value = *it2;  <span class="comment">// it2 还指向原位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ❌ 不支持的操作</span></span><br><span class="line">    <span class="comment">// --it;                 // 不能后退</span></span><br><span class="line">    <span class="comment">// it += 5;              // 不支持随机访问</span></span><br><span class="line">    <span class="comment">// it[3];                // 不支持下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="典型容器和迭代器类型"><a href="#典型容器和迭代器类型" class="headerlink" title="典型容器和迭代器类型"></a><strong>典型容器和迭代器类型</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向迭代器</span></span><br><span class="line">std::forward_list&lt;<span class="type">int</span>&gt; flist;</span><br><span class="line"><span class="keyword">auto</span> fit = flist.<span class="built_in">begin</span>();  <span class="comment">// forward iterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向迭代器</span></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; list;</span><br><span class="line"><span class="keyword">auto</span> lit = list.<span class="built_in">begin</span>();   <span class="comment">// bidirectional iterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机访问迭代器</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> vit = vec.<span class="built_in">begin</span>();    <span class="comment">// random access iterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时的限制</span></span><br><span class="line">++fit;  ✅</span><br><span class="line"><span class="comment">// --fit;  ❌ 前向迭代器不支持</span></span><br><span class="line"></span><br><span class="line">++lit;  ✅</span><br><span class="line">--lit;  ✅</span><br><span class="line"></span><br><span class="line">++vit;  ✅</span><br><span class="line">--vit;  ✅</span><br><span class="line">vit += <span class="number">3</span>;  ✅</span><br></pre></td></tr></table></figure><hr><h2 id="迭代器层次结构"><a href="#迭代器层次结构" class="headerlink" title="迭代器层次结构"></a>迭代器层次结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入迭代器 ←─┐</span><br><span class="line">           ├─→ 前向迭代器 ─→ 双向迭代器 ─→ 随机访问迭代器</span><br><span class="line">输出迭代器 ←─┘</span><br></pre></td></tr></table></figure><p><strong>每个层次都包含下层的所有功能</strong>：</p><ul><li>随机访问迭代器可以用作双向迭代器</li><li>双向迭代器可以用作前向迭代器</li><li>等等…</li></ul><hr><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><h3 id="算法对迭代器类型的要求"><a href="#算法对迭代器类型的要求" class="headerlink" title="算法对迭代器类型的要求"></a><strong>算法对迭代器类型的要求</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同算法需要不同类型的迭代器</span></span><br><span class="line">std::<span class="built_in">find</span>(first, last, value);        <span class="comment">// 需要：输入迭代器</span></span><br><span class="line">std::<span class="built_in">copy</span>(first, last, output);       <span class="comment">// 需要：输入 + 输出迭代器</span></span><br><span class="line">std::<span class="built_in">reverse</span>(first, last);            <span class="comment">// 需要：双向迭代器</span></span><br><span class="line">std::<span class="built_in">sort</span>(first, last);               <span class="comment">// 需要：随机访问迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向迭代器的典型用途</span></span><br><span class="line">std::forward_list&lt;<span class="type">int</span>&gt; flist = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> result = std::<span class="built_in">find</span>(flist.<span class="built_in">begin</span>(), flist.<span class="built_in">end</span>(), <span class="number">2</span>);  <span class="comment">// ✅ OK</span></span><br><span class="line"><span class="comment">// std::sort(flist.begin(), flist.end());  // ❌ 错误！需要随机访问</span></span><br></pre></td></tr></table></figure><p>前向迭代器是<strong>单链表等数据结构的自然选择</strong>，提供了基本的遍历和修改能力，但不支持高效的反向遍历或随机访问。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++多重继承到Java/TypeScript接口适配问题分析</title>
      <link href="/2025/06/30/C++%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%88%B0Java-TypeScript%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>/2025/06/30/C++%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%88%B0Java-TypeScript%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在跨语言开发中，经常需要将C++的多重继承类转换为Java或TypeScript对象。这种转换过程中，接口适配是一个关键问题，特别是当使用<code>void*</code>存储指针并进行强制类型转换时，可能会遇到一些陷阱。本文将从技术角度深入分析这个问题。</p><span id="more"></span><h2 id="C-多重继承的内存布局"><a href="#C-多重继承的内存布局" class="headerlink" title="C++多重继承的内存布局"></a>C++多重继承的内存布局</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>C++的多重继承允许一个类同时继承多个基类，这带来了复杂的内存布局问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> data1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> data2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> derivedData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="内存布局分析"><a href="#内存布局分析" class="headerlink" title="内存布局分析"></a>内存布局分析</h3><p>在C++中，多重继承的对象内存布局如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Derived对象内存布局：</span><br><span class="line">+------------------+</span><br><span class="line">| Base1 vtable ptr |  &lt;- 对象起始地址</span><br><span class="line">+------------------+</span><br><span class="line">| data1            |</span><br><span class="line">+------------------+</span><br><span class="line">| Base2 vtable ptr |  &lt;- 偏移量</span><br><span class="line">+------------------+</span><br><span class="line">| data2            |</span><br><span class="line">+------------------+</span><br><span class="line">| derivedData      |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><h2 id="虚继承与非虚继承的区别"><a href="#虚继承与非虚继承的区别" class="headerlink" title="虚继承与非虚继承的区别"></a>虚继承与非虚继承的区别</h2><h3 id="菱形继承问题"><a href="#菱形继承问题" class="headerlink" title="菱形继承问题"></a>菱形继承问题</h3><p>当存在菱形继承时，虚继承与非虚继承的内存布局差异变得明显：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非虚继承 - 存在数据重复</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> baseData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> derived1Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> derived2Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Final</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> finalData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="非虚继承的内存布局"><a href="#非虚继承的内存布局" class="headerlink" title="非虚继承的内存布局"></a>非虚继承的内存布局</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Final对象内存布局（非虚继承）：</span><br><span class="line">+------------------+</span><br><span class="line">| Derived1 vtable  |  &lt;- 对象起始地址</span><br><span class="line">+------------------+</span><br><span class="line">| baseData         |  &lt;- Base数据副本1</span><br><span class="line">+------------------+</span><br><span class="line">| derived1Data     |</span><br><span class="line">+------------------+</span><br><span class="line">| Derived2 vtable  |  &lt;- 偏移量</span><br><span class="line">+------------------+</span><br><span class="line">| baseData         |  &lt;- Base数据副本2（重复！）</span><br><span class="line">+------------------+</span><br><span class="line">| derived2Data     |</span><br><span class="line">+------------------+</span><br><span class="line">| finalData        |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><h3 id="虚继承的内存布局"><a href="#虚继承的内存布局" class="headerlink" title="虚继承的内存布局"></a>虚继承的内存布局</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚继承 - 解决数据重复</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> baseData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> derived1Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> derived2Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Final</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="type">int</span> finalData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Final对象内存布局（虚继承）：</span><br><span class="line">+------------------+</span><br><span class="line">| Derived1 vtable  |  &lt;- 对象起始地址</span><br><span class="line">+------------------+</span><br><span class="line">| derived1Data     |</span><br><span class="line">+------------------+</span><br><span class="line">| Derived2 vtable  |  &lt;- 偏移量</span><br><span class="line">+------------------+</span><br><span class="line">| derived2Data     |</span><br><span class="line">+------------------+</span><br><span class="line">| finalData        |</span><br><span class="line">+------------------+</span><br><span class="line">| Base vtable      |  &lt;- 共享的Base部分</span><br><span class="line">+------------------+</span><br><span class="line">| baseData         |  &lt;- 只有一份Base数据</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><h3 id="虚继承的指针偏移复杂性"><a href="#虚继承的指针偏移复杂性" class="headerlink" title="虚继承的指针偏移复杂性"></a>虚继承的指针偏移复杂性</h3><p>虚继承引入了更复杂的指针偏移机制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚继承的指针偏移示例</span></span><br><span class="line">Final* <span class="keyword">final</span> = <span class="keyword">new</span> <span class="built_in">Final</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Base指针需要特殊处理</span></span><br><span class="line">Base* base = <span class="keyword">final</span>;  <span class="comment">// 编译器自动计算到共享Base部分的偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动计算偏移（危险！）</span></span><br><span class="line"><span class="type">void</span>* voidPtr = <span class="keyword">final</span>;</span><br><span class="line">Base* base2 = <span class="built_in">static_cast</span>&lt;Base*&gt;(voidPtr);  <span class="comment">// 错误！无法正确计算偏移</span></span><br></pre></td></tr></table></figure><h2 id="虚继承对接口适配的影响"><a href="#虚继承对接口适配的影响" class="headerlink" title="虚继承对接口适配的影响"></a>虚继承对接口适配的影响</h2><h3 id="1-更复杂的指针偏移计算"><a href="#1-更复杂的指针偏移计算" class="headerlink" title="1. 更复杂的指针偏移计算"></a>1. 更复杂的指针偏移计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚继承情况下的错误包装</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VirtualWrapper</span>(<span class="type">void</span>* p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于虚继承，这种转换是危险的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例 - 存在问题</span></span><br><span class="line">Final* <span class="keyword">final</span> = <span class="keyword">new</span> <span class="built_in">Final</span>();</span><br><span class="line"><span class="function">VirtualWrapper <span class="title">wrapper</span><span class="params">(<span class="keyword">final</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些转换可能失败或指向错误位置</span></span><br><span class="line">Base* base = wrapper.<span class="built_in">get</span>&lt;Base&gt;();        <span class="comment">// 可能错误</span></span><br><span class="line">Derived1* d1 = wrapper.<span class="built_in">get</span>&lt;Derived1&gt;();  <span class="comment">// 可能错误</span></span><br><span class="line">Derived2* d2 = wrapper.<span class="built_in">get</span>&lt;Derived2&gt;();  <span class="comment">// 可能错误</span></span><br></pre></td></tr></table></figure><h3 id="2-虚函数表访问的复杂性"><a href="#2-虚函数表访问的复杂性" class="headerlink" title="2. 虚函数表访问的复杂性"></a>2. 虚函数表访问的复杂性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚继承的虚函数表结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">VirtualBase</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualDerived</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> VirtualBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">derivedMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚函数表访问问题</span></span><br><span class="line"><span class="type">void</span>* ptr = <span class="keyword">new</span> <span class="built_in">VirtualDerived</span>();</span><br><span class="line">VirtualBase* base = <span class="built_in">static_cast</span>&lt;VirtualBase*&gt;(ptr);</span><br><span class="line">base-&gt;<span class="built_in">method</span>();  <span class="comment">// 可能访问错误的虚函数表</span></span><br></pre></td></tr></table></figure><h2 id="针对虚继承的解决方案"><a href="#针对虚继承的解决方案" class="headerlink" title="针对虚继承的解决方案"></a>针对虚继承的解决方案</h2><h3 id="1-使用dynamic-cast进行安全转换"><a href="#1-使用dynamic-cast进行安全转换" class="headerlink" title="1. 使用dynamic_cast进行安全转换"></a>1. 使用dynamic_cast进行安全转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全的虚继承包装器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualSafeWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VirtualSafeWrapper</span>(T* p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    U* <span class="title">safeCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用dynamic_cast处理虚继承</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;U*&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">canCast</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;U*&gt;(ptr) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Final* <span class="keyword">final</span> = <span class="keyword">new</span> <span class="built_in">Final</span>();</span><br><span class="line"><span class="function">VirtualSafeWrapper&lt;Final&gt; <span class="title">wrapper</span><span class="params">(<span class="keyword">final</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的类型转换</span></span><br><span class="line"><span class="keyword">if</span> (wrapper.<span class="built_in">canCast</span>&lt;Base&gt;()) &#123;</span><br><span class="line">    Base* base = wrapper.<span class="built_in">safeCast</span>&lt;Base&gt;();</span><br><span class="line">    base-&gt;<span class="built_in">method</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-虚继承感知的工厂模式"><a href="#2-虚继承感知的工厂模式" class="headerlink" title="2. 虚继承感知的工厂模式"></a>2. 虚继承感知的工厂模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualInterfaceFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Target, <span class="keyword">typename</span> Source&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> Target* <span class="title">createInterface</span><span class="params">(Source* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否存在虚继承关系</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_base_of_v&lt;Target, Source&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_virtual_base_of_v&lt;Target, Source&gt;)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 虚继承：使用dynamic_cast</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;Target*&gt;(ptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非虚继承：可以使用static_cast</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Target*&gt;(ptr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-类型信息增强的包装器"><a href="#3-类型信息增强的包装器" class="headerlink" title="3. 类型信息增强的包装器"></a>3. 类型信息增强的包装器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualTypeInfo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">InheritanceType</span> &#123;</span><br><span class="line">        NORMAL,</span><br><span class="line">        VIRTUAL</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> InheritanceType <span class="title">getInheritanceType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查T是否包含虚继承</span></span><br><span class="line">        <span class="keyword">return</span> std::is_virtual_base_of_v&lt;T, T&gt; ? </span><br><span class="line">               InheritanceType::VIRTUAL : InheritanceType::NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EnhancedWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">    VirtualTypeInfo::InheritanceType inheritanceType;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EnhancedWrapper</span>(T* p) : <span class="built_in">ptr</span>(p), </span><br><span class="line">        <span class="built_in">inheritanceType</span>(VirtualTypeInfo::<span class="built_in">getInheritanceType</span>&lt;T&gt;()) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    U* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inheritanceType == VirtualTypeInfo::InheritanceType::VIRTUAL) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;U*&gt;(ptr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;U*&gt;(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="虚继承与非虚继承的解决方案对比"><a href="#虚继承与非虚继承的解决方案对比" class="headerlink" title="虚继承与非虚继承的解决方案对比"></a>虚继承与非虚继承的解决方案对比</h2><h3 id="非虚继承场景"><a href="#非虚继承场景" class="headerlink" title="非虚继承场景"></a>非虚继承场景</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非虚继承：相对简单的指针偏移</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonVirtualWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于非虚继承，static_cast相对安全</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="虚继承场景"><a href="#虚继承场景" class="headerlink" title="虚继承场景"></a>虚继承场景</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚继承：需要更复杂的处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于虚继承，必须使用dynamic_cast</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="混合场景的处理"><a href="#混合场景的处理" class="headerlink" title="混合场景的处理"></a>混合场景的处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理混合继承场景</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HybridWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    std::type_info* originalType;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">HybridWrapper</span><span class="params">(T* p)</span> : ptr(p), type(&amp;typeid(T)) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    U* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否为虚继承关系</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">hasVirtualInheritance</span>&lt;U&gt;()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;U*&gt;(ptr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;U*&gt;(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">hasVirtualInheritance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现虚继承检测逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 简化实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="接口适配的常见方案"><a href="#接口适配的常见方案" class="headerlink" title="接口适配的常见方案"></a>接口适配的常见方案</h2><h3 id="方案1：使用void-指针存储"><a href="#方案1：使用void-指针存储" class="headerlink" title="方案1：使用void*指针存储"></a>方案1：使用void*指针存储</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 包装层</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Wrapper</span>(<span class="type">void</span>* p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">getRaw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="function">Wrapper <span class="title">wrapper</span><span class="params">(derived)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Base1接口</span></span><br><span class="line">Base1* base1 = wrapper.<span class="built_in">get</span>&lt;Base1&gt;();</span><br><span class="line"><span class="comment">// 获取Base2接口  </span></span><br><span class="line">Base2* base2 = wrapper.<span class="built_in">get</span>&lt;Base2&gt;();</span><br></pre></td></tr></table></figure><h3 id="方案2：类型安全的接口映射"><a href="#方案2：类型安全的接口映射" class="headerlink" title="方案2：类型安全的接口映射"></a>方案2：类型安全的接口映射</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更安全的包装方案</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    std::type_info* type;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SafeWrapper</span><span class="params">(T* p)</span> : ptr(p), type(&amp;typeid(T)) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">typeid</span>(T) == *type) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="1-指针偏移问题"><a href="#1-指针偏移问题" class="headerlink" title="1. 指针偏移问题"></a>1. 指针偏移问题</h3><p>当使用<code>void*</code>存储多重继承对象时，直接强制转换可能导致指针偏移错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="type">void</span>* voidPtr = derived;  <span class="comment">// 存储Derived*的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：直接转换到Base2</span></span><br><span class="line">Base2* base2 = <span class="built_in">static_cast</span>&lt;Base2*&gt;(voidPtr);  <span class="comment">// 可能指向错误位置</span></span><br></pre></td></tr></table></figure><p><strong>问题原因</strong>：<code>void*</code>存储的是<code>Derived</code>对象的起始地址，但<code>Base2</code>的虚函数表在偏移位置，直接转换会得到错误的地址。</p><h3 id="2-虚函数表访问错误"><a href="#2-虚函数表访问错误" class="headerlink" title="2. 虚函数表访问错误"></a>2. 虚函数表访问错误</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="type">void</span>* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Base2* base2 = <span class="built_in">static_cast</span>&lt;Base2*&gt;(ptr);</span><br><span class="line">base2-&gt;<span class="built_in">method2</span>();  <span class="comment">// 可能访问错误的虚函数表</span></span><br></pre></td></tr></table></figure><h3 id="3-类型信息丢失"><a href="#3-类型信息丢失" class="headerlink" title="3. 类型信息丢失"></a>3. 类型信息丢失</h3><p>使用<code>void*</code>会丢失类型信息，无法进行运行时类型检查：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="comment">// 无法知道ptr实际指向什么类型</span></span><br><span class="line"><span class="comment">// 无法进行安全的类型转换</span></span><br></pre></td></tr></table></figure><h2 id="Java-TypeScript接口适配方案"><a href="#Java-TypeScript接口适配方案" class="headerlink" title="Java/TypeScript接口适配方案"></a>Java/TypeScript接口适配方案</h2><h3 id="Java接口映射"><a href="#Java接口映射" class="headerlink" title="Java接口映射"></a>Java接口映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Base1Interface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Base2Interface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CppWrapper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> nativePtr;  <span class="comment">// 存储C++对象指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CppWrapper</span><span class="params">(<span class="type">long</span> ptr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nativePtr = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过JNI调用C++方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取原始指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getNativePtr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nativePtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TypeScript接口映射"><a href="#TypeScript接口映射" class="headerlink" title="TypeScript接口映射"></a>TypeScript接口映射</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript接口定义</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Base1Interface</span> &#123;</span><br><span class="line">    <span class="title function_">method1</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Base2Interface</span> &#123;</span><br><span class="line">    <span class="title function_">method2</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CppWrapper</span> <span class="keyword">implements</span> <span class="title class_">Base1Interface</span>, <span class="title class_">Base2Interface</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">nativePtr</span>: <span class="built_in">number</span>;  <span class="comment">// 存储C++对象指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">ptr: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">nativePtr</span> = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过FFI调用C++方法</span></span><br><span class="line">    <span class="title function_">method1</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 调用native方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">callNativeMethod</span>(<span class="variable language_">this</span>.<span class="property">nativePtr</span>, <span class="string">&#x27;method1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">method2</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">callNativeMethod</span>(<span class="variable language_">this</span>.<span class="property">nativePtr</span>, <span class="string">&#x27;method2&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">callNativeMethod</span>(<span class="attr">ptr</span>: <span class="built_in">number</span>, <span class="attr">methodName</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// 实现native调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确的解决方案"><a href="#正确的解决方案" class="headerlink" title="正确的解决方案"></a>正确的解决方案</h2><h3 id="1-使用类型安全的包装器"><a href="#1-使用类型安全的包装器" class="headerlink" title="1. 使用类型安全的包装器"></a>1. 使用类型安全的包装器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypedWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TypedWrapper</span>(T* p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    U* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;U*&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="function">TypedWrapper&lt;Derived&gt; <span class="title">wrapper</span><span class="params">(derived)</span></span>;</span><br><span class="line"></span><br><span class="line">Base1* base1 = wrapper.<span class="built_in">cast</span>&lt;Base1&gt;();</span><br><span class="line">Base2* base2 = wrapper.<span class="built_in">cast</span>&lt;Base2&gt;();</span><br></pre></td></tr></table></figure><h3 id="2-接口分离原则"><a href="#2-接口分离原则" class="headerlink" title="2. 接口分离原则"></a>2. 接口分离原则</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为每个接口创建独立的包装器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1Wrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Base1* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1Wrapper</span>(Base1* p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123; ptr-&gt;<span class="built_in">method1</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2Wrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Base2* ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2Wrapper</span>(Base2* p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123; ptr-&gt;<span class="built_in">method2</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-工厂模式创建接口"><a href="#3-工厂模式创建接口" class="headerlink" title="3. 工厂模式创建接口"></a>3. 工厂模式创建接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterfaceFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> T* <span class="title">createInterface</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据类型信息正确计算偏移量</span></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_base_of_v&lt;T, Derived&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h2><h3 id="1-避免使用void-进行类型转换"><a href="#1-避免使用void-进行类型转换" class="headerlink" title="1. 避免使用void*进行类型转换"></a>1. 避免使用void*进行类型转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="type">void</span>* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Base2* base2 = <span class="built_in">static_cast</span>&lt;Base2*&gt;(ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Base2* base2 = derived;  <span class="comment">// 编译器自动处理偏移</span></span><br></pre></td></tr></table></figure><h3 id="2-使用智能指针管理生命周期"><a href="#2-使用智能指针管理生命周期" class="headerlink" title="2. 使用智能指针管理生命周期"></a>2. 使用智能指针管理生命周期</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Derived&gt; derived = std::<span class="built_in">make_unique</span>&lt;Derived&gt;();</span><br><span class="line">std::unique_ptr&lt;Base1&gt; base1 = std::<span class="built_in">move</span>(derived);</span><br></pre></td></tr></table></figure><h3 id="3-提供类型安全的接口"><a href="#3-提供类型安全的接口" class="headerlink" title="3. 提供类型安全的接口"></a>3. 提供类型安全的接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SafeInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SafeInterface</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">as</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">is</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> T*&gt;(<span class="keyword">this</span>) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++多重继承转换为Java/TypeScript时，使用<code>void*</code>存储指针并进行强制类型转换确实存在严重问题：</p><ol><li><strong>指针偏移错误</strong>：直接转换会忽略多重继承的内存布局</li><li><strong>虚函数表访问错误</strong>：可能导致调用错误的虚函数</li><li><strong>类型安全缺失</strong>：无法进行运行时类型检查</li></ol><p><strong>推荐解决方案</strong>：</p><ul><li>使用类型安全的包装器</li><li>实现接口分离</li><li>采用工厂模式创建接口</li><li>避免直接使用<code>void*</code>进行类型转换</li></ul><p>通过这些方案，可以确保C++多重继承类在转换为Java/TypeScript时能够正确适配接口，避免运行时错误。</p><h2 id="虚继承与非虚继承的关键差异总结"><a href="#虚继承与非虚继承的关键差异总结" class="headerlink" title="虚继承与非虚继承的关键差异总结"></a>虚继承与非虚继承的关键差异总结</h2><h3 id="内存布局差异"><a href="#内存布局差异" class="headerlink" title="内存布局差异"></a>内存布局差异</h3><table><thead><tr><th>特性</th><th>非虚继承</th><th>虚继承</th></tr></thead><tbody><tr><td>数据重复</td><td>存在重复的基类数据</td><td>共享基类数据</td></tr><tr><td>内存布局</td><td>相对简单，线性排列</td><td>复杂，包含虚基类指针</td></tr><tr><td>指针偏移</td><td>固定偏移量</td><td>动态计算的偏移量</td></tr></tbody></table><h3 id="接口适配策略差异"><a href="#接口适配策略差异" class="headerlink" title="接口适配策略差异"></a>接口适配策略差异</h3><table><thead><tr><th>转换方式</th><th>非虚继承</th><th>虚继承</th></tr></thead><tbody><tr><td>static_cast</td><td>相对安全</td><td>危险，可能导致错误偏移</td></tr><tr><td>dynamic_cast</td><td>可选，但开销较大</td><td>必需，保证类型安全</td></tr><tr><td>void*转换</td><td>可能工作，但不推荐</td><td>几乎总是失败</td></tr></tbody></table><h3 id="解决方案选择"><a href="#解决方案选择" class="headerlink" title="解决方案选择"></a>解决方案选择</h3><p><strong>非虚继承场景</strong>：</p><ul><li>可以使用<code>static_cast</code>进行类型转换</li><li>指针偏移计算相对简单</li><li>包装器实现相对直接</li></ul><p><strong>虚继承场景</strong>：</p><ul><li>必须使用<code>dynamic_cast</code>进行类型转换</li><li>需要复杂的指针偏移计算</li><li>包装器需要特殊处理虚基类</li></ul><p><strong>混合场景</strong>：</p><ul><li>需要检测继承类型</li><li>根据继承类型选择不同的转换策略</li><li>实现更复杂的包装器逻辑</li></ul><h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><ol><li><strong>非虚继承</strong>：<code>static_cast</code>开销小，适合性能敏感场景</li><li><strong>虚继承</strong>：<code>dynamic_cast</code>开销大，但保证类型安全</li><li><strong>混合场景</strong>：需要运行时类型检查，性能开销最大</li></ol><h3 id="最佳实践建议-1"><a href="#最佳实践建议-1" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h3><ol><li><strong>设计阶段</strong>：尽量避免复杂的多重继承，特别是虚继承</li><li><strong>接口设计</strong>：为每个接口创建独立的包装器</li><li><strong>类型安全</strong>：优先使用<code>dynamic_cast</code>而非<code>static_cast</code></li><li><strong>错误处理</strong>：始终检查类型转换的返回值</li><li><strong>文档化</strong>：明确记录继承关系和转换策略</li></ol><p>通过这些差异化的处理策略，可以确保C++多重继承类在跨语言接口适配中既保证类型安全，又兼顾性能需求。</p><h2 id="SWIG解决方案分析"><a href="#SWIG解决方案分析" class="headerlink" title="SWIG解决方案分析"></a>SWIG解决方案分析</h2><h3 id="SWIG简介"><a href="#SWIG简介" class="headerlink" title="SWIG简介"></a>SWIG简介</h3><p>SWIG（Simplified Wrapper and Interface Generator）是一个强大的跨语言接口生成工具，能够自动为C++代码生成多种语言的绑定，包括Java、Python、C#等。SWIG通过分析C++代码的语法结构，自动处理复杂的类型转换和内存管理问题。</p><h3 id="SWIG处理多重继承的机制"><a href="#SWIG处理多重继承的机制" class="headerlink" title="SWIG处理多重继承的机制"></a>SWIG处理多重继承的机制</h3><h4 id="1-自动类型映射"><a href="#1-自动类型映射" class="headerlink" title="1. 自动类型映射"></a>1. 自动类型映射</h4><p>SWIG使用类型映射（Type Mapping）机制来处理C++类型到目标语言的转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 多重继承类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base1</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base2</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SWIG接口文件 (.i)</span><br><span class="line">%module example</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">#include &quot;example.h&quot;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%include &quot;example.h&quot;</span><br><span class="line"></span><br><span class="line">// 类型映射配置</span><br><span class="line">%typemap(javabase) Base1 &quot;java.lang.Object&quot;</span><br><span class="line">%typemap(javabase) Base2 &quot;java.lang.Object&quot;</span><br><span class="line">%typemap(javabase) Derived &quot;Base1, Base2&quot;</span><br></pre></td></tr></table></figure><h4 id="2-自动生成包装类"><a href="#2-自动生成包装类" class="headerlink" title="2. 自动生成包装类"></a>2. 自动生成包装类</h4><p>SWIG会自动为每个C++类生成对应的包装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG自动生成的Java包装类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base1</span> <span class="keyword">implements</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> swigCPtr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> swigCMemOwn;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Derived</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(exampleJNI.new_Derived(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Derived</span><span class="params">(<span class="type">long</span> cPtr, <span class="type">boolean</span> cMemoryOwn)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(exampleJNI.Derived_SWIGUpcast(cPtr), cMemoryOwn);</span><br><span class="line">        swigCPtr = cPtr;</span><br><span class="line">        swigCMemOwn = cMemoryOwn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        exampleJNI.Derived_method1(swigCPtr, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        exampleJNI.Derived_method2(swigCPtr, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SWIG的解决方案策略"><a href="#SWIG的解决方案策略" class="headerlink" title="SWIG的解决方案策略"></a>SWIG的解决方案策略</h3><h4 id="1-类型安全的包装器（Type-Safe-Wrapper）"><a href="#1-类型安全的包装器（Type-Safe-Wrapper）" class="headerlink" title="1. 类型安全的包装器（Type-Safe Wrapper）"></a>1. 类型安全的包装器（Type-Safe Wrapper）</h4><p>SWIG采用类型安全的包装器策略，而不是使用<code>void*</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG内部生成的C++包装代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SWIG_Derived</span> : <span class="keyword">public</span> Derived &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* swig_self;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SWIG_Derived</span>() : <span class="built_in">swig_self</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型安全的指针获取</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 安全的类型转换</span></span><br><span class="line">    <span class="function">Base1* <span class="title">as_Base1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Base1*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Base2* <span class="title">as_Base2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Base2*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-接口分离原则（Interface-Segregation）"><a href="#2-接口分离原则（Interface-Segregation）" class="headerlink" title="2. 接口分离原则（Interface Segregation）"></a>2. 接口分离原则（Interface Segregation）</h4><p>SWIG为每个基类接口生成独立的包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG生成的接口分离</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base1</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Object &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> swigCPtr;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> swigCMemOwn;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Base1</span><span class="params">(<span class="type">long</span> cPtr, <span class="type">boolean</span> cMemoryOwn)</span> &#123;</span><br><span class="line">        swigCPtr = cPtr;</span><br><span class="line">        swigCMemOwn = cMemoryOwn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        exampleJNI.Base1_method1(swigCPtr, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base2</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Object &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> swigCPtr;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> swigCMemOwn;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Base2</span><span class="params">(<span class="type">long</span> cPtr, <span class="type">boolean</span> cMemoryOwn)</span> &#123;</span><br><span class="line">        swigCPtr = cPtr;</span><br><span class="line">        swigCMemOwn = cMemoryOwn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        exampleJNI.Base2_method2(swigCPtr, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-工厂模式创建接口-1"><a href="#3-工厂模式创建接口-1" class="headerlink" title="3. 工厂模式创建接口"></a>3. 工厂模式创建接口</h4><p>SWIG使用工厂模式来创建和管理接口实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG内部工厂实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SWIG_InterfaceFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> T* <span class="title">create_interface</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">const</span> std::type_info&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据类型信息创建正确的接口</span></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="built_in">typeid</span>(Derived)) &#123;</span><br><span class="line">            Derived* derived = <span class="built_in">static_cast</span>&lt;Derived*&gt;(ptr);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(derived);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> Base1* <span class="title">create_Base1_interface</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">create_interface</span>&lt;Base1&gt;(ptr, <span class="built_in">typeid</span>(*<span class="built_in">static_cast</span>&lt;Derived*&gt;(ptr)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> Base2* <span class="title">create_Base2_interface</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">create_interface</span>&lt;Base2&gt;(ptr, <span class="built_in">typeid</span>(*<span class="built_in">static_cast</span>&lt;Derived*&gt;(ptr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="SWIG处理虚继承的特殊机制"><a href="#SWIG处理虚继承的特殊机制" class="headerlink" title="SWIG处理虚继承的特殊机制"></a>SWIG处理虚继承的特殊机制</h3><h4 id="1-虚继承感知的类型转换"><a href="#1-虚继承感知的类型转换" class="headerlink" title="1. 虚继承感知的类型转换"></a>1. 虚继承感知的类型转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚继承场景</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">method</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">VirtualBase</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualDerived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> VirtualBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualDerived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> VirtualBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Final</span> : <span class="keyword">public</span> VirtualDerived1, <span class="keyword">public</span> VirtualDerived2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* 实现 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SWIG虚继承处理</span><br><span class="line">%module virtual_example</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">#include &quot;virtual_example.h&quot;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">// 虚继承特殊处理</span><br><span class="line">%feature(&quot;director&quot;) VirtualBase;</span><br><span class="line">%feature(&quot;director&quot;) VirtualDerived1;</span><br><span class="line">%feature(&quot;director&quot;) VirtualDerived2;</span><br><span class="line"></span><br><span class="line">%include &quot;virtual_example.h&quot;</span><br></pre></td></tr></table></figure><h4 id="2-动态类型检查"><a href="#2-动态类型检查" class="headerlink" title="2. 动态类型检查"></a>2. 动态类型检查</h4><p>SWIG为虚继承提供动态类型检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG生成的虚继承安全代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Final</span> <span class="keyword">extends</span> <span class="title class_">VirtualDerived1</span> <span class="keyword">implements</span> <span class="title class_">VirtualDerived2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> swigCPtr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> swigCMemOwn;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Final</span><span class="params">(<span class="type">long</span> cPtr, <span class="type">boolean</span> cMemoryOwn)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(exampleJNI.Final_SWIGUpcast(cPtr), cMemoryOwn);</span><br><span class="line">        swigCPtr = cPtr;</span><br><span class="line">        swigCMemOwn = cMemoryOwn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 安全的虚基类访问</span></span><br><span class="line">    <span class="keyword">public</span> VirtualBase <span class="title function_">as_VirtualBase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">cPtr</span> <span class="operator">=</span> exampleJNI.Final_as_VirtualBase(swigCPtr, <span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (cPtr == <span class="number">0</span>) ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">VirtualBase</span>(cPtr, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        exampleJNI.Final_method(swigCPtr, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SWIG的JNI层实现"><a href="#SWIG的JNI层实现" class="headerlink" title="SWIG的JNI层实现"></a>SWIG的JNI层实现</h3><h4 id="1-自动生成的JNI代码"><a href="#1-自动生成的JNI代码" class="headerlink" title="1. 自动生成的JNI代码"></a>1. 自动生成的JNI代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG生成的JNI代码</span></span><br><span class="line"><span class="function">SWIGEXPORT jlong JNICALL <span class="title">Java_exampleJNI_new_1Derived</span><span class="params">(JNIEnv *jenv, jclass jcls)</span> </span>&#123;</span><br><span class="line">    jlong jresult = <span class="number">0</span>;</span><br><span class="line">    Derived *result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    (<span class="type">void</span>)jenv;</span><br><span class="line">    (<span class="type">void</span>)jcls;</span><br><span class="line">    result = (Derived *)<span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    *(Derived **)&amp;jresult = result;</span><br><span class="line">    <span class="keyword">return</span> jresult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SWIGEXPORT jlong JNICALL <span class="title">Java_exampleJNI_Derived_1SWIGUpcast</span><span class="params">(JNIEnv *jenv, jclass jcls, jlong jarg1)</span> </span>&#123;</span><br><span class="line">    jlong jresult = <span class="number">0</span>;</span><br><span class="line">    Derived *arg1 = (Derived *) <span class="number">0</span>;</span><br><span class="line">    Base1 *result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    (<span class="type">void</span>)jenv;</span><br><span class="line">    (<span class="type">void</span>)jcls;</span><br><span class="line">    arg1 = *(Derived **)&amp;jarg1;</span><br><span class="line">    result = (Base1 *)arg1;</span><br><span class="line">    *(Base1 **)&amp;jresult = result;</span><br><span class="line">    <span class="keyword">return</span> jresult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-类型安全的指针管理"><a href="#2-类型安全的指针管理" class="headerlink" title="2. 类型安全的指针管理"></a>2. 类型安全的指针管理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SWIG的智能指针管理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SWIG_PointerManager</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;<span class="type">void</span>*, <span class="type">int</span>&gt; reference_count;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">add_reference</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            reference_count[ptr]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">remove_reference</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr &amp;&amp; --reference_count[ptr] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            reference_count.<span class="built_in">erase</span>(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="SWIG的优势与局限性"><a href="#SWIG的优势与局限性" class="headerlink" title="SWIG的优势与局限性"></a>SWIG的优势与局限性</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>自动化程度高</strong>：自动处理复杂的类型转换和内存管理</li><li><strong>类型安全</strong>：使用类型安全的包装器而非<code>void*</code></li><li><strong>多语言支持</strong>：支持Java、Python、C#等多种语言</li><li><strong>虚继承支持</strong>：能够正确处理虚继承的复杂情况</li><li><strong>性能优化</strong>：生成的代码经过优化，性能较好</li></ol><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ol><li><strong>学习曲线</strong>：需要学习SWIG的语法和配置</li><li><strong>调试困难</strong>：生成的代码复杂，调试相对困难</li><li><strong>定制化限制</strong>：某些特殊需求可能需要复杂的配置</li><li><strong>编译依赖</strong>：需要额外的编译步骤和依赖</li></ol><h3 id="SWIG配置最佳实践"><a href="#SWIG配置最佳实践" class="headerlink" title="SWIG配置最佳实践"></a>SWIG配置最佳实践</h3><h4 id="1-接口文件配置"><a href="#1-接口文件配置" class="headerlink" title="1. 接口文件配置"></a>1. 接口文件配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%module mymodule</span><br><span class="line"></span><br><span class="line">// 启用异常处理</span><br><span class="line">%exception &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        $action</span><br><span class="line">    &#125; catch (const std::exception&amp; e) &#123;</span><br><span class="line">        SWIG_exception(SWIG_RuntimeError, e.what());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类型映射配置</span><br><span class="line">%typemap(javacode) Derived %&#123;</span><br><span class="line">    // 自定义Java代码</span><br><span class="line">    public void customMethod() &#123;</span><br><span class="line">        // 实现自定义方法</span><br><span class="line">    &#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%include &quot;mymodule.h&quot;</span><br></pre></td></tr></table></figure><h4 id="2-内存管理配置"><a href="#2-内存管理配置" class="headerlink" title="2. 内存管理配置"></a>2. 内存管理配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 智能指针支持</span><br><span class="line">%include &lt;std_shared_ptr.i&gt;</span><br><span class="line">%shared_ptr(Derived)</span><br><span class="line"></span><br><span class="line">// 自定义内存管理</span><br><span class="line">%typemap(javafinalize) Derived &quot;&quot;</span><br><span class="line">%typemap(javadestruct) Derived &#123;</span><br><span class="line">    if (swigCPtr != 0) &#123;</span><br><span class="line">        if (swigCMemOwn) &#123;</span><br><span class="line">            swigCMemOwn = false;</span><br><span class="line">            exampleJNI.delete_Derived(swigCPtr);</span><br><span class="line">        &#125;</span><br><span class="line">        swigCPtr = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>SWIG采用了<strong>综合策略</strong>来解决C++多重继承的接口适配问题：</p><ol><li><strong>类型安全的包装器</strong>：避免使用<code>void*</code>，使用类型安全的模板包装器</li><li><strong>接口分离原则</strong>：为每个基类生成独立的包装类</li><li><strong>工厂模式</strong>：使用工厂模式创建和管理接口实例</li><li><strong>动态类型检查</strong>：为虚继承提供运行时类型检查</li><li><strong>智能内存管理</strong>：自动处理对象生命周期和引用计数</li></ol><p>SWIG的解决方案相比手动实现具有以下优势：</p><ul><li><strong>自动化程度高</strong>：减少手动编写包装代码的工作量</li><li><strong>类型安全性好</strong>：自动处理复杂的类型转换</li><li><strong>维护成本低</strong>：接口变更时自动更新绑定代码</li><li><strong>多语言支持</strong>：一套配置支持多种目标语言</li></ul><p>对于复杂的C++多重继承项目，SWIG是一个值得考虑的解决方案，特别是当需要支持多种目标语言时。</p><h2 id="实际案例：基于void-的改进方案"><a href="#实际案例：基于void-的改进方案" class="headerlink" title="实际案例：基于void*的改进方案"></a>实际案例：基于void*的改进方案</h2><h3 id="问题代码分析"><a href="#问题代码分析" class="headerlink" title="问题代码分析"></a>问题代码分析</h3><p>以下是一个实际使用<code>void*</code>存储指针的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CODE_GEN_BASE_OBJ</span> : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> *self;  <span class="comment">// 问题：使用void*存储指针</span></span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最小改动解决方案"><a href="#最小改动解决方案" class="headerlink" title="最小改动解决方案"></a>最小改动解决方案</h3><h4 id="方案1：类型信息增强（推荐）"><a href="#方案1：类型信息增强（推荐）" class="headerlink" title="方案1：类型信息增强（推荐）"></a>方案1：类型信息增强（推荐）</h4><p>在保持<code>void* self</code>的基础上，添加类型信息来支持安全的类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CODE_GEN_BASE_OBJ</span> : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> *self;  <span class="comment">// 保持原有接口</span></span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增：类型信息存储</span></span><br><span class="line">    std::type_info* original_type;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增：安全的类型转换方法</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">safe_cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (original_type &amp;&amp; *original_type == <span class="built_in">typeid</span>(T)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">can_cast</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> original_type &amp;&amp; *original_type == <span class="built_in">typeid</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增：类型安全的接口获取</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">can_cast</span>&lt;T&gt;()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">safe_cast</span>&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试dynamic_cast（如果支持RTTI）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;T*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(self));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有方法保持不变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方案2：模板化存储（改动稍大但更安全）"><a href="#方案2：模板化存储（改动稍大但更安全）" class="headerlink" title="方案2：模板化存储（改动稍大但更安全）"></a>方案2：模板化存储（改动稍大但更安全）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP, <span class="keyword">typename</span> STORED_TYPE = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> CODE_GEN_BASE_OBJ : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP, STORED_TYPE&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用模板化存储替代void*</span></span><br><span class="line">    STORED_TYPE* self;</span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型安全的转换</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_base_of_v&lt;T, STORED_TYPE&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;T*&gt;(self);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容原有void*接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">get_raw_ptr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(self); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有方法保持不变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP, STORED_TYPE&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方案3：智能指针包装（最安全但改动最大）"><a href="#方案3：智能指针包装（最安全但改动最大）" class="headerlink" title="方案3：智能指针包装（最安全但改动最大）"></a>方案3：智能指针包装（最安全但改动最大）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CODE_GEN_BASE_OBJ</span> : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用智能指针管理</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">void</span>&gt; self_ptr;</span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容原有void*接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">get_self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> self_ptr.<span class="built_in">get</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型安全的访问</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    std::shared_ptr&lt;T&gt; <span class="title">get_typed_ptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">static_pointer_cast</span>&lt;T&gt;(self_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self_ptr.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有方法保持不变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="改进后的Cast方法实现"><a href="#改进后的Cast方法实现" class="headerlink" title="改进后的Cast方法实现"></a>改进后的Cast方法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="type">void</span> CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;::<span class="built_in">Cast</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (info.<span class="built_in">Length</span>() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(Djsi::Value::<span class="built_in">Undefined</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取目标类型名称</span></span><br><span class="line">    std::string target_type = info[<span class="number">0</span>].<span class="built_in">As</span>&lt;Djsi::String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用类型安全的转换</span></span><br><span class="line">    <span class="keyword">if</span> (target_type == <span class="string">&quot;Base1&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span>* base1 = <span class="built_in">get_interface</span>&lt;Base1&gt;()) &#123;</span><br><span class="line">            <span class="comment">// 创建新的包装对象</span></span><br><span class="line">            <span class="keyword">auto</span> wrapper = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;(info);</span><br><span class="line">            wrapper-&gt;self = base1;</span><br><span class="line">            wrapper-&gt;owned = <span class="literal">false</span>;  <span class="comment">// 不拥有对象</span></span><br><span class="line">            wrapper-&gt;info = <span class="built_in">get_type_info</span>&lt;Base1&gt;();</span><br><span class="line">            info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(wrapper-&gt;<span class="built_in">ObjSharedPtr</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target_type == <span class="string">&quot;Base2&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span>* base2 = <span class="built_in">get_interface</span>&lt;Base2&gt;()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> wrapper = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;(info);</span><br><span class="line">            wrapper-&gt;self = base2;</span><br><span class="line">            wrapper-&gt;owned = <span class="literal">false</span>;</span><br><span class="line">            wrapper-&gt;info = <span class="built_in">get_type_info</span>&lt;Base2&gt;();</span><br><span class="line">            info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(wrapper-&gt;<span class="built_in">ObjSharedPtr</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">    info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(Djsi::Value::<span class="built_in">Undefined</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数改进"><a href="#构造函数改进" class="headerlink" title="构造函数改进"></a>构造函数改进</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line">CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;::<span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="comment">// 存储原始类型信息</span></span><br><span class="line">    <span class="keyword">if</span> (self) &#123;</span><br><span class="line">        original_type = &amp;<span class="built_in">typeid</span>(*<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(self));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他初始化代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用改进后的类型安全接口</span></span><br><span class="line"><span class="keyword">auto</span> obj = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;MyWrapper&gt;&gt;(info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的类型转换</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span>* base1 = obj-&gt;<span class="built_in">get_interface</span>&lt;Base1&gt;()) &#123;</span><br><span class="line">    base1-&gt;<span class="built_in">method1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span>* base2 = obj-&gt;<span class="built_in">get_interface</span>&lt;Base2&gt;()) &#123;</span><br><span class="line">    base2-&gt;<span class="built_in">method2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查类型转换是否可能</span></span><br><span class="line"><span class="keyword">if</span> (obj-&gt;<span class="built_in">can_cast</span>&lt;Base1&gt;()) &#123;</span><br><span class="line">    <span class="comment">// 安全的转换</span></span><br><span class="line">    <span class="keyword">auto</span>* base1 = obj-&gt;<span class="built_in">safe_cast</span>&lt;Base1&gt;();</span><br><span class="line">    <span class="comment">// 使用base1...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h3><table><thead><tr><th>方案</th><th>改动程度</th><th>类型安全性</th><th>性能影响</th><th>兼容性</th></tr></thead><tbody><tr><td>方案1（类型信息增强）</td><td>最小</td><td>中等</td><td>低</td><td>高</td></tr><tr><td>方案2（模板化存储）</td><td>中等</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>方案3（智能指针包装）</td><td>最大</td><td>最高</td><td>中等</td><td>低</td></tr></tbody></table><h3 id="推荐方案"><a href="#推荐方案" class="headerlink" title="推荐方案"></a>推荐方案</h3><p><strong>推荐使用方案1（类型信息增强）</strong>，原因如下：</p><ol><li><strong>改动最小</strong>：保持原有的<code>void* self</code>接口</li><li><strong>向后兼容</strong>：现有代码无需大幅修改</li><li><strong>渐进式改进</strong>：可以逐步替换不安全的类型转换</li><li><strong>性能影响小</strong>：只增加类型信息存储的开销</li></ol><h3 id="实施步骤"><a href="#实施步骤" class="headerlink" title="实施步骤"></a>实施步骤</h3><ol><li><strong>第一步</strong>：添加类型信息存储和安全的转换方法</li><li><strong>第二步</strong>：逐步替换现有的不安全的<code>static_cast</code>调用</li><li><strong>第三步</strong>：在Cast方法中使用类型安全的转换</li><li><strong>第四步</strong>：添加运行时类型检查</li></ol><p>这种方案既解决了类型安全问题，又保持了代码的兼容性，是一个相对改动较小的改进方案。</p><h2 id="无RTTI环境下的方案重新分析"><a href="#无RTTI环境下的方案重新分析" class="headerlink" title="无RTTI环境下的方案重新分析"></a>无RTTI环境下的方案重新分析</h2><h3 id="RTTI限制的影响"><a href="#RTTI限制的影响" class="headerlink" title="RTTI限制的影响"></a>RTTI限制的影响</h3><p>在不开启RTTI（Runtime Type Information）的环境下，<code>std::type_info</code>、<code>typeid</code>、<code>dynamic_cast</code>等特性都无法使用，这会对我们的解决方案产生重要影响。</p><h4 id="方案1在无RTTI环境下的问题"><a href="#方案1在无RTTI环境下的问题" class="headerlink" title="方案1在无RTTI环境下的问题"></a>方案1在无RTTI环境下的问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案1在无RTTI环境下无法工作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CODE_GEN_BASE_OBJ</span> : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> *self;</span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题：在无RTTI环境下，这些都无法使用</span></span><br><span class="line">    std::type_info* original_type;  <span class="comment">// ❌ 无法获取</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">safe_cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ❌ typeid无法使用</span></span><br><span class="line">        <span class="keyword">if</span> (original_type &amp;&amp; *original_type == <span class="built_in">typeid</span>(T)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">can_cast</span>&lt;T&gt;()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">safe_cast</span>&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ❌ dynamic_cast无法使用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dynamic_cast</span>&lt;T*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(self));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="无RTTI环境下的改进方案"><a href="#无RTTI环境下的改进方案" class="headerlink" title="无RTTI环境下的改进方案"></a>无RTTI环境下的改进方案</h3><h4 id="方案1改进：手动类型标识"><a href="#方案1改进：手动类型标识" class="headerlink" title="方案1改进：手动类型标识"></a>方案1改进：手动类型标识</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CODE_GEN_BASE_OBJ</span> : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> *self;</span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用枚举替代type_info</span></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ObjectType</span> &#123;</span><br><span class="line">        UNKNOWN,</span><br><span class="line">        BASE1,</span><br><span class="line">        BASE2,</span><br><span class="line">        DERIVED,</span><br><span class="line">        <span class="comment">// 根据需要添加更多类型</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ObjectType object_type;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手动类型检查</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">can_cast</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T, Base1&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> object_type == ObjectType::BASE1 || </span><br><span class="line">                   object_type == ObjectType::DERIVED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, Base2&gt;) &#123;</span><br><span class="line">            <span class="keyword">return</span> object_type == ObjectType::BASE2 || </span><br><span class="line">                   object_type == ObjectType::DERIVED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, Derived&gt;) &#123;</span><br><span class="line">            <span class="keyword">return</span> object_type == ObjectType::DERIVED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 安全的类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">safe_cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">can_cast</span>&lt;T&gt;()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型安全的接口获取</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">get_interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">safe_cast</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置对象类型</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_object_type</span><span class="params">(ObjectType type)</span> </span>&#123;</span><br><span class="line">        object_type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有方法保持不变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方案2改进：编译时类型检查"><a href="#方案2改进：编译时类型检查" class="headerlink" title="方案2改进：编译时类型检查"></a>方案2改进：编译时类型检查</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP, <span class="keyword">typename</span> STORED_TYPE = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> CODE_GEN_BASE_OBJ : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP, STORED_TYPE&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    STORED_TYPE* self;</span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译时类型检查</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_base_of_v&lt;T, STORED_TYPE&gt;)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在无RTTI环境下，无法使用dynamic_cast</span></span><br><span class="line">            <span class="comment">// 返回nullptr或抛出异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译时类型检查</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">can_cast</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::is_base_of_v&lt;T, STORED_TYPE&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容原有void*接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">get_raw_ptr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(self); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有方法保持不变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP, STORED_TYPE&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方案3改进：类型擦除的智能指针"><a href="#方案3改进：类型擦除的智能指针" class="headerlink" title="方案3改进：类型擦除的智能指针"></a>方案3改进：类型擦除的智能指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CODE_GEN_BASE_OBJ</span> : <span class="keyword">public</span> Djsi::ObjectWrap&lt;OBJ_WRAP&gt;,</span><br><span class="line">                          <span class="keyword">public</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类型擦除的智能指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TypeErasedPtr</span> &#123;</span><br><span class="line">        <span class="type">void</span>* ptr;</span><br><span class="line">        <span class="built_in">void</span> (*deleter)(<span class="type">void</span>*);</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">        <span class="title">TypeErasedPtr</span><span class="params">(T* p)</span> : ptr(p), deleter([](void* p) &#123;</span> <span class="keyword">delete</span> <span class="built_in">static_cast</span>&lt;T*&gt;(p); &#125;) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        ~<span class="built_in">TypeErasedPtr</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr &amp;&amp; deleter) &#123;</span><br><span class="line">                <span class="built_in">deleter</span>(ptr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::shared_ptr&lt;TypeErasedPtr&gt; self_ptr;</span><br><span class="line">    <span class="type">bool</span> owned;</span><br><span class="line">    Code_gen_type_info *info;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CODE_GEN_BASE_OBJ</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容原有void*接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">get_self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> self_ptr ? self_ptr-&gt;ptr : <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类型安全的访问（需要手动指定类型）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T* <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self_ptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(self_ptr-&gt;ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有方法保持不变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AttachClientData</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Then</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Cast</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Owned</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    <span class="function">Djsi::Value <span class="title">Equal</span><span class="params">(<span class="type">const</span> Djsi::CallbackInfo &amp;info)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&gt; <span class="title">ObjSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::enable_shared_from_this&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;::<span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> * client_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Djsi::Value then_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetMembers</span><span class="params">(std::vector&lt;Djsi::PropertyDescriptor&lt;OBJ_WRAP&gt;&gt; &amp;symbolTable)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="无RTTI环境下的构造函数实现"><a href="#无RTTI环境下的构造函数实现" class="headerlink" title="无RTTI环境下的构造函数实现"></a>无RTTI环境下的构造函数实现</h3><h4 id="方案1的构造函数"><a href="#方案1的构造函数" class="headerlink" title="方案1的构造函数"></a>方案1的构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line">CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;::<span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="comment">// 需要手动设置对象类型</span></span><br><span class="line">    object_type = ObjectType::UNKNOWN;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据实际创建的对象类型设置</span></span><br><span class="line">    <span class="comment">// 这需要在创建对象时明确指定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; </span><br><span class="line"><span class="built_in">create_wrapper</span>(Base1* obj, <span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="keyword">auto</span> wrapper = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;(info);</span><br><span class="line">    wrapper-&gt;self = obj;</span><br><span class="line">    wrapper-&gt;<span class="built_in">set_object_type</span>(CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;::ObjectType::BASE1);</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line">std::shared_ptr&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt; </span><br><span class="line"><span class="built_in">create_wrapper</span>(Base2* obj, <span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="keyword">auto</span> wrapper = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;(info);</span><br><span class="line">    wrapper-&gt;self = obj;</span><br><span class="line">    wrapper-&gt;<span class="built_in">set_object_type</span>(CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;::ObjectType::BASE2);</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案2的构造函数"><a href="#方案2的构造函数" class="headerlink" title="方案2的构造函数"></a>方案2的构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP, <span class="keyword">typename</span> STORED_TYPE&gt;</span><br><span class="line">CODE_GEN_BASE_OBJ&lt;OBJ_WRAP, STORED_TYPE&gt;::<span class="built_in">CODE_GEN_BASE_OBJ</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="comment">// 模板参数已经确定了存储类型</span></span><br><span class="line">    <span class="comment">// 编译时就能确定类型关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">auto</span> wrapper1 = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;MyWrapper, Base1&gt;&gt;(info);</span><br><span class="line"><span class="keyword">auto</span> wrapper2 = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;MyWrapper, Base2&gt;&gt;(info);</span><br><span class="line"><span class="keyword">auto</span> wrapper3 = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;MyWrapper, Derived&gt;&gt;(info);</span><br></pre></td></tr></table></figure><h3 id="无RTTI环境下的Cast方法实现"><a href="#无RTTI环境下的Cast方法实现" class="headerlink" title="无RTTI环境下的Cast方法实现"></a>无RTTI环境下的Cast方法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OBJ_WRAP&gt;</span><br><span class="line"><span class="type">void</span> CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;::<span class="built_in">Cast</span>(<span class="type">const</span> Djsi::CallbackInfo &amp;info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (info.<span class="built_in">Length</span>() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(Djsi::Value::<span class="built_in">Undefined</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::string target_type = info[<span class="number">0</span>].<span class="built_in">As</span>&lt;Djsi::String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方案1：使用手动类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (target_type == <span class="string">&quot;Base1&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">can_cast</span>&lt;Base1&gt;()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>* base1 = <span class="built_in">safe_cast</span>&lt;Base1&gt;();</span><br><span class="line">            <span class="keyword">auto</span> wrapper = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;(info);</span><br><span class="line">            wrapper-&gt;self = base1;</span><br><span class="line">            wrapper-&gt;<span class="built_in">set_object_type</span>(ObjectType::BASE1);</span><br><span class="line">            wrapper-&gt;owned = <span class="literal">false</span>;</span><br><span class="line">            info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(wrapper-&gt;<span class="built_in">ObjSharedPtr</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target_type == <span class="string">&quot;Base2&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">can_cast</span>&lt;Base2&gt;()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>* base2 = <span class="built_in">safe_cast</span>&lt;Base2&gt;();</span><br><span class="line">            <span class="keyword">auto</span> wrapper = std::make_shared&lt;CODE_GEN_BASE_OBJ&lt;OBJ_WRAP&gt;&gt;(info);</span><br><span class="line">            wrapper-&gt;self = base2;</span><br><span class="line">            wrapper-&gt;<span class="built_in">set_object_type</span>(ObjectType::BASE2);</span><br><span class="line">            wrapper-&gt;owned = <span class="literal">false</span>;</span><br><span class="line">            info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(wrapper-&gt;<span class="built_in">ObjSharedPtr</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    info.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(Djsi::Value::<span class="built_in">Undefined</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无RTTI环境下的方案对比"><a href="#无RTTI环境下的方案对比" class="headerlink" title="无RTTI环境下的方案对比"></a>无RTTI环境下的方案对比</h3><table><thead><tr><th>方案</th><th>RTTI依赖</th><th>类型安全性</th><th>实现复杂度</th><th>性能</th><th>兼容性</th></tr></thead><tbody><tr><td>方案1（手动类型标识）</td><td>无</td><td>中等</td><td>中等</td><td>高</td><td>高</td></tr><tr><td>方案2（编译时检查）</td><td>无</td><td>高</td><td>低</td><td>最高</td><td>中等</td></tr><tr><td>方案3（类型擦除）</td><td>无</td><td>中等</td><td>高</td><td>中等</td><td>中等</td></tr></tbody></table><h3 id="无RTTI环境下的推荐方案"><a href="#无RTTI环境下的推荐方案" class="headerlink" title="无RTTI环境下的推荐方案"></a>无RTTI环境下的推荐方案</h3><p><strong>在无RTTI环境下，推荐使用方案2（编译时类型检查）</strong>，原因如下：</p><ol><li><strong>无RTTI依赖</strong>：完全基于编译时类型检查</li><li><strong>类型安全性高</strong>：编译时就能发现类型错误</li><li><strong>性能最好</strong>：无运行时开销</li><li><strong>实现简单</strong>：利用C++模板特性</li></ol><h4 id="方案2的使用示例"><a href="#方案2的使用示例" class="headerlink" title="方案2的使用示例"></a>方案2的使用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为不同类型创建专门的包装器</span></span><br><span class="line"><span class="keyword">using</span> Base1Wrapper = CODE_GEN_BASE_OBJ&lt;MyWrapper, Base1&gt;;</span><br><span class="line"><span class="keyword">using</span> Base2Wrapper = CODE_GEN_BASE_OBJ&lt;MyWrapper, Base2&gt;;</span><br><span class="line"><span class="keyword">using</span> DerivedWrapper = CODE_GEN_BASE_OBJ&lt;MyWrapper, Derived&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">auto</span> base1_obj = std::<span class="built_in">make_shared</span>&lt;Base1Wrapper&gt;(info);</span><br><span class="line"><span class="keyword">auto</span> base2_obj = std::<span class="built_in">make_shared</span>&lt;Base2Wrapper&gt;(info);</span><br><span class="line"><span class="keyword">auto</span> derived_obj = std::<span class="built_in">make_shared</span>&lt;DerivedWrapper&gt;(info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时类型检查</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span>* base1 = base1_obj-&gt;<span class="built_in">cast</span>&lt;Base1&gt;()) &#123;</span><br><span class="line">    base1-&gt;<span class="built_in">method1</span>();  <span class="comment">// 编译时确保类型正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>在无RTTI环境下：</p><ol><li><strong>方案1</strong>需要手动管理类型信息，实现复杂度增加</li><li><strong>方案2</strong>成为最佳选择，利用编译时类型检查</li><li><strong>方案3</strong>仍然可行，但实现复杂度较高</li></ol><p><strong>最终推荐</strong>：如果项目不开启RTTI，建议使用<strong>方案2（编译时类型检查）</strong>，它提供了最好的类型安全性和性能。</p><hr><p><em>本文分析了C++多重继承在跨语言接口适配中的技术难点，希望对相关开发者有所帮助。</em> </p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Java </tag>
            
            <tag> TypeScript </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 接口适配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++原子操作函数详解：多线程编程的利器</title>
      <link href="/2025/06/25/C++%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/06/25/C++%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在多线程编程中，数据竞争和同步问题一直是开发者面临的挑战。C++11引入的原子操作（atomic operations）为解决这些问题提供了强有力的工具。本文将详细介绍几个重要的原子操作函数：<code>atomic_store</code>、<code>atomic_compare_exchange_strong_explicit</code>、<code>atomic_load_explicit</code> 和 <code>atomic_fetch_sub_explicit</code>，帮助你在多线程编程中正确使用这些函数。</p><span id="more"></span><!--more--><h2 id="什么是原子操作"><a href="#什么是原子操作" class="headerlink" title="什么是原子操作"></a>什么是原子操作</h2><p>原子操作是不可分割的操作，要么完全执行，要么完全不执行，不会被其他线程中断。在多线程环境中，原子操作保证了数据的一致性，避免了竞态条件。</p><h2 id="内存序（Memory-Order）：为什么需要它"><a href="#内存序（Memory-Order）：为什么需要它" class="headerlink" title="内存序（Memory Order）：为什么需要它"></a>内存序（Memory Order）：为什么需要它</h2><h3 id="背景：CPU和编译器的优化带来的问题"><a href="#背景：CPU和编译器的优化带来的问题" class="headerlink" title="背景：CPU和编译器的优化带来的问题"></a>背景：CPU和编译器的优化带来的问题</h3><p>在现代计算机系统中，为了提高性能，CPU和编译器会进行各种优化，这些优化可能会改变程序的执行顺序：</p><h4 id="1-编译器重排序"><a href="#1-编译器重排序" class="headerlink" title="1. 编译器重排序"></a>1. 编译器重排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = a + b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器可能重排序为：</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> c = a + b;  <span class="comment">// 因为a和b的赋值顺序不影响结果</span></span><br></pre></td></tr></table></figure><h4 id="2-CPU乱序执行"><a href="#2-CPU乱序执行" class="headerlink" title="2. CPU乱序执行"></a>2. CPU乱序执行</h4><p>现代CPU为了提高吞吐量，会：</p><ul><li><strong>乱序执行</strong>：CPU可能不按程序顺序执行指令</li><li><strong>写缓冲</strong>：写操作可能先进入缓冲区，稍后才写入内存</li><li><strong>缓存一致性延迟</strong>：多核CPU的缓存同步不是瞬时的</li></ul><h4 id="3-多线程环境下的问题"><a href="#3-多线程环境下的问题" class="headerlink" title="3. 多线程环境下的问题"></a>3. 多线程环境下的问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程1</span></span><br><span class="line">data = <span class="number">42</span>;        <span class="comment">// 写入数据</span></span><br><span class="line">ready = <span class="literal">true</span>;     <span class="comment">// 设置标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">if</span> (ready) &#123;      <span class="comment">// 检查标志</span></span><br><span class="line">    <span class="built_in">use</span>(data);    <span class="comment">// 使用数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于重排序，可能发生：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际执行顺序可能是：</span></span><br><span class="line"><span class="comment">// 线程1: ready = true; data = 42;  (重排序!)</span></span><br><span class="line"><span class="comment">// 线程2: if (ready) &#123; use(data); &#125; // data可能还是旧值!</span></span><br></pre></td></tr></table></figure><h3 id="什么是内存序"><a href="#什么是内存序" class="headerlink" title="什么是内存序"></a>什么是内存序</h3><p><strong>内存序（Memory Ordering）</strong>是一套规则，用来控制多线程程序中内存操作的可见性顺序。它告诉编译器和CPU：</p><ol><li><strong>哪些重排序是允许的</strong></li><li><strong>哪些重排序是禁止的</strong></li><li><strong>何时需要确保内存操作的可见性</strong></li></ol><h3 id="内存模型的发展历史"><a href="#内存模型的发展历史" class="headerlink" title="内存模型的发展历史"></a>内存模型的发展历史</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98/03时代：没有标准的多线程支持</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">int</span> shared_data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    shared_data++;  <span class="comment">// 依赖平台特定的内存语义</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11引入内存模型</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; shared_data&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_data.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_seq_cst);  <span class="comment">// 明确的内存语义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-11内存序的六种类型"><a href="#C-11内存序的六种类型" class="headerlink" title="C++11内存序的六种类型"></a>C++11内存序的六种类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,    <span class="comment">// 宽松序：只保证原子性，允许重排序</span></span><br><span class="line">    memory_order_consume,    <span class="comment">// 消费序：较少使用，类似acquire但更弱</span></span><br><span class="line">    memory_order_acquire,    <span class="comment">// 获取序：读操作的同步点，防止后续操作重排到前面</span></span><br><span class="line">    memory_order_release,    <span class="comment">// 释放序：写操作的同步点，防止前面操作重排到后面</span></span><br><span class="line">    memory_order_acq_rel,    <span class="comment">// 获取-释放序：同时具有acquire和release语义</span></span><br><span class="line">    memory_order_seq_cst     <span class="comment">// 顺序一致性：最强的内存序，全局统一顺序</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="为什么需要不同强度的内存序"><a href="#为什么需要不同强度的内存序" class="headerlink" title="为什么需要不同强度的内存序"></a>为什么需要不同强度的内存序</h3><h4 id="1-性能考虑"><a href="#1-性能考虑" class="headerlink" title="1. 性能考虑"></a>1. 性能考虑</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">long</span> <span class="type">long</span>&gt; counter&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试不同内存序的性能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">benchmark_memory_orders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iterations = <span class="number">1000000</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_threads = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// relaxed内存序 - 最快</span></span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>([&amp;]() &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; iterations; ++j) &#123;</span><br><span class="line">                counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) t.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> relaxed_time = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line">    </span><br><span class="line">    counter.<span class="built_in">store</span>(<span class="number">0</span>);</span><br><span class="line">    threads.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// seq_cst内存序 - 较慢但提供更强保证</span></span><br><span class="line">    start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>([&amp;]() &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; iterations; ++j) &#123;</span><br><span class="line">                counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_seq_cst);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) t.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> seq_cst_time = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Relaxed: &quot;</span> &lt;&lt; relaxed_time.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; μs&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Seq_cst: &quot;</span> &lt;&lt; seq_cst_time.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; μs&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;性能差异: &quot;</span> &lt;&lt; (<span class="type">double</span>)seq_cst_time.<span class="built_in">count</span>() / relaxed_time.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-不同场景需要不同强度的同步"><a href="#2-不同场景需要不同强度的同步" class="headerlink" title="2. 不同场景需要不同强度的同步"></a>2. 不同场景需要不同强度的同步</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景1：简单计数器，只需要原子性</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; hit_counter&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只需要保证原子性，允许重排序</span></span><br><span class="line">    hit_counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景2：生产者-消费者，需要同步</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; data_ready&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; data&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);    <span class="comment">// 1. 写入数据</span></span><br><span class="line">    data_ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 2. 发布信号（不能重排到1之前）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取信号（后续读取不能重排到这之前）</span></span><br><span class="line">    <span class="keyword">while</span> (!data_ready.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 现在可以安全读取data</span></span><br><span class="line">    <span class="type">int</span> value = data.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;读取到: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景3：全局状态需要强一致性</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; global_state&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_state_change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要全局统一的观察顺序</span></span><br><span class="line">    global_state.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存序的实际硬件映射"><a href="#内存序的实际硬件映射" class="headerlink" title="内存序的实际硬件映射"></a>内存序的实际硬件映射</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在x86-64架构上的大致映射</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X86MemoryOrdering</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// relaxed: 普通的mov指令</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">relaxed_store</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;&amp; var, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// mov %eax, (%rdi)  - 普通存储</span></span><br><span class="line">        var.<span class="built_in">store</span>(value, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// release: 可能需要sfence指令</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release_store</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;&amp; var, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sfence; mov %eax, (%rdi)  - 存储屏障</span></span><br><span class="line">        var.<span class="built_in">store</span>(value, std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// seq_cst: 需要mfence指令</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">seq_cst_store</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;&amp; var, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// mfence; mov %eax, (%rdi); mfence  - 完全内存屏障</span></span><br><span class="line">        var.<span class="built_in">store</span>(value, std::memory_order_seq_cst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在ARM架构上的映射</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ARMMemoryOrdering</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// relaxed: 普通的str指令</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">relaxed_store</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;&amp; var, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// str w1, [x0]  - 普通存储</span></span><br><span class="line">        var.<span class="built_in">store</span>(value, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// release: 需要dmb ish指令</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release_store</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;&amp; var, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dmb ish; str w1, [x0]  - 数据内存屏障</span></span><br><span class="line">        var.<span class="built_in">store</span>(value, std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// seq_cst: 需要更强的屏障</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">seq_cst_store</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;&amp; var, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dmb ish; str w1, [x0]; dmb ish  - 完全屏障</span></span><br><span class="line">        var.<span class="built_in">store</span>(value, std::memory_order_seq_cst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="没有内存序会发生什么"><a href="#没有内存序会发生什么" class="headerlink" title="没有内存序会发生什么"></a>没有内存序会发生什么</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：没有适当的内存序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; flag&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> normal_variable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    normal_variable = <span class="number">42</span>;  <span class="comment">// 普通写入</span></span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 原子写入，但使用relaxed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可能的问题：由于relaxed语义，这两个操作可能被重排序</span></span><br><span class="line">    <span class="keyword">while</span> (!flag.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里读取normal_variable可能得到旧值！</span></span><br><span class="line">    <span class="comment">// 因为relaxed不提供同步保证</span></span><br><span class="line">    std::cout &lt;&lt; normal_variable &lt;&lt; std::endl;  <span class="comment">// 可能输出0而不是42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例：使用适当的内存序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">correct_writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    normal_variable = <span class="number">42</span>;</span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// release确保前面的写入先完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">correct_reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!flag.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// acquire确保后续读取不会重排</span></span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; normal_variable &lt;&lt; std::endl;  <span class="comment">// 保证输出42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结：为什么内存序至关重要"><a href="#总结：为什么内存序至关重要" class="headerlink" title="总结：为什么内存序至关重要"></a>总结：为什么内存序至关重要</h3><ol><li><strong>现代硬件的现实</strong>：CPU和编译器的优化使得简单的代码变得复杂</li><li><strong>性能与正确性的平衡</strong>：不同强度的内存序提供了性能优化的机会</li><li><strong>可移植性</strong>：统一的内存模型确保代码在不同架构上的行为一致</li><li><strong>可预测性</strong>：明确的内存序语义让多线程程序的行为变得可预测</li></ol><p>通过理解内存序，我们可以：</p><ul><li>编写正确的多线程代码</li><li>在性能和正确性之间找到平衡</li><li>避免微妙的并发bug</li><li>充分利用现代硬件的性能</li></ul><h2 id="1-atomic-store-和-atomic-store-explicit"><a href="#1-atomic-store-和-atomic-store-explicit" class="headerlink" title="1. atomic_store 和 atomic_store_explicit"></a>1. atomic_store 和 atomic_store_explicit</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>atomic_store</code> 用于原子地存储一个值到原子变量中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_store_example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 简单的原子存储，使用默认内存序（seq_cst）</span></span><br><span class="line">    std::<span class="built_in">atomic_store</span>(&amp;counter, <span class="number">42</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式指定内存序的原子存储</span></span><br><span class="line">    std::<span class="built_in">atomic_store_explicit</span>(&amp;counter, <span class="number">100</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存序的影响"><a href="#内存序的影响" class="headerlink" title="内存序的影响"></a>内存序的影响</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; ready&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; data&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// 使用release语义，确保data的写入在ready之前完成</span></span><br><span class="line">    ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用acquire语义，确保在读取data之前ready已经为true</span></span><br><span class="line">    <span class="keyword">while</span> (!ready.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时可以安全地读取data</span></span><br><span class="line">    <span class="type">int</span> value = data.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;读取到的值: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-atomic-load-和-atomic-load-explicit"><a href="#2-atomic-load-和-atomic-load-explicit" class="headerlink" title="2. atomic_load 和 atomic_load_explicit"></a>2. atomic_load 和 atomic_load_explicit</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>atomic_load</code> 用于原子地读取原子变量的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; shared_value&#123;<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_load_example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 简单的原子加载</span></span><br><span class="line">    <span class="type">int</span> value1 = std::<span class="built_in">atomic_load</span>(&amp;shared_value);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式指定内存序的原子加载</span></span><br><span class="line">    <span class="type">int</span> value2 = std::<span class="built_in">atomic_load_explicit</span>(&amp;shared_value, std::memory_order_acquire);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value1: &quot;</span> &lt;&lt; value1 &lt;&lt; <span class="string">&quot;, Value2: &quot;</span> &lt;&lt; value2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际应用：状态检查"><a href="#实际应用：状态检查" class="headerlink" title="实际应用：状态检查"></a>实际应用：状态检查</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeCounter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; count_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop_flag_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop_flag_.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">            count_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop_flag_.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-atomic-compare-exchange-strong-explicit-和-atomic-compare-exchange-weak-explicit"><a href="#3-atomic-compare-exchange-strong-explicit-和-atomic-compare-exchange-weak-explicit" class="headerlink" title="3. atomic_compare_exchange_strong_explicit 和 atomic_compare_exchange_weak_explicit"></a>3. atomic_compare_exchange_strong_explicit 和 atomic_compare_exchange_weak_explicit</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>这是一个比较并交换操作，它原子地比较变量的值与期望值，如果相等则交换为新值。C++提供了两个版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strong版本：原子地比较并交换，如果比较失败则不交换</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">atomic_compare_exchange_strong_explicit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    atomic&lt;T&gt;* obj,</span></span></span><br><span class="line"><span class="params"><span class="function">    T* expected,</span></span></span><br><span class="line"><span class="params"><span class="function">    T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">    memory_order success,</span></span></span><br><span class="line"><span class="params"><span class="function">    memory_order failure</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// weak版本：原子地比较并交换，可能出现伪失败</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">atomic_compare_exchange_weak_explicit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    atomic&lt;T&gt;* obj,</span></span></span><br><span class="line"><span class="params"><span class="function">    T* expected,</span></span></span><br><span class="line"><span class="params"><span class="function">    T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">    memory_order success,</span></span></span><br><span class="line"><span class="params"><span class="function">    memory_order failure</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="函数行为详解"><a href="#函数行为详解" class="headerlink" title="函数行为详解"></a>函数行为详解</h3><p>两个函数都执行相同的基本操作：</p><ol><li><strong>原子地读取</strong> <code>obj</code> 的当前值</li><li><strong>比较</strong>当前值与 <code>*expected</code> 是否相等</li><li>如果<strong>相等</strong>：将 <code>desired</code> 写入 <code>obj</code>，返回 <code>true</code></li><li>如果<strong>不相等</strong>：将当前值写入 <code>*expected</code>，返回 <code>false</code></li></ol><h3 id="strong-vs-weak-的关键区别"><a href="#strong-vs-weak-的关键区别" class="headerlink" title="strong vs weak 的关键区别"></a>strong vs weak 的关键区别</h3><ul><li><p><strong>strong版本</strong>：</p><ul><li>如果比较相等，<strong>保证</strong>交换操作成功</li><li>只有在实际值与期望值不同时才返回 <code>false</code></li><li>适合单次尝试的场景</li></ul></li><li><p><strong>weak版本</strong>：</p><ul><li>如果比较相等，交换<strong>可能</strong>失败（伪失败，spurious failure）</li><li>即使实际值与期望值相同，也可能返回 <code>false</code></li><li>伪失败通常由硬件原因造成（如Load-Link/Store-Conditional指令被中断）</li><li>适合循环重试的场景，在某些架构上性能更好</li></ul></li></ul><h3 id="strong版本的基本用法"><a href="#strong版本的基本用法" class="headerlink" title="strong版本的基本用法"></a>strong版本的基本用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; value&#123;<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compare_exchange_strong_example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> desired = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果value等于expected(10)，则将其设置为desired(20)</span></span><br><span class="line">    <span class="type">bool</span> success = std::<span class="built_in">atomic_compare_exchange_strong_explicit</span>(</span><br><span class="line">        &amp;value,</span><br><span class="line">        &amp;expected,  <span class="comment">// 注意：这是指针！</span></span><br><span class="line">        desired,</span><br><span class="line">        std::memory_order_acq_rel,  <span class="comment">// 成功时的内存序</span></span><br><span class="line">        std::memory_order_acquire   <span class="comment">// 失败时的内存序</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;交换成功，新值: &quot;</span> &lt;&lt; value.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;交换失败，期望值: &quot;</span> &lt;&lt; expected </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, 实际值: &quot;</span> &lt;&lt; value.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weak版本的基本用法"><a href="#weak版本的基本用法" class="headerlink" title="weak版本的基本用法"></a>weak版本的基本用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compare_exchange_weak_example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> desired = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// weak版本通常在循环中使用，因为可能出现伪失败</span></span><br><span class="line">    <span class="keyword">while</span> (!std::<span class="built_in">atomic_compare_exchange_weak_explicit</span>(</span><br><span class="line">        &amp;counter,</span><br><span class="line">        &amp;expected,</span><br><span class="line">        desired,</span><br><span class="line">        std::memory_order_acq_rel,</span><br><span class="line">        std::memory_order_acquire)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 失败的原因可能是：</span></span><br><span class="line">        <span class="comment">// 1. 实际值与期望值不同（真失败）- expected已被更新为实际值</span></span><br><span class="line">        <span class="comment">// 2. 值相等但发生伪失败（spurious failure）- expected保持不变</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可以根据实际值决定是否继续尝试</span></span><br><span class="line">        <span class="keyword">if</span> (expected &gt;= desired) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 已经达到或超过目标值，退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续重试，expected现在包含最新的实际值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最终值: &quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="何时使用weak版本"><a href="#何时使用weak版本" class="headerlink" title="何时使用weak版本"></a>何时使用weak版本</h3><p>weak版本主要用于循环中，因为它在某些硬件架构上性能更好：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; shared_counter&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用weak版本实现原子增量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_increment_weak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> current = shared_counter.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用weak版本在循环中重试</span></span><br><span class="line">    <span class="keyword">while</span> (!shared_counter.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">        current,</span><br><span class="line">        current + <span class="number">1</span>,</span><br><span class="line">        std::memory_order_acq_rel,</span><br><span class="line">        std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="comment">// 失败后current包含最新的实际值</span></span><br><span class="line">        <span class="comment">// 可能是真失败（值被其他线程改变）或伪失败</span></span><br><span class="line">        <span class="comment">// 无论哪种情况，都继续重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用strong版本实现原子增量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_increment_strong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> current = shared_counter.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// strong版本也需要循环，但只有真失败时才重试</span></span><br><span class="line">    <span class="keyword">while</span> (!shared_counter.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">        current,</span><br><span class="line">        current + <span class="number">1</span>,</span><br><span class="line">        std::memory_order_acq_rel,</span><br><span class="line">        std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="comment">// 失败意味着值确实被其他线程改变了</span></span><br><span class="line">        <span class="comment">// current已经被更新为最新值，继续尝试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="详细行为分析：value与expected的比较结果"><a href="#详细行为分析：value与expected的比较结果" class="headerlink" title="详细行为分析：value与expected的比较结果"></a>详细行为分析：value与expected的比较结果</h3><p>让我们用具体的例子来详细分析两个函数在不同情况下的行为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detailed_behavior_analysis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; value&#123;<span class="number">10</span>&#125;;  <span class="comment">// 原子变量初始值为10</span></span><br><span class="line">    <span class="type">int</span> expected;</span><br><span class="line">    <span class="type">int</span> desired = <span class="number">20</span>;</span><br><span class="line">    <span class="type">bool</span> result;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=== 情况分析 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始状态: value = &quot;</span> &lt;&lt; value.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 情况1：value == expected (10) ==========</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n--- 情况1: value(10) == expected(10) ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.1 使用 strong 版本</span></span><br><span class="line">    value.<span class="built_in">store</span>(<span class="number">10</span>);  <span class="comment">// 重置为10</span></span><br><span class="line">    expected = <span class="number">10</span>;</span><br><span class="line">    result = value.<span class="built_in">compare_exchange_strong</span>(expected, desired);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;strong版本结果:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  返回值: &quot;</span> &lt;&lt; (result ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  value变为: &quot;</span> &lt;&lt; value.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  expected变为: &quot;</span> &lt;&lt; expected &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  结论: 比较相等，交换成功，保证返回true&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.2 使用 weak 版本</span></span><br><span class="line">    value.<span class="built_in">store</span>(<span class="number">10</span>);  <span class="comment">// 重置为10</span></span><br><span class="line">    expected = <span class="number">10</span>;</span><br><span class="line">    result = value.<span class="built_in">compare_exchange_weak</span>(expected, desired);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nweak版本结果:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  返回值: &quot;</span> &lt;&lt; (result ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  value变为: &quot;</span> &lt;&lt; value.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  expected变为: &quot;</span> &lt;&lt; expected &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;  结论: 比较相等，交换成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (expected == <span class="number">10</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  结论: 比较相等但发生伪失败，value未改变，expected未改变&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ========== 情况2：value != expected ==========</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n--- 情况2: value(15) != expected(10) ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.1 使用 strong 版本</span></span><br><span class="line">    value.<span class="built_in">store</span>(<span class="number">15</span>);  <span class="comment">// 设置为与expected不同的值</span></span><br><span class="line">    expected = <span class="number">10</span>;</span><br><span class="line">    result = value.<span class="built_in">compare_exchange_strong</span>(expected, desired);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;strong版本结果:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  返回值: &quot;</span> &lt;&lt; (result ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  value保持: &quot;</span> &lt;&lt; value.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  expected变为: &quot;</span> &lt;&lt; expected &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  结论: 比较不相等，不交换，expected被更新为实际值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.2 使用 weak 版本</span></span><br><span class="line">    value.<span class="built_in">store</span>(<span class="number">15</span>);  <span class="comment">// 设置为与expected不同的值</span></span><br><span class="line">    expected = <span class="number">10</span>;</span><br><span class="line">    result = value.<span class="built_in">compare_exchange_weak</span>(expected, desired);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nweak版本结果:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  返回值: &quot;</span> &lt;&lt; (result ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  value保持: &quot;</span> &lt;&lt; value.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  expected变为: &quot;</span> &lt;&lt; expected &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  结论: 比较不相等，不交换，expected被更新为实际值（与strong相同）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整的行为对比表"><a href="#完整的行为对比表" class="headerlink" title="完整的行为对比表"></a>完整的行为对比表</h3><table><thead><tr><th>场景</th><th>函数版本</th><th>value值</th><th>expected值(调用前)</th><th>返回值</th><th>value值(调用后)</th><th>expected值(调用后)</th><th>说明</th></tr></thead><tbody><tr><td><strong>相等情况</strong></td><td>strong</td><td>10</td><td>10</td><td><strong>true</strong></td><td><strong>20</strong></td><td>10</td><td>保证交换成功</td></tr><tr><td><strong>相等情况</strong></td><td>weak</td><td>10</td><td>10</td><td><strong>true或false</strong></td><td><strong>20或10</strong></td><td>10</td><td>可能成功或伪失败</td></tr><tr><td><strong>不等情况</strong></td><td>strong</td><td>15</td><td>10</td><td><strong>false</strong></td><td>15</td><td><strong>15</strong></td><td>不交换，更新expected</td></tr><tr><td><strong>不等情况</strong></td><td>weak</td><td>15</td><td>10</td><td><strong>false</strong></td><td>15</td><td><strong>15</strong></td><td>不交换，更新expected</td></tr></tbody></table><h3 id="伪失败的检测方法"><a href="#伪失败的检测方法" class="headerlink" title="伪失败的检测方法"></a>伪失败的检测方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">detect_spurious_failure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; value&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> desired = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录调用前的状态</span></span><br><span class="line">    <span class="type">int</span> value_before = value.<span class="built_in">load</span>();</span><br><span class="line">    <span class="type">int</span> expected_before = expected;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> result = value.<span class="built_in">compare_exchange_weak</span>(expected, desired);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="comment">// 失败了，判断是真失败还是伪失败</span></span><br><span class="line">        <span class="keyword">if</span> (expected == expected_before) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;发生伪失败！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  value调用前: &quot;</span> &lt;&lt; value_before &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  expected调用前: &quot;</span> &lt;&lt; expected_before &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  value调用后: &quot;</span> &lt;&lt; value.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  expected调用后: &quot;</span> &lt;&lt; expected &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  结论: 值确实相等，但交换失败，expected未被修改&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;真失败：值不匹配&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  期望值: &quot;</span> &lt;&lt; expected_before &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  实际值: &quot;</span> &lt;&lt; expected &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;交换成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际应用中的处理模式"><a href="#实际应用中的处理模式" class="headerlink" title="实际应用中的处理模式"></a>实际应用中的处理模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式1：使用strong版本进行单次尝试</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_once_with_strong</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;&amp; counter, <span class="type">int</span> expected_val, <span class="type">int</span> new_val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> expected = expected_val;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// strong版本：如果返回false，一定是真失败</span></span><br><span class="line">    <span class="keyword">if</span> (counter.<span class="built_in">compare_exchange_strong</span>(expected, new_val)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功将 &quot;</span> &lt;&lt; expected_val &lt;&lt; <span class="string">&quot; 改为 &quot;</span> &lt;&lt; new_val &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;失败：期望 &quot;</span> &lt;&lt; expected_val &lt;&lt; <span class="string">&quot;，实际是 &quot;</span> &lt;&lt; expected &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模式2：使用weak版本进行循环重试</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">retry_with_weak</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;&amp; counter, <span class="type">int</span> increment)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> current = counter.<span class="built_in">load</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// weak版本：在循环中重试，不区分真失败和伪失败</span></span><br><span class="line">    <span class="keyword">while</span> (!counter.<span class="built_in">compare_exchange_weak</span>(current, current + increment)) &#123;</span><br><span class="line">        <span class="comment">// current已经被更新为最新值（如果是真失败）</span></span><br><span class="line">        <span class="comment">// 如果是伪失败，current保持不变，但会继续重试</span></span><br><span class="line">        <span class="comment">// 无论哪种情况，都继续循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功增加 &quot;</span> &lt;&lt; increment &lt;&lt; <span class="string">&quot;，最终值: &quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能对比和选择建议"><a href="#性能对比和选择建议" class="headerlink" title="性能对比和选择建议"></a>性能对比和选择建议</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PerformanceTest</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::atomic&lt;<span class="type">long</span> <span class="type">long</span>&gt; counter_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用weak版本的测试</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_weak</span><span class="params">(<span class="type">int</span> iterations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; ++i) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> current = counter_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">            <span class="keyword">while</span> (!counter_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">                current,</span><br><span class="line">                current + <span class="number">1</span>,</span><br><span class="line">                std::memory_order_relaxed)) &#123;</span><br><span class="line">                <span class="comment">// 重试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用strong版本的测试</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_strong</span><span class="params">(<span class="type">int</span> iterations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; ++i) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> current = counter_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">            <span class="keyword">while</span> (!counter_.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                current,</span><br><span class="line">                current + <span class="number">1</span>,</span><br><span class="line">                std::memory_order_relaxed)) &#123;</span><br><span class="line">                <span class="comment">// 重试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter_.<span class="built_in">store</span>(<span class="number">0</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get_value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performance_comparison</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PerformanceTest test;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iterations = <span class="number">100000</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_threads = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试weak版本</span></span><br><span class="line">    test.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>([&amp;test, iterations]() &#123;</span><br><span class="line">            test.<span class="built_in">test_weak</span>(iterations);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> weak_duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Weak版本耗时: &quot;</span> &lt;&lt; weak_duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; 微秒&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Weak版本最终值: &quot;</span> &lt;&lt; test.<span class="built_in">get_value</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试strong版本</span></span><br><span class="line">    test.<span class="built_in">reset</span>();</span><br><span class="line">    threads.<span class="built_in">clear</span>();</span><br><span class="line">    start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>([&amp;test, iterations]() &#123;</span><br><span class="line">            test.<span class="built_in">test_strong</span>(iterations);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> strong_duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strong版本耗时: &quot;</span> &lt;&lt; strong_duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; 微秒&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Strong版本最终值: &quot;</span> &lt;&lt; test.<span class="built_in">get_value</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际应用：无锁栈的两种实现"><a href="#实际应用：无锁栈的两种实现" class="headerlink" title="实际应用：无锁栈的两种实现"></a>实际应用：无锁栈的两种实现</h3><h4 id="使用strong版本的无锁栈"><a href="#使用strong版本的无锁栈" class="headerlink" title="使用strong版本的无锁栈"></a>使用strong版本的无锁栈</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockFreeStackStrong</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        T data;</span><br><span class="line">        std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Node</span>(T <span class="type">const</span>&amp; data_) : <span class="built_in">data</span>(data_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::atomic&lt;std::shared_ptr&lt;Node&gt;&gt; head_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> new_node = std::<span class="built_in">make_shared</span>&lt;Node&gt;(data);</span><br><span class="line">        new_node-&gt;next = head_.<span class="built_in">load</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用compare_exchange_strong确保原子性</span></span><br><span class="line">        <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">            new_node-&gt;next,</span><br><span class="line">            new_node,</span><br><span class="line">            std::memory_order_release,</span><br><span class="line">            std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// 如果失败，new_node-&gt;next已经被更新为head_的当前值</span></span><br><span class="line">            <span class="comment">// 循环重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> old_head = head_.<span class="built_in">load</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (old_head &amp;&amp; !head_.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">            old_head,</span><br><span class="line">            old_head-&gt;next,</span><br><span class="line">            std::memory_order_acquire,</span><br><span class="line">            std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// 如果失败，old_head已经被更新为head_的当前值</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> old_head ? std::<span class="built_in">make_shared</span>&lt;T&gt;(old_head-&gt;data) : std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="使用weak版本的无锁栈（推荐）"><a href="#使用weak版本的无锁栈（推荐）" class="headerlink" title="使用weak版本的无锁栈（推荐）"></a>使用weak版本的无锁栈（推荐）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockFreeStackWeak</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        T data;</span><br><span class="line">        std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Node</span>(T <span class="type">const</span>&amp; data_) : <span class="built_in">data</span>(data_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::atomic&lt;std::shared_ptr&lt;Node&gt;&gt; head_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> new_node = std::<span class="built_in">make_shared</span>&lt;Node&gt;(data);</span><br><span class="line">        new_node-&gt;next = head_.<span class="built_in">load</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用weak版本，在某些架构上性能更好</span></span><br><span class="line">        <span class="keyword">while</span> (!head_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">            new_node-&gt;next,</span><br><span class="line">            new_node,</span><br><span class="line">            std::memory_order_release,</span><br><span class="line">            std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// weak版本可能出现伪失败，但在循环中这不是问题</span></span><br><span class="line">            <span class="comment">// new_node-&gt;next已经被更新为head_的当前值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> old_head = head_.<span class="built_in">load</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用weak版本进行pop操作</span></span><br><span class="line">        <span class="keyword">while</span> (old_head &amp;&amp; !head_.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">            old_head,</span><br><span class="line">            old_head-&gt;next,</span><br><span class="line">            std::memory_order_acquire,</span><br><span class="line">            std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// 伪失败时会自动重试</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> old_head ? std::<span class="built_in">make_shared</span>&lt;T&gt;(old_head-&gt;data) : std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="选择strong还是weak的决策指南"><a href="#选择strong还是weak的决策指南" class="headerlink" title="选择strong还是weak的决策指南"></a>选择strong还是weak的决策指南</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 决策流程图的代码示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecisionGuide</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 场景1：单次尝试，失败后不重试</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_once_operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::atomic&lt;<span class="type">int</span>&gt; value&#123;<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">int</span> expected = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用strong版本，因为我们只尝试一次</span></span><br><span class="line">        <span class="keyword">return</span> value.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">            expected, <span class="number">20</span>,</span><br><span class="line">            std::memory_order_acq_rel,</span><br><span class="line">            std::memory_order_acquire);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景2：循环重试直到成功</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop_until_success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::atomic&lt;<span class="type">int</span>&gt; counter&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> current = counter.<span class="built_in">load</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用weak版本，因为在循环中，性能更好</span></span><br><span class="line">        <span class="keyword">while</span> (!counter.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">            current, current + <span class="number">1</span>,</span><br><span class="line">            std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// 继续重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景3：有复杂的失败处理逻辑</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">complex_failure_handling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::atomic&lt;<span class="type">int</span>&gt; state&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> expected = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用strong版本，因为我们需要明确知道是否真的失败</span></span><br><span class="line">        <span class="keyword">if</span> (!state.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">            expected, <span class="number">1</span>,</span><br><span class="line">            std::memory_order_acq_rel,</span><br><span class="line">            std::memory_order_acquire)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 复杂的失败处理</span></span><br><span class="line">            <span class="keyword">if</span> (expected == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 特殊情况处理</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">handle_special_case</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">handle_special_case</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="硬件架构的影响"><a href="#硬件架构的影响" class="headerlink" title="硬件架构的影响"></a>硬件架构的影响</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同架构上的性能差异示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArchitectureComparison</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在支持LL/SC指令的架构上（如ARM），weak版本更高效</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">arm_optimized_increment</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;&amp; counter)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> current = counter.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ARM上的LL/SC指令可能自然失败，weak版本直接映射</span></span><br><span class="line">        <span class="keyword">while</span> (!counter.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">            current, current + <span class="number">1</span>,</span><br><span class="line">            std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// 在ARM上，这个循环可能因为中断或其他线程的写入而重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在x86架构上，strong和weak的性能差异较小</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">x86_increment</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;&amp; counter)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> current = counter.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// x86上的CMPXCHG指令，strong和weak性能相近</span></span><br><span class="line">        <span class="keyword">while</span> (!counter.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">            current, current + <span class="number">1</span>,</span><br><span class="line">            std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">// x86上很少出现伪失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-atomic-fetch-sub-explicit"><a href="#4-atomic-fetch-sub-explicit" class="headerlink" title="4. atomic_fetch_sub_explicit"></a>4. atomic_fetch_sub_explicit</h2><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>atomic_fetch_sub_explicit</code> 原子地从变量中减去一个值，并返回操作前的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter&#123;<span class="number">1000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fetch_sub_example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原子地减去5，返回操作前的值</span></span><br><span class="line">    <span class="type">int</span> old_value = std::<span class="built_in">atomic_fetch_sub_explicit</span>(</span><br><span class="line">        &amp;counter, </span><br><span class="line">        <span class="number">5</span>, </span><br><span class="line">        std::memory_order_acq_rel</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;操作前的值: &quot;</span> &lt;&lt; old_value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;操作后的值: &quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际应用：资源计数器"><a href="#实际应用：资源计数器" class="headerlink" title="实际应用：资源计数器"></a>实际应用：资源计数器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResourcePool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; available_resources_&#123;<span class="number">100</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">acquire_resource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> current = available_resources_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (current &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试原子地减少资源计数</span></span><br><span class="line">            <span class="keyword">if</span> (available_resources_.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                current,</span><br><span class="line">                current - <span class="number">1</span>,</span><br><span class="line">                std::memory_order_acq_rel,</span><br><span class="line">                std::memory_order_relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 成功获取资源</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果失败，current已经被更新，继续循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 没有可用资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release_resource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        available_resources_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_acq_rel);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_available_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> available_resources_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(ResourcePool&amp; pool, <span class="type">int</span> worker_id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool.<span class="built_in">acquire_resource</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; worker_id &lt;&lt; <span class="string">&quot; 获取了资源&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 模拟工作</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">            </span><br><span class="line">            pool.<span class="built_in">release_resource</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; worker_id &lt;&lt; <span class="string">&quot; 释放了资源&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; worker_id &lt;&lt; <span class="string">&quot; 无法获取资源&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="综合应用：线程安全的引用计数"><a href="#综合应用：线程安全的引用计数" class="headerlink" title="综合应用：线程安全的引用计数"></a>综合应用：线程安全的引用计数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicSharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ControlBlock</span> &#123;</span><br><span class="line">        T* ptr;</span><br><span class="line">        std::atomic&lt;<span class="type">int</span>&gt; ref_count;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">ControlBlock</span>(T* p) : <span class="built_in">ptr</span>(p), <span class="built_in">ref_count</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ControlBlock* control_block_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AtomicSharedPtr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> </span></span><br><span class="line"><span class="function">        : control_block_(ptr ? new ControlBlock(ptr) : nullptr) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">AtomicSharedPtr</span>(<span class="type">const</span> AtomicSharedPtr&amp; other) : <span class="built_in">control_block_</span>(other.control_block_) &#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block_) &#123;</span><br><span class="line">            <span class="comment">// 原子地增加引用计数</span></span><br><span class="line">            control_block_-&gt;ref_count.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    AtomicSharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> AtomicSharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">reset</span>();</span><br><span class="line">            control_block_ = other.control_block_;</span><br><span class="line">            <span class="keyword">if</span> (control_block_) &#123;</span><br><span class="line">                control_block_-&gt;ref_count.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">AtomicSharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (control_block_) &#123;</span><br><span class="line">            <span class="comment">// 原子地减少引用计数</span></span><br><span class="line">            <span class="type">int</span> old_count = control_block_-&gt;ref_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_acq_rel);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (old_count == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 最后一个引用，安全删除</span></span><br><span class="line">                <span class="keyword">delete</span> control_block_-&gt;ptr;</span><br><span class="line">                <span class="keyword">delete</span> control_block_;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            control_block_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> control_block_ ? control_block_-&gt;ptr : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> control_block_ ? control_block_-&gt;ref_count.<span class="built_in">load</span>(std::memory_order_relaxed) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="性能考虑和最佳实践"><a href="#性能考虑和最佳实践" class="headerlink" title="性能考虑和最佳实践"></a>性能考虑和最佳实践</h2><h3 id="1-选择合适的内存序"><a href="#1-选择合适的内存序" class="headerlink" title="1. 选择合适的内存序"></a>1. 选择合适的内存序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于简单的计数器，relaxed通常足够</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter&#123;<span class="number">0</span>&#125;;</span><br><span class="line">counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于同步操作，使用acquire-release</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; ready&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">while</span> (!ready.<span class="built_in">load</span>(std::memory_order_acquire)); <span class="comment">// 消费者</span></span><br></pre></td></tr></table></figure><h3 id="2-避免伪共享"><a href="#2-避免伪共享" class="headerlink" title="2. 避免伪共享"></a>2. 避免伪共享</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法：可能导致伪共享</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BadCounters</span> &#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; counter1;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; counter2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的做法：使用对齐避免伪共享</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) GoodCounters &#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; counter1;</span><br><span class="line">    <span class="type">char</span> padding[<span class="number">60</span>];  <span class="comment">// 填充到缓存行大小</span></span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; counter2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-使用合适的原子类型"><a href="#3-使用合适的原子类型" class="headerlink" title="3. 使用合适的原子类型"></a>3. 使用合适的原子类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于标志位，使用atomic&lt;bool&gt;</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; stop_flag&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于计数器，使用atomic&lt;int&gt;或atomic&lt;size_t&gt;</span></span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; request_count&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于指针，使用atomic&lt;T*&gt;</span></span><br><span class="line">std::atomic&lt;Node*&gt; head&#123;<span class="literal">nullptr</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原子操作是多线程编程中的重要工具，正确使用这些函数可以帮助我们：</p><ol><li><strong>避免数据竞争</strong>：原子操作保证操作的不可分割性</li><li><strong>提供同步机制</strong>：通过内存序控制操作的可见性顺序</li><li><strong>实现无锁数据结构</strong>：提高程序的并发性能</li><li><strong>简化线程间通信</strong>：减少对互斥锁的依赖</li></ol><p>记住以下关键点：</p><ul><li><strong>选择合适的内存序</strong>以平衡性能和正确性</li><li><strong>理解每个操作的语义和返回值</strong>，特别是compare_exchange的expected参数行为</li><li><strong>在循环中优先使用weak版本</strong>，单次操作使用strong版本</li><li><strong>根据目标硬件架构选择</strong>：ARM等LL/SC架构上weak版本性能更好</li><li><strong>在设计无锁算法时要特别小心ABA问题</strong></li><li><strong>考虑使用更高级的同步原语</strong>（如<code>std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;</code>）</li></ul><h3 id="compare-exchange使用建议总结"><a href="#compare-exchange使用建议总结" class="headerlink" title="compare_exchange使用建议总结"></a>compare_exchange使用建议总结</h3><table><thead><tr><th>场景</th><th>推荐版本</th><th>原因</th></tr></thead><tbody><tr><td>循环重试</td><td>weak</td><td>性能更好，伪失败无影响</td></tr><tr><td>单次尝试</td><td>strong</td><td>避免不必要的伪失败</td></tr><tr><td>复杂失败处理</td><td>strong</td><td>需要明确的失败原因</td></tr><tr><td>ARM/PowerPC等架构</td><td>weak</td><td>直接映射LL/SC指令</td></tr><tr><td>x86架构</td><td>两者皆可</td><td>性能差异很小</td></tr></tbody></table><p>通过掌握这些原子操作函数，特别是compare_exchange的strong和weak版本的区别，你将能够编写出更加高效和安全的多线程程序。 </p>]]></content>
      
      
      <categories>
          
          <category> C++编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 原子操作 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GLSL中的smoothstep函数详解</title>
      <link href="/2025/06/24/GLSL%E4%B8%AD%E7%9A%84smoothstep%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/06/24/GLSL%E4%B8%AD%E7%9A%84smoothstep%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在GLSL(OpenGL Shading Language)编程中，<code>smoothstep</code>函数是一个非常有用且常用的内置函数。它能够在两个值之间创建平滑的插值，广泛应用于边缘软化、渐变效果、动画过渡等场景。本文将深入介绍smoothstep函数的用法、数学原理和实际应用。</p><span id="more"></span><h3 id="smoothstep函数基础"><a href="#smoothstep函数基础" class="headerlink" title="smoothstep函数基础"></a>smoothstep函数基础</h3><h4 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本形式</span></span><br><span class="line"><span class="type">float</span> <span class="built_in">smoothstep</span>(<span class="type">float</span> edge0, <span class="type">float</span> edge1, <span class="type">float</span> x)</span><br><span class="line"><span class="type">vec2</span> <span class="built_in">smoothstep</span>(<span class="type">vec2</span> edge0, <span class="type">vec2</span> edge1, <span class="type">vec2</span> x)</span><br><span class="line"><span class="type">vec3</span> <span class="built_in">smoothstep</span>(<span class="type">vec3</span> edge0, <span class="type">vec3</span> edge1, <span class="type">vec3</span> x)</span><br><span class="line"><span class="type">vec4</span> <span class="built_in">smoothstep</span>(<span class="type">vec4</span> edge0, <span class="type">vec4</span> edge1, <span class="type">vec4</span> x)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 混合形式</span></span><br><span class="line"><span class="type">vec2</span> <span class="built_in">smoothstep</span>(<span class="type">float</span> edge0, <span class="type">float</span> edge1, <span class="type">vec2</span> x)</span><br><span class="line"><span class="type">vec3</span> <span class="built_in">smoothstep</span>(<span class="type">float</span> edge0, <span class="type">float</span> edge1, <span class="type">vec3</span> x)</span><br><span class="line"><span class="type">vec4</span> <span class="built_in">smoothstep</span>(<span class="type">float</span> edge0, <span class="type">float</span> edge1, <span class="type">vec4</span> x)</span><br></pre></td></tr></table></figure><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>edge0</code>: 下边界值，当x &lt;= edge0时返回0.0</li><li><code>edge1</code>: 上边界值，当x &gt;= edge1时返回1.0  </li><li><code>x</code>: 输入值</li><li>返回值: 在[0.0, 1.0]范围内的平滑插值结果</li></ul><h3 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h3><p>smoothstep函数实现的是一个S形的平滑插值曲线，其数学公式为：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smoothstep的等价实现</span></span><br><span class="line"><span class="type">float</span> mySmooth(<span class="type">float</span> edge0, <span class="type">float</span> edge1, <span class="type">float</span> x) &#123;</span><br><span class="line">    <span class="comment">// 将x规范化到[0,1]范围</span></span><br><span class="line">    <span class="type">float</span> t = <span class="built_in">clamp</span>((x - edge0) / (edge1 - edge0), <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// Hermite插值: 3t² - 2t³</span></span><br><span class="line">    <span class="keyword">return</span> t * t * (<span class="number">3.0</span> - <span class="number">2.0</span> * t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数特性"><a href="#函数特性" class="headerlink" title="函数特性"></a>函数特性</h4><ol><li><strong>平滑性</strong>: 在边界处一阶导数为0，确保平滑过渡</li><li><strong>单调性</strong>: 在[edge0, edge1]区间内严格递增</li><li><strong>边界行为</strong>: 在边界外返回0或1，无超调</li></ol><h4 id="与其他插值函数对比"><a href="#与其他插值函数对比" class="headerlink" title="与其他插值函数对比"></a>与其他插值函数对比</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性插值 - 存在尖锐边界</span></span><br><span class="line"><span class="type">float</span> linearStep(<span class="type">float</span> edge0, <span class="type">float</span> edge1, <span class="type">float</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">clamp</span>((x - edge0) / (edge1 - edge0), <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// smoothstep - S形平滑曲线</span></span><br><span class="line"><span class="type">float</span> smoothStep(<span class="type">float</span> edge0, <span class="type">float</span> edge1, <span class="type">float</span> x) &#123;</span><br><span class="line">    <span class="type">float</span> t = <span class="built_in">clamp</span>((x - edge0) / (edge1 - edge0), <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> t * t * (<span class="number">3.0</span> - <span class="number">2.0</span> * t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// smootherstep - 更平滑的曲线</span></span><br><span class="line"><span class="type">float</span> smootherStep(<span class="type">float</span> edge0, <span class="type">float</span> edge1, <span class="type">float</span> x) &#123;</span><br><span class="line">    <span class="type">float</span> t = <span class="built_in">clamp</span>((x - edge0) / (edge1 - edge0), <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> t * t * t * (t * (t * <span class="number">6.0</span> - <span class="number">15.0</span>) + <span class="number">10.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本用法示例"><a href="#基本用法示例" class="headerlink" title="基本用法示例"></a>基本用法示例</h3><h4 id="1-简单的边缘软化"><a href="#1-简单的边缘软化" class="headerlink" title="1. 简单的边缘软化"></a>1. 简单的边缘软化</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fragment Shader - 软化圆形边缘</span></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> center = <span class="type">vec2</span>(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="type">float</span> dist = <span class="built_in">distance</span>(<span class="built_in">gl_FragCoord</span>.xy / resolution.xy, center);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 硬边缘</span></span><br><span class="line">    <span class="type">float</span> hardCircle = <span class="built_in">step</span>(<span class="number">0.3</span>, dist);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 软边缘</span></span><br><span class="line">    <span class="type">float</span> softCircle = <span class="built_in">smoothstep</span>(<span class="number">0.25</span>, <span class="number">0.35</span>, dist);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="number">1.0</span> - softCircle), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-渐变效果"><a href="#2-渐变效果" class="headerlink" title="2. 渐变效果"></a>2. 渐变效果</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 水平渐变</span></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = <span class="built_in">gl_FragCoord</span>.xy / resolution.xy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线性渐变</span></span><br><span class="line">    <span class="type">float</span> linear = uv.x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 平滑渐变</span></span><br><span class="line">    <span class="type">float</span> <span class="keyword">smooth</span> = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, uv.x);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="keyword">smooth</span>), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><h4 id="1-雾效实现"><a href="#1-雾效实现" class="headerlink" title="1. 雾效实现"></a>1. 雾效实现</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> fogNear;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> fogFar;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> fogColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">float</span> depth = <span class="built_in">gl_FragCoord</span>.z / <span class="built_in">gl_FragCoord</span>.w;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用smoothstep创建平滑的雾效</span></span><br><span class="line">    <span class="type">float</span> fogFactor = <span class="built_in">smoothstep</span>(fogNear, fogFar, depth);</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec3</span> finalColor = <span class="built_in">mix</span>(objectColor, fogColor, fogFactor);</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(finalColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-材质混合"><a href="#2-材质混合" class="headerlink" title="2. 材质混合"></a>2. 材质混合</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture2;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> mixFactor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = <span class="built_in">gl_FragCoord</span>.xy / resolution.xy;</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec4</span> color1 = <span class="built_in">texture2D</span>(texture1, uv);</span><br><span class="line">    <span class="type">vec4</span> color2 = <span class="built_in">texture2D</span>(texture2, uv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 平滑的材质过渡</span></span><br><span class="line">    <span class="type">float</span> factor = <span class="built_in">smoothstep</span>(<span class="number">0.3</span>, <span class="number">0.7</span>, mixFactor);</span><br><span class="line">    <span class="type">vec4</span> finalColor = <span class="built_in">mix</span>(color1, color2, factor);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gl_FragColor</span> = finalColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-动画过渡"><a href="#3-动画过渡" class="headerlink" title="3. 动画过渡"></a>3. 动画过渡</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> time;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = <span class="built_in">gl_FragCoord</span>.xy / resolution.xy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建脉动效果</span></span><br><span class="line">    <span class="type">float</span> pulse = <span class="built_in">sin</span>(time * <span class="number">2.0</span>) * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> radius = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, pulse) * <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> dist = <span class="built_in">distance</span>(uv, <span class="type">vec2</span>(<span class="number">0.5</span>));</span><br><span class="line">    <span class="type">float</span> circle = <span class="number">1.0</span> - <span class="built_in">smoothstep</span>(radius - <span class="number">0.05</span>, radius + <span class="number">0.05</span>, dist);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(circle), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-边缘检测和轮廓"><a href="#4-边缘检测和轮廓" class="headerlink" title="4. 边缘检测和轮廓"></a>4. 边缘检测和轮廓</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> inputTexture;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> resolution;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = <span class="built_in">gl_FragCoord</span>.xy / resolution;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 采样周围像素</span></span><br><span class="line">    <span class="type">float</span> tl = <span class="built_in">texture2D</span>(inputTexture, uv + <span class="type">vec2</span>(<span class="number">-1.0</span>, <span class="number">-1.0</span>) / resolution).r;</span><br><span class="line">    <span class="type">float</span> tr = <span class="built_in">texture2D</span>(inputTexture, uv + <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">-1.0</span>) / resolution).r;</span><br><span class="line">    <span class="type">float</span> bl = <span class="built_in">texture2D</span>(inputTexture, uv + <span class="type">vec2</span>(<span class="number">-1.0</span>, <span class="number">1.0</span>) / resolution).r;</span><br><span class="line">    <span class="type">float</span> br = <span class="built_in">texture2D</span>(inputTexture, uv + <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">1.0</span>) / resolution).r;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算梯度</span></span><br><span class="line">    <span class="type">float</span> gradient = <span class="built_in">abs</span>(tl - br) + <span class="built_in">abs</span>(tr - bl);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用smoothstep创建清晰的边缘</span></span><br><span class="line">    <span class="type">float</span> edge = <span class="built_in">smoothstep</span>(<span class="number">0.1</span>, <span class="number">0.3</span>, gradient);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(edge), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h3><h4 id="1-多重smoothstep组合"><a href="#1-多重smoothstep组合" class="headerlink" title="1. 多重smoothstep组合"></a>1. 多重smoothstep组合</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建多段渐变</span></span><br><span class="line"><span class="type">float</span> multiStep(<span class="type">float</span> x) &#123;</span><br><span class="line">    <span class="type">float</span> step1 = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.3</span>, x);</span><br><span class="line">    <span class="type">float</span> step2 = <span class="built_in">smoothstep</span>(<span class="number">0.3</span>, <span class="number">0.7</span>, x);</span><br><span class="line">    <span class="type">float</span> step3 = <span class="built_in">smoothstep</span>(<span class="number">0.7</span>, <span class="number">1.0</span>, x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> step1 * <span class="number">0.3</span> + step2 * <span class="number">0.4</span> + step3 * <span class="number">0.3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-自定义缓动函数"><a href="#2-自定义缓动函数" class="headerlink" title="2. 自定义缓动函数"></a>2. 自定义缓动函数</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓入缓出</span></span><br><span class="line"><span class="type">float</span> easeInOut(<span class="type">float</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹性效果</span></span><br><span class="line"><span class="type">float</span> elastic(<span class="type">float</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, t) * (<span class="number">1.0</span> + <span class="built_in">sin</span>(t * <span class="number">3.14159</span> * <span class="number">4.0</span>) * <span class="number">0.1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-向量化操作"><a href="#3-向量化操作" class="headerlink" title="3. 向量化操作"></a>3. 向量化操作</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对RGB通道分别应用smoothstep</span></span><br><span class="line"><span class="type">vec3</span> colorTransition(<span class="type">vec3</span> color, <span class="type">float</span> factor) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(<span class="type">vec3</span>(<span class="number">0.2</span>), <span class="type">vec3</span>(<span class="number">0.8</span>), <span class="type">vec3</span>(factor));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建彩虹效果</span></span><br><span class="line"><span class="type">vec3</span> rainbow(<span class="type">float</span> t) &#123;</span><br><span class="line">    <span class="type">vec3</span> a = <span class="type">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="type">vec3</span> b = <span class="type">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="type">vec3</span> c = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="type">vec3</span> d = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">0.33</span>, <span class="number">0.67</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a + b * <span class="built_in">cos</span>(<span class="number">6.28318</span> * (c * t + d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><h4 id="1-内置函数优势"><a href="#1-内置函数优势" class="headerlink" title="1. 内置函数优势"></a>1. 内置函数优势</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐：使用内置smoothstep</span></span><br><span class="line"><span class="type">float</span> result = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：手动实现（除非需要自定义行为）</span></span><br><span class="line"><span class="type">float</span> t = <span class="built_in">clamp</span>((x - <span class="number">0.0</span>) / (<span class="number">1.0</span> - <span class="number">0.0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="type">float</span> result = t * t * (<span class="number">3.0</span> - <span class="number">2.0</span> * t);</span><br></pre></td></tr></table></figure><h4 id="2-预计算优化"><a href="#2-预计算优化" class="headerlink" title="2. 预计算优化"></a>2. 预计算优化</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于常量参数，可以预计算</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> precomputedRange; <span class="comment">// = 1.0 / (edge1 - edge0)</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> precomputedOffset; <span class="comment">// = -edge0 / (edge1 - edge0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> optimizedSmoothstep(<span class="type">float</span> x) &#123;</span><br><span class="line">    <span class="type">float</span> t = <span class="built_in">clamp</span>(x * precomputedRange + precomputedOffset, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> t * t * (<span class="number">3.0</span> - <span class="number">2.0</span> * t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><h4 id="1-可视化smoothstep曲线"><a href="#1-可视化smoothstep曲线" class="headerlink" title="1. 可视化smoothstep曲线"></a>1. 可视化smoothstep曲线</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = <span class="built_in">gl_FragCoord</span>.xy / resolution.xy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制函数曲线</span></span><br><span class="line">    <span class="type">float</span> x = uv.x;</span><br><span class="line">    <span class="type">float</span> y = <span class="built_in">smoothstep</span>(<span class="number">0.2</span>, <span class="number">0.8</span>, x);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示曲线</span></span><br><span class="line">    <span class="type">float</span> line = <span class="built_in">abs</span>(uv.y - y) &lt; <span class="number">0.01</span> ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(line), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-参数调试"><a href="#2-参数调试" class="headerlink" title="2. 参数调试"></a>2. 参数调试</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> debugEdge0;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> debugEdge1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> debugInput;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">float</span> result = <span class="built_in">smoothstep</span>(debugEdge0, debugEdge1, debugInput);</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(result), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见问题和解决方案"><a href="#常见问题和解决方案" class="headerlink" title="常见问题和解决方案"></a>常见问题和解决方案</h3><h4 id="1-边界值相等"><a href="#1-边界值相等" class="headerlink" title="1. 边界值相等"></a>1. 边界值相等</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：edge0 == edge1会导致除零</span></span><br><span class="line"><span class="type">float</span> bad = <span class="built_in">smoothstep</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决：确保边界值不同</span></span><br><span class="line"><span class="type">float</span> safe = <span class="built_in">smoothstep</span>(<span class="number">0.5</span>, <span class="number">0.5</span> + <span class="number">0.001</span>, x);</span><br></pre></td></tr></table></figure><h4 id="2-参数顺序"><a href="#2-参数顺序" class="headerlink" title="2. 参数顺序"></a>2. 参数顺序</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：edge0应该小于edge1</span></span><br><span class="line"><span class="type">float</span> correct = <span class="built_in">smoothstep</span>(<span class="number">0.2</span>, <span class="number">0.8</span>, x);   <span class="comment">// 正确</span></span><br><span class="line"><span class="type">float</span> incorrect = <span class="built_in">smoothstep</span>(<span class="number">0.8</span>, <span class="number">0.2</span>, x); <span class="comment">// 结果会反转</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>smoothstep函数是GLSL中一个强大而优雅的工具，它提供了：</p><ol><li><strong>数学上的优美性</strong>: S形曲线确保平滑过渡</li><li><strong>实用性</strong>: 广泛适用于各种图形效果</li><li><strong>性能</strong>: 硬件优化的内置实现</li><li><strong>灵活性</strong>: 支持标量和向量操作</li></ol><p>掌握smoothstep函数的使用技巧，能够显著提升shader编程的效果和效率。无论是创建艺术效果还是解决实际的渲染问题，smoothstep都是不可或缺的工具。</p><h3 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h3><ul><li><a href="https://www.khronos.org/registry/OpenGL-Refpages/">OpenGL官方文档 - smoothstep</a></li><li><a href="https://www.shadertoy.com/">Shadertoy</a> - 在线shader编辑器</li><li><a href="https://thebookofshaders.com/">The Book of Shaders</a> - shader学习资源</li><li><a href="https://www.khronos.org/files/opengles_shading_language.pdf">GLSL规范</a> </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GLSL </tag>
            
            <tag> Shader </tag>
            
            <tag> 图形编程 </tag>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HSV颜色空间和插值优势详解</title>
      <link href="/2025/06/24/HSV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E5%92%8C%E6%8F%92%E5%80%BC%E4%BC%98%E5%8A%BF%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/06/24/HSV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E5%92%8C%E6%8F%92%E5%80%BC%E4%BC%98%E5%8A%BF%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="HSV颜色空间和插值优势详解"><a href="#HSV颜色空间和插值优势详解" class="headerlink" title="HSV颜色空间和插值优势详解"></a>HSV颜色空间和插值优势详解</h2><p>在计算机图形学和图像处理中，颜色空间的选择对最终效果有着重要影响。本文将深入探讨 HSV 颜色空间的特点，以及为什么在颜色插值时，HSV 比传统的 RGB 能产生更自然、更符合人眼感知的效果。</p><span id="more"></span><h3 id="什么是HSV颜色空间"><a href="#什么是HSV颜色空间" class="headerlink" title="什么是HSV颜色空间"></a>什么是HSV颜色空间</h3><p>HSV 颜色空间是一种基于人类视觉感知设计的颜色模型，它将颜色分解为三个组件：</p><ul><li><strong>H (Hue) - 色相</strong>：表示颜色的基本色调，取值范围 0°-360°</li><li><strong>S (Saturation) - 饱和度</strong>：表示颜色的纯度，取值范围 0-100%</li><li><strong>V (Value) - 明度</strong>：表示颜色的亮度，取值范围 0-100%</li></ul><h4 id="HSV的几何表示"><a href="#HSV的几何表示" class="headerlink" title="HSV的几何表示"></a>HSV的几何表示</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/4/4e/HSV_color_solid_cylinder.png" alt="HSV颜色空间圆柱体"></p><p><em>图：HSV 颜色空间的圆柱体表示法</em></p><p>HSV 颜色空间通常用圆柱体来表示，具有以下特征：</p><ul><li><strong>垂直轴（明度轴）</strong>：从底部的黑色（V=0%）到顶部的白色（V=100%）</li><li><strong>角度（色相环）</strong>：围绕中心轴的角度表示不同色相</li><li><strong>半径（饱和度）</strong>：从中心轴到边缘的距离表示饱和度</li></ul><h4 id="HSV各分量的意义"><a href="#HSV各分量的意义" class="headerlink" title="HSV各分量的意义"></a>HSV各分量的意义</h4><ol><li><p>**色相 (Hue)**：</p><ul><li>0° = 红色</li><li>60° = 黄色</li><li>120° = 绿色</li><li>180° = 青色</li><li>240° = 蓝色</li><li>300° = 洋红色</li></ul></li><li><p>**饱和度 (Saturation)**：</p><ul><li>0% = 灰色（无彩色）</li><li>100% = 纯色（最鲜艳）</li></ul></li><li><p>**明度 (Value)**：</p><ul><li>0% = 黑色</li><li>100% = 最亮状态</li></ul></li></ol><h3 id="RGB-vs-HSV：直观对比"><a href="#RGB-vs-HSV：直观对比" class="headerlink" title="RGB vs HSV：直观对比"></a>RGB vs HSV：直观对比</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RGB 表示法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RGB</span> &#123;</span><br><span class="line">    <span class="type">float</span> r, g, b;  <span class="comment">// 范围 [0, 1]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HSV 表示法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HSV</span> &#123;</span><br><span class="line">    <span class="type">float</span> h;  <span class="comment">// 色相，范围 [0, 360]</span></span><br><span class="line">    <span class="type">float</span> s;  <span class="comment">// 饱和度，范围 [0, 1]</span></span><br><span class="line">    <span class="type">float</span> v;  <span class="comment">// 明度，范围 [0, 1]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些颜色的对比</span></span><br><span class="line">RGB red = &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;;</span><br><span class="line">HSV red_hsv = &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"></span><br><span class="line">RGB green = &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;;</span><br><span class="line">HSV green_hsv = &#123;<span class="number">120.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line"></span><br><span class="line">RGB blue = &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line">HSV blue_hsv = &#123;<span class="number">240.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="RGB颜色插值的问题"><a href="#RGB颜色插值的问题" class="headerlink" title="RGB颜色插值的问题"></a>RGB颜色插值的问题</h3><h4 id="问题1：路径不直观"><a href="#问题1：路径不直观" class="headerlink" title="问题1：路径不直观"></a>问题1：路径不直观</h4><p>当我们在 RGB 空间中从红色插值到绿色时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RGB 插值：从红色到绿色</span></span><br><span class="line"><span class="function">RGB <span class="title">interpolateRGB</span><span class="params">(<span class="type">float</span> t)</span> </span>&#123;</span><br><span class="line">    RGB red = &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;;</span><br><span class="line">    RGB green = &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        red.r + t * (green.r - red.r),  <span class="comment">// 1.0 → 0.0</span></span><br><span class="line">        red.g + t * (green.g - red.g),  <span class="comment">// 0.0 → 1.0</span></span><br><span class="line">        red.b + t * (green.b - red.b)   <span class="comment">// 0.0 → 0.0</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 RGB 空间中，从红色到绿色的插值路径会经过暗色区域，产生不自然的中间色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t=0.0: RGB(1.0, 0.0, 0.0) → 鲜红色</span><br><span class="line">t=0.5: RGB(0.5, 0.5, 0.0) → 暗黄色 (不理想!)</span><br><span class="line">t=1.0: RGB(0.0, 1.0, 0.0) → 鲜绿色</span><br></pre></td></tr></table></figure><h4 id="问题2：亮度变化不均匀"><a href="#问题2：亮度变化不均匀" class="headerlink" title="问题2：亮度变化不均匀"></a>问题2：亮度变化不均匀</h4><p>RGB 插值可能导致中间颜色的亮度出现非预期的变化，因为 RGB 三个分量对人眼亮度的贡献不相等。</p><h4 id="问题3：违反人眼感知"><a href="#问题3：违反人眼感知" class="headerlink" title="问题3：违反人眼感知"></a>问题3：违反人眼感知</h4><p>人眼对颜色的感知更接近 HSV 模型，RGB 插值产生的中间色可能看起来不自然。</p><h3 id="HSV颜色插值的优势"><a href="#HSV颜色插值的优势" class="headerlink" title="HSV颜色插值的优势"></a>HSV颜色插值的优势</h3><h4 id="优势1：符合直觉的颜色过渡"><a href="#优势1：符合直觉的颜色过渡" class="headerlink" title="优势1：符合直觉的颜色过渡"></a>优势1：符合直觉的颜色过渡</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HSV 插值：从红色到绿色</span></span><br><span class="line"><span class="function">HSV <span class="title">interpolateHSV</span><span class="params">(<span class="type">float</span> t)</span> </span>&#123;</span><br><span class="line">    HSV red = &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line">    HSV green = &#123;<span class="number">120.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 色相插值需要考虑圆形特性</span></span><br><span class="line">    <span class="type">float</span> hue = red.h + t * (green.h - red.h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        hue,                                    <span class="comment">// 0° → 120°</span></span><br><span class="line">        red.s + t * (green.s - red.s),         <span class="comment">// 1.0 → 1.0 (不变)</span></span><br><span class="line">        red.v + t * (green.v - red.v)          <span class="comment">// 1.0 → 1.0 (不变)</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HSV 插值的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t=0.0: HSV(0°, 100%, 100%) → 鲜红色</span><br><span class="line">t=0.5: HSV(60°, 100%, 100%) → 鲜黄色 (自然!)</span><br><span class="line">t=1.0: HSV(120°, 100%, 100%) → 鲜绿色</span><br></pre></td></tr></table></figure><h4 id="优势2：可控的亮度变化"><a href="#优势2：可控的亮度变化" class="headerlink" title="优势2：可控的亮度变化"></a>优势2：可控的亮度变化</h4><p>在 HSV 空间中，我们可以独立控制亮度，确保过渡过程中亮度变化符合预期：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HSV <span class="title">interpolateHSVWithBrightness</span><span class="params">(<span class="type">float</span> t, <span class="type">float</span> startV, <span class="type">float</span> endV)</span> </span>&#123;</span><br><span class="line">    HSV start = &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, startV&#125;;</span><br><span class="line">    HSV end = &#123;<span class="number">120.0f</span>, <span class="number">1.0f</span>, endV&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        start.h + t * (end.h - start.h),</span><br><span class="line">        start.s + t * (end.s - start.s),</span><br><span class="line">        start.v + t * (end.v - start.v)  <span class="comment">// 可控的亮度变化</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优势3：处理色相环的连续性"><a href="#优势3：处理色相环的连续性" class="headerlink" title="优势3：处理色相环的连续性"></a>优势3：处理色相环的连续性</h4><p>色相是圆形的，从 350° 到 10° 应该是短路径，而不是经过整个色相环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">interpolateHue</span><span class="params">(<span class="type">float</span> h1, <span class="type">float</span> h2, <span class="type">float</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> diff = h2 - h1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理色相环的连续性</span></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">180.0f</span>) &#123;</span><br><span class="line">        diff -= <span class="number">360.0f</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &lt; <span class="number">-180.0f</span>) &#123;</span><br><span class="line">        diff += <span class="number">360.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> result = h1 + t * diff;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保结果在 [0, 360) 范围内</span></span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0.0f</span>) result += <span class="number">360.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= <span class="number">360.0f</span>) result -= <span class="number">360.0f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实用的HSV插值实现"><a href="#实用的HSV插值实现" class="headerlink" title="实用的HSV插值实现"></a>实用的HSV插值实现</h3><h4 id="完整的HSV插值函数"><a href="#完整的HSV插值函数" class="headerlink" title="完整的HSV插值函数"></a>完整的HSV插值函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RGB 到 HSV 转换</span></span><br><span class="line"><span class="function">HSV <span class="title">rgbToHsv</span><span class="params">(<span class="type">const</span> RGB&amp; rgb)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> max_val = std::<span class="built_in">max</span>(&#123;rgb.r, rgb.g, rgb.b&#125;);</span><br><span class="line">    <span class="type">float</span> min_val = std::<span class="built_in">min</span>(&#123;rgb.r, rgb.g, rgb.b&#125;);</span><br><span class="line">    <span class="type">float</span> delta = max_val - min_val;</span><br><span class="line">    </span><br><span class="line">    HSV hsv;</span><br><span class="line">    hsv.v = max_val;</span><br><span class="line">    hsv.s = (max_val == <span class="number">0.0f</span>) ? <span class="number">0.0f</span> : delta / max_val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (delta == <span class="number">0.0f</span>) &#123;</span><br><span class="line">        hsv.h = <span class="number">0.0f</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (max_val == rgb.r) &#123;</span><br><span class="line">            hsv.h = <span class="number">60.0f</span> * (<span class="built_in">fmod</span>((rgb.g - rgb.b) / delta, <span class="number">6.0f</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (max_val == rgb.g) &#123;</span><br><span class="line">            hsv.h = <span class="number">60.0f</span> * ((rgb.b - rgb.r) / delta + <span class="number">2.0f</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hsv.h = <span class="number">60.0f</span> * ((rgb.r - rgb.g) / delta + <span class="number">4.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hsv.h &lt; <span class="number">0.0f</span>) hsv.h += <span class="number">360.0f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hsv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HSV 到 RGB 转换</span></span><br><span class="line"><span class="function">RGB <span class="title">hsvToRgb</span><span class="params">(<span class="type">const</span> HSV&amp; hsv)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> c = hsv.v * hsv.s;</span><br><span class="line">    <span class="type">float</span> x = c * (<span class="number">1.0f</span> - <span class="built_in">abs</span>(<span class="built_in">fmod</span>(hsv.h / <span class="number">60.0f</span>, <span class="number">2.0f</span>) - <span class="number">1.0f</span>));</span><br><span class="line">    <span class="type">float</span> m = hsv.v - c;</span><br><span class="line">    </span><br><span class="line">    RGB rgb;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hsv.h &gt;= <span class="number">0.0f</span> &amp;&amp; hsv.h &lt; <span class="number">60.0f</span>) &#123;</span><br><span class="line">        rgb = &#123;c, x, <span class="number">0.0f</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hsv.h &gt;= <span class="number">60.0f</span> &amp;&amp; hsv.h &lt; <span class="number">120.0f</span>) &#123;</span><br><span class="line">        rgb = &#123;x, c, <span class="number">0.0f</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hsv.h &gt;= <span class="number">120.0f</span> &amp;&amp; hsv.h &lt; <span class="number">180.0f</span>) &#123;</span><br><span class="line">        rgb = &#123;<span class="number">0.0f</span>, c, x&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hsv.h &gt;= <span class="number">180.0f</span> &amp;&amp; hsv.h &lt; <span class="number">240.0f</span>) &#123;</span><br><span class="line">        rgb = &#123;<span class="number">0.0f</span>, x, c&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hsv.h &gt;= <span class="number">240.0f</span> &amp;&amp; hsv.h &lt; <span class="number">300.0f</span>) &#123;</span><br><span class="line">        rgb = &#123;x, <span class="number">0.0f</span>, c&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rgb = &#123;c, <span class="number">0.0f</span>, x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rgb.r += m;</span><br><span class="line">    rgb.g += m;</span><br><span class="line">    rgb.b += m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rgb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HSV 空间中的插值</span></span><br><span class="line"><span class="function">HSV <span class="title">interpolateHSV</span><span class="params">(<span class="type">const</span> HSV&amp; start, <span class="type">const</span> HSV&amp; end, <span class="type">float</span> t)</span> </span>&#123;</span><br><span class="line">    HSV result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 色相插值（考虑圆形特性）</span></span><br><span class="line">    result.h = <span class="built_in">interpolateHue</span>(start.h, end.h, t);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 饱和度和明度的线性插值</span></span><br><span class="line">    result.s = start.s + t * (end.s - start.s);</span><br><span class="line">    result.v = start.v + t * (end.v - start.v);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 便利函数：RGB 空间的 HSV 插值</span></span><br><span class="line"><span class="function">RGB <span class="title">interpolateRGBviaHSV</span><span class="params">(<span class="type">const</span> RGB&amp; start, <span class="type">const</span> RGB&amp; end, <span class="type">float</span> t)</span> </span>&#123;</span><br><span class="line">    HSV startHSV = <span class="built_in">rgbToHsv</span>(start);</span><br><span class="line">    HSV endHSV = <span class="built_in">rgbToHsv</span>(end);</span><br><span class="line">    HSV interpolatedHSV = <span class="built_in">interpolateHSV</span>(startHSV, endHSV, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hsvToRgb</span>(interpolatedHSV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><h4 id="1-用户界面渐变"><a href="#1-用户界面渐变" class="headerlink" title="1. 用户界面渐变"></a>1. 用户界面渐变</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建彩虹渐变</span></span><br><span class="line"><span class="function">std::vector&lt;RGB&gt; <span class="title">createRainbowGradient</span><span class="params">(<span class="type">int</span> steps)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;RGB&gt; gradient;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; steps; ++i) &#123;</span><br><span class="line">        <span class="type">float</span> t = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i) / (steps - <span class="number">1</span>);</span><br><span class="line">        HSV hsv = &#123;t * <span class="number">360.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;;  <span class="comment">// 遍历整个色相环</span></span><br><span class="line">        gradient.<span class="built_in">push_back</span>(<span class="built_in">hsvToRgb</span>(hsv));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gradient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-数据可视化"><a href="#2-数据可视化" class="headerlink" title="2. 数据可视化"></a>2. 数据可视化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 热力图颜色映射</span></span><br><span class="line"><span class="function">RGB <span class="title">getHeatmapColor</span><span class="params">(<span class="type">float</span> value)</span> </span>&#123;  <span class="comment">// value 在 [0, 1] 范围内</span></span><br><span class="line">    HSV cold = &#123;<span class="number">240.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;;  <span class="comment">// 蓝色</span></span><br><span class="line">    HSV hot = &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;;     <span class="comment">// 红色</span></span><br><span class="line">    </span><br><span class="line">    HSV interpolated = <span class="built_in">interpolateHSV</span>(cold, hot, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hsvToRgb</span>(interpolated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-游戏开发中的颜色效果"><a href="#3-游戏开发中的颜色效果" class="headerlink" title="3. 游戏开发中的颜色效果"></a>3. 游戏开发中的颜色效果</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日夜循环颜色变化</span></span><br><span class="line"><span class="function">RGB <span class="title">getDayNightColor</span><span class="params">(<span class="type">float</span> timeOfDay)</span> </span>&#123;  <span class="comment">// 0.0 = 午夜, 0.5 = 正午</span></span><br><span class="line">    HSV night = &#123;<span class="number">240.0f</span>, <span class="number">0.8f</span>, <span class="number">0.2f</span>&#125;;    <span class="comment">// 深蓝色</span></span><br><span class="line">    HSV day = &#123;<span class="number">60.0f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>&#125;;       <span class="comment">// 明黄色</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> t = <span class="number">0.5f</span> * (<span class="number">1.0f</span> + <span class="built_in">sin</span>(timeOfDay * <span class="number">2.0f</span> * M_PI));</span><br><span class="line">    HSV current = <span class="built_in">interpolateHSV</span>(night, day, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hsvToRgb</span>(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><p>虽然 HSV 插值在视觉效果上更优，但需要额外的颜色空间转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化：预计算 HSV 值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorInterpolator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HSV startHSV, endHSV;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ColorInterpolator</span>(<span class="type">const</span> RGB&amp; start, <span class="type">const</span> RGB&amp; end) </span><br><span class="line">        : <span class="built_in">startHSV</span>(<span class="built_in">rgbToHsv</span>(start)), <span class="built_in">endHSV</span>(<span class="built_in">rgbToHsv</span>(end)) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">RGB <span class="title">interpolate</span><span class="params">(<span class="type">float</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        HSV interpolated = <span class="built_in">interpolateHSV</span>(startHSV, endHSV, t);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hsvToRgb</span>(interpolated);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HSV 颜色空间相比 RGB 在插值应用中具有明显优势：</p><ol><li><strong>更自然的过渡</strong>：符合人眼对颜色变化的感知</li><li><strong>可控的亮度</strong>：可以独立控制亮度变化</li><li><strong>直观的参数</strong>：色相、饱和度、明度更容易理解和调整</li><li><strong>更好的视觉效果</strong>：避免了 RGB 插值中的暗色区域问题</li></ol><p>在需要高质量颜色过渡的应用中，如用户界面设计、数据可视化、游戏开发等领域，HSV 插值是比 RGB 插值更好的选择。虽然需要额外的计算开销，但现代硬件的性能足以支持这种转换，而获得的视觉效果提升是非常值得的。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 颜色空间 </tag>
            
            <tag> 插值算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11 委托构造函数和继承构造函数</title>
      <link href="/2025/06/24/C++11%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2025/06/24/C++11%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="C-11-委托构造函数和继承构造函数"><a href="#C-11-委托构造函数和继承构造函数" class="headerlink" title="C++11 委托构造函数和继承构造函数"></a>C++11 委托构造函数和继承构造函数</h2><p>C++11 引入了两个重要的构造函数特性：委托构造函数（Delegating Constructors）和继承构造函数（Inheriting Constructors）。这两个特性都旨在减少代码重复，提高代码的可维护性和可读性。</p><span id="more"></span><h3 id="委托构造函数（Delegating-Constructors）"><a href="#委托构造函数（Delegating-Constructors）" class="headerlink" title="委托构造函数（Delegating Constructors）"></a>委托构造函数（Delegating Constructors）</h3><p>委托构造函数允许一个构造函数调用同一个类的另一个构造函数，从而避免在多个构造函数中重复相同的初始化代码。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 主构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> std::string&amp; name) </span><br><span class="line">        : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">name</span>(name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;主构造函数被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 其他复杂的初始化逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 委托构造函数 - 委托给主构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">MyClass</span>(x, y, <span class="string">&quot;default&quot;</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;委托构造函数1被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 委托构造函数 - 委托给主构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;empty&quot;</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;委托构造函数2被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="委托构造函数的执行顺序"><a href="#委托构造函数的执行顺序" class="headerlink" title="委托构造函数的执行顺序"></a>委托构造函数的执行顺序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;1. 目标构造函数执行完成&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Example</span>() : <span class="built_in">Example</span>(<span class="number">42</span>) &#123;  <span class="comment">// 委托给 Example(int)</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;2. 委托构造函数体执行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Example obj;  <span class="comment">// 输出：</span></span><br><span class="line">              <span class="comment">// 1. 目标构造函数执行完成</span></span><br><span class="line">              <span class="comment">// 2. 委托构造函数体执行</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><p><strong>不能形成循环委托</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bad</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bad</span>(<span class="type">int</span> x) : <span class="built_in">Bad</span>() &#123;&#125;      <span class="comment">// 错误：形成循环委托</span></span><br><span class="line">    <span class="built_in">Bad</span>() : <span class="built_in">Bad</span>(<span class="number">10</span>) &#123;&#125;         <span class="comment">// 错误：形成循环委托</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>委托构造函数不能同时使用成员初始化列表</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Invalid</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Invalid</span>(<span class="type">int</span> a) : <span class="built_in">x</span>(a), <span class="built_in">Invalid</span>() &#123;&#125;  <span class="comment">// 错误：不能同时委托和初始化成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h4 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h4><p>委托构造函数特别适用于需要多种初始化方式的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width, height;</span><br><span class="line">    std::string color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 完整构造函数</span></span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> w, <span class="type">double</span> h, <span class="type">const</span> std::string&amp; c) </span><br><span class="line">        : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h), <span class="built_in">color</span>(c) &#123;</span><br><span class="line">        <span class="built_in">validateDimensions</span>();</span><br><span class="line">        <span class="built_in">initializeDefaults</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正方形构造函数</span></span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> side) : <span class="built_in">Rectangle</span>(side, side, <span class="string">&quot;white&quot;</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Rectangle</span>() : <span class="built_in">Rectangle</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="string">&quot;white&quot;</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只指定颜色的构造函数</span></span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">const</span> std::string&amp; c) : <span class="built_in">Rectangle</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, c) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">validateDimensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;尺寸必须为正数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initializeDefaults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 其他初始化逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="继承构造函数（Inheriting-Constructors）"><a href="#继承构造函数（Inheriting-Constructors）" class="headerlink" title="继承构造函数（Inheriting Constructors）"></a>继承构造函数（Inheriting Constructors）</h3><p>继承构造函数允许派生类直接继承基类的构造函数，而不需要在派生类中重新声明和定义它们。</p><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base(int): &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x, <span class="type">double</span> y) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base(int, double): &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> std::string&amp; s) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base(string): &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 继承所有基类构造函数</span></span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以定义自己的构造函数</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">bool</span> flag) : <span class="built_in">Base</span>(flag ? <span class="number">1</span> : <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived(bool): &quot;</span> &lt;&lt; flag &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d1</span><span class="params">(<span class="number">42</span>)</span></span>;          <span class="comment">// 调用继承的 Base(int)</span></span><br><span class="line">    <span class="function">Derived <span class="title">d2</span><span class="params">(<span class="number">3</span>, <span class="number">3.14</span>)</span></span>;     <span class="comment">// 调用继承的 Base(int, double)</span></span><br><span class="line">    <span class="function">Derived <span class="title">d3</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;     <span class="comment">// 调用继承的 Base(string)</span></span><br><span class="line">    <span class="function">Derived <span class="title">d4</span><span class="params">(<span class="literal">true</span>)</span></span>;        <span class="comment">// 调用 Derived(bool)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承构造函数的特点"><a href="#继承构造函数的特点" class="headerlink" title="继承构造函数的特点"></a>继承构造函数的特点</h4><ol><li><p><strong>选择性继承</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">double</span> y) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x, <span class="type">int</span> y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;  <span class="comment">// 继承所有构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果定义了相同签名的构造函数，会覆盖继承的版本</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> x) : <span class="built_in">Base</span>(x) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived 的 int 构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>与默认构造函数的关系</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) &#123;&#125;</span><br><span class="line">    <span class="comment">// 注意：没有默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">// Derived 也不会有默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Derived d;  // 错误：没有默认构造函数</span></span><br><span class="line"><span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">42</span>)</span></span>;  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="实际应用场景-1"><a href="#实际应用场景-1" class="headerlink" title="实际应用场景"></a>实际应用场景</h4><p>继承构造函数在扩展现有类时特别有用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础日志类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string prefix;</span><br><span class="line">    std::ofstream logFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> std::string&amp; filename) : <span class="built_in">logFile</span>(filename) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> std::string&amp; filename, <span class="type">const</span> std::string&amp; prefix) </span><br><span class="line">        : <span class="built_in">logFile</span>(filename), <span class="built_in">prefix</span>(prefix) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        logFile &lt;&lt; prefix &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带时间戳的日志类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimestampLogger</span> : <span class="keyword">public</span> Logger &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Logger::Logger;  <span class="comment">// 继承所有构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">auto</span> <span class="type">time_t</span> = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">        </span><br><span class="line">        logFile &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;<span class="type">time_t</span>), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) </span><br><span class="line">                &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; prefix &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function">TimestampLogger <span class="title">logger1</span><span class="params">(<span class="string">&quot;app.log&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">TimestampLogger <span class="title">logger2</span><span class="params">(<span class="string">&quot;debug.log&quot;</span>, <span class="string">&quot;[DEBUG] &quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="组合使用委托构造函数和继承构造函数"><a href="#组合使用委托构造函数和继承构造函数" class="headerlink" title="组合使用委托构造函数和继承构造函数"></a>组合使用委托构造函数和继承构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) : <span class="built_in">Base</span>(x, <span class="number">0</span>) &#123;  <span class="comment">// 委托构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base(int) 委托完成&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;  <span class="comment">// 继承构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自己的委托构造函数</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> std::string&amp; s) : <span class="built_in">Derived</span>(std::<span class="built_in">stoi</span>(s)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived(string) 委托完成&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function">Derived <span class="title">d1</span><span class="params">(<span class="number">42</span>)</span></span>;        <span class="comment">// 继承的构造函数 + 基类委托</span></span><br><span class="line"><span class="function">Derived <span class="title">d2</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;     <span class="comment">// 派生类委托 + 继承构造函数 + 基类委托</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>委托构造函数</strong>：减少同一类中多个构造函数的代码重复</li><li><strong>继承构造函数</strong>：简化派生类对基类构造函数的继承</li><li>两者都提高了代码的可维护性和可读性</li><li>在现代 C++ 开发中，应该充分利用这些特性来编写更清洁的代码</li></ul><p>这些特性使得 C++11 在构造函数设计方面更加灵活和强大，是现代 C++ 编程的重要工具。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> C++11 </tag>
            
            <tag> 构造函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++宏定义陷阱与#、##操作符详解 - 播客分析</title>
      <link href="/2025/06/15/cpp-macro-analysis-podcast/"/>
      <url>/2025/06/15/cpp-macro-analysis-podcast/</url>
      
        <content type="html"><![CDATA[<h2 id="播客分析：C-宏定义的陷阱与-、-操作符详解"><a href="#播客分析：C-宏定义的陷阱与-、-操作符详解" class="headerlink" title="播客分析：C++宏定义的陷阱与#、##操作符详解"></a>播客分析：C++宏定义的陷阱与#、##操作符详解</h2><h3 id="C-宏中的-和-操作符详解"><a href="#C-宏中的-和-操作符详解" class="headerlink" title="C++宏中的#和##操作符详解"></a>C++宏中的#和##操作符详解</h3><span id="more"></span><p>现在让我们深入了解C++宏系统中两个重要的操作符：</p><h4 id="单个-操作符（字符串化操作符）"><a href="#单个-操作符（字符串化操作符）" class="headerlink" title="单个#操作符（字符串化操作符）"></a>单个#操作符（字符串化操作符）</h4><p>单个<code>#</code>用于将宏参数转换为字符串字面量。</p><p><strong>语法</strong>：<code>#parameter</code></p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STRINGIFY(x) #x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">STRINGIFY</span>(hello world) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 输出：hello world</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">STRINGIFY</span>(<span class="number">123</span> + <span class="number">456</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 输出：123 + 456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工作原理</strong>：</p><ul><li>预处理器将参数原样转换为字符串</li><li>保留参数中的空格和特殊字符</li><li>在字符串两端添加双引号</li></ul><p><strong>实际应用场景</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_PRINT(var) \</span></span><br><span class="line"><span class="meta">    std::cout &lt;&lt; #var &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; var &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">DEBUG_PRINT</span>(x);  <span class="comment">// 输出：x = 42</span></span><br></pre></td></tr></table></figure><h4 id="双个-操作符（标记粘贴操作符）"><a href="#双个-操作符（标记粘贴操作符）" class="headerlink" title="双个##操作符（标记粘贴操作符）"></a>双个##操作符（标记粘贴操作符）</h4><p>双个<code>##</code>用于将两个标记连接成一个标记。</p><p><strong>语法</strong>：<code>token1 ## token2</code></p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONCAT(a, b) a ## b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CONCAT</span><span class="params">(var, <span class="number">123</span>)</span> </span>= <span class="number">456</span>;  <span class="comment">// 创建变量 var123</span></span><br><span class="line">    std::cout &lt;&lt; var123 &lt;&lt; std::endl;  <span class="comment">// 输出：456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>更复杂的应用</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_GETTER_SETTER(type, name) \</span></span><br><span class="line"><span class="meta">    private: \</span></span><br><span class="line"><span class="meta">        type name##_; \</span></span><br><span class="line"><span class="meta">    public: \</span></span><br><span class="line"><span class="meta">        type get##name() const &#123; return name##_; &#125; \</span></span><br><span class="line"><span class="meta">        void set##name(const type&amp; value) &#123; name##_ = value; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="built_in">DECLARE_GETTER_SETTER</span>(std::string, Name)</span><br><span class="line">    <span class="built_in">DECLARE_GETTER_SETTER</span>(<span class="type">int</span>, Age)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开后相当于：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string Name_;</span><br><span class="line">    <span class="type">int</span> Age_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Name_; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; value)</span> </span>&#123; Name_ = value; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Age_; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; value)</span> </span>&#123; Age_ = value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h3><h4 id="1-宏定义的正确格式"><a href="#1-宏定义的正确格式" class="headerlink" title="1. 宏定义的正确格式"></a>1. 宏定义的正确格式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确：宏名和宏体之间有空格</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：没有空格分隔</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b)((a)&gt;(b)?(a):(b))</span></span><br></pre></td></tr></table></figure><h4 id="2-避免在宏中使用预处理指令"><a href="#2-避免在宏中使用预处理指令" class="headerlink" title="2. 避免在宏中使用预处理指令"></a>2. 避免在宏中使用预处理指令</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险：不要这样做</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_STRING #<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：如果需要条件包含，使用条件编译</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NEED_STRING</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="3-使用括号保护宏参数"><a href="#3-使用括号保护宏参数" class="headerlink" title="3. 使用括号保护宏参数"></a>3. 使用括号保护宏参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险：可能导致运算符优先级问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) x * x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：用括号保护参数和整个表达式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure><h4 id="4-多行宏的正确写法"><a href="#4-多行宏的正确写法" class="headerlink" title="4. 多行宏的正确写法"></a>4. 多行宏的正确写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COMPLEX_MACRO(x, y) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        std::cout &lt;&lt; <span class="string">&quot;Processing: &quot;</span> &lt;&lt; #x &lt;&lt; std::endl; \</span></span><br><span class="line"><span class="meta">        result = (x) + (y); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br></pre></td></tr></table></figure><hr><h3 id="现代C-的替代方案"><a href="#现代C-的替代方案" class="headerlink" title="现代C++的替代方案"></a>现代C++的替代方案</h3><p>在现代C++中，我们有更好的替代方案：</p><h4 id="1-使用constexpr函数替代函数式宏"><a href="#1-使用constexpr函数替代函数式宏" class="headerlink" title="1. 使用constexpr函数替代函数式宏"></a>1. 使用constexpr函数替代函数式宏</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代C++</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-使用模板和constexpr替代复杂宏"><a href="#2-使用模板和constexpr替代复杂宏" class="headerlink" title="2. 使用模板和constexpr替代复杂宏"></a>2. 使用模板和constexpr替代复杂宏</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统宏方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_COMPARISON(type) \</span></span><br><span class="line"><span class="meta">    bool operator&lt;(const type&amp; other) const; \</span></span><br><span class="line"><span class="meta">    bool operator&gt;(const type&amp; other) const;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代C++方式</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Comparable = <span class="built_in">requires</span>(T a, T b) &#123;</span><br><span class="line">    &#123; a &lt; b &#125; -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">    &#123; a &gt; b &#125; -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-使用constexpr变量替代常量宏"><a href="#3-使用constexpr变量替代常量宏" class="headerlink" title="3. 使用constexpr变量替代常量宏"></a>3. 使用constexpr变量替代常量宏</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159265359</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代C++</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> PI = <span class="number">3.14159265359</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="调试宏的技巧"><a href="#调试宏的技巧" class="headerlink" title="调试宏的技巧"></a>调试宏的技巧</h3><h4 id="1-使用编译器选项查看宏展开"><a href="#1-使用编译器选项查看宏展开" class="headerlink" title="1. 使用编译器选项查看宏展开"></a>1. 使用编译器选项查看宏展开</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GCC/Clang</span></span><br><span class="line">g++ -E source.cpp &gt; preprocessed.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定宏的展开</span></span><br><span class="line">g++ -E -dM source.cpp | grep MY_MACRO</span><br></pre></td></tr></table></figure><h4 id="2-使用静态断言验证宏行为"><a href="#2-使用静态断言验证宏行为" class="headerlink" title="2. 使用静态断言验证宏行为"></a>2. 使用静态断言验证宏行为</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_POWER_OF_TWO(x) (((x) &amp; ((x) - 1)) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">IS_POWER_OF_TWO</span>(<span class="number">8</span>), <span class="string">&quot;8 should be power of 2&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(!<span class="built_in">IS_POWER_OF_TWO</span>(<span class="number">6</span>), <span class="string">&quot;6 should not be power of 2&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="常见宏陷阱总结"><a href="#常见宏陷阱总结" class="headerlink" title="常见宏陷阱总结"></a>常见宏陷阱总结</h3><h4 id="1-副作用问题"><a href="#1-副作用问题" class="headerlink" title="1. 副作用问题"></a>1. 副作用问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">MAX</span>(++i, <span class="number">10</span>);  <span class="comment">// i被递增两次！</span></span><br></pre></td></tr></table></figure><h4 id="2-类型问题"><a href="#2-类型问题" class="headerlink" title="2. 类型问题"></a>2. 类型问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ABS(x) ((x) &lt; 0 ? -(x) : (x))</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> u = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">ABS</span>(u - <span class="number">2</span>);  <span class="comment">// 可能产生意外结果</span></span><br></pre></td></tr></table></figure><h4 id="3-作用域问题"><a href="#3-作用域问题" class="headerlink" title="3. 作用域问题"></a>3. 作用域问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SWAP(a, b) &#123; int temp = a; a = b; b = temp; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> temp = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">SWAP</span>(x, y);  <span class="comment">// temp变量名冲突！</span></span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><strong>语法正确性</strong>：宏定义必须遵循正确的语法格式</li><li><strong>语义合理性</strong>：不要在宏中包含预处理指令</li><li><strong>理解工具</strong>：深入理解#和##操作符的作用机制</li><li><strong>现代化思维</strong>：在可能的情况下，优先使用现代C++特性</li></ol><p><strong>关键要点回顾</strong>：</p><ul><li><code>#</code>操作符用于字符串化参数</li><li><code>##</code>操作符用于标记粘贴</li><li>宏定义需要正确的语法格式</li><li>现代C++提供了更安全的替代方案</li><li>调试宏需要特殊的技巧和工具</li></ul><p>记住，宏是一个强大但危险的工具。正确使用它们需要深入理解预处理器的工作原理，以及对潜在陷阱的充分认识。在现代C++开发中，我们应该优先考虑类型安全、易于调试的替代方案。</p><p>感谢大家收听今天的播客，我们下期再见！</p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://en.cppreference.com/w/cpp/preprocessor">C++ Preprocessor Reference</a></li><li><a href="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/">Effective Modern C++ by Scott Meyers</a></li><li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C++ Core Guidelines</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 宏定义 </tag>
            
            <tag> 预处理器 </tag>
            
            <tag> 播客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类型转换陷阱：有符号和无符号整数比较</title>
      <link href="/2025/06/08/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%99%B7%E9%98%B1-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%AF%94%E8%BE%83/"/>
      <url>/2025/06/08/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%99%B7%E9%98%B1-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>在C++编程中，有一些看似简单的操作可能会带来意想不到的结果。今天我们要讨论一个常见但容易被忽视的问题：有符号整数（signed）和无符号整数（unsigned）的比较操作。</p><span id="more"></span><h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>让我们看一个具体的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> a = <span class="number">-1</span>;</span><br><span class="line">uint b = <span class="number">4152</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isLess = a &lt; b; <span class="comment">// 预期结果：true，实际结果：false</span></span><br></pre></td></tr></table></figure><p>这段代码的运行结果可能会让人感到困惑。虽然-1显然小于4152，但比较结果却返回false。这是为什么呢？</p><h2 id="背后的机制"><a href="#背后的机制" class="headerlink" title="背后的机制"></a>背后的机制</h2><h3 id="类型转换规则"><a href="#类型转换规则" class="headerlink" title="类型转换规则"></a>类型转换规则</h3><p>在C++中，当有符号整数和无符号整数进行比较时，会发生以下转换：</p><ol><li><strong>有符号整数会被转换为无符号整数</strong></li><li><strong>转换规则遵循补码表示</strong></li></ol><p>在我们的例子中：</p><ul><li><code>-1</code>的补码表示为<code>0xFFFFFFFF</code></li><li>当转换为无符号整数时，这个值被解释为<code>4294967295</code></li><li>因此实际的比较变成了：<code>4294967295 &lt; 4152</code></li><li>显然这个比较会返回<code>false</code></li></ul><h3 id="为什么会这样设计？"><a href="#为什么会这样设计？" class="headerlink" title="为什么会这样设计？"></a>为什么会这样设计？</h3><p>这个设计有其历史原因：</p><ul><li>处理器进行整数比较时，实际是在比较二进制位</li><li>无符号整数的比较更简单且更快</li><li>C++继承了C语言的这一特性</li></ul><h2 id="如何避免这类问题"><a href="#如何避免这类问题" class="headerlink" title="如何避免这类问题"></a>如何避免这类问题</h2><h3 id="1-使用相同的类型"><a href="#1-使用相同的类型" class="headerlink" title="1. 使用相同的类型"></a>1. 使用相同的类型</h3><p>最简单的解决方案是确保比较的两个数使用相同的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案1：都使用有符号整数</span></span><br><span class="line"><span class="type">int32_t</span> m_IBufferMaxValue = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int32_t</span> pointCount = <span class="number">4152</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案2：都使用无符号整数（如果数值总是非负的话）</span></span><br><span class="line"><span class="type">uint32_t</span> m_IBufferMaxValue = <span class="number">0</span>;  <span class="comment">// 或其他非负值</span></span><br><span class="line"><span class="type">uint32_t</span> pointCount = <span class="number">4152</span>;</span><br></pre></td></tr></table></figure><h3 id="2-显式类型转换"><a href="#2-显式类型转换" class="headerlink" title="2. 显式类型转换"></a>2. 显式类型转换</h3><p>如果必须使用不同的类型，请使用显式类型转换并注意检查值的范围：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用static_cast进行显式转换</span></span><br><span class="line"><span class="type">bool</span> isLess = m_IBufferMaxValue &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(pointCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者先进行范围检查</span></span><br><span class="line"><span class="keyword">if</span> (pointCount &lt;= INT32_MAX) &#123;</span><br><span class="line">    <span class="type">bool</span> isLess = m_IBufferMaxValue &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(pointCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用类型安全的比较函数"><a href="#3-使用类型安全的比较函数" class="headerlink" title="3. 使用类型安全的比较函数"></a>3. 使用类型安全的比较函数</h3><p>可以封装一个安全的比较函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SafeCompare</span><span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_signed_v&lt;T1&gt; &amp;&amp; std::is_unsigned_v&lt;T2&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">make_unsigned_t</span>&lt;T1&gt;&gt;(a) &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加其他类型组合的处理...</span></span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-代码检查工具"><a href="#4-代码检查工具" class="headerlink" title="4. 代码检查工具"></a>4. 代码检查工具</h3><ul><li>使用静态代码分析工具</li><li>启用编译器警告</li><li>使用<code>-Wsign-compare</code>警告选项</li></ul><h2 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h2><ol><li><p><strong>明确变量类型</strong></p><ul><li>在声明变量时就明确其是否需要支持负值</li><li>如果数值永远不会为负，就使用无符号类型</li></ul></li><li><p><strong>统一类型使用</strong></p><ul><li>在同一个模块或相关的代码中保持类型的一致性</li><li>避免混合使用有符号和无符号类型</li></ul></li><li><p><strong>文档和注释</strong></p><ul><li>在可能发生类型转换的地方添加清晰的注释</li><li>记录类型选择的原因和注意事项</li></ul></li><li><p><strong>单元测试</strong></p><ul><li>编写测试用例覆盖边界条件</li><li>特别注意类型转换可能发生的场景</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>类型转换的陷阱虽然看似简单，但在实际开发中经常会造成难以发现的bug。通过：</p><ul><li>理解类型转换规则</li><li>采用一致的类型</li><li>使用显式转换</li><li>添加适当的检查</li></ul><p>我们可以有效地避免这类问题。记住，在处理不同整数类型的比较时，宁可多写几行代码，也要确保类型转换的安全性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>C++ Standard Library</li><li>Effective C++</li><li>C++ Core Guidelines </li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程陷阱 </tag>
            
            <tag> 类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>培养孩子阅读习惯的优质书单推荐</title>
      <link href="/2025/06/07/%E5%9F%B9%E5%85%BB%E5%AD%A9%E5%AD%90%E9%98%85%E8%AF%BB%E4%B9%A0%E6%83%AF%E7%9A%84%E4%BC%98%E8%B4%A8%E4%B9%A6%E5%8D%95%E6%8E%A8%E8%8D%90/"/>
      <url>/2025/06/07/%E5%9F%B9%E5%85%BB%E5%AD%A9%E5%AD%90%E9%98%85%E8%AF%BB%E4%B9%A0%E6%83%AF%E7%9A%84%E4%BC%98%E8%B4%A8%E4%B9%A6%E5%8D%95%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>选择合适的书籍是培养孩子阅读兴趣的关键第一步。本文根据不同年龄段孩子的认知特点和兴趣偏好，精心整理了一份优质书单，帮助家长为孩子挑选最适合的读物。</p><span id="more"></span><h2 id="3-6岁：启蒙阶段书单"><a href="#3-6岁：启蒙阶段书单" class="headerlink" title="3-6岁：启蒙阶段书单"></a>3-6岁：启蒙阶段书单</h2><h3 id="经典绘本系列"><a href="#经典绘本系列" class="headerlink" title="经典绘本系列"></a>经典绘本系列</h3><p><strong>《好饿的毛毛虫》- 艾瑞克·卡尔</strong></p><ul><li><strong>推荐理由</strong>：色彩鲜艳，故事简单有趣，教授数字和星期概念</li><li><strong>阅读技巧</strong>：可以让孩子用手指跟着毛毛虫”吃”东西</li><li><strong>延伸活动</strong>：制作毛毛虫手工，观察真实的蝴蝶变化过程</li></ul><p><strong>《猜猜我有多爱你》- 山姆·麦克布雷尼</strong></p><ul><li><strong>推荐理由</strong>：温馨的亲情故事，培养表达爱的能力</li><li><strong>阅读技巧</strong>：鼓励孩子模仿书中动作，增强互动性</li><li><strong>延伸活动</strong>：和孩子一起比较”谁爱谁更多”</li></ul><p><strong>《逃家小兔》- 玛格丽特·怀兹·布朗</strong></p><ul><li><strong>推荐理由</strong>：经典的母爱主题，给孩子安全感</li><li><strong>阅读技巧</strong>：可以和孩子角色扮演，一个当小兔，一个当妈妈</li><li><strong>延伸活动</strong>：讨论”如果你要逃跑，妈妈会怎么找到你”</li></ul><h3 id="中文原创绘本"><a href="#中文原创绘本" class="headerlink" title="中文原创绘本"></a>中文原创绘本</h3><p><strong>《小熊和最好的爸爸》系列 - 阿兰德·丹姆</strong></p><ul><li><strong>推荐理由</strong>：父子情深，适合爸爸和孩子一起阅读</li><li><strong>特色</strong>：7本书涵盖不同主题，从游戏到成长</li></ul><p><strong>《不一样的卡梅拉》系列</strong></p><ul><li><strong>推荐理由</strong>：想象力丰富，鼓励孩子勇于尝试</li><li><strong>特色</strong>：每本都有不同的冒险故事</li></ul><h2 id="7-10岁：桥梁书阶段"><a href="#7-10岁：桥梁书阶段" class="headerlink" title="7-10岁：桥梁书阶段"></a>7-10岁：桥梁书阶段</h2><h3 id="冒险故事类"><a href="#冒险故事类" class="headerlink" title="冒险故事类"></a>冒险故事类</h3><p><strong>《神奇树屋》系列 - 玛丽·波·奥斯本</strong></p><ul><li><strong>推荐理由</strong>：结合历史知识和冒险故事，寓教于乐</li><li><strong>阅读建议</strong>：可以按照历史时间线阅读，增强历史感</li><li><strong>延伸学习</strong>：查阅相关历史资料，制作时间轴</li></ul><p><strong>《内德的秘密花园》- 琳达·苏·帕克</strong></p><ul><li><strong>推荐理由</strong>：环保主题，培养孩子的责任感</li><li><strong>特色</strong>：插图精美，文字适中</li></ul><h3 id="科普启蒙类"><a href="#科普启蒙类" class="headerlink" title="科普启蒙类"></a>科普启蒙类</h3><p><strong>《可怕的科学》系列</strong></p><ul><li><strong>推荐理由</strong>：用幽默的方式讲解科学知识</li><li><strong>特色</strong>：图文并茂，实验性强</li><li><strong>阅读建议</strong>：可以和孩子一起做书中的小实验</li></ul><p><strong>《DK儿童百科全书》</strong></p><ul><li><strong>推荐理由</strong>：知识全面，图片精美</li><li><strong>使用方法</strong>：不需要从头读到尾，可以按兴趣查阅</li></ul><h3 id="成长励志类"><a href="#成长励志类" class="headerlink" title="成长励志类"></a>成长励志类</h3><p><strong>《小屁孩日记》系列</strong></p><ul><li><strong>推荐理由</strong>：贴近孩子生活，幽默风趣</li><li><strong>特色</strong>：日记体形式，容易引起共鸣</li></ul><p><strong>《窗边的小豆豆》- 黑柳彻子</strong></p><ul><li><strong>推荐理由</strong>：真实的成长故事，培养同理心</li><li><strong>教育价值</strong>：让孩子理解不同的教育方式</li></ul><h2 id="11-14岁：深度阅读阶段"><a href="#11-14岁：深度阅读阶段" class="headerlink" title="11-14岁：深度阅读阶段"></a>11-14岁：深度阅读阶段</h2><h3 id="经典文学入门"><a href="#经典文学入门" class="headerlink" title="经典文学入门"></a>经典文学入门</h3><p><strong>《哈利·波特》系列 - J.K.罗琳</strong></p><ul><li><strong>推荐理由</strong>：想象力丰富，情节引人入胜</li><li><strong>阅读建议</strong>：可以先看前三部，适应后再读后续</li><li><strong>延伸活动</strong>：制作魔法道具，讨论友谊和勇气</li></ul><p><strong>《纳尼亚传奇》系列 - C.S.路易斯</strong></p><ul><li><strong>推荐理由</strong>：奇幻冒险，蕴含深刻哲理</li><li><strong>特色</strong>：每本都是独立故事，可以单独阅读</li></ul><p><strong>《小王子》- 安托万·德·圣-埃克苏佩里</strong></p><ul><li><strong>推荐理由</strong>：哲理深刻，适合反复阅读</li><li><strong>阅读建议</strong>：可以和孩子讨论每个星球的寓意</li></ul><h3 id="科幻探索类"><a href="#科幻探索类" class="headerlink" title="科幻探索类"></a>科幻探索类</h3><p><strong>《三体》青少年版 - 刘慈欣</strong></p><ul><li><strong>推荐理由</strong>：中国科幻经典，培养科学思维</li><li><strong>注意事项</strong>：内容较深，建议有一定阅读基础后再读</li></ul><p><strong>《时间机器》- H.G.威尔斯</strong></p><ul><li><strong>推荐理由</strong>：科幻经典，引发对时间的思考</li><li><strong>延伸讨论</strong>：时间旅行的可能性和后果</li></ul><h3 id="历史传记类"><a href="#历史传记类" class="headerlink" title="历史传记类"></a>历史传记类</h3><p><strong>《上下五千年》</strong></p><ul><li><strong>推荐理由</strong>：了解中国历史，培养文化自信</li><li><strong>阅读建议</strong>：可以选择感兴趣的历史人物重点阅读</li></ul><p><strong>《居里夫人传》</strong></p><ul><li><strong>推荐理由</strong>：科学家传记，特别适合女孩阅读</li><li><strong>教育价值</strong>：坚持和奉献精神的典范</li></ul><h2 id="15岁以上：经典文学阶段"><a href="#15岁以上：经典文学阶段" class="headerlink" title="15岁以上：经典文学阶段"></a>15岁以上：经典文学阶段</h2><h3 id="中外经典名著"><a href="#中外经典名著" class="headerlink" title="中外经典名著"></a>中外经典名著</h3><p><strong>《红楼梦》（青少年版）</strong></p><ul><li><strong>推荐理由</strong>：中国古典文学巅峰之作</li><li><strong>阅读建议</strong>：可以先读简化版，培养兴趣后再读原著</li></ul><p><strong>《傲慢与偏见》- 简·奥斯汀</strong></p><ul><li><strong>推荐理由</strong>：经典爱情小说，文笔优美</li><li><strong>教育价值</strong>：理解人性的复杂和成长的意义</li></ul><p><strong>《1984》- 乔治·奥威尔</strong></p><ul><li><strong>推荐理由</strong>：反乌托邦经典，培养批判思维</li><li><strong>注意事项</strong>：内容较为深刻，需要引导讨论</li></ul><h3 id="哲学思辨类"><a href="#哲学思辨类" class="headerlink" title="哲学思辨类"></a>哲学思辨类</h3><p><strong>《苏菲的世界》- 乔斯坦·贾德</strong></p><ul><li><strong>推荐理由</strong>：哲学启蒙读物，深入浅出</li><li><strong>阅读建议</strong>：可以分章节讨论，不急于一次读完</li></ul><p><strong>《瓦尔登湖》- 梭罗</strong></p><ul><li><strong>推荐理由</strong>：自然哲学，培养独立思考</li><li><strong>延伸活动</strong>：尝试简单生活，体验自然</li></ul><h2 id="选书的实用技巧"><a href="#选书的实用技巧" class="headerlink" title="选书的实用技巧"></a>选书的实用技巧</h2><h3 id="根据孩子兴趣选择"><a href="#根据孩子兴趣选择" class="headerlink" title="根据孩子兴趣选择"></a>根据孩子兴趣选择</h3><p><strong>观察孩子的偏好：</strong></p><ul><li>喜欢动物的孩子：选择动物主题的故事</li><li>喜欢冒险的孩子：选择探险类小说</li><li>喜欢科学的孩子：选择科普类读物</li><li>喜欢历史的孩子：选择历史故事和传记</li></ul><h3 id="循序渐进的原则"><a href="#循序渐进的原则" class="headerlink" title="循序渐进的原则"></a>循序渐进的原则</h3><p><strong>难度递增：</strong></p><ol><li>从图多字少开始</li><li>逐步增加文字比例</li><li>最终过渡到纯文字书籍</li></ol><p><strong>兴趣引导：</strong></p><ol><li>先选择孩子感兴趣的主题</li><li>在同一主题下选择不同难度的书</li><li>适时引入新的主题和类型</li></ol><h3 id="质量判断标准"><a href="#质量判断标准" class="headerlink" title="质量判断标准"></a>质量判断标准</h3><p><strong>好书的特征：</strong></p><ul><li>语言优美，适合年龄段</li><li>内容积极正面，传递正确价值观</li><li>情节引人入胜，能够吸引孩子</li><li>插图精美（对于低年龄段）</li><li>获得过权威奖项或专家推荐</li></ul><h2 id="亲子阅读的实施建议"><a href="#亲子阅读的实施建议" class="headerlink" title="亲子阅读的实施建议"></a>亲子阅读的实施建议</h2><h3 id="创建阅读计划"><a href="#创建阅读计划" class="headerlink" title="创建阅读计划"></a>创建阅读计划</h3><p><strong>每日阅读时间安排：</strong></p><ul><li>3-6岁：15-20分钟</li><li>7-10岁：30-45分钟</li><li>11-14岁：45-60分钟</li><li>15岁以上：60分钟以上</li></ul><p><strong>阅读方式多样化：</strong></p><ul><li>亲子共读</li><li>独立阅读</li><li>有声书辅助</li><li>电子书补充</li></ul><h3 id="阅读后的互动"><a href="#阅读后的互动" class="headerlink" title="阅读后的互动"></a>阅读后的互动</h3><p><strong>讨论要点：</strong></p><ul><li>最喜欢的角色是谁？为什么？</li><li>如果你是主人公，会怎么做？</li><li>这个故事告诉我们什么道理？</li><li>你想推荐给其他小朋友吗？</li></ul><p><strong>创意活动：</strong></p><ul><li>画出故事中的场景</li><li>续写故事结尾</li><li>表演故事片段</li><li>制作读书笔记</li></ul><h2 id="建立家庭图书馆"><a href="#建立家庭图书馆" class="headerlink" title="建立家庭图书馆"></a>建立家庭图书馆</h2><h3 id="购书建议"><a href="#购书建议" class="headerlink" title="购书建议"></a>购书建议</h3><p><strong>预算分配：</strong></p><ul><li>经典必读书籍：60%</li><li>孩子兴趣书籍：30%</li><li>尝试性新书：10%</li></ul><p><strong>购买渠道：</strong></p><ul><li>实体书店：可以现场翻阅</li><li>网上书店：价格优惠，选择丰富</li><li>二手书市场：经济实惠</li><li>图书馆借阅：先试读再决定是否购买</li></ul><h3 id="图书管理"><a href="#图书管理" class="headerlink" title="图书管理"></a>图书管理</h3><p><strong>分类整理：</strong></p><ul><li>按年龄段分类</li><li>按主题分类</li><li>按阅读状态分类（已读/未读/正在读）</li></ul><p><strong>阅读记录：</strong></p><ul><li>建立读书清单</li><li>记录阅读日期</li><li>写下简单感想</li><li>评分推荐指数</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>培养孩子的阅读习惯是一个长期的过程，选择合适的书籍只是第一步。更重要的是要：</p><ol><li><strong>尊重孩子的选择</strong>：在推荐的基础上，让孩子有自主选择权</li><li><strong>保持耐心</strong>：不要急于求成，允许孩子有自己的阅读节奏</li><li><strong>以身作则</strong>：家长的阅读习惯是最好的榜样</li><li><strong>创造氛围</strong>：营造良好的家庭阅读环境</li><li><strong>适时引导</strong>：在孩子遇到困难时给予帮助和鼓励</li></ol><p>记住，每个孩子都是独特的，最适合的书单是根据自己孩子的特点量身定制的。希望这份书单能够为您提供参考，帮助您的孩子在书籍的海洋中找到属于自己的宝藏，从而逐步减少对手机的依赖，爱上阅读的美好世界。 </p>]]></content>
      
      
      <categories>
          
          <category> 家庭教育 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 亲子 </tag>
            
            <tag> 阅读 </tag>
            
            <tag> 书单 </tag>
            
            <tag> 儿童教育 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让孩子戒掉手机爱上阅读：实用策略指南</title>
      <link href="/2025/06/07/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AD%A9%E5%AD%90%E6%88%92%E6%8E%89%E6%89%8B%E6%9C%BA%E7%88%B1%E4%B8%8A%E9%98%85%E8%AF%BB-%E5%AE%9E%E7%94%A8%E7%AD%96%E7%95%A5%E6%8C%87%E5%8D%97/"/>
      <url>/2025/06/07/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AD%A9%E5%AD%90%E6%88%92%E6%8E%89%E6%89%8B%E6%9C%BA%E7%88%B1%E4%B8%8A%E9%98%85%E8%AF%BB-%E5%AE%9E%E7%94%A8%E7%AD%96%E7%95%A5%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>在数字化时代，如何引导孩子从手机屏幕转向书本页面，是每个家长都关心的话题。本文将分享一些经过实践验证的策略，帮助您的孩子逐步减少对手机的依赖，培养良好的阅读习惯。</p><span id="more"></span><h2 id="为什么孩子容易沉迷手机？"><a href="#为什么孩子容易沉迷手机？" class="headerlink" title="为什么孩子容易沉迷手机？"></a>为什么孩子容易沉迷手机？</h2><h3 id="心理层面的原因"><a href="#心理层面的原因" class="headerlink" title="心理层面的原因"></a>心理层面的原因</h3><ul><li><strong>即时满足感</strong>：手机游戏和短视频提供即时的快乐反馈</li><li><strong>社交需求</strong>：通过社交媒体与同龄人保持联系</li><li><strong>逃避现实</strong>：面对学习压力时的一种逃避方式</li><li><strong>好奇心驱动</strong>：对新奇内容的天然渴望</li></ul><h3 id="技术设计的”陷阱”"><a href="#技术设计的”陷阱”" class="headerlink" title="技术设计的”陷阱”"></a>技术设计的”陷阱”</h3><p>现代应用程序采用了大量心理学技巧来吸引用户：</p><ul><li>无限下拉的信息流</li><li>随机奖励机制</li><li>推送通知的及时性</li><li>个性化推荐算法</li></ul><h2 id="循序渐进的戒手机策略"><a href="#循序渐进的戒手机策略" class="headerlink" title="循序渐进的戒手机策略"></a>循序渐进的戒手机策略</h2><h3 id="第一阶段：建立规则和界限"><a href="#第一阶段：建立规则和界限" class="headerlink" title="第一阶段：建立规则和界限"></a>第一阶段：建立规则和界限</h3><p><strong>1. 制定家庭数字使用协议</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 用餐时间禁用电子设备</span><br><span class="line">- 睡前1小时收起所有设备</span><br><span class="line">- 作业时间手机放在指定位置</span><br><span class="line">- 周末可适当放宽，但需要计时</span><br></pre></td></tr></table></figure><p><strong>2. 创建”无手机区域”</strong></p><ul><li>餐厅：促进家庭交流</li><li>卧室：保证睡眠质量</li><li>学习桌：提高专注力</li></ul><h3 id="第二阶段：寻找替代活动"><a href="#第二阶段：寻找替代活动" class="headerlink" title="第二阶段：寻找替代活动"></a>第二阶段：寻找替代活动</h3><p><strong>优质替代活动清单：</strong></p><ul><li>户外运动（骑车、跑步、球类）</li><li>手工制作（绘画、折纸、乐高）</li><li>音乐学习（乐器演奏、唱歌）</li><li>社交活动（与朋友面对面交流）</li></ul><h2 id="培养阅读兴趣的具体方法"><a href="#培养阅读兴趣的具体方法" class="headerlink" title="培养阅读兴趣的具体方法"></a>培养阅读兴趣的具体方法</h2><h3 id="1-营造良好的阅读环境"><a href="#1-营造良好的阅读环境" class="headerlink" title="1. 营造良好的阅读环境"></a>1. 营造良好的阅读环境</h3><p><strong>物理环境优化：</strong></p><ul><li>设置专门的阅读角落</li><li>确保充足的自然光照</li><li>准备舒适的座椅和靠垫</li><li>减少干扰因素</li></ul><p><strong>家庭阅读氛围：</strong></p><ul><li>父母以身作则，经常阅读</li><li>定期进行家庭阅读时间</li><li>在家中显眼位置摆放书籍</li><li>限制电视和其他电子设备的使用时间</li></ul><h3 id="2-选择合适的书籍"><a href="#2-选择合适的书籍" class="headerlink" title="2. 选择合适的书籍"></a>2. 选择合适的书籍</h3><p><strong>年龄段推荐：</strong></p><p><strong>3-6岁：</strong></p><ul><li>图画书和绘本</li><li>互动式翻翻书</li><li>简单的故事书</li></ul><p><strong>7-10岁：</strong></p><ul><li>桥梁书（介于绘本和文字书之间）</li><li>科普类读物</li><li>冒险故事</li></ul><p><strong>11-14岁：</strong></p><ul><li>青少年小说</li><li>科幻和奇幻作品</li><li>传记和历史故事</li></ul><p><strong>15岁以上：</strong></p><ul><li>经典文学作品</li><li>哲学和思辨类书籍</li><li>专业兴趣相关书籍</li></ul><h3 id="3-创新的阅读方法"><a href="#3-创新的阅读方法" class="headerlink" title="3. 创新的阅读方法"></a>3. 创新的阅读方法</h3><p><strong>亲子共读技巧：</strong></p><ul><li>轮流朗读，增加参与感</li><li>讨论情节，培养思辨能力</li><li>角色扮演，增强理解</li><li>绘制思维导图，梳理内容</li></ul><p><strong>阅读游戏化：</strong></p><ul><li>设立阅读积分制度</li><li>创建家庭读书俱乐部</li><li>举办”家庭读书分享会”</li><li>制作读书笔记和书评</li></ul><h2 id="应对常见挑战"><a href="#应对常见挑战" class="headerlink" title="应对常见挑战"></a>应对常见挑战</h2><h3 id="孩子说”书太无聊”"><a href="#孩子说”书太无聊”" class="headerlink" title="孩子说”书太无聊”"></a>孩子说”书太无聊”</h3><ul><li>从孩子感兴趣的主题开始</li><li>选择有视觉冲击力的书籍</li><li>尝试有声书作为过渡</li><li>与孩子一起选书，给予选择权</li></ul><h3 id="注意力不集中"><a href="#注意力不集中" class="headerlink" title="注意力不集中"></a>注意力不集中</h3><ul><li>从短篇开始，逐步增加长度</li><li>设定小目标，如”每天读10分钟”</li><li>使用番茄工作法进行阅读</li><li>在安静的环境中阅读</li></ul><h3 id="阅读理解困难"><a href="#阅读理解困难" class="headerlink" title="阅读理解困难"></a>阅读理解困难</h3><ul><li>选择适合当前水平的书籍</li><li>鼓励孩子问问题</li><li>一起查阅不懂的词汇</li><li>用图片和实物帮助理解</li></ul><h2 id="长期坚持的秘诀"><a href="#长期坚持的秘诀" class="headerlink" title="长期坚持的秘诀"></a>长期坚持的秘诀</h2><h3 id="建立正向反馈循环"><a href="#建立正向反馈循环" class="headerlink" title="建立正向反馈循环"></a>建立正向反馈循环</h3><ol><li><strong>设定合理目标</strong>：从小目标开始，逐步提高</li><li><strong>及时鼓励</strong>：认可孩子的每一次进步</li><li><strong>记录成长</strong>：建立阅读档案，记录阅读历程</li><li><strong>适时调整</strong>：根据孩子的反馈调整策略</li></ol><h3 id="社区支持的力量"><a href="#社区支持的力量" class="headerlink" title="社区支持的力量"></a>社区支持的力量</h3><ul><li>加入其他家长的阅读群体</li><li>参加图书馆的活动</li><li>与学校老师保持沟通</li><li>寻找有相同目标的家庭一起努力</li></ul><h2 id="成功案例分享"><a href="#成功案例分享" class="headerlink" title="成功案例分享"></a>成功案例分享</h2><p><strong>案例一：张家的”21天阅读挑战”</strong><br>张妈妈发现10岁的儿子每天花3小时玩手机后，实施了”21天阅读挑战”：</p><ul><li>前7天：每天阅读15分钟，手机时间减少30分钟</li><li>中间7天：阅读时间增加到30分钟，手机时间再减少30分钟</li><li>最后7天：阅读45分钟，手机仅在周末使用</li></ul><p>结果：21天后，孩子主动要求继续阅读计划。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>让孩子戒掉手机爱上阅读不是一蹴而就的过程，需要家长的耐心、坚持和智慧。记住以下几个关键点：</p><ol><li><strong>循序渐进</strong>：不要试图一夜之间改变所有习惯</li><li><strong>以身作则</strong>：父母的行为是最好的教育</li><li><strong>保持耐心</strong>：允许孩子有反复，给予时间适应</li><li><strong>个性化策略</strong>：根据孩子的特点调整方法</li><li><strong>创造乐趣</strong>：让阅读成为一种享受，而不是负担</li></ol><p>只要坚持正确的方法，相信每个孩子都能够在书籍的世界中找到属于自己的快乐，并逐步减少对电子设备的过度依赖。阅读不仅能够提升孩子的学习能力，更能够培养他们的思维能力、想象力和专注力，为未来的成长打下坚实的基础。 </p>]]></content>
      
      
      <categories>
          
          <category> 家庭教育 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教育 </tag>
            
            <tag> 亲子 </tag>
            
            <tag> 阅读 </tag>
            
            <tag> 手机成瘾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>type script</title>
      <link href="/2025/03/15/type-script/"/>
      <url>/2025/03/15/type-script/</url>
      
        <content type="html"><![CDATA[<p>TypeScript 是一种由 <strong>Microsoft</strong> 开发的开源编程语言，它是 <strong>JavaScript 的超集</strong>，为 JavaScript 添加了可选的静态类型系统和现代语言特性。TypeScript 的目标是提高 JavaScript 代码的可维护性、可读性和开发效率，同时保持与 JavaScript 的完全兼容。</p><span id="more"></span><hr><h3 id="1-TypeScript-的核心特性"><a href="#1-TypeScript-的核心特性" class="headerlink" title="1. TypeScript 的核心特性"></a><strong>1. TypeScript 的核心特性</strong></h3><h4 id="1-静态类型检查"><a href="#1-静态类型检查" class="headerlink" title="(1) 静态类型检查"></a><strong>(1) 静态类型检查</strong></h4><ul><li><strong>类型注解</strong>：<br>允许开发者为变量、函数参数和返回值等添加类型注解，例如：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">count</span>: <span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>类型推断</strong>：<br>即使没有显式注解，TypeScript 也能根据上下文推断类型。</li></ul><h4 id="2-面向对象编程"><a href="#2-面向对象编程" class="headerlink" title="(2) 面向对象编程"></a><strong>(2) 面向对象编程</strong></h4><ul><li><strong>类与接口</strong>：<br>支持类、继承、接口等面向对象特性：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">makeSound</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">makeSound</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-现代-JavaScript-特性"><a href="#3-现代-JavaScript-特性" class="headerlink" title="(3) 现代 JavaScript 特性"></a><strong>(3) 现代 JavaScript 特性</strong></h4><ul><li><strong>ES6+ 支持</strong>：<br>TypeScript 支持最新的 JavaScript 特性（如箭头函数、解构赋值、模块化等），并将其编译为兼容性更好的 ES5 或更低版本。</li><li><strong>装饰器</strong>：<br>支持实验性装饰器语法，常用于 Angular 等框架。</li></ul><h4 id="4-工具支持"><a href="#4-工具支持" class="headerlink" title="(4) 工具支持"></a><strong>(4) 工具支持</strong></h4><ul><li><strong>强大的 IDE 支持</strong>：<br>TypeScript 提供了丰富的工具支持，如代码补全、类型检查、重构等，主流 IDE（如 VS Code）对 TypeScript 有原生支持。</li><li><strong>编译时错误检查</strong>：<br>在编译阶段捕获类型错误，减少运行时错误。</li></ul><hr><h3 id="2-TypeScript-的优势"><a href="#2-TypeScript-的优势" class="headerlink" title="2. TypeScript 的优势"></a><strong>2. TypeScript 的优势</strong></h3><h4 id="1-提高代码质量"><a href="#1-提高代码质量" class="headerlink" title="(1) 提高代码质量"></a><strong>(1) 提高代码质量</strong></h4><ul><li><strong>类型安全</strong>：<br>静态类型检查可以在编译阶段发现潜在的错误，减少运行时错误。</li><li><strong>代码可读性</strong>：<br>类型注解使代码更易于理解和维护。</li></ul><h4 id="2-提高开发效率"><a href="#2-提高开发效率" class="headerlink" title="(2) 提高开发效率"></a><strong>(2) 提高开发效率</strong></h4><ul><li><strong>智能提示</strong>：<br>IDE 可以根据类型信息提供更准确的代码补全和提示。</li><li><strong>重构支持</strong>：<br>类型信息使得重构代码更加安全和高效。</li></ul><h4 id="3-兼容性"><a href="#3-兼容性" class="headerlink" title="(3) 兼容性"></a><strong>(3) 兼容性</strong></h4><ul><li><strong>与 JavaScript 兼容</strong>：<br>TypeScript 是 JavaScript 的超集，任何合法的 JavaScript 代码都是合法的 TypeScript 代码。</li><li><strong>渐进式采用</strong>：<br>可以在现有 JavaScript 项目中逐步引入 TypeScript。</li></ul><hr><h3 id="3-TypeScript-的基本语法"><a href="#3-TypeScript-的基本语法" class="headerlink" title="3. TypeScript 的基本语法"></a><strong>3. TypeScript 的基本语法</strong></h3><h4 id="1-类型注解"><a href="#1-类型注解" class="headerlink" title="(1) 类型注解"></a><strong>(1) 类型注解</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">count</span>: <span class="built_in">number</span> = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;TypeScript&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="2-接口"><a href="#2-接口" class="headerlink" title="(2) 接口"></a><strong>(2) 接口</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    email?: <span class="built_in">string</span>;  <span class="comment">// 可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">user</span>: <span class="title class_">User</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-类"><a href="#3-类" class="headerlink" title="(3) 类"></a><strong>(3) 类</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">person.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure><h4 id="4-泛型"><a href="#4-泛型" class="headerlink" title="(4) 泛型"></a><strong>(4) 泛型</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="5-模块化"><a href="#5-模块化" class="headerlink" title="(5) 模块化"></a><strong>(5) 模块化</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><hr><h3 id="4-TypeScript-的工作流程"><a href="#4-TypeScript-的工作流程" class="headerlink" title="4. TypeScript 的工作流程"></a><strong>4. TypeScript 的工作流程</strong></h3><ol><li><strong>编写 TypeScript 代码</strong>：<br>使用 <code>.ts</code> 或 <code>.tsx</code> 文件编写代码。</li><li><strong>编译 TypeScript</strong>：<br>使用 TypeScript 编译器（<code>tsc</code>）将代码编译为 JavaScript：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc main.ts</span><br></pre></td></tr></table></figure></li><li><strong>运行 JavaScript</strong>：<br>执行生成的 <code>.js</code> 文件。</li></ol><hr><h3 id="5-TypeScript-的适用场景"><a href="#5-TypeScript-的适用场景" class="headerlink" title="5. TypeScript 的适用场景"></a><strong>5. TypeScript 的适用场景</strong></h3><ul><li><strong>大型项目</strong>：<br>类型系统有助于管理复杂的代码库。</li><li><strong>团队协作</strong>：<br>类型注解和接口定义可以提高团队协作效率。</li><li><strong>框架开发</strong>：<br>许多现代前端框架（如 Angular、Vue 3、React）都支持 TypeScript。</li><li><strong>渐进式迁移</strong>：<br>可以在现有 JavaScript 项目中逐步引入 TypeScript。</li></ul><hr><h3 id="6-TypeScript-与-JavaScript-的区别"><a href="#6-TypeScript-与-JavaScript-的区别" class="headerlink" title="6. TypeScript 与 JavaScript 的区别"></a><strong>6. TypeScript 与 JavaScript 的区别</strong></h3><table><thead><tr><th>特性</th><th>TypeScript</th><th>JavaScript</th></tr></thead><tbody><tr><td><strong>类型系统</strong></td><td>静态类型</td><td>动态类型</td></tr><tr><td><strong>编译</strong></td><td>需要编译为 JavaScript</td><td>直接运行</td></tr><tr><td><strong>工具支持</strong></td><td>强大的 IDE 支持</td><td>有限的工具支持</td></tr><tr><td><strong>学习曲线</strong></td><td>较高（需要学习类型系统）</td><td>较低</td></tr><tr><td><strong>适用场景</strong></td><td>大型项目、团队协作</td><td>小型项目、快速原型开发</td></tr></tbody></table><hr><h3 id="7-如何开始学习-TypeScript"><a href="#7-如何开始学习-TypeScript" class="headerlink" title="7. 如何开始学习 TypeScript"></a><strong>7. 如何开始学习 TypeScript</strong></h3><ol><li><strong>安装 TypeScript</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure></li><li><strong>编写第一个 TypeScript 程序</strong>：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.ts</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greet</span>(<span class="string">&quot;TypeScript&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><strong>编译并运行</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br><span class="line">node hello.js</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>TypeScript 是一种强大的编程语言，通过静态类型检查和现代语言特性，显著提升了 JavaScript 的开发效率和代码质量。它特别适合大型项目、团队协作以及对代码质量要求较高的场景。如果你已经熟悉 JavaScript，学习 TypeScript 将是一个自然且有益的进阶选择。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>what is mpx</title>
      <link href="/2025/03/15/what-is-mpx/"/>
      <url>/2025/03/15/what-is-mpx/</url>
      
        <content type="html"><![CDATA[<p>MPX 是一个 <strong>面向小程序开发的前端框架</strong>，由滴滴出行团队开源，专为提升小程序开发效率和性能而设计。它基于 Vue.js 的语法和特性，同时针对小程序的特点进行了深度优化和扩展。以下是 MPX 的核心特性和详细介绍：</p><span id="more"></span><hr><h3 id="1-MPX-的核心特性"><a href="#1-MPX-的核心特性" class="headerlink" title="1. MPX 的核心特性"></a><strong>1. MPX 的核心特性</strong></h3><h4 id="1-基于-Vue-js-语法"><a href="#1-基于-Vue-js-语法" class="headerlink" title="(1) 基于 Vue.js 语法"></a><strong>(1) 基于 Vue.js 语法</strong></h4><ul><li><strong>语法兼容</strong>：<br>MPX 支持 Vue.js 的模板语法、计算属性、侦听器、生命周期钩子等，开发者可以快速上手。</li><li><strong>响应式数据</strong>：<br>支持 Vue 风格的响应式数据绑定，简化状态管理。</li></ul><h4 id="2-多平台支持"><a href="#2-多平台支持" class="headerlink" title="(2) 多平台支持"></a><strong>(2) 多平台支持</strong></h4><ul><li><strong>跨平台开发</strong>：<br>MPX 支持将同一套代码编译到微信小程序、支付宝小程序、百度小程序、字节跳动小程序等多个平台。</li><li><strong>平台差异化处理</strong>：<br>提供平台特定的 API 和配置，方便处理不同平台的兼容性问题。</li></ul><h4 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="(3) 性能优化"></a><strong>(3) 性能优化</strong></h4><ul><li><strong>运行时优化</strong>：<br>通过减少不必要的 setData 调用和优化数据更新机制，提升小程序的运行性能。</li><li><strong>体积优化</strong>：<br>支持按需加载和代码分割，减小小程序包体积。</li></ul><h4 id="4-增强的开发体验"><a href="#4-增强的开发体验" class="headerlink" title="(4) 增强的开发体验"></a><strong>(4) 增强的开发体验</strong></h4><ul><li><strong>单文件组件</strong>：<br>支持 <code>.mpx</code> 单文件组件，将模板、脚本、样式封装在一个文件中，提升开发效率。</li><li><strong>TypeScript 支持</strong>：<br>提供完整的 TypeScript 支持，增强代码的可维护性和类型安全。</li><li><strong>插件系统</strong>：<br>支持丰富的插件生态，方便扩展功能（如状态管理、请求封装等）。</li></ul><h4 id="5-状态管理"><a href="#5-状态管理" class="headerlink" title="(5) 状态管理"></a><strong>(5) 状态管理</strong></h4><ul><li><strong>Vuex 支持</strong>：<br>内置 Vuex 支持，方便管理全局状态。</li><li><strong>轻量级状态管理</strong>：<br>提供更轻量的状态管理方案，适合小型项目。</li></ul><hr><h3 id="2-MPX-的核心架构"><a href="#2-MPX-的核心架构" class="headerlink" title="2. MPX 的核心架构"></a><strong>2. MPX 的核心架构</strong></h3><h4 id="1-编译时"><a href="#1-编译时" class="headerlink" title="(1) 编译时"></a><strong>(1) 编译时</strong></h4><ul><li><strong>模板编译</strong>：<br>将 <code>.mpx</code> 文件中的模板编译为小程序支持的 WXML。</li><li><strong>样式编译</strong>：<br>支持 Sass、Less 等预处理器，并将样式编译为小程序的 WXSS。</li><li><strong>脚本编译</strong>：<br>将 Vue.js 语法转换为小程序支持的 JS 代码。</li></ul><h4 id="2-运行时"><a href="#2-运行时" class="headerlink" title="(2) 运行时"></a><strong>(2) 运行时</strong></h4><ul><li><strong>响应式系统</strong>：<br>基于 Vue.js 的响应式系统，实现数据与视图的绑定。</li><li><strong>生命周期适配</strong>：<br>将 Vue.js 的生命周期钩子映射到小程序的生命周期中。</li></ul><h4 id="3-多平台适配"><a href="#3-多平台适配" class="headerlink" title="(3) 多平台适配"></a><strong>(3) 多平台适配</strong></h4><ul><li><strong>平台差异抹平</strong>：<br>通过统一的 API 和配置，抹平不同小程序平台的差异。</li><li><strong>条件编译</strong>：<br>支持条件编译，针对不同平台编写特定的代码逻辑。</li></ul><hr><h3 id="3-MPX-的使用场景"><a href="#3-MPX-的使用场景" class="headerlink" title="3. MPX 的使用场景"></a><strong>3. MPX 的使用场景</strong></h3><ul><li><strong>多平台小程序开发</strong>：<br>适合需要同时发布到多个小程序平台的项目。</li><li><strong>复杂业务逻辑</strong>：<br>适合需要复杂状态管理和组件化开发的场景。</li><li><strong>性能敏感项目</strong>：<br>适合对性能要求较高的小程序项目。</li></ul><hr><h3 id="4-MPX-的优缺点"><a href="#4-MPX-的优缺点" class="headerlink" title="4. MPX 的优缺点"></a><strong>4. MPX 的优缺点</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><strong>开发效率高</strong>：<br>基于 Vue.js 语法，学习成本低，开发效率高。</li><li><strong>跨平台支持</strong>：<br>一套代码多端运行，减少重复开发。</li><li><strong>性能优化</strong>：<br>针对小程序性能做了深度优化。</li><li><strong>生态丰富</strong>：<br>支持 TypeScript、Vuex 等现代前端工具。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li><strong>社区规模较小</strong>：<br>相比 Taro 和 uni-app，MPX 的社区和生态相对较小。</li><li><strong>平台兼容性</strong>：<br>虽然支持多平台，但在某些特定平台的兼容性上可能需要额外处理。</li></ul><hr><h3 id="5-MPX-与其他小程序框架对比"><a href="#5-MPX-与其他小程序框架对比" class="headerlink" title="5. MPX 与其他小程序框架对比"></a><strong>5. MPX 与其他小程序框架对比</strong></h3><table><thead><tr><th>特性</th><th>MPX</th><th>Taro</th><th>uni-app</th></tr></thead><tbody><tr><td><strong>语法基础</strong></td><td>Vue.js</td><td>React</td><td>Vue.js</td></tr><tr><td><strong>跨平台支持</strong></td><td>微信、支付宝、百度等</td><td>微信、支付宝、H5 等</td><td>微信、支付宝、H5、App 等</td></tr><tr><td><strong>性能优化</strong></td><td>深度优化</td><td>一般优化</td><td>一般优化</td></tr><tr><td><strong>生态丰富度</strong></td><td>中等</td><td>丰富</td><td>丰富</td></tr><tr><td><strong>学习成本</strong></td><td>低（Vue.js 开发者）</td><td>中（React 开发者）</td><td>低（Vue.js 开发者）</td></tr></tbody></table><hr><h3 id="6-快速上手-MPX"><a href="#6-快速上手-MPX" class="headerlink" title="6. 快速上手 MPX"></a><strong>6. 快速上手 MPX</strong></h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="(1) 安装"></a><strong>(1) 安装</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @mpxjs/cli -g</span><br></pre></td></tr></table></figure><h4 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="(2) 创建项目"></a><strong>(2) 创建项目</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpx init my-project</span><br></pre></td></tr></table></figure><h4 id="3-开发与构建"><a href="#3-开发与构建" class="headerlink" title="(3) 开发与构建"></a><strong>(3) 开发与构建</strong></h4><ul><li>开发模式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run watch</span><br></pre></td></tr></table></figure></li><li>生产构建：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="(4) 示例代码"></a><strong>(4) 示例代码</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">tap</span>=<span class="string">&quot;changeMessage&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; createComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;@mpxjs/core&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">createComponent</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">message</span>: <span class="string">&#x27;Hello MPX!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">changeMessage</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;你好，MPX！&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>MPX 是一个专注于小程序开发的 Vue.js 风格框架，具有跨平台支持、性能优化和开发效率高等特点。它适合需要多平台发布、复杂业务逻辑和性能敏感的小程序项目。如果你已经是 Vue.js 开发者，MPX 将是一个快速上手且高效的选择。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高性能std::string实现分析</title>
      <link href="/2025/01/27/high-performance-string-implementation/"/>
      <url>/2025/01/27/high-performance-string-implementation/</url>
      
        <content type="html"><![CDATA[<h1 id="高性能std-string实现分析"><a href="#高性能std-string实现分析" class="headerlink" title="高性能std::string实现分析"></a>高性能std::string实现分析</h1><h2 id="1-字符串存储策略"><a href="#1-字符串存储策略" class="headerlink" title="1. 字符串存储策略"></a>1. 字符串存储策略</h2><span id="more"></span><h3 id="1-1-小字符串优化（SSO）"><a href="#1-1-小字符串优化（SSO）" class="headerlink" title="1.1 小字符串优化（SSO）"></a>1.1 小字符串优化（SSO）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> SSO_SIZE = <span class="number">15</span>;  <span class="comment">// 典型值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="type">char</span>* data;</span><br><span class="line">            <span class="type">size_t</span> size;</span><br><span class="line">            <span class="type">size_t</span> capacity;</span><br><span class="line">        &#125; heap;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="type">char</span> data[SSO_SIZE + <span class="number">1</span>];</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> size;</span><br><span class="line">        &#125; stack;</span><br><span class="line">    &#125; storage;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_sso</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> storage.stack.size &lt; SSO_SIZE; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>优势</strong>：</p><ul><li>避免小字符串的堆分配</li><li>减少内存碎片</li><li>提高缓存局部性</li></ul><h3 id="1-2-中长字符串处理"><a href="#1-2-中长字符串处理" class="headerlink" title="1.2 中长字符串处理"></a>1.2 中长字符串处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="comment">// 堆分配策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">grow</span><span class="params">(<span class="type">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> new_size = std::<span class="built_in">max</span>(</span><br><span class="line">            new_capacity,</span><br><span class="line">            <span class="built_in">capacity</span>() * <span class="number">2</span>  <span class="comment">// 2倍增长策略</span></span><br><span class="line">        );</span><br><span class="line">        <span class="type">char</span>* new_data = <span class="built_in">allocate</span>(new_size);</span><br><span class="line">        <span class="built_in">memcpy</span>(new_data, <span class="built_in">data</span>(), <span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">deallocate</span>(<span class="built_in">data</span>());</span><br><span class="line">        storage.heap.data = new_data;</span><br><span class="line">        storage.heap.capacity = new_size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-引用计数优化"><a href="#2-引用计数优化" class="headerlink" title="2. 引用计数优化"></a>2. 引用计数优化</h2><h3 id="2-1-共享字符串实现"><a href="#2-1-共享字符串实现" class="headerlink" title="2.1 共享字符串实现"></a>2.1 共享字符串实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SharedData</span> &#123;</span><br><span class="line">        std::atomic&lt;<span class="type">size_t</span>&gt; ref_count;</span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">        <span class="type">size_t</span> capacity;</span><br><span class="line">        <span class="type">char</span> data[<span class="number">1</span>];  <span class="comment">// 柔性数组</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    SharedData* shared;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_ref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shared) &#123;</span><br><span class="line">            shared-&gt;ref_count.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shared &amp;&amp; shared-&gt;ref_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_acq_rel) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">deallocate</span>(shared);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-2-写时复制（COW）"><a href="#2-2-写时复制（COW）" class="headerlink" title="2.2 写时复制（COW）"></a>2.2 写时复制（COW）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ensure_unique</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shared &amp;&amp; shared-&gt;ref_count.<span class="built_in">load</span>(std::memory_order_acquire) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            SharedData* new_data = <span class="built_in">allocate</span>(<span class="built_in">size</span>());</span><br><span class="line">            <span class="built_in">memcpy</span>(new_data-&gt;data, shared-&gt;data, <span class="built_in">size</span>());</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            shared = new_data;</span><br><span class="line">            shared-&gt;ref_count.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-字面量优化"><a href="#3-字面量优化" class="headerlink" title="3. 字面量优化"></a>3. 字面量优化</h2><h3 id="3-1-字符串字面量处理"><a href="#3-1-字符串字面量处理" class="headerlink" title="3.1 字符串字面量处理"></a>3.1 字符串字面量处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="comment">// 字面量优化</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function">    <span class="title">string</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;str)[N])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt;= SSO_SIZE) &#123;</span><br><span class="line">            <span class="comment">// 使用SSO</span></span><br><span class="line">            <span class="built_in">memcpy</span>(storage.stack.data, str, N);</span><br><span class="line">            storage.stack.size = N;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 堆分配</span></span><br><span class="line">            storage.heap.data = <span class="built_in">allocate</span>(N);</span><br><span class="line">            <span class="built_in">memcpy</span>(storage.heap.data, str, N);</span><br><span class="line">            storage.heap.size = N;</span><br><span class="line">            storage.heap.capacity = N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-字符串视图"><a href="#3-2-字符串视图" class="headerlink" title="3.2 字符串视图"></a>3.2 字符串视图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string_view</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* data_;</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 零拷贝构造</span></span><br><span class="line">    <span class="built_in">string_view</span>(<span class="type">const</span> string&amp; str) </span><br><span class="line">        : <span class="built_in">data_</span>(str.<span class="built_in">data</span>()), <span class="built_in">size_</span>(str.<span class="built_in">size</span>()) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-内存管理优化"><a href="#4-内存管理优化" class="headerlink" title="4. 内存管理优化"></a>4. 内存管理优化</h2><h3 id="4-1-内存池"><a href="#4-1-内存池" class="headerlink" title="4.1 内存池"></a>4.1 内存池</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringPool</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> BLOCK_SIZE = <span class="number">4096</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">        <span class="type">char</span>* data;</span><br><span class="line">        <span class="type">size_t</span> used;</span><br><span class="line">        Block* next;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Block* current_block;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (current_block-&gt;used + size &gt; BLOCK_SIZE) &#123;</span><br><span class="line">            <span class="built_in">allocate_new_block</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>* ptr = current_block-&gt;data + current_block-&gt;used;</span><br><span class="line">        current_block-&gt;used += size;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-2-对齐优化"><a href="#4-2-对齐优化" class="headerlink" title="4.2 对齐优化"></a>4.2 对齐优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> ALIGNMENT = <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> aligned_size = (size + ALIGNMENT - <span class="number">1</span>) &amp; ~(ALIGNMENT - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="built_in">aligned_alloc</span>(ALIGNMENT, aligned_size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-性能优化技巧"><a href="#5-性能优化技巧" class="headerlink" title="5. 性能优化技巧"></a>5. 性能优化技巧</h2><h3 id="5-1-移动语义"><a href="#5-1-移动语义" class="headerlink" title="5.1 移动语义"></a>5.1 移动语义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="built_in">string</span>(string&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.<span class="built_in">is_sso</span>()) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(storage.stack.data, other.storage.stack.data, other.<span class="built_in">size</span>());</span><br><span class="line">            storage.stack.size = other.storage.stack.size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            storage.heap = other.storage.heap;</span><br><span class="line">            other.storage.heap.data = <span class="literal">nullptr</span>;</span><br><span class="line">            other.storage.heap.size = <span class="number">0</span>;</span><br><span class="line">            other.storage.heap.capacity = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-2-预留空间"><a href="#5-2-预留空间" class="headerlink" title="5.2 预留空间"></a>5.2 预留空间</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (new_capacity &gt; <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_sso</span>() &amp;&amp; new_capacity &lt;= SSO_SIZE) &#123;</span><br><span class="line">                <span class="keyword">return</span>;  <span class="comment">// 已经在栈上，且空间足够</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">grow</span>(new_capacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-线程安全考虑"><a href="#6-线程安全考虑" class="headerlink" title="6. 线程安全考虑"></a>6. 线程安全考虑</h2><h3 id="6-1-引用计数原子操作"><a href="#6-1-引用计数原子操作" class="headerlink" title="6.1 引用计数原子操作"></a>6.1 引用计数原子操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SharedData</span> &#123;</span><br><span class="line">        std::atomic&lt;<span class="type">size_t</span>&gt; ref_count;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_ref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shared) &#123;</span><br><span class="line">            shared-&gt;ref_count.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-2-写时复制线程安全"><a href="#6-2-写时复制线程安全" class="headerlink" title="6.2 写时复制线程安全"></a>6.2 写时复制线程安全</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ensure_unique</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shared) &#123;</span><br><span class="line">            <span class="type">size_t</span> refs = shared-&gt;ref_count.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            <span class="keyword">if</span> (refs &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建新副本</span></span><br><span class="line">                SharedData* new_data = <span class="built_in">allocate</span>(<span class="built_in">size</span>());</span><br><span class="line">                <span class="built_in">memcpy</span>(new_data-&gt;data, shared-&gt;data, <span class="built_in">size</span>());</span><br><span class="line">                <span class="built_in">release</span>();</span><br><span class="line">                shared = new_data;</span><br><span class="line">                shared-&gt;ref_count.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-性能测试指标"><a href="#7-性能测试指标" class="headerlink" title="7. 性能测试指标"></a>7. 性能测试指标</h2><h3 id="7-1-内存使用"><a href="#7-1-内存使用" class="headerlink" title="7.1 内存使用"></a>7.1 内存使用</h3><ul><li>小字符串（&lt;16字节）：栈存储，零堆分配</li><li>中字符串（16-64字节）：单次堆分配</li><li>大字符串（&gt;64字节）：多次堆分配</li></ul><h3 id="7-2-操作性能"><a href="#7-2-操作性能" class="headerlink" title="7.2 操作性能"></a>7.2 操作性能</h3><ul><li>构造/析构：O(1) 小字符串，O(n) 大字符串</li><li>复制：O(1) 引用计数，O(n) 写时复制</li><li>修改：O(1) 小字符串，O(n) 大字符串</li></ul><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>高性能std::string实现需要综合考虑多个方面：</p><ol><li>小字符串优化（SSO）减少堆分配</li><li>引用计数优化内存使用</li><li>字面量处理提高构造效率</li><li>内存管理优化减少碎片</li><li>移动语义提升性能</li><li>线程安全保证正确性</li></ol><p>通过合理使用这些技术，可以在保证功能正确性的同时，显著提升字符串操作的性能。 </p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端SSAO实现方案分析</title>
      <link href="/2025/01/27/mobile-ssao-implementation/"/>
      <url>/2025/01/27/mobile-ssao-implementation/</url>
      
        <content type="html"><![CDATA[<h1 id="移动端SSAO实现方案分析"><a href="#移动端SSAO实现方案分析" class="headerlink" title="移动端SSAO实现方案分析"></a>移动端SSAO实现方案分析</h1><h2 id="1-核心依赖"><a href="#1-核心依赖" class="headerlink" title="1. 核心依赖"></a>1. 核心依赖</h2><span id="more"></span><h3 id="1-1-G-Buffer渲染"><a href="#1-1-G-Buffer渲染" class="headerlink" title="1.1 G-Buffer渲染"></a>1.1 G-Buffer渲染</h3><ul><li><strong>深度缓冲区（Depth Buffer）</strong>：用于重建世界空间位置</li><li><strong>法线缓冲区（Normal Buffer）</strong>：存储视空间或世界空间法线</li><li><strong>可选的位置缓冲区</strong>：直接存储位置，避免重建计算</li></ul><h3 id="1-2-相机参数"><a href="#1-2-相机参数" class="headerlink" title="1.2 相机参数"></a>1.2 相机参数</h3><ul><li>投影矩阵：屏幕空间到视空间的转换</li><li>视图矩阵：世界空间到视空间转换</li><li>近远平面参数：深度值线性化</li></ul><h2 id="2-移动端优化方案"><a href="#2-移动端优化方案" class="headerlink" title="2. 移动端优化方案"></a>2. 移动端优化方案</h2><h3 id="2-1-简化的采样策略"><a href="#2-1-简化的采样策略" class="headerlink" title="2.1 简化的采样策略"></a>2.1 简化的采样策略</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 减少采样点数量（桌面端通常64个，移动端8-16个）</span></span><br><span class="line"><span class="keyword">const</span> <span class="type">int</span> SAMPLE_COUNT = <span class="number">12</span>;</span><br><span class="line"><span class="type">vec3</span> samples[SAMPLE_COUNT] = &#123;</span><br><span class="line">    <span class="type">vec3</span>(<span class="number">0.04</span>, <span class="number">0.04</span>, <span class="number">0.02</span>),</span><br><span class="line">    <span class="type">vec3</span>(<span class="number">-0.08</span>, <span class="number">0.05</span>, <span class="number">0.03</span>),</span><br><span class="line">    <span class="comment">// ... 更多采样点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-2-分辨率降级"><a href="#2-2-分辨率降级" class="headerlink" title="2.2 分辨率降级"></a>2.2 分辨率降级</h3><ul><li>半分辨率渲染：在屏幕分辨率的1/2进行SSAO计算</li><li>四分之一分辨率：极端性能要求下使用1/4分辨率</li><li>双线性上采样：将低分辨率结果上采样到全分辨率</li></ul><h3 id="2-3-深度重建优化"><a href="#2-3-深度重建优化" class="headerlink" title="2.3 深度重建优化"></a>2.3 深度重建优化</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> reconstructViewPos(<span class="type">vec2</span> uv, <span class="type">float</span> depth) &#123;</span><br><span class="line">    <span class="type">vec4</span> clipPos = <span class="type">vec4</span>(uv * <span class="number">2.0</span> - <span class="number">1.0</span>, depth, <span class="number">1.0</span>);</span><br><span class="line">    <span class="type">vec4</span> viewPos = u_invProjection * clipPos;</span><br><span class="line">    <span class="keyword">return</span> viewPos.xyz / viewPos.w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-移动端特定优化"><a href="#3-移动端特定优化" class="headerlink" title="3. 移动端特定优化"></a>3. 移动端特定优化</h2><h3 id="3-1-自适应采样半径"><a href="#3-1-自适应采样半径" class="headerlink" title="3.1 自适应采样半径"></a>3.1 自适应采样半径</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> getAdaptiveRadius(<span class="type">float</span> viewDepth) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(minRadius, maxRadius, <span class="number">1.0</span> / (<span class="number">1.0</span> + viewDepth * <span class="number">0.1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-分层SSAO"><a href="#3-2-分层SSAO" class="headerlink" title="3.2 分层SSAO"></a>3.2 分层SSAO</h3><ul><li>近景高质量：对近距离物体使用更多采样点</li><li>远景简化：远距离物体使用简化算法或跳过处理</li></ul><h3 id="3-3-时间分片"><a href="#3-3-时间分片" class="headerlink" title="3.3 时间分片"></a>3.3 时间分片</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TemporalSSAO</span> &#123;</span><br><span class="line">    <span class="type">int</span> currentTile = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> tilesPerFrame = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">renderFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">renderSSAOTile</span>(currentTile, tilesPerFrame);</span><br><span class="line">        currentTile = (currentTile + <span class="number">1</span>) % totalTiles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-内存和带宽优化"><a href="#4-内存和带宽优化" class="headerlink" title="4. 内存和带宽优化"></a>4. 内存和带宽优化</h2><h3 id="4-1-纹理格式优化"><a href="#4-1-纹理格式优化" class="headerlink" title="4.1 纹理格式优化"></a>4.1 纹理格式优化</h3><ul><li>R8格式：AO值只需要单通道</li><li>压缩纹理：使用ETC2/ASTC压缩法线纹理</li><li>打包存储：将多个值打包到单个纹理通道</li></ul><h3 id="4-2-渲染目标管理"><a href="#4-2-渲染目标管理" class="headerlink" title="4.2 渲染目标管理"></a>4.2 渲染目标管理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RenderTarget ssaoRT = <span class="built_in">createRT</span>(width/<span class="number">2</span>, height/<span class="number">2</span>, R8_UNORM);</span><br><span class="line">RenderTarget blurRT = ssaoRT; <span class="comment">// 乒乓缓冲复用</span></span><br></pre></td></tr></table></figure><h2 id="5-质量与性能平衡"><a href="#5-质量与性能平衡" class="headerlink" title="5. 质量与性能平衡"></a>5. 质量与性能平衡</h2><h3 id="5-1-LOD系统集成"><a href="#5-1-LOD系统集成" class="headerlink" title="5.1 LOD系统集成"></a>5.1 LOD系统集成</h3><ul><li>距离衰减：根据相机距离调整SSAO强度</li><li>重要性采样：对重要物体使用高质量SSAO</li></ul><h3 id="5-2-动态质量调整"><a href="#5-2-动态质量调整" class="headerlink" title="5.2 动态质量调整"></a>5.2 动态质量调整</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdaptiveSSAO</span> &#123;</span><br><span class="line">    <span class="type">float</span> targetFrameTime = <span class="number">16.67f</span>; <span class="comment">// 60fps</span></span><br><span class="line">    <span class="type">int</span> currentSampleCount = <span class="number">12</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjustQuality</span><span class="params">(<span class="type">float</span> frameTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (frameTime &gt; targetFrameTime * <span class="number">1.1f</span>) &#123;</span><br><span class="line">            currentSampleCount = <span class="built_in">max</span>(<span class="number">8</span>, currentSampleCount - <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameTime &lt; targetFrameTime * <span class="number">0.9f</span>) &#123;</span><br><span class="line">            currentSampleCount = <span class="built_in">min</span>(<span class="number">16</span>, currentSampleCount + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-移动端特殊考虑"><a href="#6-移动端特殊考虑" class="headerlink" title="6. 移动端特殊考虑"></a>6. 移动端特殊考虑</h2><h3 id="6-1-功耗优化"><a href="#6-1-功耗优化" class="headerlink" title="6.1 功耗优化"></a>6.1 功耗优化</h3><ul><li>Early-Z优化：利用移动GPU的Early-Z特性</li><li>Shader分支减少：避免动态分支，使用预编译变体</li></ul><h3 id="6-2-带宽敏感优化"><a href="#6-2-带宽敏感优化" class="headerlink" title="6.2 带宽敏感优化"></a>6.2 带宽敏感优化</h3><ul><li>就地模糊：在同一个Pass中完成AO计算和模糊</li><li>单Pass实现：将多个步骤合并到单个着色器</li></ul><h3 id="6-3-兼容性处理"><a href="#6-3-兼容性处理" class="headerlink" title="6.3 兼容性处理"></a>6.3 兼容性处理</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line">    <span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line">    <span class="meta">#define SAMPLE_COUNT 8</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="meta">#define SAMPLE_COUNT 16</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h2 id="7-实现流程"><a href="#7-实现流程" class="headerlink" title="7. 实现流程"></a>7. 实现流程</h2><ol><li>G-Buffer Pass：渲染深度和法线</li><li>SSAO Pass：在降级分辨率下计算AO</li><li>模糊Pass：边缘保持模糊（可选）</li><li>上采样Pass：恢复到全分辨率</li><li>合成Pass：与最终渲染结果混合</li></ol><h2 id="8-性能指标"><a href="#8-性能指标" class="headerlink" title="8. 性能指标"></a>8. 性能指标</h2><ul><li>采样点数：8-16个（vs桌面端32-64个）</li><li>渲染分辨率：1/2到1/4屏幕分辨率</li><li>GPU时间：目标控制在1-2ms内</li><li>内存占用：额外2-4MB纹理内存</li></ul><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>移动端SSAO实现需要在视觉效果和性能之间找到平衡点。通过合理的优化策略，包括采样点减少、分辨率降级、自适应质量调整等技术，可以在移动设备上实现可接受的SSAO效果，同时保持稳定的帧率表现。关键是要根据具体项目的性能要求和目标设备来选择合适的优化方案。 </p>]]></content>
      
      
      <categories>
          
          <category> 图形渲染 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> SSAO </tag>
            
            <tag> 移动端优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM-64架构中寄存器</title>
      <link href="/2024/12/19/%E5%AF%84%E5%AD%98%E5%99%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/12/19/%E5%AF%84%E5%AD%98%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>让我详细解释ARM-64架构中这些寄存器的用途：</p><h2 id="核心寄存器"><a href="#核心寄存器" class="headerlink" title="核心寄存器"></a>核心寄存器</h2><span id="more"></span><h3 id="1-程序控制寄存器"><a href="#1-程序控制寄存器" class="headerlink" title="1. 程序控制寄存器"></a>1. <strong>程序控制寄存器</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cpsr: 0x0000000060001000    // Current Program Status Register</span><br><span class="line">                              // 当前程序状态寄存器，包含条件标志位</span><br><span class="line">                              // 0x60001000 表示某些条件位被设置</span><br><span class="line"></span><br><span class="line">pc: 0x00000001054a6ae8      // Program Counter</span><br><span class="line">                             // 程序计数器，指向当前执行的指令地址</span><br><span class="line">                             // 崩溃发生的位置</span><br><span class="line"></span><br><span class="line">lr: 0x0000000108836b94      // Link Register</span><br><span class="line">                             // 链接寄存器，存储函数返回地址</span><br></pre></td></tr></table></figure><h3 id="2-栈和帧指针"><a href="#2-栈和帧指针" class="headerlink" title="2. 栈和帧指针"></a>2. <strong>栈和帧指针</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sp: 0x000000016bb92220      // Stack Pointer</span><br><span class="line">                             // 栈指针，指向当前栈顶</span><br><span class="line"></span><br><span class="line">fp: 0x000000016bb92230      // Frame Pointer (x29)</span><br><span class="line">                             // 帧指针，指向当前函数栈帧</span><br></pre></td></tr></table></figure><h2 id="通用寄存器-x0-x30"><a href="#通用寄存器-x0-x30" class="headerlink" title="通用寄存器 (x0-x30)"></a>通用寄存器 (x0-x30)</h2><h3 id="3-参数和返回值寄存器"><a href="#3-参数和返回值寄存器" class="headerlink" title="3. 参数和返回值寄存器"></a>3. <strong>参数和返回值寄存器</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x0: 0x0000000000000000      // 函数第一个参数 / 返回值 / this指针</span><br><span class="line">x1: 0x0000000000000001      // 函数第二个参数</span><br><span class="line">x2: 0x0000000108836b94      // 函数第三个参数</span><br><span class="line">x3: 0xfffff0007fc00000      // 函数第四个参数</span><br><span class="line">x4: 0x0000000163e766c0      // 函数第五个参数</span><br><span class="line">x5: 0x0000000000000000      // 函数第六个参数</span><br><span class="line">x6: 0x0000000000068974      // 函数第七个参数</span><br><span class="line">x7: 0xb89fc74d8831dffe      // 函数第八个参数</span><br></pre></td></tr></table></figure><h3 id="4-临时寄存器"><a href="#4-临时寄存器" class="headerlink" title="4. 临时寄存器"></a>4. <strong>临时寄存器</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x8: 0x0000000000000000      // 临时寄存器 / 间接结果寄存器</span><br><span class="line">x9: 0x0000000000000001      // 临时寄存器</span><br><span class="line">x10: 0x0000000000000000     // 临时寄存器</span><br><span class="line">x11: 0x0000000000000000     // 临时寄存器</span><br><span class="line">x12: 0x001490a400422a64     // 临时寄存器</span><br><span class="line">x13: 0x001480a380422268     // 临时寄存器</span><br><span class="line">x14: 0x0000000000022800     // 临时寄存器</span><br><span class="line">x15: 0x0000000000000010     // 临时寄存器</span><br></pre></td></tr></table></figure><h3 id="5-平台寄存器"><a href="#5-平台寄存器" class="headerlink" title="5. 平台寄存器"></a>5. <strong>平台寄存器</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x16: 0x0000000224613f24     // 平台寄存器 (IP0)</span><br><span class="line">x17: 0x00000001480a3a68     // 平台寄存器 (IP1)</span><br><span class="line">x18: 0x0000000000000000     // 平台寄存器 (PR)</span><br></pre></td></tr></table></figure><h3 id="6-被调用者保存寄存器"><a href="#6-被调用者保存寄存器" class="headerlink" title="6. 被调用者保存寄存器"></a>6. <strong>被调用者保存寄存器</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x19: 0x0000000163e766f8     // 被调用者保存寄存器</span><br><span class="line">x20: 0x0000000163e766d8     // 被调用者保存寄存器</span><br><span class="line">x21: 0x000000013d0c6720     // 被调用者保存寄存器</span><br><span class="line">x22: 0x000000010b3c3000     // 被调用者保存寄存器</span><br><span class="line">x23: 0x0000000204d00dc0     // 被调用者保存寄存器</span><br><span class="line">x24: 0x0000000163e76740     // 被调用者保存寄存器</span><br><span class="line">x25: 0x0000000163e76980     // 被调用者保存寄存器</span><br><span class="line">x26: 0x0000000000000114     // 被调用者保存寄存器</span><br><span class="line">x27: 0x0000000000000000     // 被调用者保存寄存器</span><br><span class="line">x28: 0xffffffff76ffffff     // 被调用者保存寄存器</span><br></pre></td></tr></table></figure><h3 id="7-帧指针"><a href="#7-帧指针" class="headerlink" title="7. 帧指针"></a>7. <strong>帧指针</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x29: 0x000000016bb92230     // Frame Pointer (fp)</span><br><span class="line">                             // 帧指针，与fp相同</span><br></pre></td></tr></table></figure><h2 id="寄存器分类总结"><a href="#寄存器分类总结" class="headerlink" title="寄存器分类总结"></a>寄存器分类总结</h2><h3 id="1-特殊用途寄存器"><a href="#1-特殊用途寄存器" class="headerlink" title="1. 特殊用途寄存器"></a>1. <strong>特殊用途寄存器</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pc   - 程序计数器</span><br><span class="line">lr   - 链接寄存器</span><br><span class="line">sp   - 栈指针</span><br><span class="line">fp   - 帧指针</span><br><span class="line">cpsr - 程序状态寄存器</span><br></pre></td></tr></table></figure><h3 id="2-参数传递寄存器"><a href="#2-参数传递寄存器" class="headerlink" title="2. 参数传递寄存器"></a>2. <strong>参数传递寄存器</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x0-x7 - 函数参数传递</span><br></pre></td></tr></table></figure><h3 id="3-临时寄存器"><a href="#3-临时寄存器" class="headerlink" title="3. 临时寄存器"></a>3. <strong>临时寄存器</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x8-x15 - 临时计算和中间结果</span><br></pre></td></tr></table></figure><h3 id="4-平台寄存器"><a href="#4-平台寄存器" class="headerlink" title="4. 平台寄存器"></a>4. <strong>平台寄存器</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x16-x17 - 平台特定用途</span><br><span class="line">x18     - 平台保留寄存器</span><br></pre></td></tr></table></figure><h3 id="5-被调用者保存寄存器"><a href="#5-被调用者保存寄存器" class="headerlink" title="5. 被调用者保存寄存器"></a>5. <strong>被调用者保存寄存器</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x19-x28 - 函数调用间保持值</span><br></pre></td></tr></table></figure><h3 id="6-栈和帧指针"><a href="#6-栈和帧指针" class="headerlink" title="6. 栈和帧指针"></a>6. <strong>栈和帧指针</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x29 - 帧指针</span><br><span class="line">x30 - 链接寄存器 (lr)</span><br></pre></td></tr></table></figure><h2 id="在你的崩溃案例中"><a href="#在你的崩溃案例中" class="headerlink" title="在你的崩溃案例中"></a>在你的崩溃案例中</h2><h3 id="关键信息"><a href="#关键信息" class="headerlink" title="关键信息"></a>关键信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x0: 0x0000000000000000    // this指针为空</span><br><span class="line">x1: 0x0000000000000001    // enable参数为true</span><br><span class="line">pc: 0x00000001054a6ae8    // 崩溃位置</span><br><span class="line">lr: 0x0000000108836b94    // 返回地址</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li><strong>x0为0</strong>：确认this指针为空</li><li><strong>x1为1</strong>：enable参数为true</li><li><strong>pc和lr</strong>：可以用于定位崩溃位置和调用栈</li><li><strong>其他寄存器</strong>：包含函数执行时的临时值和上下文信息</li></ol><p>这些寄存器状态完整记录了崩溃时刻的程序状态，是调试的重要信息。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>命令行通配符</title>
      <link href="/2024/11/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
      <url>/2024/11/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="这是因为-shell-中的通配符（-）展开行为不同："><a href="#这是因为-shell-中的通配符（-）展开行为不同：" class="headerlink" title="这是因为 shell 中的通配符（*）展开行为不同："></a>这是因为 shell 中的通配符（<code>*</code>）展开行为不同：</h3><ol><li><code>unzip *.zip</code>：</li></ol><ul><li>shell 会先展开 <code>*.zip</code>，如果当前目录有多个 zip 文件</li><li>命令会变成 <code>unzip file1.zip file2.zip file3.zip</code></li><li>这可能导致 unzip 命令收到多个参数而报错</li></ul><span id="more"></span><ol start="2"><li><code>unzip &quot;*.zip&quot;</code>：</li></ol><ul><li>引号阻止了 shell 展开通配符</li><li>通配符会直接传递给 unzip 命令</li><li>unzip 命令自己处理通配符匹配</li></ul><h3 id="正确的写法有几种："><a href="#正确的写法有几种：" class="headerlink" title="正确的写法有几种："></a>正确的写法有几种：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：使用引号</span></span><br><span class="line">unzip <span class="string">&quot;*.zip&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：使用转义</span></span><br><span class="line">unzip \*.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3：使用循环处理多个文件</span></span><br><span class="line"><span class="keyword">for</span> zip <span class="keyword">in</span> *.zip; <span class="keyword">do</span></span><br><span class="line">    unzip <span class="string">&quot;<span class="variable">$zip</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法4：使用find命令</span></span><br><span class="line">find . -name <span class="string">&quot;*.zip&quot;</span> -<span class="built_in">exec</span> unzip &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>如果需要更健壮的处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压所有zip文件</span></span><br><span class="line"><span class="function"><span class="title">unzip_all</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> zip_files=( *.zip )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查是否存在zip文件</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -e <span class="string">&quot;<span class="variable">$&#123;zip_files[0]&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;没有找到zip文件&quot;</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 逐个解压</span></span><br><span class="line">    <span class="keyword">for</span> zip <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;zip_files[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;解压: <span class="variable">$zip</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> ! unzip <span class="string">&quot;<span class="variable">$zip</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;解压失败: <span class="variable">$zip</span>&quot;</span></span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则与通配符区别</title>
      <link href="/2024/10/11/%E6%AD%A3%E5%88%99%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/10/11/%E6%AD%A3%E5%88%99%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>正则表达式（Regular Expressions）和通配符（Wildcards）都是用于模式匹配的工具，但它们在功能、语法和应用场景上有显著的区别。以下是它们之间的主要区别：</p><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><span id="more"></span><ul><li><strong>正则表达式</strong>:<ul><li>正则表达式是一种用于描述字符串模式的强大工具，允许复杂的匹配规则。它可以用于查找、替换和验证字符串。</li></ul></li><li><strong>通配符</strong>:<ul><li>通配符是一种简单的模式匹配符号，通常用于文件名匹配或简单的字符串匹配。它们的功能相对较简单。</li></ul></li></ul><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h3><ul><li><p><strong>正则表达式</strong>:</p><ul><li>正则表达式使用特定的语法来定义模式，包括字符类、量词、边界匹配、分组等。例如：<ul><li><code>^abc</code>：匹配以 “abc” 开头的字符串。</li><li><code>\d</code>：匹配任何数字字符。</li><li><code>.*</code>：匹配任意字符（包括空字符）零次或多次。</li></ul></li></ul></li><li><p><strong>通配符</strong>:</p><ul><li>通配符通常使用简单的符号来表示匹配模式：<ul><li><code>*</code>：匹配零个或多个字符。</li><li><code>?</code>：匹配一个字符。</li><li><code>[]</code>：匹配括号内的任意一个字符（例如，<code>[abc]</code> 匹配 “a”、”b” 或 “c”）。</li></ul></li></ul></li></ul><h3 id="3-功能"><a href="#3-功能" class="headerlink" title="3. 功能"></a>3. 功能</h3><ul><li><p><strong>正则表达式</strong>:</p><ul><li>正则表达式功能强大，支持复杂的匹配规则、分组、反向引用、替换等操作。可以用于文本处理、数据验证、搜索引擎等多种场景。</li></ul></li><li><p><strong>通配符</strong>:</p><ul><li>通配符功能相对简单，主要用于文件系统中的文件名匹配（如在命令行中使用）或简单的字符串匹配。它们不支持复杂的匹配规则。</li></ul></li></ul><h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h3><ul><li><p><strong>正则表达式</strong>:</p><ul><li>常用于编程语言（如 Python、Java、JavaScript、C++ 等）中的字符串处理、数据验证（如电子邮件、电话号码格式）、文本搜索和替换等。</li></ul></li><li><p><strong>通配符</strong>:</p><ul><li>常用于文件系统操作（如在命令行中查找文件）、数据库查询（如 SQL 中的 LIKE 操作）等。</li></ul></li></ul><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h3><ul><li><p><strong>正则表达式示例</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[A-Za-z0-9]+@[A-Za-z]+\.[A-Za-z]&#123;2,&#125;$</span><br></pre></td></tr></table></figure><ul><li>这个正则表达式用于匹配电子邮件地址。</li></ul></li><li><p><strong>通配符示例</strong>:</p><ul><li><code>*.txt</code>：匹配所有以 <code>.txt</code> 结尾的文件。</li><li><code>file?.jpg</code>：匹配 <code>file1.jpg</code>、<code>file2.jpg</code> 等文件，但不匹配 <code>file10.jpg</code>。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>正则表达式</strong> 是一种功能强大的模式匹配工具，适用于复杂的字符串处理和验证。</li><li><strong>通配符</strong> 是一种简单的模式匹配符号，主要用于文件名匹配和简单的字符串匹配。</li></ul><p>根据具体的需求选择合适的工具，可以更有效地完成字符串匹配和处理任务。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>std::nth_element实现</title>
      <link href="/2024/10/08/std-nth-element%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/10/08/std-nth-element%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><code>std::nth_element</code> 是 C++ 标准库中的一个算法，用于在一个范围内重新排列元素，使得第 <code>n</code> 个元素位于其最终位置，并且该元素左侧的所有元素都小于或等于它，右侧的所有元素都大于或等于它。这个算法的时间复杂度为 O(n) 平均情况下，最坏情况下为 O(n^2)。</p><span id="more"></span><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><code>std::nth_element</code> 的实现通常基于快速选择算法（Quickselect），这是一个选择算法，类似于快速排序。其基本思路如下：</p><ol><li><strong>选择一个基准元素</strong>: 从数组中选择一个基准元素（pivot）。</li><li><strong>分区</strong>: 将数组分为两部分：小于基准元素的部分和大于基准元素的部分。</li><li><strong>递归选择</strong>: 根据基准元素的位置与 <code>n</code> 的关系，决定在左侧还是右侧继续查找。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是一个简单的 <code>std::nth_element</code> 的实现示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// for std::rand</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Partition function for Quickselect</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function">RandomIt <span class="title">partition</span><span class="params">(RandomIt first, RandomIt last, RandomIt pivot)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">iter_swap</span>(pivot, last - <span class="number">1</span>); <span class="comment">// Move pivot to end</span></span><br><span class="line">    RandomIt storeIndex = first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RandomIt it = first; it &lt; last - <span class="number">1</span>; ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it &lt; *(last - <span class="number">1</span>)) &#123;</span><br><span class="line">            std::<span class="built_in">iter_swap</span>(it, storeIndex);</span><br><span class="line">            ++storeIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">iter_swap</span>(storeIndex, last - <span class="number">1</span>); <span class="comment">// Move pivot to its final place</span></span><br><span class="line">    <span class="keyword">return</span> storeIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quickselect function</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickselect</span><span class="params">(RandomIt first, RandomIt last, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &lt; last) &#123;</span><br><span class="line">        RandomIt pivot = first + std::<span class="built_in">rand</span>() % (last - first); <span class="comment">// Random pivot</span></span><br><span class="line">        pivot = <span class="built_in">partition</span>(first, last, pivot);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pivot - first == n) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// Found the nth element</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivot - first &gt; n) &#123;</span><br><span class="line">            <span class="built_in">quickselect</span>(first, pivot, n); <span class="comment">// Search in the left part</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">quickselect</span>(pivot + <span class="number">1</span>, last, n - (pivot - first + <span class="number">1</span>)); <span class="comment">// Search in the right part</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nth_element implementation</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_nth_element</span><span class="params">(RandomIt first, RandomIt nth, RandomIt last)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> n = nth - first;</span><br><span class="line">    <span class="built_in">quickselect</span>(first, last, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">size_t</span> n = <span class="number">5</span>; <span class="comment">// We want the 5th element (0-based index)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">my_nth_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + n, vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;th element is: &quot;</span> &lt;&lt; vec[n] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p><strong>Partition Function</strong>: </p><ul><li><code>partition</code> 函数将数组分为两部分，返回基准元素的最终位置。</li><li>它将基准元素移动到数组的末尾，然后遍历数组，将小于基准的元素移动到左侧。</li></ul></li><li><p><strong>Quickselect Function</strong>:</p><ul><li><code>quickselect</code> 函数递归地选择基准元素并进行分区，直到找到第 <code>n</code> 个元素。</li></ul></li><li><p><strong>My Nth Element Function</strong>:</p><ul><li><code>my_nth_element</code> 是用户定义的函数，调用 <code>quickselect</code> 来找到第 <code>n</code> 个元素。</li></ul></li><li><p><strong>Main Function</strong>:</p><ul><li>在 <code>main</code> 函数中，创建一个整数向量，调用 <code>my_nth_element</code>，并输出第 <code>n</code> 个元素。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>std::nth_element</code> 的实现基于快速选择算法，能够高效地找到数组中第 <code>n</code> 个元素。上述代码展示了如何实现这一算法，并提供了一个简单的示例来演示其用法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>texelFetch</title>
      <link href="/2024/10/06/texelFetch/"/>
      <url>/2024/10/06/texelFetch/</url>
      
        <content type="html"><![CDATA[<p><code>texelFetch</code> 是一个在着色器编程中用于从纹理中获取特定纹素（texel）的函数。与常规的纹理采样不同，<code>texelFetch</code> 使用整数纹理坐标来直接访问纹理数据，不进行过滤或插值。</p><p>在 OpenGL 的 GLSL（OpenGL Shading Language）中，<code>texelFetch</code> 的用法如下：</p><span id="more"></span><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> <span class="built_in">texelFetch</span>(<span class="type">sampler2D</span> sampler, <span class="type">ivec2</span> coord, <span class="type">int</span> lod);</span><br></pre></td></tr></table></figure><ul><li><code>sampler</code>：纹理采样器。</li><li><code>coord</code>：整数形式的纹理坐标。</li><li><code>lod</code>：细节层次（level of detail），通常为 0。</li></ul><p><code>texelFetch</code> 适用于需要精确访问纹理像素的场合，比如在一些计算或图像处理效果中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>traits设计和用法</title>
      <link href="/2024/09/29/traits%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%94%A8%E6%B3%95/"/>
      <url>/2024/09/29/traits%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中，<strong>Traits</strong>（特性）是一种设计模式，通常用于提供类型信息或行为的模板类。Traits 允许在编译时获取类型的特性，从而实现更灵活和可扩展的代码。Traits 模式广泛应用于标准库和现代 C++ 编程中，尤其是在模板编程和泛型编程中。</p><span id="more"></span><h3 id="1-Traits-的设计"><a href="#1-Traits-的设计" class="headerlink" title="1. Traits 的设计"></a>1. Traits 的设计</h3><p>Traits 通常是一个模板类，专门用于提供与类型相关的信息。它们可以用于：</p><ul><li><strong>类型特性</strong>: 提供类型的属性（如是否是指针、是否是类等）。</li><li><strong>类型转换</strong>: 提供类型的转换信息（如获取类型的基类、去除引用等）。</li><li><strong>类型操作</strong>: 提供与类型相关的操作（如获取类型的大小、默认构造函数等）。</li></ul><h3 id="2-Traits-的基本用法"><a href="#2-Traits-的基本用法" class="headerlink" title="2. Traits 的基本用法"></a>2. Traits 的基本用法</h3><p>以下是一些常见的 Traits 用法示例：</p><h4 id="a-类型特性"><a href="#a-类型特性" class="headerlink" title="a. 类型特性"></a>a. 类型特性</h4><p>使用 <code>std::is_integral</code> 来检查一个类型是否是整数类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::is_integral&lt;T&gt;::value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T is an integral type.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T is not an integral type.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">checkType</span>&lt;<span class="type">int</span>&gt;();    <span class="comment">// 输出: T is an integral type.</span></span><br><span class="line">    <span class="built_in">checkType</span>&lt;<span class="type">double</span>&gt;(); <span class="comment">// 输出: T is not an integral type.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="b-自定义-Traits"><a href="#b-自定义-Traits" class="headerlink" title="b. 自定义 Traits"></a>b. 自定义 Traits</h4><p>你可以定义自己的 Traits 类来提供特定类型的信息。例如，定义一个 Traits 类来获取类型的大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeTraits</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(T);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of int: &quot;</span> &lt;&lt; TypeTraits&lt;<span class="type">int</span>&gt;::size &lt;&lt; std::endl; <span class="comment">// 输出: Size of int: 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of double: &quot;</span> &lt;&lt; TypeTraits&lt;<span class="type">double</span>&gt;::size &lt;&lt; std::endl; <span class="comment">// 输出: Size of double: 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c-结合-SFINAE"><a href="#c-结合-SFINAE" class="headerlink" title="c. 结合 SFINAE"></a>c. 结合 SFINAE</h4><p>Traits 可以与 SFINAE（Substitution Failure Is Not An Error）结合使用，以实现更复杂的模板特化。例如，选择性地启用某些函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing non-integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">42</span>);        <span class="comment">// 输出: Processing integral type: 42</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">3.14</span>);     <span class="comment">// 输出: Processing non-integral type: 3.14</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Traits-的应用"><a href="#3-Traits-的应用" class="headerlink" title="3. Traits 的应用"></a>3. Traits 的应用</h3><p>Traits 在 C++ 标准库中有广泛的应用，以下是一些常见的例子：</p><ul><li><strong><code>std::iterator_traits</code></strong>: 提供迭代器的类型信息，如值类型、指针类型等。</li><li><strong><code>std::numeric_limits</code></strong>: 提供数值类型的特性，如最小值、最大值等。</li><li><strong><code>std::enable_if</code></strong>: 用于条件性地启用模板特化。</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul><li><strong>Traits</strong> 是一种强大的设计模式，允许在编译时获取类型信息和行为。</li><li>它们可以用于类型特性、类型转换和类型操作，提供灵活性和可扩展性。</li><li>Traits 在 C++ 标准库中有广泛的应用，尤其是在模板编程和泛型编程中。</li></ul><p>通过使用 Traits，开发者可以编写更通用和可重用的代码，同时提高类型安全性和性能。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shell和子shell环境变量</title>
      <link href="/2024/09/29/shell%E5%92%8C%E5%AD%90shell%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2024/09/29/shell%E5%92%8C%E5%AD%90shell%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>在 Shell 脚本中，命令替换（command substitution）是指将命令的输出作为字符串插入到另一个命令中。命令替换通常使用反引号（<code>`command`</code>）或 <code>$()</code> 语法来实现。命令替换会在一个子 Shell 中执行指定的命令，这意味着在子 Shell 中定义的变量不会影响父 Shell 中的变量。</p><span id="more"></span><h3 id="1-子-Shell-的概念"><a href="#1-子-Shell-的概念" class="headerlink" title="1. 子 Shell 的概念"></a>1. 子 Shell 的概念</h3><ul><li><strong>子 Shell</strong>: 当你在 Shell 中执行一个命令替换时，Shell 会创建一个新的子 Shell 来执行该命令。子 Shell 是父 Shell 的一个独立实例，具有自己的环境和变量。</li></ul><h3 id="2-变量作用域"><a href="#2-变量作用域" class="headerlink" title="2. 变量作用域"></a>2. 变量作用域</h3><ul><li>在子 Shell 中定义的变量不会影响父 Shell 中的变量。相反，父 Shell 中的变量也无法在子 Shell 中被访问。</li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>以下是一个示例，展示了命令替换如何在子 Shell 中运行命令，并且如何影响变量的作用域。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个变量</span></span><br><span class="line">var=<span class="string">&quot;Hello from parent shell&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用命令替换</span></span><br><span class="line">result=$(<span class="built_in">echo</span> <span class="variable">$var</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Result from command substitution: <span class="variable">$result</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在子 Shell 中修改变量</span></span><br><span class="line">result=$(<span class="built_in">echo</span> <span class="string">&quot;Hello from child shell&quot;</span>; var=<span class="string">&quot;Hello from child shell&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Result after child shell: <span class="variable">$result</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Variable in parent shell: <span class="variable">$var</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-运行结果"><a href="#4-运行结果" class="headerlink" title="4. 运行结果"></a>4. 运行结果</h3><p>如果你运行上述脚本，输出将是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Result from command substitution: Hello from parent shell</span><br><span class="line">Result after child shell: Hello from child shell</span><br><span class="line">Variable in parent shell: Hello from parent shell</span><br></pre></td></tr></table></figure><h3 id="5-解释"><a href="#5-解释" class="headerlink" title="5. 解释"></a>5. 解释</h3><ul><li><p><strong>第一部分</strong>: </p><ul><li><code>var=&quot;Hello from parent shell&quot;</code> 定义了一个变量 <code>var</code> 在父 Shell 中。</li><li><code>result=$(echo $var)</code> 使用命令替换，将 <code>var</code> 的值传递给 <code>result</code>。此时，<code>result</code> 的值为 <code>Hello from parent shell</code>。</li></ul></li><li><p><strong>第二部分</strong>:</p><ul><li><code>result=$(echo &quot;Hello from child shell&quot;; var=&quot;Hello from child shell&quot;)</code> 在子 Shell 中执行。虽然在子 Shell 中修改了 <code>var</code> 的值，但这个修改不会影响父 Shell 中的 <code>var</code> 变量。</li><li><code>result</code> 的值被设置为 <code>Hello from child shell</code>，但父 Shell 中的 <code>var</code> 仍然保持为 <code>Hello from parent shell</code>。</li></ul></li></ul><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>命令替换会在子 Shell 中执行命令，因此在子 Shell 中定义的变量不会影响父 Shell 中的变量。这种行为是 Shell 的一个重要特性，理解这一点对于编写有效的 Shell 脚本非常重要。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分支预测</title>
      <link href="/2024/09/27/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/"/>
      <url>/2024/09/27/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<ol><li>宏定义解释<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure></li></ol><span id="more"></span><ul><li>likely(x):<br>这个宏用于表示某个条件 x 是“可能为真”的。它的作用是告诉编译器，x 很可能为真（即返回值为 1）。<br>__builtin_expect(!!(x), 1) 的作用是将 x 的值转换为布尔值（0 或 1），并告诉编译器这个值很可能是 1。</li><li>unlikely(x):<br>这个宏用于表示某个条件 x 是“可能为假”的。它的作用是告诉编译器，x 很可能为假（即返回值为 0）。<br>__builtin_expect(!!(x), 0) 的作用是将 x 的值转换为布尔值，并告诉编译器这个值很可能是 0。</li></ul><ol start="2"><li>使用场景<br>这些宏通常用于条件语句中，以优化分支预测。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">likely</span>(condition)) &#123;</span><br><span class="line">    <span class="comment">// 处理条件为真的情况</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理条件为假的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，使用 likely 可以帮助编译器优化代码生成，使得在条件为真的情况下，相关的代码路径更快。</p><ol start="3"><li><p>优化原理<br>分支预测：现代 CPU 通常具有分支预测机制，能够根据历史执行路径预测条件语句的结果。通过使用 likely 和 unlikely，开发者可以显式地告诉编译器和 CPU 哪个分支更可能被执行，从而提高预测的准确性。<br>性能提升：在性能敏感的代码中，减少错误的分支预测可以显著提高执行效率，尤其是在循环和频繁调用的函数中。</p></li><li><p>注意事项<br>可读性：虽然使用这些宏可以提高性能，但过度使用可能会影响代码的可读性。应在性能关键的部分使用，而不是在所有条件判断中使用。<br>编译器支持：__builtin_expect 是 GCC 和 Clang 的扩展，其他编译器可能不支持此功能。在使用时需要确保代码的可移植性。<br>总结<br>likely 和 unlikely 宏通过利用 __builtin_expect 提供了对条件分支的预测信息，帮助编译器生成更高效的代码。它们在性能敏感的应用中非常有用，尤其是在需要优化分支预测的场景中</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++模版函数delete防止隐士类型转换.md</title>
      <link href="/2024/09/26/c-%E6%A8%A1%E7%89%88%E5%87%BD%E6%95%B0delete%E9%98%B2%E6%AD%A2%E9%9A%90%E5%A3%AB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-md/"/>
      <url>/2024/09/26/c-%E6%A8%A1%E7%89%88%E5%87%BD%E6%95%B0delete%E9%98%B2%E6%AD%A2%E9%9A%90%E5%A3%AB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-md/</url>
      
        <content type="html"><![CDATA[<p>本文展示如何使用C++模板函数的<code>delete</code>关键字来防止不必要的隐式类型转换。</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">int</span>&amp;() &#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">const</span> <span class="type">int</span>&amp;() <span class="type">const</span> &#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">(T arg)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">(<span class="type">int</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;called testFunc int\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Person a;</span><br><span class="line">    <span class="built_in">testFunc</span>(a); <span class="comment">//报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AndoirdEGLContext销毁管理</title>
      <link href="/2024/08/01/AndoirdEGLContext%E9%94%80%E6%AF%81%E7%AE%A1%E7%90%86/"/>
      <url>/2024/08/01/AndoirdEGLContext%E9%94%80%E6%AF%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EGLContextFactory</span> &#123;</span><br><span class="line">    EGLContext <span class="title function_">createContext</span><span class="params">(EGL10 egl, EGLDisplay display, EGLConfig eglConfig)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroyContext</span><span class="params">(EGL10 egl, EGLDisplay display, EGLContext context)</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗"><a href="#EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗" class="headerlink" title="EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗"></a>EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗</h3><span id="more"></span><h3 id="在-OpenGL-ES-中，当一个-EGLContext-被销毁时，所有在该上下文中创建的-OpenGL-资源（如-buffer、texture-和-framebuffer-objects-FBO-等）都会被删除。这是因为这些资源是与特定的-OpenGL-上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。"><a href="#在-OpenGL-ES-中，当一个-EGLContext-被销毁时，所有在该上下文中创建的-OpenGL-资源（如-buffer、texture-和-framebuffer-objects-FBO-等）都会被删除。这是因为这些资源是与特定的-OpenGL-上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。" class="headerlink" title="在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。"></a>在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。</h3><p>具体来说，当你调用 <code>EGLContextFactory</code> 接口的 <code>destroyContext</code> 方法来销毁一个 EGLContext 时，OpenGL ES 会自动处理这个上下文的清理工作，包括删除所有在该上下文中创建的资源。</p><p>因此，你不需要手动删除这些资源，销毁上下文的过程会自动处理它们的释放。</p><p>不过，如果你需要提前释放某些资源以便在上下文还没有销毁之前释放内存，你可以在合适的时机手动删除这些资源（例如通过调用 <code>glDeleteBuffers</code>、<code>glDeleteTextures</code>、<code>glDeleteFramebuffers</code> 等方法）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵</title>
      <link href="/2024/07/30/%E4%BB%8E%E5%8C%85%E5%90%AB%E5%B9%B3%E7%A7%BB%E3%80%81%E6%97%8B%E8%BD%AC%E5%92%8C%E7%BC%A9%E6%94%BE%E7%9A%84%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BB%85%E5%8C%85%E5%90%AB%E5%B9%B3%E7%A7%BB%E5%92%8C%E6%97%8B%E8%BD%AC%E7%9A%84%E7%9F%A9%E9%98%B5/"/>
      <url>/2024/07/30/%E4%BB%8E%E5%8C%85%E5%90%AB%E5%B9%B3%E7%A7%BB%E3%80%81%E6%97%8B%E8%BD%AC%E5%92%8C%E7%BC%A9%E6%94%BE%E7%9A%84%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BB%85%E5%8C%85%E5%90%AB%E5%B9%B3%E7%A7%BB%E5%92%8C%E6%97%8B%E8%BD%AC%E7%9A%84%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>要从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵，您需要对原矩阵进行一些操作。原矩阵通常是一个3x3或4x4的矩阵。</p><h3 id="对于3x3矩阵："><a href="#对于3x3矩阵：" class="headerlink" title="对于3x3矩阵："></a>对于3x3矩阵：</h3><p>原3x3矩阵的形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| a  b  tx |</span><br><span class="line">| c  d  ty |</span><br><span class="line">| 0  0  1  |</span><br></pre></td></tr></table></figure><span id="more"></span><p>步骤：</p><ol><li><p>提取旋转部分（左上2x2子矩阵）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| a  b |</span><br><span class="line">| c  d |</span><br></pre></td></tr></table></figure></li><li><p>计算缩放因子（可以使用行向量的范数或列向量的范数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = sqrt(a^2 + c^2) = sqrt(b^2 + d^2)</span><br></pre></td></tr></table></figure></li><li><p>将旋转部分归一化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| a/s  b/s |</span><br><span class="line">| c/s  d/s |</span><br></pre></td></tr></table></figure></li><li><p>构建新的3x3矩阵，包含平移分量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| a/s  b/s  tx |</span><br><span class="line">| c/s  d/s  ty |</span><br><span class="line">|  0    0    1 |</span><br></pre></td></tr></table></figure></li></ol><h3 id="对于4x4矩阵："><a href="#对于4x4矩阵：" class="headerlink" title="对于4x4矩阵："></a>对于4x4矩阵：</h3><p>原4x4矩阵的形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| a  b  c  tx |</span><br><span class="line">| d  e  f  ty |</span><br><span class="line">| g  h  i  tz |</span><br><span class="line">| 0  0  0   1 |</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li><p>提取旋转部分（左上3x3子矩阵）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| a  b  c |</span><br><span class="line">| d  e  f |</span><br><span class="line">| g  h  i |</span><br></pre></td></tr></table></figure></li><li><p>计算缩放因子（可以使用行向量的范数或列向量的范数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sx = sqrt(a^2 + d^2 + g^2)</span><br><span class="line">sy = sqrt(b^2 + e^2 + h^2)</span><br><span class="line">sz = sqrt(c^2 + f^2 + i^2)</span><br></pre></td></tr></table></figure></li><li><p>将旋转部分归一化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| a/sx  b/sy  c/sz |</span><br><span class="line">| d/sx  e/sy  f/sz |</span><br><span class="line">| g/sx  h/sy  i/sz |</span><br></pre></td></tr></table></figure></li><li><p>构建新的4x4矩阵，包含平移分量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| a/sx  b/sy  c/sz  tx |</span><br><span class="line">| d/sx  e/sy  f/sz  ty |</span><br><span class="line">| g/sx  h/sy  i/sz  tz |</span><br><span class="line">|  0     0     0    1  |</span><br></pre></td></tr></table></figure></li></ol><p>这些步骤可以帮助您从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGLE_VAO局部影响vs全局影响</title>
      <link href="/2024/07/28/OpenGLE-VAO%E5%B1%80%E9%83%A8%E5%BD%B1%E5%93%8Dvs%E5%85%A8%E5%B1%80%E5%BD%B1%E5%93%8D/"/>
      <url>/2024/07/28/OpenGLE-VAO%E5%B1%80%E9%83%A8%E5%BD%B1%E5%93%8Dvs%E5%85%A8%E5%B1%80%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="全局顶点属性数组使能状态"><a href="#全局顶点属性数组使能状态" class="headerlink" title="全局顶点属性数组使能状态"></a>全局顶点属性数组使能状态</h3><span id="more"></span><p><code>glEnableVertexAttribArray</code> 和 <code>glDisableVertexAttribArray</code> 确实是全局状态。这意味着在不使用 VAO 的情况下，启用或禁用特定的顶点属性数组会影响所有后续的绘制调用，直到该状态被改变。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用顶点属性数组索引 0</span></span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行绘制调用，使用索引 0 的顶点属性数组</span></span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用顶点属性数组索引 0</span></span><br><span class="line">glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次进行绘制调用，此时索引 0 的顶点属性数组将不会被使用</span></span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="顶点数组对象（VAO）"><a href="#顶点数组对象（VAO）" class="headerlink" title="顶点数组对象（VAO）"></a>顶点数组对象（VAO）</h3><p>当使用 VAO 时，<code>glEnableVertexAttribArray</code> 和 <code>glVertexAttribPointer</code> 等顶点属性相关的状态是存储在 VAO 中的。这意味着当你绑定一个 VAO 时，它会恢复之前存储的所有顶点属性状态，包括哪些属性数组是启用的。这样，每个 VAO 可以拥有自己独立的顶点属性配置。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并绑定第一个 VAO</span></span><br><span class="line">GLuint vao1;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;vao1);</span><br><span class="line">glBindVertexArray(vao1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置顶点属性指针和启用顶点属性数组</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑 VAO</span></span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并绑定第二个 VAO</span></span><br><span class="line">GLuint vao2;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;vao2);</span><br><span class="line">glBindVertexArray(vao2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置不同的顶点属性指针和启用顶点属性数组</span></span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="keyword">sizeof</span>(GLfloat), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑 VAO</span></span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用第一个 VAO 进行绘制</span></span><br><span class="line">glBindVertexArray(vao1);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用第二个 VAO 进行绘制</span></span><br><span class="line">glBindVertexArray(vao2);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>vao1</code> 存储了顶点属性索引 0 的配置和使能状态。</li><li><code>vao2</code> 存储了顶点属性索引 1 的配置和使能状态。</li></ul><p>绑定 <code>vao1</code> 会恢复其配置和状态，绑定 <code>vao2</code> 则会恢复其自身的配置和状态。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>全局顶点属性数组使能状态</strong>：在不使用 VAO 时，<code>glEnableVertexAttribArray</code> 和 <code>glDisableVertexAttribArray</code> 对所有后续绘制调用生效，直到状态被改变。</li><li><strong>顶点数组对象（VAO）</strong>：存储了顶点属性相关的所有状态，包括使能状态。当绑定 VAO 时，会恢复之前存储的顶点属性配置和使能状态，使得每个 VAO 拥有独立的顶点属性配置。</li></ul><p>使用 VAO 是管理复杂场景和多个对象的最佳实践，因为它简化了状态管理，并且可以提高渲染性能。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGLES设置顶点属性的默认值</title>
      <link href="/2024/07/28/OpenGLES%E8%AE%BE%E7%BD%AE%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
      <url>/2024/07/28/OpenGLES%E8%AE%BE%E7%BD%AE%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>在 OpenGL ES 中，设置顶点属性的默认值和通过顶点缓冲对象（VBO）上传顶点属性是两种不同的处理顶点属性的方法。以下是详细的解释：</p><h3 id="设置顶点属性默认值"><a href="#设置顶点属性默认值" class="headerlink" title="设置顶点属性默认值"></a>设置顶点属性默认值</h3><span id="more"></span><p>在 OpenGL ES 中，可以使用 <code>glVertexAttrib4f</code>（或其他类似的函数）来设置顶点属性的默认值。这些函数允许您为指定的顶点属性索引设置一个常量值，而不必为每个顶点提供一个值。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置索引为 0 的顶点属性的默认值为 (1.0, 0.0, 0.0, 1.0)</span></span><br><span class="line">glVertexAttrib4f(<span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><p>请注意，这种方法直接在顶点着色器中使用常量值，因此适用于需要相同属性值的所有顶点的情况。</p><h3 id="通过-VBO-上传顶点属性"><a href="#通过-VBO-上传顶点属性" class="headerlink" title="通过 VBO 上传顶点属性"></a>通过 VBO 上传顶点属性</h3><p>VBO 是一种在图形硬件上存储顶点数据的高效方式。使用 VBO 可以提高渲染性能，因为数据存储在 GPU 内存中，而不是通过每次绘制调用从 CPU 内存传输数据。以下是使用 VBO 上传顶点属性的步骤：</p><ol><li><p><strong>生成和绑定 VBO</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GLuint vbo;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;vbo);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, vbo);</span><br></pre></td></tr></table></figure></li><li><p><strong>上传顶点数据</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 顶点数据，假设每个顶点包含 3 个浮点数 (x, y, z)</span></span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">&#125;;</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure></li><li><p><strong>设置顶点属性指针</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>绘制</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="性能差别"><a href="#性能差别" class="headerlink" title="性能差别"></a>性能差别</h3><ul><li><p><strong>设置顶点属性默认值</strong>：这种方法适用于所有顶点共享相同属性值的情况。其优点是简单直接，不需要额外的内存传输。然而，它缺乏灵活性，只能应用于特定的简单场景。</p></li><li><p><strong>通过 VBO 上传顶点属性</strong>：这种方法更为灵活，可以为每个顶点设置不同的属性值。因为数据存储在 GPU 内存中，所以渲染性能通常更高，特别是在处理大量顶点数据时。这种方法适用于大多数复杂的渲染任务。</p></li></ul><p>总结来说，如果您的应用场景中所有顶点都共享相同的属性值，可以使用设置默认值的方法。如果不同顶点有不同的属性值，并且您希望获得更好的性能，应使用 VBO。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AddressSanitizer实现原理</title>
      <link href="/2024/07/28/AddressSanitizer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2024/07/28/AddressSanitizer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>AddressSanitizer（简称ASan）是一种内存错误检测工具，用于捕捉诸如缓冲区溢出、使用已释放内存、堆栈溢出等内存错误。ASan在编译时和运行时对程序进行处理，以检测和报告内存相关的错误。以下是AddressSanitizer的实现原理的详细解释：</p><span id="more"></span><h3 id="1-编译时插桩"><a href="#1-编译时插桩" class="headerlink" title="1. 编译时插桩"></a>1. 编译时插桩</h3><p>ASan在编译时对代码进行插桩，插入额外的检查代码。这些检查代码会在每次内存访问时执行，以验证访问是否合法。具体过程包括：</p><ul><li><strong>插入检查代码</strong>：在每次内存分配、释放和访问操作前后插入检查代码。</li><li><strong>标记内存区域</strong>：在内存分配和释放时，更新内存区域的元数据，以记录该区域的状态（已分配、已释放等）。</li></ul><h3 id="2-Shadow-Memory"><a href="#2-Shadow-Memory" class="headerlink" title="2. Shadow Memory"></a>2. Shadow Memory</h3><p>ASan使用影子内存（Shadow Memory）来记录主内存的状态。影子内存是主内存的一个映射区域，每个字节的影子内存对应主内存的几个字节（通常是8字节）。影子内存的值用于指示主内存的哪些部分是合法访问的，哪些部分是非法的。</p><ul><li><strong>影子内存布局</strong>：影子内存占用主内存的1/8，因为每个影子字节代表8个主内存字节。</li><li><strong>影子内存值</strong>：影子内存中的值表示主内存的状态。例如，0表示所有8个字节都是合法的，负值表示不合法的访问，正值表示部分合法访问。</li></ul><h3 id="3-内存分配和释放"><a href="#3-内存分配和释放" class="headerlink" title="3. 内存分配和释放"></a>3. 内存分配和释放</h3><p>ASan对内存分配和释放函数（如<code>malloc</code>和<code>free</code>）进行重载，以维护内存区域的元数据。这些元数据包括：</p><ul><li><strong>红色区域（Redzones）</strong>：在每个分配的内存块周围添加红色区域，用于检测缓冲区溢出。红色区域被标记为非法访问区域。</li><li><strong>元数据</strong>：记录每个内存块的大小、分配堆栈等信息，以便在检测到错误时提供详细报告。</li></ul><h3 id="4-运行时检查"><a href="#4-运行时检查" class="headerlink" title="4. 运行时检查"></a>4. 运行时检查</h3><p>在运行时，ASan插入的检查代码会在每次内存访问时执行，检查访问的地址是否在合法范围内。如果访问非法区域，则报告错误并终止程序。</p><ul><li><strong>内存访问检查</strong>：每次内存读取或写入时，检查影子内存中的值，以确定访问是否合法。</li><li><strong>错误报告</strong>：在检测到非法访问时，ASan会生成详细的错误报告，包含访问地址、内存块信息、调用堆栈等。</li></ul><h3 id="5-错误类型检测"><a href="#5-错误类型检测" class="headerlink" title="5. 错误类型检测"></a>5. 错误类型检测</h3><p>ASan能够检测多种类型的内存错误，包括：</p><ul><li><strong>缓冲区溢出</strong>：访问数组或内存块的边界外的区域。</li><li><strong>使用未初始化内存</strong>：访问未初始化的内存。</li><li><strong>使用已释放内存</strong>：访问已经释放的内存。</li><li><strong>双重释放</strong>：重复释放同一块内存。</li><li><strong>堆栈溢出</strong>：访问栈帧之外的内存。</li></ul><h3 id="6-性能与开销"><a href="#6-性能与开销" class="headerlink" title="6. 性能与开销"></a>6. 性能与开销</h3><p>ASan在检测内存错误时会引入一定的性能开销和内存开销：</p><ul><li><strong>性能开销</strong>：由于插入了额外的检查代码，程序的执行速度会有所降低。通常，ASan引入的性能开销在2-3倍左右。</li><li><strong>内存开销</strong>：影子内存和红色区域会增加内存使用量，通常内存开销在2倍左右。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AddressSanitizer通过编译时插桩、使用影子内存和运行时检查等机制，能够有效地检测和报告内存相关的错误。尽管引入了一定的性能和内存开销，但它在提高程序安全性和稳定性方面具有重要意义，是开发和调试C/C++程序的强大工具。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pthread_create设置栈size</title>
      <link href="/2024/07/28/pthread-create%E8%AE%BE%E7%BD%AE%E6%A0%88size/"/>
      <url>/2024/07/28/pthread-create%E8%AE%BE%E7%BD%AE%E6%A0%88size/</url>
      
        <content type="html"><![CDATA[<p>本文演示如何在使用 <code>pthread_create</code> 创建线程时设置自定义的栈大小。通过 <code>pthread_attr_setstacksize</code> 函数可以控制线程的栈空间大小，这在需要大量栈空间或者优化内存使用时非常有用。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunction</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程的执行代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">size_t</span> stackSize = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 设置栈大小为2 MiB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_attr_init</span>(&amp;attr) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_attr_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程栈大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_attr_setstacksize</span>(&amp;attr, stackSize) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_attr_setstacksize&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thread, &amp;attr, threadFunction, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_join</span>(thread, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁线程属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_attr_destroy</span>(&amp;attr) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_attr_destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用__asan_unpoison_memory_region屏蔽某处内存检查</title>
      <link href="/2024/07/22/%E4%BD%BF%E7%94%A8-asan-unpoison-memory-region%E5%B1%8F%E8%94%BD%E6%9F%90%E5%A4%84%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5/"/>
      <url>/2024/07/22/%E4%BD%BF%E7%94%A8-asan-unpoison-memory-region%E5%B1%8F%E8%94%BD%E6%9F%90%E5%A4%84%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p><code>__asan_unpoison_memory_region</code> 是 AddressSanitizer (ASan) 库中的一个函数。ASan 是一个用于检测内存错误的工具，主要用于 C 和 C++ 程序开发者。<code>__asan_unpoison_memory_region</code> 的作用是标记一段内存区域为“未污染”状态，这意味着这段内存可以被访问且不会触发 ASan 的错误报告。</p><span id="more"></span><p>具体来说，这个函数通常用于以下场景：</p><ol><li>在内存被分配后但未初始化之前，标记该区域为未污染，以便在初始化期间可以安全访问。</li><li>当程序知道某段内存区域将被合法访问时，预先标记该区域为未污染，以避免误报。</li></ol><p>函数原型通常如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __asan_unpoison_memory_region(<span class="type">void</span> *addr, <span class="type">size_t</span> size);</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li><code>addr</code>：内存区域的起始地址。</li><li><code>size</code>：内存区域的大小（以字节为单位）。</li></ul><p>通过调用这个函数，开发者可以更精细地控制 ASan 的内存监控行为，减少误报，提高调试效率。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UTF编码内存角度比较.md</title>
      <link href="/2024/07/11/UTF%E7%BC%96%E7%A0%81%E5%86%85%E5%AD%98%E8%A7%92%E5%BA%A6%E6%AF%94%E8%BE%83-md/"/>
      <url>/2024/07/11/UTF%E7%BC%96%E7%A0%81%E5%86%85%E5%AD%98%E8%A7%92%E5%BA%A6%E6%AF%94%E8%BE%83-md/</url>
      
        <content type="html"><![CDATA[<p>UTF-8、UTF-16 和 UTF-32 是三种不同的 Unicode 编码方式，它们在表示字符时占用的字节数各不相同。具体如下：</p><ol><li><strong>UTF-8</strong>：<ul><li>UTF-8 是一种可变长度的编码方式，每个字符占用 1 到 4 个字节。</li><li>具体字节数取决于字符的 Unicode 码点：<ul><li>U+0000 至 U+007F（基本拉丁字母）占 1 个字节。</li><li>U+0080 至 U+07FF 占 2 个字节。</li><li>U+0800 至 U+FFFF 占 3 个字节。</li><li>U+10000 至 U+10FFFF 占 4 个字节。</li></ul></li></ul></li></ol><span id="more"></span><ol start="2"><li><p><strong>UTF-16</strong>：</p><ul><li>UTF-16 也是一种可变长度的编码方式，每个字符占用 2 或 4 个字节。</li><li>具体字节数取决于字符的 Unicode 码点：<ul><li>U+0000 至 U+FFFF（基本多语言平面，BMP）占 2 个字节。</li><li>U+10000 至 U+10FFFF（辅助平面）占 4 个字节（使用一对代理项，即高位代理项和低位代理项，每个占 2 个字节）。</li></ul></li></ul></li><li><p><strong>UTF-32</strong>：</p><ul><li>UTF-32 是一种固定长度的编码方式，每个字符占用 4 个字节。</li><li>无论字符的 Unicode 码点是多少，每个字符始终占用 4 个字节。</li></ul></li></ol><p>总结：</p><ul><li><strong>UTF-8</strong>：1 到 4 个字节，具体取决于字符。</li><li><strong>UTF-16</strong>：2 或 4 个字节，具体取决于字符。</li><li><strong>UTF-32</strong>：固定 4 个字节。</li></ul><p>这三种编码方式各有优缺点。UTF-8 是最常用的编码方式，因其对 ASCII 字符的高效编码（仅占 1 个字节），节省空间且向后兼容 ASCII。UTF-16 在处理基本多语言平面字符时相对高效，但对于包括大量辅助平面字符的文本，可能会占用更多空间。UTF-32 最简单，但由于每个字符固定占用 4 个字节，通常会占用更多的存储空间。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android动态库加载-dlopen与System.loadLibrary对比</title>
      <link href="/2024/06/12/Android%E5%8A%A8%E6%80%81%E5%BA%93%E5%8A%A0%E8%BD%BD-dlopen%E4%B8%8ESystem.loadLibrary%E5%AF%B9%E6%AF%94/"/>
      <url>/2024/06/12/Android%E5%8A%A8%E6%80%81%E5%BA%93%E5%8A%A0%E8%BD%BD-dlopen%E4%B8%8ESystem.loadLibrary%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Android开发中，我们经常需要加载本地动态库（.so文件）来实现一些底层功能。Android提供了两种主要的动态库加载方式：<code>dlopen</code>和<code>System.loadLibrary</code>。本文将详细对比这两种方式的区别，并分析<code>System.loadLibrary</code>可能失败的原因。</p><span id="more"></span><h3 id="dlopen-vs-System-loadLibrary"><a href="#dlopen-vs-System-loadLibrary" class="headerlink" title="dlopen vs System.loadLibrary"></a>dlopen vs System.loadLibrary</h3><h4 id="1-dlopen方式"><a href="#1-dlopen方式" class="headerlink" title="1. dlopen方式"></a>1. dlopen方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*AddFunc)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PrintFunc)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* handle = <span class="built_in">dlopen</span>(<span class="string">&quot;libexample.so&quot;</span>, RTLD_NOW);</span><br><span class="line"><span class="keyword">if</span> (handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">char</span>* error = <span class="built_in">dlerror</span>();</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数指针</span></span><br><span class="line">AddFunc add = (AddFunc)<span class="built_in">dlsym</span>(handle, <span class="string">&quot;add&quot;</span>);</span><br><span class="line">PrintFunc print = (PrintFunc)<span class="built_in">dlsym</span>(handle, <span class="string">&quot;print&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (add == <span class="literal">NULL</span> || print == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">char</span>* error = <span class="built_in">dlerror</span>();</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    <span class="built_in">dlclose</span>(handle);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello from dynamic library!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用完毕后关闭库</span></span><br><span class="line"><span class="built_in">dlclose</span>(handle);</span><br></pre></td></tr></table></figure><p>对应的动态库头文件示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>动态库实现示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>直接调用系统API</li><li>可以指定库的完整路径</li><li>需要手动管理库的生命周期</li><li>可以动态加载和卸载</li><li>可以获取加载失败的具体原因</li><li>可以动态获取和调用库中的函数</li><li>支持运行时加载不同版本的库</li><li>可以实现插件化架构</li></ul><p>注意事项：</p><ol><li>函数指针类型定义要与库中函数签名完全匹配</li><li>使用<code>extern &quot;C&quot;</code>防止C++名称修饰</li><li>记得检查函数指针是否为NULL</li><li>使用完毕后要调用<code>dlclose</code>释放资源</li><li>错误处理要使用<code>dlerror</code>获取详细信息</li></ol><h4 id="2-System-loadLibrary方式"><a href="#2-System-loadLibrary方式" class="headerlink" title="2. System.loadLibrary方式"></a>2. System.loadLibrary方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">&quot;example&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsatisfiedLinkError e) &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>Java层API，使用更简单</li><li>自动管理库的生命周期</li><li>只能加载应用lib目录下的库</li><li>错误信息相对简单</li></ul><h3 id="System-loadLibrary失败原因分析"><a href="#System-loadLibrary失败原因分析" class="headerlink" title="System.loadLibrary失败原因分析"></a>System.loadLibrary失败原因分析</h3><p>即使APK中存在.so文件，<code>System.loadLibrary</code>仍然可能失败，主要原因包括：</p><h4 id="1-架构不匹配"><a href="#1-架构不匹配" class="headerlink" title="1. 架构不匹配"></a>1. 架构不匹配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查当前设备支持的架构</span></span><br><span class="line">String[] supportedABIs = Build.SUPPORTED_ABIS;</span><br></pre></td></tr></table></figure><p>可能的原因：</p><ul><li>库文件与设备CPU架构不匹配</li><li>库文件缺少目标架构的支持</li><li>库文件被错误打包到错误的目录</li></ul><h4 id="2-依赖库缺失"><a href="#2-依赖库缺失" class="headerlink" title="2. 依赖库缺失"></a>2. 依赖库缺失</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用readelf查看库的依赖</span></span><br><span class="line">readelf -d libexample.so</span><br></pre></td></tr></table></figure><p>常见问题：</p><ul><li>依赖的其他.so文件不存在</li><li>依赖的系统库版本不兼容</li><li>依赖库的路径问题</li></ul><h4 id="3-权限问题"><a href="#3-权限问题" class="headerlink" title="3. 权限问题"></a>3. 权限问题</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AndroidManifest.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可能的原因：</p><ul><li>应用没有读取权限</li><li>文件系统权限设置不正确</li><li>SELinux策略限制</li></ul><h4 id="4-库文件损坏"><a href="#4-库文件损坏" class="headerlink" title="4. 库文件损坏"></a>4. 库文件损坏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查文件完整性</span></span><br><span class="line"><span class="type">File</span> <span class="variable">libFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getApplicationInfo().nativeLibraryDir + <span class="string">&quot;/libexample.so&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!libFile.exists() || libFile.length() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 文件不存在或为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能的原因：</p><ul><li>文件下载不完整</li><li>文件被损坏</li><li>文件格式错误</li></ul><h4 id="5-内存问题"><a href="#5-内存问题" class="headerlink" title="5. 内存问题"></a>5. 内存问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查内存状态</span></span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> runtime.maxMemory();</span><br><span class="line"><span class="type">long</span> <span class="variable">usedMemory</span> <span class="operator">=</span> runtime.totalMemory() - runtime.freeMemory();</span><br></pre></td></tr></table></figure><p>可能的原因：</p><ul><li>内存不足</li><li>内存碎片化</li><li>内存限制</li></ul><h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><h4 id="1-使用dlopen调试"><a href="#1-使用dlopen调试" class="headerlink" title="1. 使用dlopen调试"></a>1. 使用dlopen调试</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* handle = <span class="built_in">dlopen</span>(<span class="string">&quot;libexample.so&quot;</span>, RTLD_NOW);</span><br><span class="line"><span class="keyword">if</span> (handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">char</span>* error = <span class="built_in">dlerror</span>();</span><br><span class="line">    __android_log_print(ANDROID_LOG_ERROR, <span class="string">&quot;NativeLib&quot;</span>, <span class="string">&quot;dlopen failed: %s&quot;</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-检查库文件信息"><a href="#2-检查库文件信息" class="headerlink" title="2. 检查库文件信息"></a>2. 检查库文件信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看库文件信息</span></span><br><span class="line">file libexample.so</span><br><span class="line"><span class="comment"># 查看库文件依赖</span></span><br><span class="line">ldd libexample.so</span><br><span class="line"><span class="comment"># 查看库文件符号</span></span><br><span class="line">nm libexample.so</span><br></pre></td></tr></table></figure><h4 id="3-日志分析"><a href="#3-日志分析" class="headerlink" title="3. 日志分析"></a>3. 日志分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启详细日志</span></span><br><span class="line">System.setProperty(<span class="string">&quot;java.library.path&quot;</span>, <span class="string">&quot;/data/app/.../lib/arm64&quot;</span>);</span><br><span class="line">System.loadLibrary(<span class="string">&quot;example&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li><p><strong>架构支持</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ndk &#123;</span><br><span class="line">            abiFilters <span class="string">&#x27;armeabi-v7a&#x27;</span>, <span class="string">&#x27;arm64-v8a&#x27;</span>, <span class="string">&#x27;x86&#x27;</span>, <span class="string">&#x27;x86_64&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>错误处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">&quot;example&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsatisfiedLinkError e) &#123;</span><br><span class="line">    Log.e(<span class="string">&quot;NativeLib&quot;</span>, <span class="string">&quot;Failed to load library: &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 尝试使用备用方案</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.load(<span class="string">&quot;/data/data/com.example.app/lib/libexample.so&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsatisfiedLinkError e2) &#123;</span><br><span class="line">        <span class="comment">// 处理错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>版本兼容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">    <span class="comment">// 使用新版本API</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用兼容方案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>dlopen</code>和<code>System.loadLibrary</code>各有优势，选择合适的方式取决于具体需求</li><li><code>System.loadLibrary</code>失败的原因多种多样，需要系统性地排查</li><li>良好的错误处理和日志记录对调试至关重要</li><li>遵循最佳实践可以避免大多数常见问题</li></ol><h3 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h3><ul><li><a href="https://developer.android.com/ndk/guides">Android NDK文档</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/">JNI规范</a></li><li><a href="https://source.android.com/devices/architecture/vndk">Android动态库加载机制</a> </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> JNI </tag>
            
            <tag> 动态库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDF实现CornerRadius</title>
      <link href="/2023/12/28/SDF%E5%AE%9E%E7%8E%B0CornerRadius/"/>
      <url>/2023/12/28/SDF%E5%AE%9E%E7%8E%B0CornerRadius/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍如何使用SDF（Signed Distance Field）实现圆角效果。</p><!-- 内容待补充 -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>lamda 初始化捕获用法</title>
      <link href="/2023/12/27/lamda-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8D%95%E8%8E%B7%E7%94%A8%E6%B3%95/"/>
      <url>/2023/12/27/lamda-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8D%95%E8%8E%B7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍C++ Lambda表达式的初始化捕获用法。</p><!-- 内容待补充 -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tag dispatch</title>
      <link href="/2023/12/24/tag-dispatch/"/>
      <url>/2023/12/24/tag-dispatch/</url>
      
        <content type="html"><![CDATA[<h4 id="对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string"><a href="#对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string" class="headerlink" title="对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string"></a>对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> TagDispatch &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; temp;</span><br><span class="line">    temp.<span class="built_in">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called fun(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called fun(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(std::forward&lt;T&gt;(params));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fwd</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">//suc</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fwd</span>(a);     <span class="comment">//suc</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">short</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//fwd(b);     //failed, 匹配到了通用引用函数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;    </span><br><span class="line">    TagDispatch::<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="使用TagDispath，来解决匹配的问题"><a href="#使用TagDispath，来解决匹配的问题" class="headerlink" title="使用TagDispath，来解决匹配的问题"></a>使用TagDispath，来解决匹配的问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> TagDispatch &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(T&amp;&amp; params, std::false_type)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; temp;</span><br><span class="line">    temp.<span class="built_in">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called fun(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a, std::true_type)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called fun(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun2</span>(std::forward&lt;T&gt;(params), std::is_integral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fwd</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">//suc</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fwd</span>(a);     <span class="comment">//suc</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">short</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">fwd</span>(b);     <span class="comment">//succeed, 匹配到了通用引用函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable-if来限制模板的匹配"><a href="#针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable-if来限制模板的匹配" class="headerlink" title="针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配"></a>针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;</span><br><span class="line">            !std::is_base_of&lt;Person, std::<span class="type">decay_t</span>&lt;T&gt;&gt;::value    <span class="comment">// 防止调用拷贝和移动构造函数，并且考虑了子类</span></span><br><span class="line">            &amp;&amp;                                                  <span class="comment">// decay,移除指针引用和cv修饰符</span></span><br><span class="line">            !std::is_integral&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class="line">        &gt;</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; params) &#123;</span><br><span class="line">        std::vector&lt;std::string&gt; temp;</span><br><span class="line">        temp.<span class="built_in">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Person(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Person(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testCtrOverload</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(b)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>smoothStep实现</title>
      <link href="/2023/12/22/smoothStep%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/12/22/smoothStep%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍smoothStep函数的实现原理和应用。</p><!-- 内容待补充 -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模板规则推导</title>
      <link href="/2023/12/21/%E6%A8%A1%E6%9D%BF%E8%A7%84%E5%88%99%E6%8E%A8%E5%AF%BC/"/>
      <url>/2023/12/21/%E6%A8%A1%E6%9D%BF%E8%A7%84%E5%88%99%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="模板推导规则"><a href="#模板推导规则" class="headerlink" title="模板推导规则"></a>模板推导规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void passByRefFun(T&amp; val) &#123; &#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void passByUniRefFun(T&amp;&amp; val) &#123; &#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void passByValueFun(T val) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void fun3(int&amp; a) &#123; &#125;</span><br><span class="line">void fun3(int&amp;&amp; a) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 0;          //a int</span><br><span class="line">    const int b = a;    //b const int</span><br><span class="line">    const int&amp; c = a;   //c const int&amp;</span><br><span class="line">    </span><br><span class="line">    passByRefFun(a);    // int&amp;</span><br><span class="line">    passByRefFun(b);    // const int&amp;</span><br><span class="line">    passByRefFun(c);    // const int&amp;</span><br><span class="line">    //passByRefFun(27);   // 报错</span><br><span class="line">    </span><br><span class="line">    passByUniRefFun(a); // int&amp;</span><br><span class="line">    passByUniRefFun(b); // const int&amp;</span><br><span class="line">    passByUniRefFun(c); // const int&amp;</span><br><span class="line">    passByUniRefFun(27); // int&amp;&amp;</span><br><span class="line">    </span><br><span class="line">    passByValueFun(a);  // int</span><br><span class="line">    passByValueFun(b);  // int</span><br><span class="line">    passByValueFun(c);  // int</span><br><span class="line">    passByValueFun(27); // int</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        int&amp;&amp; a = 10;</span><br><span class="line">        fun3(a);            // called void fun3(int&amp; a)</span><br><span class="line">        fun3(std::move(a)); // called void fun3(int&amp;&amp; a)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h3><p>SFINAE（Substitution Failure Is Not An Error）是 C++ 中的一个重要概念，主要用于模板编程。它的意思是，当模板参数替换导致错误时，编译器不会将其视为错误，而是会继续查找其他可能的匹配。这使得我们可以在模板中进行条件编译，选择合适的重载或特化</p><p>SFINAE 的优势<br>条件编译：可以根据类型特征选择不同的实现，增强代码的灵活性和可重用性。<br>避免编译错误：当模板参数替换导致错误时，编译器不会将其视为错误，而是继续查找其他匹配的模板。<br>类型安全：通过类型特征，可以确保只有符合条件的类型才能使用特定的模板实现。</p><p>SFINAE 是 C++ 模板编程中的一个强大工具，允许开发者根据类型特征选择合适的模板特化或重载。通过结合 std::enable_if 和类型特征，开发者可以编写更灵活和安全的代码。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>电子书目录</title>
      <link href="/2022/12/25/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/12/25/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="渲染整理"><a href="#渲染整理" class="headerlink" title="渲染整理"></a>渲染整理</h2><h4 id="开放世界的场景管理"><a href="#开放世界的场景管理" class="headerlink" title="开放世界的场景管理"></a>开放世界的场景管理</h4><pre><code>1. 切成tile2. 数据分级LOD3. 根据天顶角，调整远平面，裁剪数据</code></pre><span id="more"></span><h4 id="游戏引擎分层架构"><a href="#游戏引擎分层架构" class="headerlink" title="游戏引擎分层架构"></a>游戏引擎分层架构</h4><pre><code>1. EditorLayer2. FuntionLayer    1. Rendering    2. Animation    3. Camera    4. Physics    5. Script3. ResourceLayer4. CoreLayer    1. threadPoolManagement    2. memoryPool    3. mathLibrary5. PlatformLayer    1. RHI</code></pre><h4 id="Renderable"><a href="#Renderable" class="headerlink" title="Renderable"></a>Renderable</h4><pre><code>1. shader    1. vs,fs    2. macro2. RenderState3. MVP 4. Texture5. DrawImp</code></pre><h4 id="渲染效果"><a href="#渲染效果" class="headerlink" title="渲染效果"></a>渲染效果</h4><pre><code>1. 前向渲染      1. PBR      2. 布林冯模型2. 阴影shadowMap：    1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性    2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度3. 楼的倒影    1. 矩阵楼块插入地面    2. 模板测试，只有地面和水才绘制4. AO5. 聚光灯效果6. UV动画</code></pre><h4 id="技术点提炼"><a href="#技术点提炼" class="headerlink" title="技术点提炼"></a>技术点提炼</h4><pre><code>1. 楼块    1. 切成小块    2. 柔化圆角    3. 贴UV2. 3d瓦片绘制    1. 瓦片的加载，与cache    2. 非实施例渲染，按材质进行分类渲染    3. 实例化渲染，动态计算lod进行渲染3. 模型渲染    1. PBR渲染    2. 非PBR渲染</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++ 可变参数模板</title>
      <link href="/2022/12/11/c-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/12/11/c-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="可变模版参数-variadic-templates"><a href="#可变模版参数-variadic-templates" class="headerlink" title="可变模版参数(variadic templates)"></a>可变模版参数(variadic templates)</h3><p>可以对参数进行高度泛化，标识0到任意个数参数</p><span id="more"></span><h4 id="两种展开形式"><a href="#两种展开形式" class="headerlink" title="两种展开形式"></a>两种展开形式</h4><ol><li>使用特化的终止函数结合递归</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//终止函数</span><br><span class="line">int multiply()</span><br><span class="line">&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//递归展开</span><br><span class="line">template &lt;typename T, typename ...Args&gt;</span><br><span class="line">int multiply(T&amp;&amp; t, Args&amp;&amp; ...arg)</span><br><span class="line">&#123;</span><br><span class="line">    return t * multiply(arg...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; multiply(3, 4, 5) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; multiply() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用逗号表达式<br>初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc… )，最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class F, class... Args&gt;void expand(const F&amp; f, Args&amp;&amp;...args)</span><br><span class="line">&#123;</span><br><span class="line">  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》</span><br><span class="line">  initializer_list&lt;int&gt;&#123;(f(std::forward&lt; Args&gt;(args)),0)...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    expand([](int i) &#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;, 1,2,3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h3><p>为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct myclass &#123;</span><br><span class="line">    myclass(int,int)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;myclass constructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    myclass(initializer_list&lt;int&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;myclass initializer_list constructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    auto il = &#123;10, 20, 30&#125;;</span><br><span class="line">    </span><br><span class="line">    myclass foo &#123;10,20&#125;;  // calls initializer_list constructor</span><br><span class="line">    myclass bar (10,20);  // calls first constructo</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++继承权限</title>
      <link href="/2022/12/04/c-%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90/"/>
      <url>/2022/12/04/c-%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<ol><li><p>继承有三种权限，public，proteced，private，默认不写是private</p></li><li><p>权限的最低是public，其次是protected，最高private</p></li><li><p>继承方式代表是父类属性在当前类中的最低呈现</p></li><li><p>父类中的privated属性在子类中不可访问</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL模板测试流程</title>
      <link href="/2022/11/08/OpenGL%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/11/08/OpenGL%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="模板测试流程"><a href="#模板测试流程" class="headerlink" title="模板测试流程"></a>模板测试流程</h3><span id="more"></span><p>不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试</p><h4 id="模板测试一般使用流程："><a href="#模板测试一般使用流程：" class="headerlink" title="模板测试一般使用流程："></a>模板测试一般使用流程：</h4><pre><code>1. 启用模板缓冲写入2. 渲染物体，更新模板缓冲3. 禁用模板缓冲写入4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段</code></pre><h5 id="使用模板测试绘制物体轮廓的例子"><a href="#使用模板测试绘制物体轮廓的例子" class="headerlink" title="使用模板测试绘制物体轮廓的例子"></a>使用模板测试绘制物体轮廓的例子</h5><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glStencilMask();</span><br><span class="line">glStencilFunc(GLenum func, GLint ref, GLuint mask);</span><br><span class="line">glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);</span><br></pre></td></tr></table></figure>1. 开启模板测试和深度测试2. 第一次render pass，主要是绘制，并写入模板    1. 开启模板测试和深度测试    2. glStencilMask(0xFF);    3. glStencilOp(keep, keep, replace);    4. glStencilFunc(always, 1, 0xFF);    5. 绘制物体3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素    1. 将物体缩放变大    2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系    3. 关闭模板写入glStencilMask(0x00);    4. glStencilFunc(not_equal, 1, 0xFF);    5. 绘制物体</code></pre><h3 id="关于OpenGL里面的Mask"><a href="#关于OpenGL里面的Mask" class="headerlink" title="关于OpenGL里面的Mask"></a>关于OpenGL里面的Mask</h3><pre><code>1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&amp;运算后写入2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>trivially copyable 拷贝不变</title>
      <link href="/2022/10/25/trivially-copyable-%E6%8B%B7%E8%B4%9D%E4%B8%8D%E5%8F%98/"/>
      <url>/2022/10/25/trivially-copyable-%E6%8B%B7%E8%B4%9D%E4%B8%8D%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍C++中trivially copyable概念及其应用。</p><!-- 内容待补充 -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实现完美转发</title>
      <link href="/2022/10/23/C++%E5%AE%9E%E7%8E%B0%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
      <url>/2022/10/23/C++%E5%AE%9E%E7%8E%B0%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是完美转发？"><a href="#什么是完美转发？" class="headerlink" title="什么是完美转发？"></a>什么是完美转发？</h3><span id="more"></span><h4 id="在理解什么是完美转发之前，需要知道什么是万能引用"><a href="#在理解什么是完美转发之前，需要知道什么是万能引用" class="headerlink" title="在理解什么是完美转发之前，需要知道什么是万能引用?"></a>在理解什么是完美转发之前，需要知道什么是万能引用?</h4><p>在模板推导过程中，使用T&amp;&amp; a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    Add(4, 5); // a，b的类型会被推导成int&amp;&amp;</span><br><span class="line">    int a = 0;</span><br><span class="line">    int b = 0;</span><br><span class="line">    Add(a, b); // a，b的类型会被推导成int&amp;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用</p><h4 id="万能引用遇到的问题？"><a href="#万能引用遇到的问题？" class="headerlink" title="万能引用遇到的问题？"></a>万能引用遇到的问题？</h4><p>上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void AddImp(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class="line">    AddImp(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    Add(4, 5);</span><br><span class="line">    int a = 0;</span><br><span class="line">    int b = 0;</span><br><span class="line">    Add(a, b);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决方案-std-forward"><a href="#解决方案-std-forward" class="headerlink" title="解决方案: std::forward"></a>解决方案: std::forward<T></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class="line">    AddImp(std::forward&lt;T&gt;(a), std::forward&lt;T&gt;(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>std::forward的具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Tp&gt;</span><br><span class="line">_Tp&amp;&amp; forward(typename remove_reference&lt;_Tp&gt;::type&amp; __t) </span><br><span class="line">&#123;</span><br><span class="line">  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体分析一下，也是通过引用折叠来实现</p><ol><li>如果_Tp的类型是int&amp;， 通过引用折叠 int&amp; &amp;&amp; 折叠后是左值引用int&amp;</li><li>如果_Tp的类型是int&amp;&amp;， 通过引用折叠 int&amp;&amp; &amp;&amp; 折叠后是int&amp;&amp;</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>add Image</title>
      <link href="/2022/09/25/add-Image/"/>
      <url>/2022/09/25/add-Image/</url>
      
        <content type="html"><![CDATA[<p>###测试插入一张图片</p><p><img src="/2022/09/25/add-Image/sharedptr1.png"></p><p>test end</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 11 智能指针</title>
      <link href="/2022/09/25/C++-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2022/09/25/C++-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="share-ptr使用"><a href="#share-ptr使用" class="headerlink" title="share_ptr使用"></a>share_ptr使用</h3><span id="more"></span><h4 id="sharet-ptr构造函数和std-make-share-的区别"><a href="#sharet-ptr构造函数和std-make-share-的区别" class="headerlink" title="sharet_ptr构造函数和std::make_share 的区别"></a>sharet_ptr<T>构造函数和std::make_share<T> 的区别</h4><ol><li>两个堆内存和一个堆内存，std::make_share效率更高</li><li></li></ol><h3 id="weak-ptr使用"><a href="#weak-ptr使用" class="headerlink" title="weak_ptr使用"></a>weak_ptr使用</h3><ol><li>expired(),返回指向对堆对象是否释放</li><li>use_count,share_ptr的强引用计数</li><li>lock，返回share_ptr，如果释放，返回空</li><li></li></ol><h3 id="share-ptr线程安全话题"><a href="#share-ptr线程安全话题" class="headerlink" title="share_ptr线程安全话题"></a>share_ptr线程安全话题</h3><ol><li>share_ptr引用计数本身是线程安全的</li><li>一个share_ptr对象，在多个线程操作，不能保证线程安全</li><li>share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全</li></ol><h3 id="stl容器多线程安全时的性能考虑"><a href="#stl容器多线程安全时的性能考虑" class="headerlink" title="stl容器多线程安全时的性能考虑"></a>stl容器多线程安全时的性能考虑</h3><h3 id="code使用"><a href="#code使用" class="headerlink" title="code使用"></a>code使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;Person&gt; person1;</span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;Person&gt; person2(nullptr);</span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;Person&gt; person3(new Person(10));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Person&gt; person4 = std::make_shared&lt;Person&gt;(5); //效率更高，内存分布在一起</span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;Person&gt; person5(std::move(person3)); // person3无法再使用</span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;Person&gt; arary(new Person[10], deletePersonArray);</span><br><span class="line">    </span><br><span class="line">    weak_ptr&lt;Person&gt; weak_Person = person5;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;Person&gt; person6 = person5;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    person5.reset();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    person6.reset();</span><br><span class="line">    </span><br><span class="line">    if (weak_Person.expired()) &#123;</span><br><span class="line">        cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        auto shareptr = weak_Person.lock();</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; shareptr &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 右值引用</title>
      <link href="/2022/09/18/C++%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>/2022/09/18/C++%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是右值？"><a href="#1-什么是右值？" class="headerlink" title="1. 什么是右值？"></a>1. 什么是右值？</h3><p>有名称，可以取地址的值，是左值。<br>没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。<br>c++11中，所有的值，必属于左值，将亡值，和纯右值。</p><span id="more"></span><h3 id="2-左值引用，右值引用"><a href="#2-左值引用，右值引用" class="headerlink" title="2. 左值引用，右值引用"></a>2. 左值引用，右值引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    int a = 0; //ok</span><br><span class="line">    </span><br><span class="line">    int&amp; b = a; //ok,左值引用</span><br><span class="line">    int&amp; c = 0; // not ok,左值引用无法引用右值</span><br><span class="line">    </span><br><span class="line">    const int&amp; d = 0; // ok，常左值引用，可以绑定右值</span><br><span class="line">    const int&amp; e = a; // ok，常左值引用，可以绑定左值</span><br><span class="line">    </span><br><span class="line">    int&amp;&amp; f = 0;//ok 右值引用绑定右值</span><br><span class="line">    const int &amp;&amp; g = 0; // ok,常右值引用可以绑定右值</span><br><span class="line">    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗</span><br><span class="line">    </span><br><span class="line">    int&amp;&amp; h = a;//not ok，右值引用无法绑定左值</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左值引用，只能绑定左值<br>常左值引用，可以绑定常量左值，右值，非常量左值和右值<br>右值引用，只能绑定非常量右值<br>常右值引用，可以绑定常量右值，非常量右值</p><h3 id="3-讨论右值引用，要注意排除返回值优化"><a href="#3-讨论右值引用，要注意排除返回值优化" class="headerlink" title="3. 讨论右值引用，要注意排除返回值优化"></a>3. 讨论右值引用，要注意排除返回值优化</h3><p>如果关闭返回值优化，可以参考<br><a href="https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO">https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Person GetPerson()&#123;</span><br><span class="line">    return Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person person = GetPerson();</span><br><span class="line">    person.print();</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     一共执行三次构造</span><br><span class="line">    1 Person()默认构造函数</span><br><span class="line">    2 GetPerson函数返回时，生成临时对象，调用移动构造函数</span><br><span class="line">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class="line">     */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Person&amp;&amp; GetPerson()&#123;</span><br><span class="line">    return Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person person = GetPerson();</span><br><span class="line">    person.print();</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     一共执行两次次构造，这种写法是错的，会有warnning</span><br><span class="line">     Returning reference to local temporary object</span><br><span class="line">    1 Person()默认构造函数</span><br><span class="line">    2 右值引用，引用了已经析构的临时对象</span><br><span class="line">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class="line">     */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-函数返回值，如果没有写左值引用，就是临时变量属于右值"><a href="#4-函数返回值，如果没有写左值引用，就是临时变量属于右值" class="headerlink" title="4. 函数返回值，如果没有写左值引用，就是临时变量属于右值"></a>4. 函数返回值，如果没有写左值引用，就是临时变量属于右值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person GetPerson()&#123;</span><br><span class="line">    return Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    Person person1 = GetPerson(); //调用一次构造，两次次移动构造</span><br><span class="line">    </span><br><span class="line">    Person&amp;&amp; person2 = GetPerson(); //调用一次构造，一次移动构造</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象<br>person2是直接对临时变量的右值引用</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const Person&amp; GetPerson1()&#123;</span><br><span class="line">    return Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&amp;&amp; GetPerson2()&#123;</span><br><span class="line">    return Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告</p><p><code>Returning reference to local temporary object</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++中operator的重载</title>
      <link href="/2022/09/18/C++%E4%B8%ADoperator%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
      <url>/2022/09/18/C++%E4%B8%ADoperator%E7%9A%84%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="两种函数允许编译器进行隐士类型转换"><a href="#两种函数允许编译器进行隐士类型转换" class="headerlink" title="两种函数允许编译器进行隐士类型转换"></a>两种函数允许编译器进行隐士类型转换</h2><ol><li>单一参数调用成功的constructors</li><li>隐士转换操作符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Ration &#123;</span><br><span class="line">public:</span><br><span class="line">    //1 隐士构造函数</span><br><span class="line">    Ration(int a) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //2 隐士类型转换函数</span><br><span class="line">    operator double() const &#123;</span><br><span class="line">        return 5.0f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Ration ration(1);</span><br><span class="line">    cout &lt;&lt; ration &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="如何阻止构造函数发生不期望的隐士类型转换"><a href="#如何阻止构造函数发生不期望的隐士类型转换" class="headerlink" title="如何阻止构造函数发生不期望的隐士类型转换"></a>如何阻止构造函数发生不期望的隐士类型转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Ration &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Ration(int a) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Ration ration(1);</span><br><span class="line">    </span><br><span class="line">    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错</span><br><span class="line">    if (ration == 2) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。"><a href="#重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。" class="headerlink" title="重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。"></a>重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。</h3><h4 id="这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。"><a href="#这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。" class="headerlink" title="这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。"></a>这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。</h4><p>###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Ration &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Ration(int a) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int operator() (int a , int b, int c)</span><br><span class="line">    &#123;</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int operator() (int a , int b)</span><br><span class="line">    &#123;</span><br><span class="line">        return 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Ration ration(1);</span><br><span class="line">    ration(1, 2, 3);</span><br><span class="line">    ration(1, 3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 构造函数</title>
      <link href="/2022/09/18/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2022/09/18/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="C-构造函数"><a href="#C-构造函数" class="headerlink" title="C++ 构造函数"></a>C++ 构造函数</h2><ol><li>默认构造</li><li>copy构造</li><li>移动构造</li><li>operator= 赋值函数</li></ol><span id="more"></span><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Person() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Person(const Person&amp; Person) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person(Person&amp;&amp; Person) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person&amp; operator=(const Person&amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//    Person() &#123;</span><br><span class="line">//        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">//    &#125;;</span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">//    Person(const Person&amp; Person) &#123;</span><br><span class="line">//        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    Person(Person&amp;&amp; Person) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person&amp; operator=(const Person&amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person person; //编译报错，找不到匹配的构造函数</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS运行时消息转发</title>
      <link href="/2017/12/14/iOS-MessageForwarding/"/>
      <url>/2017/12/14/iOS-MessageForwarding/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解</p></blockquote><span id="more"></span><h3 id="iOS-方法调用探讨"><a href="#iOS-方法调用探讨" class="headerlink" title="iOS 方法调用探讨"></a>iOS 方法调用探讨</h3><p>这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, …)方法这种方式</p><p>在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding</p><p>如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：</p><p><img src="https://oh144b0ji.qnssl.com/OC%20runTime.jpg" alt="image.png"></p><p>主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程</p><p>1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123;</span><br><span class="line">  </span><br><span class="line">    if (aSEL == @selector(notFoundFunctiion)) &#123;</span><br><span class="line">        </span><br><span class="line">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    需要注意的是，不仅[self notFoundFunctiion]会触发这里，在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self respondsToSelector:@selector(notFoundFunctiion)]</span><br></pre></td></tr></table></figure><p>​    这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。</p><p>2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程</p><p>可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO</p><h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">Objective-C Runtime Programming Guide</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOSCALayer的presentLayer那点事</title>
      <link href="/2017/11/12/CALayer%E7%9A%84presentLayer%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
      <url>/2017/11/12/CALayer%E7%9A%84presentLayer%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决</p></blockquote><span id="more"></span><h3 id="动画过程中，如何获取它的实时位置"><a href="#动画过程中，如何获取它的实时位置" class="headerlink" title="动画过程中，如何获取它的实时位置"></a>动画过程中，如何获取它的实时位置</h3><p>这个话题涉及对CALayer的理解和使用</p><p>CALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer</p><ul><li>modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据</li><li>presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">UIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class="line"></span><br><span class="line">    view.backgroundColor = [UIColor redColor];</span><br><span class="line"></span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class="line"></span><br><span class="line">    [UIView animateWithDuration:10 animations:^&#123;</span><br><span class="line"></span><br><span class="line">        view.frame = CGRectMake(200, 100, 100, 100);</span><br><span class="line">        </span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">    </span><br><span class="line">        NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class="line">        NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac环境下安装Ruby</title>
      <link href="/2017/09/19/MacOS%E4%B8%8Bruby%E5%AE%89%E8%A3%85/"/>
      <url>/2017/09/19/MacOS%E4%B8%8Bruby%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="使用rvm来安装ruby"><a href="#使用rvm来安装ruby" class="headerlink" title="使用rvm来安装ruby"></a>使用rvm来安装ruby</h2><h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L get.rvm.io | bash -s stable  </span><br></pre></td></tr></table></figure><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  </span><br><span class="line">$ source ~/.bash_profile  </span><br><span class="line">$ rvm -v  </span><br></pre></td></tr></table></figure><h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm list known  </span><br></pre></td></tr></table></figure><h3 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm install 2.2.0  </span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="如果Step4失败，可以进行如下尝试"><a href="#如果Step4失败，可以进行如下尝试" class="headerlink" title="如果Step4失败，可以进行如下尝试"></a>如果Step4失败，可以进行如下尝试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami):admin /usr/local</span><br><span class="line">cd /usr/local</span><br><span class="line">git remote set-url origin git://mirrors.ustc.edu.cn/brew.git</span><br><span class="line">brew update</span><br><span class="line">sudo chown root:wheel /usr/local</span><br><span class="line">rvm install 2.2.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS11模拟器运行OpenGL相关程序卡顿</title>
      <link href="/2017/09/19/iOS11%20Simulator%20OpenGL%20Slowly/"/>
      <url>/2017/09/19/iOS11%20Simulator%20OpenGL%20Slowly/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug</p></blockquote><span id="more"></span><h3 id="具体的解决方案是"><a href="#具体的解决方案是" class="headerlink" title="具体的解决方案是"></a>具体的解决方案是</h3><p>替换此路径下的文件用附件文件，替换此路径下文件即可</p><p><em>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib</em>  </p><p><a href="http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib">libCoreVMClient.dylib下载链接</a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://forums.developer.apple.com/thread/83570">苹果开发者论坛</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS不受用户手动修改时间的影响的计时技术</title>
      <link href="/2017/09/17/iOS%E5%87%86%E7%A1%AE%E8%AE%A1%E6%97%B6/"/>
      <url>/2017/09/17/iOS%E5%87%86%E7%A1%AE%E8%AE%A1%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="iOS不受用户手动修改时间的影响的计时技术"><a href="#iOS不受用户手动修改时间的影响的计时技术" class="headerlink" title="iOS不受用户手动修改时间的影响的计时技术"></a>iOS不受用户手动修改时间的影响的计时技术</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><span id="more"></span><p>这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>直接说最终方案</p><p><code>[[NSProcessInfo processInfo] systemUptime];</code></p><p>这个函数返回的是开机到当前的时间，秒数为单位，并且<strong>不受系统时钟的影响</strong>，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc">苹果接口文档</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS手势事件分发原理</title>
      <link href="/2017/07/01/iOS%E6%89%8B%E5%8A%BF%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%8E%9F%E7%90%86/"/>
      <url>/2017/07/01/iOS%E6%89%8B%E5%8A%BF%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>HitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event&#123;</span><br><span class="line">    </span><br><span class="line">    //apple文档描述，不接受事件的情况</span><br><span class="line">    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha &lt; 0.01) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果当前View包含此Point</span><br><span class="line">    if ([self pointInside:point withEvent:event]) &#123;</span><br><span class="line">        </span><br><span class="line">        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的</span><br><span class="line">        for (NSInteger i=self.subviews.count-1; i&gt;=0; i--) &#123;</span><br><span class="line">            </span><br><span class="line">            UIView* subView = [self.subviews objectAtIndex:i];</span><br><span class="line">            </span><br><span class="line">            //将父View的Point转换成子View坐标系的Point</span><br><span class="line">            CGPoint pointInSubView = [subView convertPoint:point fromView:self];</span><br><span class="line">            </span><br><span class="line">            //递归子View调用HitTest:</span><br><span class="line">            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];</span><br><span class="line">            </span><br><span class="line">            //找到了子View可以响应</span><br><span class="line">            if (resultView) &#123;</span><br><span class="line">                return resultView;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //没有找到可以响应的子View，返回自己</span><br><span class="line">        return self;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //返回nil，告诉上一级自己无法响应此事件</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>流程图总结</p><p><img src="http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tweak心得</title>
      <link href="/2017/03/07/tweak%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2017/03/07/tweak%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="1-关于ssh"><a href="#1-关于ssh" class="headerlink" title="1 关于ssh"></a>1 关于ssh</h3><p>一般形式 ssh <a href="mailto:&#x72;&#111;&#111;&#x74;&#64;&#49;&#x39;&#50;&#x2e;&#x31;&#x36;&#56;&#46;&#50;&#46;&#x31;&#x37;">&#x72;&#111;&#111;&#x74;&#64;&#49;&#x39;&#50;&#x2e;&#x31;&#x36;&#56;&#46;&#50;&#46;&#x31;&#x37;</a>或者ssh <a href="mailto:&#x6d;&#x6f;&#98;&#105;&#x6c;&#101;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#x32;&#46;&#49;&#x37;">&#x6d;&#x6f;&#98;&#105;&#x6c;&#101;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#x32;&#46;&#49;&#x37;</a></p><span id="more"></span><p>root和mobile分别为iOS上默认用户，alpine是默认密码</p><p>可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码</p><h3 id="2-scp-source-dest"><a href="#2-scp-source-dest" class="headerlink" title="2 scp source dest"></a>2 scp source dest</h3><p>一般为</p><p>scp ~/123.txt <a href="mailto:&#x6d;&#x6f;&#98;&#105;&#x6c;&#x65;&#64;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#50;&#x2e;&#x31;&#x37;">&#x6d;&#x6f;&#98;&#105;&#x6c;&#x65;&#64;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#50;&#x2e;&#x31;&#x37;</a>:/usr/bin</p><h3 id="3-Makefile"><a href="#3-Makefile" class="headerlink" title="3 Makefile"></a>3 Makefile</h3><p>可以配置手机的IP，framework，arch等参数</p><p>THEOS_DEVICE_IP = 192.168.31.202<br>ARCHS = armv7 arm64<br>TARGET = iphone:latest:8.0</p><p>iOSREGreetings_FRAMEWORKS = UIKit </p><h3 id="4-关于bundleID"><a href="#4-关于bundleID" class="headerlink" title="4 关于bundleID"></a>4 关于bundleID</h3><p>.plist中的bundle就是你想hook的程序的bundleID</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tweak环境搭建</title>
      <link href="/2017/03/07/tweak%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/03/07/tweak%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="0-设置环境变量-export-THEOS-opt-theos"><a href="#0-设置环境变量-export-THEOS-opt-theos" class="headerlink" title="0 设置环境变量 export THEOS=/opt/theos"></a>0 设置环境变量 export THEOS=/opt/theos</h3><p>可以设置~/.zshrc中添加，修改后用source命令重新加载</p><span id="more"></span><h3 id="1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下"><a href="#1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下" class="headerlink" title="1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下"></a>1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下</h3><h3 id="2-下载ldid，放到-opt-theos-bin下"><a href="#2-下载ldid，放到-opt-theos-bin下" class="headerlink" title="2 下载ldid，放到/opt/theos/bin下"></a>2 下载ldid，放到/opt/theos/bin下</h3><p>sudo chmod 777 /opt/theos/bin/ldid</p><h3 id="3-配置CydiaSubstrate"><a href="#3-配置CydiaSubstrate" class="headerlink" title="3 配置CydiaSubstrate"></a>3 配置CydiaSubstrate</h3><p>在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib</p><p>并将头文件substrate.h也scp 到/opt/theos/include下</p><p>sudo /opt/theos/bin/bootstrap.sh substrate</p><h3 id="4-将dm-pl重命名为dpkg-deb，cp到-opt-bin"><a href="#4-将dm-pl重命名为dpkg-deb，cp到-opt-bin" class="headerlink" title="4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/"></a>4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/</h3><p>suodo chmod 777 /opt/bin/dpkg-deb</p><p>基本就搭建完成，可以练习创建工程</p><p>/opt/theos/bin/nic.pl</p><p>然后进行make package </p><p>make package install</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纹理贴图</title>
      <link href="/2017/01/03/OpenGL-%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/"/>
      <url>/2017/01/03/OpenGL-%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>1 VertexShader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">attribute vec2 TexCoordIn; // New</span><br><span class="line">varying vec2 TexCoordOut; // New</span><br><span class="line"></span><br><span class="line">void main(void) &#123; </span><br><span class="line">    DestinationColor = SourceColor; </span><br><span class="line">    gl_Position = Projection * Modelview * Position;</span><br><span class="line">    TexCoordOut = TexCoordIn; // New</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>2 FragmentShader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">varying lowp vec4 DestinationColor;</span><br><span class="line">varying lowp vec2 TexCoordOut; // New</span><br><span class="line">uniform sampler2D Texture; // New</span><br><span class="line"></span><br><span class="line">void main(void) &#123;</span><br><span class="line">    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 将图片资源转换成位图数据，绑定到对应纹理ID中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ (GLuint)createTextureWithImage:(UIImage *)image&#123;</span><br><span class="line">    </span><br><span class="line">    //转换为CGImage，获取图片基本参数</span><br><span class="line">    CGImageRef cgImageRef = [image CGImage];</span><br><span class="line">    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);</span><br><span class="line">    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);</span><br><span class="line">    CGRect rect = CGRectMake(0, 0, width, height);</span><br><span class="line">    </span><br><span class="line">    //绘制图片</span><br><span class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    void *imageData = malloc(width * height * 4);</span><br><span class="line">    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line">    CGContextTranslateCTM(context, 0, height);</span><br><span class="line">    CGContextScaleCTM(context, 1.0f, -1.0f);</span><br><span class="line">    CGColorSpaceRelease(colorSpace);</span><br><span class="line">    CGContextClearRect(context, rect);</span><br><span class="line">    CGContextDrawImage(context, rect, cgImageRef);</span><br><span class="line">    </span><br><span class="line">    GLuint textureID;</span><br><span class="line">    glGenTextures(1, &amp;textureID);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, textureID);</span><br><span class="line">    </span><br><span class="line">    //纹理一些设置，可有可无</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    </span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);</span><br><span class="line">    </span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, 0);</span><br><span class="line">    </span><br><span class="line">    //释放内存</span><br><span class="line">    CGContextRelease(context);</span><br><span class="line">    free(imageData);</span><br><span class="line">    </span><br><span class="line">    return textureID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 绘制时使用纹理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">//载入纹理</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, _textTureId);</span><br><span class="line"></span><br><span class="line">glUniform1i(_textureSlot, 0);</span><br><span class="line"></span><br><span class="line">const GLfloat texCoords[] = &#123;</span><br><span class="line">    0, 0,//左下</span><br><span class="line">    1, 0,//右下</span><br><span class="line">    0, 1,//左上</span><br><span class="line">    1, 1,//右上</span><br><span class="line">&#125;;</span><br><span class="line">glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);</span><br><span class="line">glEnableVertexAttribArray(_textureCoordsSlot);</span><br></pre></td></tr></table></figure><p>5 关于纹理坐标</p>]]></content>
      
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光照学习</title>
      <link href="/2017/01/02/OpenGL-%E5%85%89%E7%85%A7%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/01/02/OpenGL-%E5%85%89%E7%85%A7%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性</p><span id="more"></span><p>2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）</p><p>3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射</p><p>4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节</p><h3 id="光的计算："><a href="#光的计算：" class="headerlink" title="光的计算："></a>光的计算：</h3><p>1 发射光计算：发射颜色=物体的发射材质颜色</p><p>2 环境光计算</p><p>环境颜色 = 光源的环境光颜色*物体的环境材质颜色</p><p>3 漫反射计算：</p><p>漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor</p><p>其中DiffuseFactor = max（0，dot（N，L））</p><p>dot表示两个向量夹角的cos</p><p>4 镜面反射：</p><p>镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor</p><p>SpecularFactor = power（max（0， dot（N，H）），shininess）</p><p>H = normalise（L+E）</p>]]></content>
      
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VBO</title>
      <link href="/2017/01/02/OpenGL-VBO/"/>
      <url>/2017/01/02/OpenGL-VBO/</url>
      
        <content type="html"><![CDATA[<h3 id="VBO的目的："><a href="#VBO的目的：" class="headerlink" title="VBO的目的："></a>VBO的目的：</h3><p>主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间</p><span id="more"></span><p>两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER</p><p>分别对应顶点数据和索引</p><p>使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量</p><h3 id="VBO使用的大概流程："><a href="#VBO使用的大概流程：" class="headerlink" title="VBO使用的大概流程："></a>VBO使用的大概流程：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//获取一个操作句柄</span><br><span class="line">glGenBuffers(1, &amp;_vertexBuffer);</span><br><span class="line">//设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class="line">//分配内存空间</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class="line">glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);</span><br><span class="line">glEnableVertexAttribArray(_positionSlot);</span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);</span><br><span class="line">glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);</span><br><span class="line"></span><br><span class="line">//可以在清理时，释放VBO</span><br><span class="line">glDeleteBuffers(1, &amp;_vertexBuffer);</span><br><span class="line">_vertexBuffer = 0;</span><br><span class="line"></span><br><span class="line">glDeleteBuffers(1, &amp;_triangleIndexBuffer);</span><br><span class="line">_triangleIndexBuffer = 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniform和attribute区别</title>
      <link href="/2016/12/30/OpenGL-uniform%E5%92%8Cattribute/"/>
      <url>/2016/12/30/OpenGL-uniform%E5%92%8Cattribute/</url>
      
        <content type="html"><![CDATA[<h4 id="简单对比一下"><a href="#简单对比一下" class="headerlink" title="简单对比一下"></a>简单对比一下</h4><p>attribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用</p><span id="more"></span><p>uniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用</p><p>使用上的区别：</p><p>1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法</p><p>2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制</p><p>3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements</p>]]></content>
      
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opengl iOS创建OpenGL环境绘制一个简单三角形</title>
      <link href="/2016/12/30/OpenGL-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%92%8C%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2/"/>
      <url>/2016/12/30/OpenGL-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%92%8C%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="EAGLView创建要点"><a href="#EAGLView创建要点" class="headerlink" title="EAGLView创建要点"></a>EAGLView创建要点</h3><p>1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupLayer&#123;</span><br><span class="line"></span><br><span class="line">    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;</span><br><span class="line">    </span><br><span class="line">    layer.opaque = YES;</span><br><span class="line">    </span><br><span class="line">    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,</span><br><span class="line">                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2  创建EAGLContext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br></pre></td></tr></table></figure><p>3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：</p><p>a获取着色器源文件，创建shader，编译</p><p>b创建program，attachShader，link，useProgram</p><p>c从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)</p><p>这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext</p><p>4 每一帧绘制流程</p><p>在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawFrame&#123;</span><br><span class="line"></span><br><span class="line">    [_eaglView setFramebuffer];</span><br><span class="line">    </span><br><span class="line">    [_eaglView draw];</span><br><span class="line">    </span><br><span class="line">    [_eaglView presentFramebuffer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5 关于frameBuffetObject的创建和释放</p><p>前提：context确保设置</p><p>流程大致是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (void)createBuffer&#123;</span><br><span class="line">    </span><br><span class="line">    [self checkContext];</span><br><span class="line">    </span><br><span class="line">    glGenRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class="line">    </span><br><span class="line">    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class="line">    </span><br><span class="line">    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];</span><br><span class="line">    </span><br><span class="line">    glGenFramebuffers(1, &amp;_frameBuffer);</span><br><span class="line">    </span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class="line">    </span><br><span class="line">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">    GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)deleteBuffer&#123;</span><br><span class="line"></span><br><span class="line">    [self checkContext];</span><br><span class="line">    </span><br><span class="line">    glDeleteRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class="line">    </span><br><span class="line">    _colorRenderBuffer = 0;</span><br><span class="line">    </span><br><span class="line">    glDeleteFramebuffers(1, &amp;_frameBuffer);</span><br><span class="line">    </span><br><span class="line">    _frameBuffer = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFramebuffer</span><br><span class="line">&#123;</span><br><span class="line">    if ([self checkContext])</span><br><span class="line">    &#123;</span><br><span class="line">        if (!_frameBuffer)&#123;</span><br><span class="line">            [self createBuffer];</span><br><span class="line">        &#125;</span><br><span class="line">        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)presentFramebuffer</span><br><span class="line">&#123;</span><br><span class="line">    BOOL success = FALSE;</span><br><span class="line">    </span><br><span class="line">    if ([self checkContext])</span><br><span class="line">    &#123;</span><br><span class="line">        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class="line">        </span><br><span class="line">        success = [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class="line">    &#125;</span><br><span class="line">    return success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6 关于绘制三角形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)draw&#123;</span><br><span class="line">    //设置背景颜色为绿色</span><br><span class="line">    glClearColor(0, 1.0, 0,1.0);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    //设置管区域大小</span><br><span class="line">    glViewport(0, 0, self.frame.size.width, self.frame.size.height);</span><br><span class="line">    </span><br><span class="line">    GLfloat vertices[] = &#123;</span><br><span class="line">        0.0f,  0.5f, 0.0f,</span><br><span class="line">        -0.5f, -0.5f, 0.0f,</span><br><span class="line">        0.5f,  -0.5f, 0.0f &#125;;</span><br><span class="line">    //设置着色器中的vPositon</span><br><span class="line">    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);</span><br><span class="line">    //使上一步的设置生效</span><br><span class="line">    glEnableVertexAttribArray(_positionSlot);</span><br><span class="line">    //绘制三角形</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CALayer opaque</title>
      <link href="/2016/12/30/CALayer-opaque/"/>
      <url>/2016/12/30/CALayer-opaque/</url>
      
        <content type="html"><![CDATA[<h3 id="颜色合成公式"><a href="#颜色合成公式" class="headerlink" title="颜色合成公式"></a>颜色合成公式</h3><p><strong>R = S + D * ( 1 – Sa )</strong></p><p> <img src="/Users/baidu/Downloads/20130819170332968.png" alt="20130819170332968"></p><p>其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。</p><p>设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算</p><p>注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CALayer属性positon和anchor</title>
      <link href="/2016/10/26/CALayer%E5%B1%9E%E6%80%A7positon%E5%92%8Canchor/"/>
      <url>/2016/10/26/CALayer%E5%B1%9E%E6%80%A7positon%E5%92%8Canchor/</url>
      
        <content type="html"><![CDATA[<h3 id="CALayer-的frame，bounds-position和anchor"><a href="#CALayer-的frame，bounds-position和anchor" class="headerlink" title="CALayer 的frame，bounds, position和anchor"></a>CALayer 的frame，bounds, position和anchor</h3><span id="more"></span><p>frame描述的是在父layer上的坐标和尺寸</p><p>bounds是类似于View的bounds</p><p>anchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）</p><p>position描述的是anchor的在父layer的坐标</p><p>举例来说，一个View的Frame是（40，40，100，100）</p><p>那么layer的frame是（40，40，100，100）</p><p>bound是（0，0，100，100）</p><p>position是：（140，140）</p><p>position计算：</p><p>pos.x = origin.x + anchor.x*size.with</p><p>pos.y = origin.y + anchor.y*size.height</p><p>如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化</p><p>如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可</p><pre><code>CGRect oldFrame = _redView.frame;_redView.layer.anchorPoint = CGPointMake(0.5, 1);_redView.frame = oldFrame;</code></pre><p>注意，position并不适用这一点</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么build apple watch app</title>
      <link href="/2016/10/26/How%20to%20build%20Apple%20Watch%20App/"/>
      <url>/2016/10/26/How%20to%20build%20Apple%20Watch%20App/</url>
      
        <content type="html"><![CDATA[<h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>在IphoneCom 的Embedded Binaries中添加Watch.app</p><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>Run IphoneCom</p><h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h3><p>run WachApp</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
