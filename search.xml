<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++类型转换陷阱：有符号和无符号整数比较</title>
      <link href="/2025/06/08/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%99%B7%E9%98%B1-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%AF%94%E8%BE%83/"/>
      <url>/2025/06/08/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%99%B7%E9%98%B1-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>在C++编程中，有一些看似简单的操作可能会带来意想不到的结果。今天我们要讨论一个常见但容易被忽视的问题：有符号整数（signed）和无符号整数（unsigned）的比较操作。</p><span id="more"></span><h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>让我们看一个具体的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> a = <span class="number">-1</span>;</span><br><span class="line">uint b = <span class="number">4152</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isLess = a &lt; b; <span class="comment">// 预期结果：true，实际结果：false</span></span><br></pre></td></tr></table></figure><p>这段代码的运行结果可能会让人感到困惑。虽然-1显然小于4152，但比较结果却返回false。这是为什么呢？</p><h2 id="背后的机制"><a href="#背后的机制" class="headerlink" title="背后的机制"></a>背后的机制</h2><h3 id="类型转换规则"><a href="#类型转换规则" class="headerlink" title="类型转换规则"></a>类型转换规则</h3><p>在C++中，当有符号整数和无符号整数进行比较时，会发生以下转换：</p><ol><li><strong>有符号整数会被转换为无符号整数</strong></li><li><strong>转换规则遵循补码表示</strong></li></ol><p>在我们的例子中：</p><ul><li><code>-1</code>的补码表示为<code>0xFFFFFFFF</code></li><li>当转换为无符号整数时，这个值被解释为<code>4294967295</code></li><li>因此实际的比较变成了：<code>4294967295 &lt; 4152</code></li><li>显然这个比较会返回<code>false</code></li></ul><h3 id="为什么会这样设计？"><a href="#为什么会这样设计？" class="headerlink" title="为什么会这样设计？"></a>为什么会这样设计？</h3><p>这个设计有其历史原因：</p><ul><li>处理器进行整数比较时，实际是在比较二进制位</li><li>无符号整数的比较更简单且更快</li><li>C++继承了C语言的这一特性</li></ul><h2 id="如何避免这类问题"><a href="#如何避免这类问题" class="headerlink" title="如何避免这类问题"></a>如何避免这类问题</h2><h3 id="1-使用相同的类型"><a href="#1-使用相同的类型" class="headerlink" title="1. 使用相同的类型"></a>1. 使用相同的类型</h3><p>最简单的解决方案是确保比较的两个数使用相同的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案1：都使用有符号整数</span></span><br><span class="line"><span class="type">int32_t</span> m_IBufferMaxValue = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int32_t</span> pointCount = <span class="number">4152</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案2：都使用无符号整数（如果数值总是非负的话）</span></span><br><span class="line"><span class="type">uint32_t</span> m_IBufferMaxValue = <span class="number">0</span>;  <span class="comment">// 或其他非负值</span></span><br><span class="line"><span class="type">uint32_t</span> pointCount = <span class="number">4152</span>;</span><br></pre></td></tr></table></figure><h3 id="2-显式类型转换"><a href="#2-显式类型转换" class="headerlink" title="2. 显式类型转换"></a>2. 显式类型转换</h3><p>如果必须使用不同的类型，请使用显式类型转换并注意检查值的范围：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用static_cast进行显式转换</span></span><br><span class="line"><span class="type">bool</span> isLess = m_IBufferMaxValue &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(pointCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者先进行范围检查</span></span><br><span class="line"><span class="keyword">if</span> (pointCount &lt;= INT32_MAX) &#123;</span><br><span class="line">    <span class="type">bool</span> isLess = m_IBufferMaxValue &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(pointCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用类型安全的比较函数"><a href="#3-使用类型安全的比较函数" class="headerlink" title="3. 使用类型安全的比较函数"></a>3. 使用类型安全的比较函数</h3><p>可以封装一个安全的比较函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SafeCompare</span><span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_signed_v&lt;T1&gt; &amp;&amp; std::is_unsigned_v&lt;T2&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">make_unsigned_t</span>&lt;T1&gt;&gt;(a) &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加其他类型组合的处理...</span></span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-代码检查工具"><a href="#4-代码检查工具" class="headerlink" title="4. 代码检查工具"></a>4. 代码检查工具</h3><ul><li>使用静态代码分析工具</li><li>启用编译器警告</li><li>使用<code>-Wsign-compare</code>警告选项</li></ul><h2 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h2><ol><li><p><strong>明确变量类型</strong></p><ul><li>在声明变量时就明确其是否需要支持负值</li><li>如果数值永远不会为负，就使用无符号类型</li></ul></li><li><p><strong>统一类型使用</strong></p><ul><li>在同一个模块或相关的代码中保持类型的一致性</li><li>避免混合使用有符号和无符号类型</li></ul></li><li><p><strong>文档和注释</strong></p><ul><li>在可能发生类型转换的地方添加清晰的注释</li><li>记录类型选择的原因和注意事项</li></ul></li><li><p><strong>单元测试</strong></p><ul><li>编写测试用例覆盖边界条件</li><li>特别注意类型转换可能发生的场景</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>类型转换的陷阱虽然看似简单，但在实际开发中经常会造成难以发现的bug。通过：</p><ul><li>理解类型转换规则</li><li>采用一致的类型</li><li>使用显式转换</li><li>添加适当的检查</li></ul><p>我们可以有效地避免这类问题。记住，在处理不同整数类型的比较时，宁可多写几行代码，也要确保类型转换的安全性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>C++ Standard Library</li><li>Effective C++</li><li>C++ Core Guidelines </li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程陷阱 </tag>
            
            <tag> 类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>培养孩子阅读习惯的优质书单推荐</title>
      <link href="/2025/06/07/%E5%9F%B9%E5%85%BB%E5%AD%A9%E5%AD%90%E9%98%85%E8%AF%BB%E4%B9%A0%E6%83%AF%E7%9A%84%E4%BC%98%E8%B4%A8%E4%B9%A6%E5%8D%95%E6%8E%A8%E8%8D%90/"/>
      <url>/2025/06/07/%E5%9F%B9%E5%85%BB%E5%AD%A9%E5%AD%90%E9%98%85%E8%AF%BB%E4%B9%A0%E6%83%AF%E7%9A%84%E4%BC%98%E8%B4%A8%E4%B9%A6%E5%8D%95%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>选择合适的书籍是培养孩子阅读兴趣的关键第一步。本文根据不同年龄段孩子的认知特点和兴趣偏好，精心整理了一份优质书单，帮助家长为孩子挑选最适合的读物。</p><span id="more"></span><h2 id="3-6岁：启蒙阶段书单"><a href="#3-6岁：启蒙阶段书单" class="headerlink" title="3-6岁：启蒙阶段书单"></a>3-6岁：启蒙阶段书单</h2><h3 id="经典绘本系列"><a href="#经典绘本系列" class="headerlink" title="经典绘本系列"></a>经典绘本系列</h3><p><strong>《好饿的毛毛虫》- 艾瑞克·卡尔</strong></p><ul><li><strong>推荐理由</strong>：色彩鲜艳，故事简单有趣，教授数字和星期概念</li><li><strong>阅读技巧</strong>：可以让孩子用手指跟着毛毛虫”吃”东西</li><li><strong>延伸活动</strong>：制作毛毛虫手工，观察真实的蝴蝶变化过程</li></ul><p><strong>《猜猜我有多爱你》- 山姆·麦克布雷尼</strong></p><ul><li><strong>推荐理由</strong>：温馨的亲情故事，培养表达爱的能力</li><li><strong>阅读技巧</strong>：鼓励孩子模仿书中动作，增强互动性</li><li><strong>延伸活动</strong>：和孩子一起比较”谁爱谁更多”</li></ul><p><strong>《逃家小兔》- 玛格丽特·怀兹·布朗</strong></p><ul><li><strong>推荐理由</strong>：经典的母爱主题，给孩子安全感</li><li><strong>阅读技巧</strong>：可以和孩子角色扮演，一个当小兔，一个当妈妈</li><li><strong>延伸活动</strong>：讨论”如果你要逃跑，妈妈会怎么找到你”</li></ul><h3 id="中文原创绘本"><a href="#中文原创绘本" class="headerlink" title="中文原创绘本"></a>中文原创绘本</h3><p><strong>《小熊和最好的爸爸》系列 - 阿兰德·丹姆</strong></p><ul><li><strong>推荐理由</strong>：父子情深，适合爸爸和孩子一起阅读</li><li><strong>特色</strong>：7本书涵盖不同主题，从游戏到成长</li></ul><p><strong>《不一样的卡梅拉》系列</strong></p><ul><li><strong>推荐理由</strong>：想象力丰富，鼓励孩子勇于尝试</li><li><strong>特色</strong>：每本都有不同的冒险故事</li></ul><h2 id="7-10岁：桥梁书阶段"><a href="#7-10岁：桥梁书阶段" class="headerlink" title="7-10岁：桥梁书阶段"></a>7-10岁：桥梁书阶段</h2><h3 id="冒险故事类"><a href="#冒险故事类" class="headerlink" title="冒险故事类"></a>冒险故事类</h3><p><strong>《神奇树屋》系列 - 玛丽·波·奥斯本</strong></p><ul><li><strong>推荐理由</strong>：结合历史知识和冒险故事，寓教于乐</li><li><strong>阅读建议</strong>：可以按照历史时间线阅读，增强历史感</li><li><strong>延伸学习</strong>：查阅相关历史资料，制作时间轴</li></ul><p><strong>《内德的秘密花园》- 琳达·苏·帕克</strong></p><ul><li><strong>推荐理由</strong>：环保主题，培养孩子的责任感</li><li><strong>特色</strong>：插图精美，文字适中</li></ul><h3 id="科普启蒙类"><a href="#科普启蒙类" class="headerlink" title="科普启蒙类"></a>科普启蒙类</h3><p><strong>《可怕的科学》系列</strong></p><ul><li><strong>推荐理由</strong>：用幽默的方式讲解科学知识</li><li><strong>特色</strong>：图文并茂，实验性强</li><li><strong>阅读建议</strong>：可以和孩子一起做书中的小实验</li></ul><p><strong>《DK儿童百科全书》</strong></p><ul><li><strong>推荐理由</strong>：知识全面，图片精美</li><li><strong>使用方法</strong>：不需要从头读到尾，可以按兴趣查阅</li></ul><h3 id="成长励志类"><a href="#成长励志类" class="headerlink" title="成长励志类"></a>成长励志类</h3><p><strong>《小屁孩日记》系列</strong></p><ul><li><strong>推荐理由</strong>：贴近孩子生活，幽默风趣</li><li><strong>特色</strong>：日记体形式，容易引起共鸣</li></ul><p><strong>《窗边的小豆豆》- 黑柳彻子</strong></p><ul><li><strong>推荐理由</strong>：真实的成长故事，培养同理心</li><li><strong>教育价值</strong>：让孩子理解不同的教育方式</li></ul><h2 id="11-14岁：深度阅读阶段"><a href="#11-14岁：深度阅读阶段" class="headerlink" title="11-14岁：深度阅读阶段"></a>11-14岁：深度阅读阶段</h2><h3 id="经典文学入门"><a href="#经典文学入门" class="headerlink" title="经典文学入门"></a>经典文学入门</h3><p><strong>《哈利·波特》系列 - J.K.罗琳</strong></p><ul><li><strong>推荐理由</strong>：想象力丰富，情节引人入胜</li><li><strong>阅读建议</strong>：可以先看前三部，适应后再读后续</li><li><strong>延伸活动</strong>：制作魔法道具，讨论友谊和勇气</li></ul><p><strong>《纳尼亚传奇》系列 - C.S.路易斯</strong></p><ul><li><strong>推荐理由</strong>：奇幻冒险，蕴含深刻哲理</li><li><strong>特色</strong>：每本都是独立故事，可以单独阅读</li></ul><p><strong>《小王子》- 安托万·德·圣-埃克苏佩里</strong></p><ul><li><strong>推荐理由</strong>：哲理深刻，适合反复阅读</li><li><strong>阅读建议</strong>：可以和孩子讨论每个星球的寓意</li></ul><h3 id="科幻探索类"><a href="#科幻探索类" class="headerlink" title="科幻探索类"></a>科幻探索类</h3><p><strong>《三体》青少年版 - 刘慈欣</strong></p><ul><li><strong>推荐理由</strong>：中国科幻经典，培养科学思维</li><li><strong>注意事项</strong>：内容较深，建议有一定阅读基础后再读</li></ul><p><strong>《时间机器》- H.G.威尔斯</strong></p><ul><li><strong>推荐理由</strong>：科幻经典，引发对时间的思考</li><li><strong>延伸讨论</strong>：时间旅行的可能性和后果</li></ul><h3 id="历史传记类"><a href="#历史传记类" class="headerlink" title="历史传记类"></a>历史传记类</h3><p><strong>《上下五千年》</strong></p><ul><li><strong>推荐理由</strong>：了解中国历史，培养文化自信</li><li><strong>阅读建议</strong>：可以选择感兴趣的历史人物重点阅读</li></ul><p><strong>《居里夫人传》</strong></p><ul><li><strong>推荐理由</strong>：科学家传记，特别适合女孩阅读</li><li><strong>教育价值</strong>：坚持和奉献精神的典范</li></ul><h2 id="15岁以上：经典文学阶段"><a href="#15岁以上：经典文学阶段" class="headerlink" title="15岁以上：经典文学阶段"></a>15岁以上：经典文学阶段</h2><h3 id="中外经典名著"><a href="#中外经典名著" class="headerlink" title="中外经典名著"></a>中外经典名著</h3><p><strong>《红楼梦》（青少年版）</strong></p><ul><li><strong>推荐理由</strong>：中国古典文学巅峰之作</li><li><strong>阅读建议</strong>：可以先读简化版，培养兴趣后再读原著</li></ul><p><strong>《傲慢与偏见》- 简·奥斯汀</strong></p><ul><li><strong>推荐理由</strong>：经典爱情小说，文笔优美</li><li><strong>教育价值</strong>：理解人性的复杂和成长的意义</li></ul><p><strong>《1984》- 乔治·奥威尔</strong></p><ul><li><strong>推荐理由</strong>：反乌托邦经典，培养批判思维</li><li><strong>注意事项</strong>：内容较为深刻，需要引导讨论</li></ul><h3 id="哲学思辨类"><a href="#哲学思辨类" class="headerlink" title="哲学思辨类"></a>哲学思辨类</h3><p><strong>《苏菲的世界》- 乔斯坦·贾德</strong></p><ul><li><strong>推荐理由</strong>：哲学启蒙读物，深入浅出</li><li><strong>阅读建议</strong>：可以分章节讨论，不急于一次读完</li></ul><p><strong>《瓦尔登湖》- 梭罗</strong></p><ul><li><strong>推荐理由</strong>：自然哲学，培养独立思考</li><li><strong>延伸活动</strong>：尝试简单生活，体验自然</li></ul><h2 id="选书的实用技巧"><a href="#选书的实用技巧" class="headerlink" title="选书的实用技巧"></a>选书的实用技巧</h2><h3 id="根据孩子兴趣选择"><a href="#根据孩子兴趣选择" class="headerlink" title="根据孩子兴趣选择"></a>根据孩子兴趣选择</h3><p><strong>观察孩子的偏好：</strong></p><ul><li>喜欢动物的孩子：选择动物主题的故事</li><li>喜欢冒险的孩子：选择探险类小说</li><li>喜欢科学的孩子：选择科普类读物</li><li>喜欢历史的孩子：选择历史故事和传记</li></ul><h3 id="循序渐进的原则"><a href="#循序渐进的原则" class="headerlink" title="循序渐进的原则"></a>循序渐进的原则</h3><p><strong>难度递增：</strong></p><ol><li>从图多字少开始</li><li>逐步增加文字比例</li><li>最终过渡到纯文字书籍</li></ol><p><strong>兴趣引导：</strong></p><ol><li>先选择孩子感兴趣的主题</li><li>在同一主题下选择不同难度的书</li><li>适时引入新的主题和类型</li></ol><h3 id="质量判断标准"><a href="#质量判断标准" class="headerlink" title="质量判断标准"></a>质量判断标准</h3><p><strong>好书的特征：</strong></p><ul><li>语言优美，适合年龄段</li><li>内容积极正面，传递正确价值观</li><li>情节引人入胜，能够吸引孩子</li><li>插图精美（对于低年龄段）</li><li>获得过权威奖项或专家推荐</li></ul><h2 id="亲子阅读的实施建议"><a href="#亲子阅读的实施建议" class="headerlink" title="亲子阅读的实施建议"></a>亲子阅读的实施建议</h2><h3 id="创建阅读计划"><a href="#创建阅读计划" class="headerlink" title="创建阅读计划"></a>创建阅读计划</h3><p><strong>每日阅读时间安排：</strong></p><ul><li>3-6岁：15-20分钟</li><li>7-10岁：30-45分钟</li><li>11-14岁：45-60分钟</li><li>15岁以上：60分钟以上</li></ul><p><strong>阅读方式多样化：</strong></p><ul><li>亲子共读</li><li>独立阅读</li><li>有声书辅助</li><li>电子书补充</li></ul><h3 id="阅读后的互动"><a href="#阅读后的互动" class="headerlink" title="阅读后的互动"></a>阅读后的互动</h3><p><strong>讨论要点：</strong></p><ul><li>最喜欢的角色是谁？为什么？</li><li>如果你是主人公，会怎么做？</li><li>这个故事告诉我们什么道理？</li><li>你想推荐给其他小朋友吗？</li></ul><p><strong>创意活动：</strong></p><ul><li>画出故事中的场景</li><li>续写故事结尾</li><li>表演故事片段</li><li>制作读书笔记</li></ul><h2 id="建立家庭图书馆"><a href="#建立家庭图书馆" class="headerlink" title="建立家庭图书馆"></a>建立家庭图书馆</h2><h3 id="购书建议"><a href="#购书建议" class="headerlink" title="购书建议"></a>购书建议</h3><p><strong>预算分配：</strong></p><ul><li>经典必读书籍：60%</li><li>孩子兴趣书籍：30%</li><li>尝试性新书：10%</li></ul><p><strong>购买渠道：</strong></p><ul><li>实体书店：可以现场翻阅</li><li>网上书店：价格优惠，选择丰富</li><li>二手书市场：经济实惠</li><li>图书馆借阅：先试读再决定是否购买</li></ul><h3 id="图书管理"><a href="#图书管理" class="headerlink" title="图书管理"></a>图书管理</h3><p><strong>分类整理：</strong></p><ul><li>按年龄段分类</li><li>按主题分类</li><li>按阅读状态分类（已读/未读/正在读）</li></ul><p><strong>阅读记录：</strong></p><ul><li>建立读书清单</li><li>记录阅读日期</li><li>写下简单感想</li><li>评分推荐指数</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>培养孩子的阅读习惯是一个长期的过程，选择合适的书籍只是第一步。更重要的是要：</p><ol><li><strong>尊重孩子的选择</strong>：在推荐的基础上，让孩子有自主选择权</li><li><strong>保持耐心</strong>：不要急于求成，允许孩子有自己的阅读节奏</li><li><strong>以身作则</strong>：家长的阅读习惯是最好的榜样</li><li><strong>创造氛围</strong>：营造良好的家庭阅读环境</li><li><strong>适时引导</strong>：在孩子遇到困难时给予帮助和鼓励</li></ol><p>记住，每个孩子都是独特的，最适合的书单是根据自己孩子的特点量身定制的。希望这份书单能够为您提供参考，帮助您的孩子在书籍的海洋中找到属于自己的宝藏，从而逐步减少对手机的依赖，爱上阅读的美好世界。 </p>]]></content>
      
      
      <categories>
          
          <category> 家庭教育 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 书单 </tag>
            
            <tag> 儿童教育 </tag>
            
            <tag> 亲子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让孩子戒掉手机爱上阅读：实用策略指南</title>
      <link href="/2025/06/07/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AD%A9%E5%AD%90%E6%88%92%E6%8E%89%E6%89%8B%E6%9C%BA%E7%88%B1%E4%B8%8A%E9%98%85%E8%AF%BB-%E5%AE%9E%E7%94%A8%E7%AD%96%E7%95%A5%E6%8C%87%E5%8D%97/"/>
      <url>/2025/06/07/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%AD%A9%E5%AD%90%E6%88%92%E6%8E%89%E6%89%8B%E6%9C%BA%E7%88%B1%E4%B8%8A%E9%98%85%E8%AF%BB-%E5%AE%9E%E7%94%A8%E7%AD%96%E7%95%A5%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>在数字化时代，如何引导孩子从手机屏幕转向书本页面，是每个家长都关心的话题。本文将分享一些经过实践验证的策略，帮助您的孩子逐步减少对手机的依赖，培养良好的阅读习惯。</p><span id="more"></span><h2 id="为什么孩子容易沉迷手机？"><a href="#为什么孩子容易沉迷手机？" class="headerlink" title="为什么孩子容易沉迷手机？"></a>为什么孩子容易沉迷手机？</h2><h3 id="心理层面的原因"><a href="#心理层面的原因" class="headerlink" title="心理层面的原因"></a>心理层面的原因</h3><ul><li><strong>即时满足感</strong>：手机游戏和短视频提供即时的快乐反馈</li><li><strong>社交需求</strong>：通过社交媒体与同龄人保持联系</li><li><strong>逃避现实</strong>：面对学习压力时的一种逃避方式</li><li><strong>好奇心驱动</strong>：对新奇内容的天然渴望</li></ul><h3 id="技术设计的”陷阱”"><a href="#技术设计的”陷阱”" class="headerlink" title="技术设计的”陷阱”"></a>技术设计的”陷阱”</h3><p>现代应用程序采用了大量心理学技巧来吸引用户：</p><ul><li>无限下拉的信息流</li><li>随机奖励机制</li><li>推送通知的及时性</li><li>个性化推荐算法</li></ul><h2 id="循序渐进的戒手机策略"><a href="#循序渐进的戒手机策略" class="headerlink" title="循序渐进的戒手机策略"></a>循序渐进的戒手机策略</h2><h3 id="第一阶段：建立规则和界限"><a href="#第一阶段：建立规则和界限" class="headerlink" title="第一阶段：建立规则和界限"></a>第一阶段：建立规则和界限</h3><p><strong>1. 制定家庭数字使用协议</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 用餐时间禁用电子设备</span><br><span class="line">- 睡前1小时收起所有设备</span><br><span class="line">- 作业时间手机放在指定位置</span><br><span class="line">- 周末可适当放宽，但需要计时</span><br></pre></td></tr></table></figure><p><strong>2. 创建”无手机区域”</strong></p><ul><li>餐厅：促进家庭交流</li><li>卧室：保证睡眠质量</li><li>学习桌：提高专注力</li></ul><h3 id="第二阶段：寻找替代活动"><a href="#第二阶段：寻找替代活动" class="headerlink" title="第二阶段：寻找替代活动"></a>第二阶段：寻找替代活动</h3><p><strong>优质替代活动清单：</strong></p><ul><li>户外运动（骑车、跑步、球类）</li><li>手工制作（绘画、折纸、乐高）</li><li>音乐学习（乐器演奏、唱歌）</li><li>社交活动（与朋友面对面交流）</li></ul><h2 id="培养阅读兴趣的具体方法"><a href="#培养阅读兴趣的具体方法" class="headerlink" title="培养阅读兴趣的具体方法"></a>培养阅读兴趣的具体方法</h2><h3 id="1-营造良好的阅读环境"><a href="#1-营造良好的阅读环境" class="headerlink" title="1. 营造良好的阅读环境"></a>1. 营造良好的阅读环境</h3><p><strong>物理环境优化：</strong></p><ul><li>设置专门的阅读角落</li><li>确保充足的自然光照</li><li>准备舒适的座椅和靠垫</li><li>减少干扰因素</li></ul><p><strong>家庭阅读氛围：</strong></p><ul><li>父母以身作则，经常阅读</li><li>定期进行家庭阅读时间</li><li>在家中显眼位置摆放书籍</li><li>限制电视和其他电子设备的使用时间</li></ul><h3 id="2-选择合适的书籍"><a href="#2-选择合适的书籍" class="headerlink" title="2. 选择合适的书籍"></a>2. 选择合适的书籍</h3><p><strong>年龄段推荐：</strong></p><p><strong>3-6岁：</strong></p><ul><li>图画书和绘本</li><li>互动式翻翻书</li><li>简单的故事书</li></ul><p><strong>7-10岁：</strong></p><ul><li>桥梁书（介于绘本和文字书之间）</li><li>科普类读物</li><li>冒险故事</li></ul><p><strong>11-14岁：</strong></p><ul><li>青少年小说</li><li>科幻和奇幻作品</li><li>传记和历史故事</li></ul><p><strong>15岁以上：</strong></p><ul><li>经典文学作品</li><li>哲学和思辨类书籍</li><li>专业兴趣相关书籍</li></ul><h3 id="3-创新的阅读方法"><a href="#3-创新的阅读方法" class="headerlink" title="3. 创新的阅读方法"></a>3. 创新的阅读方法</h3><p><strong>亲子共读技巧：</strong></p><ul><li>轮流朗读，增加参与感</li><li>讨论情节，培养思辨能力</li><li>角色扮演，增强理解</li><li>绘制思维导图，梳理内容</li></ul><p><strong>阅读游戏化：</strong></p><ul><li>设立阅读积分制度</li><li>创建家庭读书俱乐部</li><li>举办”家庭读书分享会”</li><li>制作读书笔记和书评</li></ul><h2 id="应对常见挑战"><a href="#应对常见挑战" class="headerlink" title="应对常见挑战"></a>应对常见挑战</h2><h3 id="孩子说”书太无聊”"><a href="#孩子说”书太无聊”" class="headerlink" title="孩子说”书太无聊”"></a>孩子说”书太无聊”</h3><ul><li>从孩子感兴趣的主题开始</li><li>选择有视觉冲击力的书籍</li><li>尝试有声书作为过渡</li><li>与孩子一起选书，给予选择权</li></ul><h3 id="注意力不集中"><a href="#注意力不集中" class="headerlink" title="注意力不集中"></a>注意力不集中</h3><ul><li>从短篇开始，逐步增加长度</li><li>设定小目标，如”每天读10分钟”</li><li>使用番茄工作法进行阅读</li><li>在安静的环境中阅读</li></ul><h3 id="阅读理解困难"><a href="#阅读理解困难" class="headerlink" title="阅读理解困难"></a>阅读理解困难</h3><ul><li>选择适合当前水平的书籍</li><li>鼓励孩子问问题</li><li>一起查阅不懂的词汇</li><li>用图片和实物帮助理解</li></ul><h2 id="长期坚持的秘诀"><a href="#长期坚持的秘诀" class="headerlink" title="长期坚持的秘诀"></a>长期坚持的秘诀</h2><h3 id="建立正向反馈循环"><a href="#建立正向反馈循环" class="headerlink" title="建立正向反馈循环"></a>建立正向反馈循环</h3><ol><li><strong>设定合理目标</strong>：从小目标开始，逐步提高</li><li><strong>及时鼓励</strong>：认可孩子的每一次进步</li><li><strong>记录成长</strong>：建立阅读档案，记录阅读历程</li><li><strong>适时调整</strong>：根据孩子的反馈调整策略</li></ol><h3 id="社区支持的力量"><a href="#社区支持的力量" class="headerlink" title="社区支持的力量"></a>社区支持的力量</h3><ul><li>加入其他家长的阅读群体</li><li>参加图书馆的活动</li><li>与学校老师保持沟通</li><li>寻找有相同目标的家庭一起努力</li></ul><h2 id="成功案例分享"><a href="#成功案例分享" class="headerlink" title="成功案例分享"></a>成功案例分享</h2><p><strong>案例一：张家的”21天阅读挑战”</strong><br>张妈妈发现10岁的儿子每天花3小时玩手机后，实施了”21天阅读挑战”：</p><ul><li>前7天：每天阅读15分钟，手机时间减少30分钟</li><li>中间7天：阅读时间增加到30分钟，手机时间再减少30分钟</li><li>最后7天：阅读45分钟，手机仅在周末使用</li></ul><p>结果：21天后，孩子主动要求继续阅读计划。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>让孩子戒掉手机爱上阅读不是一蹴而就的过程，需要家长的耐心、坚持和智慧。记住以下几个关键点：</p><ol><li><strong>循序渐进</strong>：不要试图一夜之间改变所有习惯</li><li><strong>以身作则</strong>：父母的行为是最好的教育</li><li><strong>保持耐心</strong>：允许孩子有反复，给予时间适应</li><li><strong>个性化策略</strong>：根据孩子的特点调整方法</li><li><strong>创造乐趣</strong>：让阅读成为一种享受，而不是负担</li></ol><p>只要坚持正确的方法，相信每个孩子都能够在书籍的世界中找到属于自己的快乐，并逐步减少对电子设备的过度依赖。阅读不仅能够提升孩子的学习能力，更能够培养他们的思维能力、想象力和专注力，为未来的成长打下坚实的基础。 </p>]]></content>
      
      
      <categories>
          
          <category> 家庭教育 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 亲子 </tag>
            
            <tag> 教育 </tag>
            
            <tag> 手机成瘾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>type script</title>
      <link href="/2025/03/15/type-script/"/>
      <url>/2025/03/15/type-script/</url>
      
        <content type="html"><![CDATA[<p>TypeScript 是一种由 <strong>Microsoft</strong> 开发的开源编程语言，它是 <strong>JavaScript 的超集</strong>，为 JavaScript 添加了可选的静态类型系统和现代语言特性。TypeScript 的目标是提高 JavaScript 代码的可维护性、可读性和开发效率，同时保持与 JavaScript 的完全兼容。</p><span id="more"></span><hr><h3 id="1-TypeScript-的核心特性"><a href="#1-TypeScript-的核心特性" class="headerlink" title="1. TypeScript 的核心特性"></a><strong>1. TypeScript 的核心特性</strong></h3><h4 id="1-静态类型检查"><a href="#1-静态类型检查" class="headerlink" title="(1) 静态类型检查"></a><strong>(1) 静态类型检查</strong></h4><ul><li><strong>类型注解</strong>：<br>允许开发者为变量、函数参数和返回值等添加类型注解，例如：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">count</span>: <span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>类型推断</strong>：<br>即使没有显式注解，TypeScript 也能根据上下文推断类型。</li></ul><h4 id="2-面向对象编程"><a href="#2-面向对象编程" class="headerlink" title="(2) 面向对象编程"></a><strong>(2) 面向对象编程</strong></h4><ul><li><strong>类与接口</strong>：<br>支持类、继承、接口等面向对象特性：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">makeSound</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">makeSound</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-现代-JavaScript-特性"><a href="#3-现代-JavaScript-特性" class="headerlink" title="(3) 现代 JavaScript 特性"></a><strong>(3) 现代 JavaScript 特性</strong></h4><ul><li><strong>ES6+ 支持</strong>：<br>TypeScript 支持最新的 JavaScript 特性（如箭头函数、解构赋值、模块化等），并将其编译为兼容性更好的 ES5 或更低版本。</li><li><strong>装饰器</strong>：<br>支持实验性装饰器语法，常用于 Angular 等框架。</li></ul><h4 id="4-工具支持"><a href="#4-工具支持" class="headerlink" title="(4) 工具支持"></a><strong>(4) 工具支持</strong></h4><ul><li><strong>强大的 IDE 支持</strong>：<br>TypeScript 提供了丰富的工具支持，如代码补全、类型检查、重构等，主流 IDE（如 VS Code）对 TypeScript 有原生支持。</li><li><strong>编译时错误检查</strong>：<br>在编译阶段捕获类型错误，减少运行时错误。</li></ul><hr><h3 id="2-TypeScript-的优势"><a href="#2-TypeScript-的优势" class="headerlink" title="2. TypeScript 的优势"></a><strong>2. TypeScript 的优势</strong></h3><h4 id="1-提高代码质量"><a href="#1-提高代码质量" class="headerlink" title="(1) 提高代码质量"></a><strong>(1) 提高代码质量</strong></h4><ul><li><strong>类型安全</strong>：<br>静态类型检查可以在编译阶段发现潜在的错误，减少运行时错误。</li><li><strong>代码可读性</strong>：<br>类型注解使代码更易于理解和维护。</li></ul><h4 id="2-提高开发效率"><a href="#2-提高开发效率" class="headerlink" title="(2) 提高开发效率"></a><strong>(2) 提高开发效率</strong></h4><ul><li><strong>智能提示</strong>：<br>IDE 可以根据类型信息提供更准确的代码补全和提示。</li><li><strong>重构支持</strong>：<br>类型信息使得重构代码更加安全和高效。</li></ul><h4 id="3-兼容性"><a href="#3-兼容性" class="headerlink" title="(3) 兼容性"></a><strong>(3) 兼容性</strong></h4><ul><li><strong>与 JavaScript 兼容</strong>：<br>TypeScript 是 JavaScript 的超集，任何合法的 JavaScript 代码都是合法的 TypeScript 代码。</li><li><strong>渐进式采用</strong>：<br>可以在现有 JavaScript 项目中逐步引入 TypeScript。</li></ul><hr><h3 id="3-TypeScript-的基本语法"><a href="#3-TypeScript-的基本语法" class="headerlink" title="3. TypeScript 的基本语法"></a><strong>3. TypeScript 的基本语法</strong></h3><h4 id="1-类型注解"><a href="#1-类型注解" class="headerlink" title="(1) 类型注解"></a><strong>(1) 类型注解</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">count</span>: <span class="built_in">number</span> = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;TypeScript&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="2-接口"><a href="#2-接口" class="headerlink" title="(2) 接口"></a><strong>(2) 接口</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    email?: <span class="built_in">string</span>;  <span class="comment">// 可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">user</span>: <span class="title class_">User</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-类"><a href="#3-类" class="headerlink" title="(3) 类"></a><strong>(3) 类</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">person.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure><h4 id="4-泛型"><a href="#4-泛型" class="headerlink" title="(4) 泛型"></a><strong>(4) 泛型</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="5-模块化"><a href="#5-模块化" class="headerlink" title="(5) 模块化"></a><strong>(5) 模块化</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><hr><h3 id="4-TypeScript-的工作流程"><a href="#4-TypeScript-的工作流程" class="headerlink" title="4. TypeScript 的工作流程"></a><strong>4. TypeScript 的工作流程</strong></h3><ol><li><strong>编写 TypeScript 代码</strong>：<br>使用 <code>.ts</code> 或 <code>.tsx</code> 文件编写代码。</li><li><strong>编译 TypeScript</strong>：<br>使用 TypeScript 编译器（<code>tsc</code>）将代码编译为 JavaScript：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc main.ts</span><br></pre></td></tr></table></figure></li><li><strong>运行 JavaScript</strong>：<br>执行生成的 <code>.js</code> 文件。</li></ol><hr><h3 id="5-TypeScript-的适用场景"><a href="#5-TypeScript-的适用场景" class="headerlink" title="5. TypeScript 的适用场景"></a><strong>5. TypeScript 的适用场景</strong></h3><ul><li><strong>大型项目</strong>：<br>类型系统有助于管理复杂的代码库。</li><li><strong>团队协作</strong>：<br>类型注解和接口定义可以提高团队协作效率。</li><li><strong>框架开发</strong>：<br>许多现代前端框架（如 Angular、Vue 3、React）都支持 TypeScript。</li><li><strong>渐进式迁移</strong>：<br>可以在现有 JavaScript 项目中逐步引入 TypeScript。</li></ul><hr><h3 id="6-TypeScript-与-JavaScript-的区别"><a href="#6-TypeScript-与-JavaScript-的区别" class="headerlink" title="6. TypeScript 与 JavaScript 的区别"></a><strong>6. TypeScript 与 JavaScript 的区别</strong></h3><table><thead><tr><th>特性</th><th>TypeScript</th><th>JavaScript</th></tr></thead><tbody><tr><td><strong>类型系统</strong></td><td>静态类型</td><td>动态类型</td></tr><tr><td><strong>编译</strong></td><td>需要编译为 JavaScript</td><td>直接运行</td></tr><tr><td><strong>工具支持</strong></td><td>强大的 IDE 支持</td><td>有限的工具支持</td></tr><tr><td><strong>学习曲线</strong></td><td>较高（需要学习类型系统）</td><td>较低</td></tr><tr><td><strong>适用场景</strong></td><td>大型项目、团队协作</td><td>小型项目、快速原型开发</td></tr></tbody></table><hr><h3 id="7-如何开始学习-TypeScript"><a href="#7-如何开始学习-TypeScript" class="headerlink" title="7. 如何开始学习 TypeScript"></a><strong>7. 如何开始学习 TypeScript</strong></h3><ol><li><strong>安装 TypeScript</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure></li><li><strong>编写第一个 TypeScript 程序</strong>：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.ts</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greet</span>(<span class="string">&quot;TypeScript&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><strong>编译并运行</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br><span class="line">node hello.js</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>TypeScript 是一种强大的编程语言，通过静态类型检查和现代语言特性，显著提升了 JavaScript 的开发效率和代码质量。它特别适合大型项目、团队协作以及对代码质量要求较高的场景。如果你已经熟悉 JavaScript，学习 TypeScript 将是一个自然且有益的进阶选择。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>what is mpx</title>
      <link href="/2025/03/15/what-is-mpx/"/>
      <url>/2025/03/15/what-is-mpx/</url>
      
        <content type="html"><![CDATA[<p>MPX 是一个 <strong>面向小程序开发的前端框架</strong>，由滴滴出行团队开源，专为提升小程序开发效率和性能而设计。它基于 Vue.js 的语法和特性，同时针对小程序的特点进行了深度优化和扩展。以下是 MPX 的核心特性和详细介绍：</p><span id="more"></span><hr><h3 id="1-MPX-的核心特性"><a href="#1-MPX-的核心特性" class="headerlink" title="1. MPX 的核心特性"></a><strong>1. MPX 的核心特性</strong></h3><h4 id="1-基于-Vue-js-语法"><a href="#1-基于-Vue-js-语法" class="headerlink" title="(1) 基于 Vue.js 语法"></a><strong>(1) 基于 Vue.js 语法</strong></h4><ul><li><strong>语法兼容</strong>：<br>MPX 支持 Vue.js 的模板语法、计算属性、侦听器、生命周期钩子等，开发者可以快速上手。</li><li><strong>响应式数据</strong>：<br>支持 Vue 风格的响应式数据绑定，简化状态管理。</li></ul><h4 id="2-多平台支持"><a href="#2-多平台支持" class="headerlink" title="(2) 多平台支持"></a><strong>(2) 多平台支持</strong></h4><ul><li><strong>跨平台开发</strong>：<br>MPX 支持将同一套代码编译到微信小程序、支付宝小程序、百度小程序、字节跳动小程序等多个平台。</li><li><strong>平台差异化处理</strong>：<br>提供平台特定的 API 和配置，方便处理不同平台的兼容性问题。</li></ul><h4 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="(3) 性能优化"></a><strong>(3) 性能优化</strong></h4><ul><li><strong>运行时优化</strong>：<br>通过减少不必要的 setData 调用和优化数据更新机制，提升小程序的运行性能。</li><li><strong>体积优化</strong>：<br>支持按需加载和代码分割，减小小程序包体积。</li></ul><h4 id="4-增强的开发体验"><a href="#4-增强的开发体验" class="headerlink" title="(4) 增强的开发体验"></a><strong>(4) 增强的开发体验</strong></h4><ul><li><strong>单文件组件</strong>：<br>支持 <code>.mpx</code> 单文件组件，将模板、脚本、样式封装在一个文件中，提升开发效率。</li><li><strong>TypeScript 支持</strong>：<br>提供完整的 TypeScript 支持，增强代码的可维护性和类型安全。</li><li><strong>插件系统</strong>：<br>支持丰富的插件生态，方便扩展功能（如状态管理、请求封装等）。</li></ul><h4 id="5-状态管理"><a href="#5-状态管理" class="headerlink" title="(5) 状态管理"></a><strong>(5) 状态管理</strong></h4><ul><li><strong>Vuex 支持</strong>：<br>内置 Vuex 支持，方便管理全局状态。</li><li><strong>轻量级状态管理</strong>：<br>提供更轻量的状态管理方案，适合小型项目。</li></ul><hr><h3 id="2-MPX-的核心架构"><a href="#2-MPX-的核心架构" class="headerlink" title="2. MPX 的核心架构"></a><strong>2. MPX 的核心架构</strong></h3><h4 id="1-编译时"><a href="#1-编译时" class="headerlink" title="(1) 编译时"></a><strong>(1) 编译时</strong></h4><ul><li><strong>模板编译</strong>：<br>将 <code>.mpx</code> 文件中的模板编译为小程序支持的 WXML。</li><li><strong>样式编译</strong>：<br>支持 Sass、Less 等预处理器，并将样式编译为小程序的 WXSS。</li><li><strong>脚本编译</strong>：<br>将 Vue.js 语法转换为小程序支持的 JS 代码。</li></ul><h4 id="2-运行时"><a href="#2-运行时" class="headerlink" title="(2) 运行时"></a><strong>(2) 运行时</strong></h4><ul><li><strong>响应式系统</strong>：<br>基于 Vue.js 的响应式系统，实现数据与视图的绑定。</li><li><strong>生命周期适配</strong>：<br>将 Vue.js 的生命周期钩子映射到小程序的生命周期中。</li></ul><h4 id="3-多平台适配"><a href="#3-多平台适配" class="headerlink" title="(3) 多平台适配"></a><strong>(3) 多平台适配</strong></h4><ul><li><strong>平台差异抹平</strong>：<br>通过统一的 API 和配置，抹平不同小程序平台的差异。</li><li><strong>条件编译</strong>：<br>支持条件编译，针对不同平台编写特定的代码逻辑。</li></ul><hr><h3 id="3-MPX-的使用场景"><a href="#3-MPX-的使用场景" class="headerlink" title="3. MPX 的使用场景"></a><strong>3. MPX 的使用场景</strong></h3><ul><li><strong>多平台小程序开发</strong>：<br>适合需要同时发布到多个小程序平台的项目。</li><li><strong>复杂业务逻辑</strong>：<br>适合需要复杂状态管理和组件化开发的场景。</li><li><strong>性能敏感项目</strong>：<br>适合对性能要求较高的小程序项目。</li></ul><hr><h3 id="4-MPX-的优缺点"><a href="#4-MPX-的优缺点" class="headerlink" title="4. MPX 的优缺点"></a><strong>4. MPX 的优缺点</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><strong>开发效率高</strong>：<br>基于 Vue.js 语法，学习成本低，开发效率高。</li><li><strong>跨平台支持</strong>：<br>一套代码多端运行，减少重复开发。</li><li><strong>性能优化</strong>：<br>针对小程序性能做了深度优化。</li><li><strong>生态丰富</strong>：<br>支持 TypeScript、Vuex 等现代前端工具。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li><strong>社区规模较小</strong>：<br>相比 Taro 和 uni-app，MPX 的社区和生态相对较小。</li><li><strong>平台兼容性</strong>：<br>虽然支持多平台，但在某些特定平台的兼容性上可能需要额外处理。</li></ul><hr><h3 id="5-MPX-与其他小程序框架对比"><a href="#5-MPX-与其他小程序框架对比" class="headerlink" title="5. MPX 与其他小程序框架对比"></a><strong>5. MPX 与其他小程序框架对比</strong></h3><table><thead><tr><th>特性</th><th>MPX</th><th>Taro</th><th>uni-app</th></tr></thead><tbody><tr><td><strong>语法基础</strong></td><td>Vue.js</td><td>React</td><td>Vue.js</td></tr><tr><td><strong>跨平台支持</strong></td><td>微信、支付宝、百度等</td><td>微信、支付宝、H5 等</td><td>微信、支付宝、H5、App 等</td></tr><tr><td><strong>性能优化</strong></td><td>深度优化</td><td>一般优化</td><td>一般优化</td></tr><tr><td><strong>生态丰富度</strong></td><td>中等</td><td>丰富</td><td>丰富</td></tr><tr><td><strong>学习成本</strong></td><td>低（Vue.js 开发者）</td><td>中（React 开发者）</td><td>低（Vue.js 开发者）</td></tr></tbody></table><hr><h3 id="6-快速上手-MPX"><a href="#6-快速上手-MPX" class="headerlink" title="6. 快速上手 MPX"></a><strong>6. 快速上手 MPX</strong></h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="(1) 安装"></a><strong>(1) 安装</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @mpxjs/cli -g</span><br></pre></td></tr></table></figure><h4 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="(2) 创建项目"></a><strong>(2) 创建项目</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpx init my-project</span><br></pre></td></tr></table></figure><h4 id="3-开发与构建"><a href="#3-开发与构建" class="headerlink" title="(3) 开发与构建"></a><strong>(3) 开发与构建</strong></h4><ul><li>开发模式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run watch</span><br></pre></td></tr></table></figure></li><li>生产构建：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="(4) 示例代码"></a><strong>(4) 示例代码</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">tap</span>=<span class="string">&quot;changeMessage&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; createComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;@mpxjs/core&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">createComponent</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">message</span>: <span class="string">&#x27;Hello MPX!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">changeMessage</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;你好，MPX！&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>MPX 是一个专注于小程序开发的 Vue.js 风格框架，具有跨平台支持、性能优化和开发效率高等特点。它适合需要多平台发布、复杂业务逻辑和性能敏感的小程序项目。如果你已经是 Vue.js 开发者，MPX 将是一个快速上手且高效的选择。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>命令行通配符</title>
      <link href="/2024/11/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
      <url>/2024/11/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="这是因为-shell-中的通配符（-）展开行为不同："><a href="#这是因为-shell-中的通配符（-）展开行为不同：" class="headerlink" title="这是因为 shell 中的通配符（*）展开行为不同："></a>这是因为 shell 中的通配符（<code>*</code>）展开行为不同：</h3><ol><li><code>unzip *.zip</code>：</li></ol><ul><li>shell 会先展开 <code>*.zip</code>，如果当前目录有多个 zip 文件</li><li>命令会变成 <code>unzip file1.zip file2.zip file3.zip</code></li><li>这可能导致 unzip 命令收到多个参数而报错</li></ul><span id="more"></span><ol start="2"><li><code>unzip &quot;*.zip&quot;</code>：</li></ol><ul><li>引号阻止了 shell 展开通配符</li><li>通配符会直接传递给 unzip 命令</li><li>unzip 命令自己处理通配符匹配</li></ul><h3 id="正确的写法有几种："><a href="#正确的写法有几种：" class="headerlink" title="正确的写法有几种："></a>正确的写法有几种：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：使用引号</span></span><br><span class="line">unzip <span class="string">&quot;*.zip&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：使用转义</span></span><br><span class="line">unzip \*.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3：使用循环处理多个文件</span></span><br><span class="line"><span class="keyword">for</span> zip <span class="keyword">in</span> *.zip; <span class="keyword">do</span></span><br><span class="line">    unzip <span class="string">&quot;<span class="variable">$zip</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法4：使用find命令</span></span><br><span class="line">find . -name <span class="string">&quot;*.zip&quot;</span> -<span class="built_in">exec</span> unzip &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>如果需要更健壮的处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压所有zip文件</span></span><br><span class="line"><span class="function"><span class="title">unzip_all</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> zip_files=( *.zip )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查是否存在zip文件</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -e <span class="string">&quot;<span class="variable">$&#123;zip_files[0]&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;没有找到zip文件&quot;</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 逐个解压</span></span><br><span class="line">    <span class="keyword">for</span> zip <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;zip_files[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;解压: <span class="variable">$zip</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> ! unzip <span class="string">&quot;<span class="variable">$zip</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;解压失败: <span class="variable">$zip</span>&quot;</span></span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则与通配符区别</title>
      <link href="/2024/10/11/%E6%AD%A3%E5%88%99%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/10/11/%E6%AD%A3%E5%88%99%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>正则表达式（Regular Expressions）和通配符（Wildcards）都是用于模式匹配的工具，但它们在功能、语法和应用场景上有显著的区别。以下是它们之间的主要区别：</p><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><span id="more"></span><ul><li><strong>正则表达式</strong>:<ul><li>正则表达式是一种用于描述字符串模式的强大工具，允许复杂的匹配规则。它可以用于查找、替换和验证字符串。</li></ul></li><li><strong>通配符</strong>:<ul><li>通配符是一种简单的模式匹配符号，通常用于文件名匹配或简单的字符串匹配。它们的功能相对较简单。</li></ul></li></ul><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h3><ul><li><p><strong>正则表达式</strong>:</p><ul><li>正则表达式使用特定的语法来定义模式，包括字符类、量词、边界匹配、分组等。例如：<ul><li><code>^abc</code>：匹配以 “abc” 开头的字符串。</li><li><code>\d</code>：匹配任何数字字符。</li><li><code>.*</code>：匹配任意字符（包括空字符）零次或多次。</li></ul></li></ul></li><li><p><strong>通配符</strong>:</p><ul><li>通配符通常使用简单的符号来表示匹配模式：<ul><li><code>*</code>：匹配零个或多个字符。</li><li><code>?</code>：匹配一个字符。</li><li><code>[]</code>：匹配括号内的任意一个字符（例如，<code>[abc]</code> 匹配 “a”、”b” 或 “c”）。</li></ul></li></ul></li></ul><h3 id="3-功能"><a href="#3-功能" class="headerlink" title="3. 功能"></a>3. 功能</h3><ul><li><p><strong>正则表达式</strong>:</p><ul><li>正则表达式功能强大，支持复杂的匹配规则、分组、反向引用、替换等操作。可以用于文本处理、数据验证、搜索引擎等多种场景。</li></ul></li><li><p><strong>通配符</strong>:</p><ul><li>通配符功能相对简单，主要用于文件系统中的文件名匹配（如在命令行中使用）或简单的字符串匹配。它们不支持复杂的匹配规则。</li></ul></li></ul><h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h3><ul><li><p><strong>正则表达式</strong>:</p><ul><li>常用于编程语言（如 Python、Java、JavaScript、C++ 等）中的字符串处理、数据验证（如电子邮件、电话号码格式）、文本搜索和替换等。</li></ul></li><li><p><strong>通配符</strong>:</p><ul><li>常用于文件系统操作（如在命令行中查找文件）、数据库查询（如 SQL 中的 LIKE 操作）等。</li></ul></li></ul><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h3><ul><li><p><strong>正则表达式示例</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[A-Za-z0-9]+@[A-Za-z]+\.[A-Za-z]&#123;2,&#125;$</span><br></pre></td></tr></table></figure><ul><li>这个正则表达式用于匹配电子邮件地址。</li></ul></li><li><p><strong>通配符示例</strong>:</p><ul><li><code>*.txt</code>：匹配所有以 <code>.txt</code> 结尾的文件。</li><li><code>file?.jpg</code>：匹配 <code>file1.jpg</code>、<code>file2.jpg</code> 等文件，但不匹配 <code>file10.jpg</code>。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>正则表达式</strong> 是一种功能强大的模式匹配工具，适用于复杂的字符串处理和验证。</li><li><strong>通配符</strong> 是一种简单的模式匹配符号，主要用于文件名匹配和简单的字符串匹配。</li></ul><p>根据具体的需求选择合适的工具，可以更有效地完成字符串匹配和处理任务。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>std::nth_element实现</title>
      <link href="/2024/10/08/std-nth-element%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/10/08/std-nth-element%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><code>std::nth_element</code> 是 C++ 标准库中的一个算法，用于在一个范围内重新排列元素，使得第 <code>n</code> 个元素位于其最终位置，并且该元素左侧的所有元素都小于或等于它，右侧的所有元素都大于或等于它。这个算法的时间复杂度为 O(n) 平均情况下，最坏情况下为 O(n^2)。</p><span id="more"></span><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><code>std::nth_element</code> 的实现通常基于快速选择算法（Quickselect），这是一个选择算法，类似于快速排序。其基本思路如下：</p><ol><li><strong>选择一个基准元素</strong>: 从数组中选择一个基准元素（pivot）。</li><li><strong>分区</strong>: 将数组分为两部分：小于基准元素的部分和大于基准元素的部分。</li><li><strong>递归选择</strong>: 根据基准元素的位置与 <code>n</code> 的关系，决定在左侧还是右侧继续查找。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是一个简单的 <code>std::nth_element</code> 的实现示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// for std::rand</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Partition function for Quickselect</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function">RandomIt <span class="title">partition</span><span class="params">(RandomIt first, RandomIt last, RandomIt pivot)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">iter_swap</span>(pivot, last - <span class="number">1</span>); <span class="comment">// Move pivot to end</span></span><br><span class="line">    RandomIt storeIndex = first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RandomIt it = first; it &lt; last - <span class="number">1</span>; ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it &lt; *(last - <span class="number">1</span>)) &#123;</span><br><span class="line">            std::<span class="built_in">iter_swap</span>(it, storeIndex);</span><br><span class="line">            ++storeIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">iter_swap</span>(storeIndex, last - <span class="number">1</span>); <span class="comment">// Move pivot to its final place</span></span><br><span class="line">    <span class="keyword">return</span> storeIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quickselect function</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickselect</span><span class="params">(RandomIt first, RandomIt last, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &lt; last) &#123;</span><br><span class="line">        RandomIt pivot = first + std::<span class="built_in">rand</span>() % (last - first); <span class="comment">// Random pivot</span></span><br><span class="line">        pivot = <span class="built_in">partition</span>(first, last, pivot);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pivot - first == n) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// Found the nth element</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivot - first &gt; n) &#123;</span><br><span class="line">            <span class="built_in">quickselect</span>(first, pivot, n); <span class="comment">// Search in the left part</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">quickselect</span>(pivot + <span class="number">1</span>, last, n - (pivot - first + <span class="number">1</span>)); <span class="comment">// Search in the right part</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nth_element implementation</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_nth_element</span><span class="params">(RandomIt first, RandomIt nth, RandomIt last)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> n = nth - first;</span><br><span class="line">    <span class="built_in">quickselect</span>(first, last, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">size_t</span> n = <span class="number">5</span>; <span class="comment">// We want the 5th element (0-based index)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">my_nth_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + n, vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;th element is: &quot;</span> &lt;&lt; vec[n] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p><strong>Partition Function</strong>: </p><ul><li><code>partition</code> 函数将数组分为两部分，返回基准元素的最终位置。</li><li>它将基准元素移动到数组的末尾，然后遍历数组，将小于基准的元素移动到左侧。</li></ul></li><li><p><strong>Quickselect Function</strong>:</p><ul><li><code>quickselect</code> 函数递归地选择基准元素并进行分区，直到找到第 <code>n</code> 个元素。</li></ul></li><li><p><strong>My Nth Element Function</strong>:</p><ul><li><code>my_nth_element</code> 是用户定义的函数，调用 <code>quickselect</code> 来找到第 <code>n</code> 个元素。</li></ul></li><li><p><strong>Main Function</strong>:</p><ul><li>在 <code>main</code> 函数中，创建一个整数向量，调用 <code>my_nth_element</code>，并输出第 <code>n</code> 个元素。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>std::nth_element</code> 的实现基于快速选择算法，能够高效地找到数组中第 <code>n</code> 个元素。上述代码展示了如何实现这一算法，并提供了一个简单的示例来演示其用法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>texelFetch</title>
      <link href="/2024/10/06/texelFetch/"/>
      <url>/2024/10/06/texelFetch/</url>
      
        <content type="html"><![CDATA[<p><code>texelFetch</code> 是一个在着色器编程中用于从纹理中获取特定纹素（texel）的函数。与常规的纹理采样不同，<code>texelFetch</code> 使用整数纹理坐标来直接访问纹理数据，不进行过滤或插值。</p><p>在 OpenGL 的 GLSL（OpenGL Shading Language）中，<code>texelFetch</code> 的用法如下：</p><span id="more"></span><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> <span class="built_in">texelFetch</span>(<span class="type">sampler2D</span> sampler, <span class="type">ivec2</span> coord, <span class="type">int</span> lod);</span><br></pre></td></tr></table></figure><ul><li><code>sampler</code>：纹理采样器。</li><li><code>coord</code>：整数形式的纹理坐标。</li><li><code>lod</code>：细节层次（level of detail），通常为 0。</li></ul><p><code>texelFetch</code> 适用于需要精确访问纹理像素的场合，比如在一些计算或图像处理效果中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>traits设计和用法</title>
      <link href="/2024/09/29/traits%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%94%A8%E6%B3%95/"/>
      <url>/2024/09/29/traits%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中，<strong>Traits</strong>（特性）是一种设计模式，通常用于提供类型信息或行为的模板类。Traits 允许在编译时获取类型的特性，从而实现更灵活和可扩展的代码。Traits 模式广泛应用于标准库和现代 C++ 编程中，尤其是在模板编程和泛型编程中。</p><span id="more"></span><h3 id="1-Traits-的设计"><a href="#1-Traits-的设计" class="headerlink" title="1. Traits 的设计"></a>1. Traits 的设计</h3><p>Traits 通常是一个模板类，专门用于提供与类型相关的信息。它们可以用于：</p><ul><li><strong>类型特性</strong>: 提供类型的属性（如是否是指针、是否是类等）。</li><li><strong>类型转换</strong>: 提供类型的转换信息（如获取类型的基类、去除引用等）。</li><li><strong>类型操作</strong>: 提供与类型相关的操作（如获取类型的大小、默认构造函数等）。</li></ul><h3 id="2-Traits-的基本用法"><a href="#2-Traits-的基本用法" class="headerlink" title="2. Traits 的基本用法"></a>2. Traits 的基本用法</h3><p>以下是一些常见的 Traits 用法示例：</p><h4 id="a-类型特性"><a href="#a-类型特性" class="headerlink" title="a. 类型特性"></a>a. 类型特性</h4><p>使用 <code>std::is_integral</code> 来检查一个类型是否是整数类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::is_integral&lt;T&gt;::value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T is an integral type.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T is not an integral type.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">checkType</span>&lt;<span class="type">int</span>&gt;();    <span class="comment">// 输出: T is an integral type.</span></span><br><span class="line">    <span class="built_in">checkType</span>&lt;<span class="type">double</span>&gt;(); <span class="comment">// 输出: T is not an integral type.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="b-自定义-Traits"><a href="#b-自定义-Traits" class="headerlink" title="b. 自定义 Traits"></a>b. 自定义 Traits</h4><p>你可以定义自己的 Traits 类来提供特定类型的信息。例如，定义一个 Traits 类来获取类型的大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeTraits</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(T);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of int: &quot;</span> &lt;&lt; TypeTraits&lt;<span class="type">int</span>&gt;::size &lt;&lt; std::endl; <span class="comment">// 输出: Size of int: 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of double: &quot;</span> &lt;&lt; TypeTraits&lt;<span class="type">double</span>&gt;::size &lt;&lt; std::endl; <span class="comment">// 输出: Size of double: 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c-结合-SFINAE"><a href="#c-结合-SFINAE" class="headerlink" title="c. 结合 SFINAE"></a>c. 结合 SFINAE</h4><p>Traits 可以与 SFINAE（Substitution Failure Is Not An Error）结合使用，以实现更复杂的模板特化。例如，选择性地启用某些函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing non-integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">42</span>);        <span class="comment">// 输出: Processing integral type: 42</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">3.14</span>);     <span class="comment">// 输出: Processing non-integral type: 3.14</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Traits-的应用"><a href="#3-Traits-的应用" class="headerlink" title="3. Traits 的应用"></a>3. Traits 的应用</h3><p>Traits 在 C++ 标准库中有广泛的应用，以下是一些常见的例子：</p><ul><li><strong><code>std::iterator_traits</code></strong>: 提供迭代器的类型信息，如值类型、指针类型等。</li><li><strong><code>std::numeric_limits</code></strong>: 提供数值类型的特性，如最小值、最大值等。</li><li><strong><code>std::enable_if</code></strong>: 用于条件性地启用模板特化。</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul><li><strong>Traits</strong> 是一种强大的设计模式，允许在编译时获取类型信息和行为。</li><li>它们可以用于类型特性、类型转换和类型操作，提供灵活性和可扩展性。</li><li>Traits 在 C++ 标准库中有广泛的应用，尤其是在模板编程和泛型编程中。</li></ul><p>通过使用 Traits，开发者可以编写更通用和可重用的代码，同时提高类型安全性和性能。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shell和子shell环境变量</title>
      <link href="/2024/09/29/shell%E5%92%8C%E5%AD%90shell%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2024/09/29/shell%E5%92%8C%E5%AD%90shell%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>在 Shell 脚本中，命令替换（command substitution）是指将命令的输出作为字符串插入到另一个命令中。命令替换通常使用反引号（<code>`command`</code>）或 <code>$()</code> 语法来实现。命令替换会在一个子 Shell 中执行指定的命令，这意味着在子 Shell 中定义的变量不会影响父 Shell 中的变量。</p><span id="more"></span><h3 id="1-子-Shell-的概念"><a href="#1-子-Shell-的概念" class="headerlink" title="1. 子 Shell 的概念"></a>1. 子 Shell 的概念</h3><ul><li><strong>子 Shell</strong>: 当你在 Shell 中执行一个命令替换时，Shell 会创建一个新的子 Shell 来执行该命令。子 Shell 是父 Shell 的一个独立实例，具有自己的环境和变量。</li></ul><h3 id="2-变量作用域"><a href="#2-变量作用域" class="headerlink" title="2. 变量作用域"></a>2. 变量作用域</h3><ul><li>在子 Shell 中定义的变量不会影响父 Shell 中的变量。相反，父 Shell 中的变量也无法在子 Shell 中被访问。</li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>以下是一个示例，展示了命令替换如何在子 Shell 中运行命令，并且如何影响变量的作用域。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个变量</span></span><br><span class="line">var=<span class="string">&quot;Hello from parent shell&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用命令替换</span></span><br><span class="line">result=$(<span class="built_in">echo</span> <span class="variable">$var</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Result from command substitution: <span class="variable">$result</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在子 Shell 中修改变量</span></span><br><span class="line">result=$(<span class="built_in">echo</span> <span class="string">&quot;Hello from child shell&quot;</span>; var=<span class="string">&quot;Hello from child shell&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Result after child shell: <span class="variable">$result</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Variable in parent shell: <span class="variable">$var</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-运行结果"><a href="#4-运行结果" class="headerlink" title="4. 运行结果"></a>4. 运行结果</h3><p>如果你运行上述脚本，输出将是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Result from command substitution: Hello from parent shell</span><br><span class="line">Result after child shell: Hello from child shell</span><br><span class="line">Variable in parent shell: Hello from parent shell</span><br></pre></td></tr></table></figure><h3 id="5-解释"><a href="#5-解释" class="headerlink" title="5. 解释"></a>5. 解释</h3><ul><li><p><strong>第一部分</strong>: </p><ul><li><code>var=&quot;Hello from parent shell&quot;</code> 定义了一个变量 <code>var</code> 在父 Shell 中。</li><li><code>result=$(echo $var)</code> 使用命令替换，将 <code>var</code> 的值传递给 <code>result</code>。此时，<code>result</code> 的值为 <code>Hello from parent shell</code>。</li></ul></li><li><p><strong>第二部分</strong>:</p><ul><li><code>result=$(echo &quot;Hello from child shell&quot;; var=&quot;Hello from child shell&quot;)</code> 在子 Shell 中执行。虽然在子 Shell 中修改了 <code>var</code> 的值，但这个修改不会影响父 Shell 中的 <code>var</code> 变量。</li><li><code>result</code> 的值被设置为 <code>Hello from child shell</code>，但父 Shell 中的 <code>var</code> 仍然保持为 <code>Hello from parent shell</code>。</li></ul></li></ul><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>命令替换会在子 Shell 中执行命令，因此在子 Shell 中定义的变量不会影响父 Shell 中的变量。这种行为是 Shell 的一个重要特性，理解这一点对于编写有效的 Shell 脚本非常重要。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分支预测</title>
      <link href="/2024/09/27/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/"/>
      <url>/2024/09/27/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<ol><li>宏定义解释<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure></li></ol><span id="more"></span><ul><li>likely(x):<br>这个宏用于表示某个条件 x 是“可能为真”的。它的作用是告诉编译器，x 很可能为真（即返回值为 1）。<br>__builtin_expect(!!(x), 1) 的作用是将 x 的值转换为布尔值（0 或 1），并告诉编译器这个值很可能是 1。</li><li>unlikely(x):<br>这个宏用于表示某个条件 x 是“可能为假”的。它的作用是告诉编译器，x 很可能为假（即返回值为 0）。<br>__builtin_expect(!!(x), 0) 的作用是将 x 的值转换为布尔值，并告诉编译器这个值很可能是 0。</li></ul><ol start="2"><li>使用场景<br>这些宏通常用于条件语句中，以优化分支预测。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">likely</span>(condition)) &#123;</span><br><span class="line">    <span class="comment">// 处理条件为真的情况</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理条件为假的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，使用 likely 可以帮助编译器优化代码生成，使得在条件为真的情况下，相关的代码路径更快。</p><ol start="3"><li><p>优化原理<br>分支预测：现代 CPU 通常具有分支预测机制，能够根据历史执行路径预测条件语句的结果。通过使用 likely 和 unlikely，开发者可以显式地告诉编译器和 CPU 哪个分支更可能被执行，从而提高预测的准确性。<br>性能提升：在性能敏感的代码中，减少错误的分支预测可以显著提高执行效率，尤其是在循环和频繁调用的函数中。</p></li><li><p>注意事项<br>可读性：虽然使用这些宏可以提高性能，但过度使用可能会影响代码的可读性。应在性能关键的部分使用，而不是在所有条件判断中使用。<br>编译器支持：__builtin_expect 是 GCC 和 Clang 的扩展，其他编译器可能不支持此功能。在使用时需要确保代码的可移植性。<br>总结<br>likely 和 unlikely 宏通过利用 __builtin_expect 提供了对条件分支的预测信息，帮助编译器生成更高效的代码。它们在性能敏感的应用中非常有用，尤其是在需要优化分支预测的场景中</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++模版函数delete防止隐士类型转换.md</title>
      <link href="/2024/09/26/c-%E6%A8%A1%E7%89%88%E5%87%BD%E6%95%B0delete%E9%98%B2%E6%AD%A2%E9%9A%90%E5%A3%AB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-md/"/>
      <url>/2024/09/26/c-%E6%A8%A1%E7%89%88%E5%87%BD%E6%95%B0delete%E9%98%B2%E6%AD%A2%E9%9A%90%E5%A3%AB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-md/</url>
      
        <content type="html"><![CDATA[<p>本文展示如何使用C++模板函数的<code>delete</code>关键字来防止不必要的隐式类型转换。</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">int</span>&amp;() &#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">const</span> <span class="type">int</span>&amp;() <span class="type">const</span> &#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">(T arg)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">(<span class="type">int</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;called testFunc int\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Person a;</span><br><span class="line">    <span class="built_in">testFunc</span>(a); <span class="comment">//报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AndoirdEGLContext销毁管理</title>
      <link href="/2024/08/01/AndoirdEGLContext%E9%94%80%E6%AF%81%E7%AE%A1%E7%90%86/"/>
      <url>/2024/08/01/AndoirdEGLContext%E9%94%80%E6%AF%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EGLContextFactory</span> &#123;</span><br><span class="line">    EGLContext <span class="title function_">createContext</span><span class="params">(EGL10 egl, EGLDisplay display, EGLConfig eglConfig)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroyContext</span><span class="params">(EGL10 egl, EGLDisplay display, EGLContext context)</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗"><a href="#EGLContext-如果释放时，会删除在当前Context-下创建的bufffer-texture-以及fbo等资源吗" class="headerlink" title="EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗"></a>EGLContext 如果释放时，会删除在当前Context 下创建的bufffer,texture 以及fbo等资源吗</h3><span id="more"></span><h3 id="在-OpenGL-ES-中，当一个-EGLContext-被销毁时，所有在该上下文中创建的-OpenGL-资源（如-buffer、texture-和-framebuffer-objects-FBO-等）都会被删除。这是因为这些资源是与特定的-OpenGL-上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。"><a href="#在-OpenGL-ES-中，当一个-EGLContext-被销毁时，所有在该上下文中创建的-OpenGL-资源（如-buffer、texture-和-framebuffer-objects-FBO-等）都会被删除。这是因为这些资源是与特定的-OpenGL-上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。" class="headerlink" title="在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。"></a>在 OpenGL ES 中，当一个 EGLContext 被销毁时，所有在该上下文中创建的 OpenGL 资源（如 buffer、texture 和 framebuffer objects (FBO) 等）都会被删除。这是因为这些资源是与特定的 OpenGL 上下文相关联的，一旦上下文被销毁，与之相关的所有资源也会被自动释放。</h3><p>具体来说，当你调用 <code>EGLContextFactory</code> 接口的 <code>destroyContext</code> 方法来销毁一个 EGLContext 时，OpenGL ES 会自动处理这个上下文的清理工作，包括删除所有在该上下文中创建的资源。</p><p>因此，你不需要手动删除这些资源，销毁上下文的过程会自动处理它们的释放。</p><p>不过，如果你需要提前释放某些资源以便在上下文还没有销毁之前释放内存，你可以在合适的时机手动删除这些资源（例如通过调用 <code>glDeleteBuffers</code>、<code>glDeleteTextures</code>、<code>glDeleteFramebuffers</code> 等方法）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵</title>
      <link href="/2024/07/30/%E4%BB%8E%E5%8C%85%E5%90%AB%E5%B9%B3%E7%A7%BB%E3%80%81%E6%97%8B%E8%BD%AC%E5%92%8C%E7%BC%A9%E6%94%BE%E7%9A%84%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BB%85%E5%8C%85%E5%90%AB%E5%B9%B3%E7%A7%BB%E5%92%8C%E6%97%8B%E8%BD%AC%E7%9A%84%E7%9F%A9%E9%98%B5/"/>
      <url>/2024/07/30/%E4%BB%8E%E5%8C%85%E5%90%AB%E5%B9%B3%E7%A7%BB%E3%80%81%E6%97%8B%E8%BD%AC%E5%92%8C%E7%BC%A9%E6%94%BE%E7%9A%84%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BB%85%E5%8C%85%E5%90%AB%E5%B9%B3%E7%A7%BB%E5%92%8C%E6%97%8B%E8%BD%AC%E7%9A%84%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>要从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵，您需要对原矩阵进行一些操作。原矩阵通常是一个3x3或4x4的矩阵。</p><h3 id="对于3x3矩阵："><a href="#对于3x3矩阵：" class="headerlink" title="对于3x3矩阵："></a>对于3x3矩阵：</h3><p>原3x3矩阵的形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| a  b  tx |</span><br><span class="line">| c  d  ty |</span><br><span class="line">| 0  0  1  |</span><br></pre></td></tr></table></figure><span id="more"></span><p>步骤：</p><ol><li><p>提取旋转部分（左上2x2子矩阵）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| a  b |</span><br><span class="line">| c  d |</span><br></pre></td></tr></table></figure></li><li><p>计算缩放因子（可以使用行向量的范数或列向量的范数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = sqrt(a^2 + c^2) = sqrt(b^2 + d^2)</span><br></pre></td></tr></table></figure></li><li><p>将旋转部分归一化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| a/s  b/s |</span><br><span class="line">| c/s  d/s |</span><br></pre></td></tr></table></figure></li><li><p>构建新的3x3矩阵，包含平移分量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| a/s  b/s  tx |</span><br><span class="line">| c/s  d/s  ty |</span><br><span class="line">|  0    0    1 |</span><br></pre></td></tr></table></figure></li></ol><h3 id="对于4x4矩阵："><a href="#对于4x4矩阵：" class="headerlink" title="对于4x4矩阵："></a>对于4x4矩阵：</h3><p>原4x4矩阵的形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| a  b  c  tx |</span><br><span class="line">| d  e  f  ty |</span><br><span class="line">| g  h  i  tz |</span><br><span class="line">| 0  0  0   1 |</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li><p>提取旋转部分（左上3x3子矩阵）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| a  b  c |</span><br><span class="line">| d  e  f |</span><br><span class="line">| g  h  i |</span><br></pre></td></tr></table></figure></li><li><p>计算缩放因子（可以使用行向量的范数或列向量的范数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sx = sqrt(a^2 + d^2 + g^2)</span><br><span class="line">sy = sqrt(b^2 + e^2 + h^2)</span><br><span class="line">sz = sqrt(c^2 + f^2 + i^2)</span><br></pre></td></tr></table></figure></li><li><p>将旋转部分归一化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| a/sx  b/sy  c/sz |</span><br><span class="line">| d/sx  e/sy  f/sz |</span><br><span class="line">| g/sx  h/sy  i/sz |</span><br></pre></td></tr></table></figure></li><li><p>构建新的4x4矩阵，包含平移分量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| a/sx  b/sy  c/sz  tx |</span><br><span class="line">| d/sx  e/sy  f/sz  ty |</span><br><span class="line">| g/sx  h/sy  i/sz  tz |</span><br><span class="line">|  0     0     0    1  |</span><br></pre></td></tr></table></figure></li></ol><p>这些步骤可以帮助您从包含平移、旋转和缩放的矩阵中提取仅包含平移和旋转的矩阵。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGLE_VAO局部影响vs全局影响</title>
      <link href="/2024/07/28/OpenGLE-VAO%E5%B1%80%E9%83%A8%E5%BD%B1%E5%93%8Dvs%E5%85%A8%E5%B1%80%E5%BD%B1%E5%93%8D/"/>
      <url>/2024/07/28/OpenGLE-VAO%E5%B1%80%E9%83%A8%E5%BD%B1%E5%93%8Dvs%E5%85%A8%E5%B1%80%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="全局顶点属性数组使能状态"><a href="#全局顶点属性数组使能状态" class="headerlink" title="全局顶点属性数组使能状态"></a>全局顶点属性数组使能状态</h3><span id="more"></span><p><code>glEnableVertexAttribArray</code> 和 <code>glDisableVertexAttribArray</code> 确实是全局状态。这意味着在不使用 VAO 的情况下，启用或禁用特定的顶点属性数组会影响所有后续的绘制调用，直到该状态被改变。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用顶点属性数组索引 0</span></span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行绘制调用，使用索引 0 的顶点属性数组</span></span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用顶点属性数组索引 0</span></span><br><span class="line">glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次进行绘制调用，此时索引 0 的顶点属性数组将不会被使用</span></span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="顶点数组对象（VAO）"><a href="#顶点数组对象（VAO）" class="headerlink" title="顶点数组对象（VAO）"></a>顶点数组对象（VAO）</h3><p>当使用 VAO 时，<code>glEnableVertexAttribArray</code> 和 <code>glVertexAttribPointer</code> 等顶点属性相关的状态是存储在 VAO 中的。这意味着当你绑定一个 VAO 时，它会恢复之前存储的所有顶点属性状态，包括哪些属性数组是启用的。这样，每个 VAO 可以拥有自己独立的顶点属性配置。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并绑定第一个 VAO</span></span><br><span class="line">GLuint vao1;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;vao1);</span><br><span class="line">glBindVertexArray(vao1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置顶点属性指针和启用顶点属性数组</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑 VAO</span></span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并绑定第二个 VAO</span></span><br><span class="line">GLuint vao2;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;vao2);</span><br><span class="line">glBindVertexArray(vao2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置不同的顶点属性指针和启用顶点属性数组</span></span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="keyword">sizeof</span>(GLfloat), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑 VAO</span></span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用第一个 VAO 进行绘制</span></span><br><span class="line">glBindVertexArray(vao1);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用第二个 VAO 进行绘制</span></span><br><span class="line">glBindVertexArray(vao2);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>vao1</code> 存储了顶点属性索引 0 的配置和使能状态。</li><li><code>vao2</code> 存储了顶点属性索引 1 的配置和使能状态。</li></ul><p>绑定 <code>vao1</code> 会恢复其配置和状态，绑定 <code>vao2</code> 则会恢复其自身的配置和状态。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>全局顶点属性数组使能状态</strong>：在不使用 VAO 时，<code>glEnableVertexAttribArray</code> 和 <code>glDisableVertexAttribArray</code> 对所有后续绘制调用生效，直到状态被改变。</li><li><strong>顶点数组对象（VAO）</strong>：存储了顶点属性相关的所有状态，包括使能状态。当绑定 VAO 时，会恢复之前存储的顶点属性配置和使能状态，使得每个 VAO 拥有独立的顶点属性配置。</li></ul><p>使用 VAO 是管理复杂场景和多个对象的最佳实践，因为它简化了状态管理，并且可以提高渲染性能。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGLES设置顶点属性的默认值</title>
      <link href="/2024/07/28/OpenGLES%E8%AE%BE%E7%BD%AE%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
      <url>/2024/07/28/OpenGLES%E8%AE%BE%E7%BD%AE%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>在 OpenGL ES 中，设置顶点属性的默认值和通过顶点缓冲对象（VBO）上传顶点属性是两种不同的处理顶点属性的方法。以下是详细的解释：</p><h3 id="设置顶点属性默认值"><a href="#设置顶点属性默认值" class="headerlink" title="设置顶点属性默认值"></a>设置顶点属性默认值</h3><span id="more"></span><p>在 OpenGL ES 中，可以使用 <code>glVertexAttrib4f</code>（或其他类似的函数）来设置顶点属性的默认值。这些函数允许您为指定的顶点属性索引设置一个常量值，而不必为每个顶点提供一个值。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置索引为 0 的顶点属性的默认值为 (1.0, 0.0, 0.0, 1.0)</span></span><br><span class="line">glVertexAttrib4f(<span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><p>请注意，这种方法直接在顶点着色器中使用常量值，因此适用于需要相同属性值的所有顶点的情况。</p><h3 id="通过-VBO-上传顶点属性"><a href="#通过-VBO-上传顶点属性" class="headerlink" title="通过 VBO 上传顶点属性"></a>通过 VBO 上传顶点属性</h3><p>VBO 是一种在图形硬件上存储顶点数据的高效方式。使用 VBO 可以提高渲染性能，因为数据存储在 GPU 内存中，而不是通过每次绘制调用从 CPU 内存传输数据。以下是使用 VBO 上传顶点属性的步骤：</p><ol><li><p><strong>生成和绑定 VBO</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GLuint vbo;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;vbo);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, vbo);</span><br></pre></td></tr></table></figure></li><li><p><strong>上传顶点数据</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 顶点数据，假设每个顶点包含 3 个浮点数 (x, y, z)</span></span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">&#125;;</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure></li><li><p><strong>设置顶点属性指针</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>绘制</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="性能差别"><a href="#性能差别" class="headerlink" title="性能差别"></a>性能差别</h3><ul><li><p><strong>设置顶点属性默认值</strong>：这种方法适用于所有顶点共享相同属性值的情况。其优点是简单直接，不需要额外的内存传输。然而，它缺乏灵活性，只能应用于特定的简单场景。</p></li><li><p><strong>通过 VBO 上传顶点属性</strong>：这种方法更为灵活，可以为每个顶点设置不同的属性值。因为数据存储在 GPU 内存中，所以渲染性能通常更高，特别是在处理大量顶点数据时。这种方法适用于大多数复杂的渲染任务。</p></li></ul><p>总结来说，如果您的应用场景中所有顶点都共享相同的属性值，可以使用设置默认值的方法。如果不同顶点有不同的属性值，并且您希望获得更好的性能，应使用 VBO。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AddressSanitizer实现原理</title>
      <link href="/2024/07/28/AddressSanitizer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2024/07/28/AddressSanitizer%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>AddressSanitizer（简称ASan）是一种内存错误检测工具，用于捕捉诸如缓冲区溢出、使用已释放内存、堆栈溢出等内存错误。ASan在编译时和运行时对程序进行处理，以检测和报告内存相关的错误。以下是AddressSanitizer的实现原理的详细解释：</p><span id="more"></span><h3 id="1-编译时插桩"><a href="#1-编译时插桩" class="headerlink" title="1. 编译时插桩"></a>1. 编译时插桩</h3><p>ASan在编译时对代码进行插桩，插入额外的检查代码。这些检查代码会在每次内存访问时执行，以验证访问是否合法。具体过程包括：</p><ul><li><strong>插入检查代码</strong>：在每次内存分配、释放和访问操作前后插入检查代码。</li><li><strong>标记内存区域</strong>：在内存分配和释放时，更新内存区域的元数据，以记录该区域的状态（已分配、已释放等）。</li></ul><h3 id="2-Shadow-Memory"><a href="#2-Shadow-Memory" class="headerlink" title="2. Shadow Memory"></a>2. Shadow Memory</h3><p>ASan使用影子内存（Shadow Memory）来记录主内存的状态。影子内存是主内存的一个映射区域，每个字节的影子内存对应主内存的几个字节（通常是8字节）。影子内存的值用于指示主内存的哪些部分是合法访问的，哪些部分是非法的。</p><ul><li><strong>影子内存布局</strong>：影子内存占用主内存的1/8，因为每个影子字节代表8个主内存字节。</li><li><strong>影子内存值</strong>：影子内存中的值表示主内存的状态。例如，0表示所有8个字节都是合法的，负值表示不合法的访问，正值表示部分合法访问。</li></ul><h3 id="3-内存分配和释放"><a href="#3-内存分配和释放" class="headerlink" title="3. 内存分配和释放"></a>3. 内存分配和释放</h3><p>ASan对内存分配和释放函数（如<code>malloc</code>和<code>free</code>）进行重载，以维护内存区域的元数据。这些元数据包括：</p><ul><li><strong>红色区域（Redzones）</strong>：在每个分配的内存块周围添加红色区域，用于检测缓冲区溢出。红色区域被标记为非法访问区域。</li><li><strong>元数据</strong>：记录每个内存块的大小、分配堆栈等信息，以便在检测到错误时提供详细报告。</li></ul><h3 id="4-运行时检查"><a href="#4-运行时检查" class="headerlink" title="4. 运行时检查"></a>4. 运行时检查</h3><p>在运行时，ASan插入的检查代码会在每次内存访问时执行，检查访问的地址是否在合法范围内。如果访问非法区域，则报告错误并终止程序。</p><ul><li><strong>内存访问检查</strong>：每次内存读取或写入时，检查影子内存中的值，以确定访问是否合法。</li><li><strong>错误报告</strong>：在检测到非法访问时，ASan会生成详细的错误报告，包含访问地址、内存块信息、调用堆栈等。</li></ul><h3 id="5-错误类型检测"><a href="#5-错误类型检测" class="headerlink" title="5. 错误类型检测"></a>5. 错误类型检测</h3><p>ASan能够检测多种类型的内存错误，包括：</p><ul><li><strong>缓冲区溢出</strong>：访问数组或内存块的边界外的区域。</li><li><strong>使用未初始化内存</strong>：访问未初始化的内存。</li><li><strong>使用已释放内存</strong>：访问已经释放的内存。</li><li><strong>双重释放</strong>：重复释放同一块内存。</li><li><strong>堆栈溢出</strong>：访问栈帧之外的内存。</li></ul><h3 id="6-性能与开销"><a href="#6-性能与开销" class="headerlink" title="6. 性能与开销"></a>6. 性能与开销</h3><p>ASan在检测内存错误时会引入一定的性能开销和内存开销：</p><ul><li><strong>性能开销</strong>：由于插入了额外的检查代码，程序的执行速度会有所降低。通常，ASan引入的性能开销在2-3倍左右。</li><li><strong>内存开销</strong>：影子内存和红色区域会增加内存使用量，通常内存开销在2倍左右。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AddressSanitizer通过编译时插桩、使用影子内存和运行时检查等机制，能够有效地检测和报告内存相关的错误。尽管引入了一定的性能和内存开销，但它在提高程序安全性和稳定性方面具有重要意义，是开发和调试C/C++程序的强大工具。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pthread_create设置栈size</title>
      <link href="/2024/07/28/pthread-create%E8%AE%BE%E7%BD%AE%E6%A0%88size/"/>
      <url>/2024/07/28/pthread-create%E8%AE%BE%E7%BD%AE%E6%A0%88size/</url>
      
        <content type="html"><![CDATA[<p>本文演示如何在使用 <code>pthread_create</code> 创建线程时设置自定义的栈大小。通过 <code>pthread_attr_setstacksize</code> 函数可以控制线程的栈空间大小，这在需要大量栈空间或者优化内存使用时非常有用。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunction</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程的执行代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">size_t</span> stackSize = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 设置栈大小为2 MiB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_attr_init</span>(&amp;attr) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_attr_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程栈大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_attr_setstacksize</span>(&amp;attr, stackSize) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_attr_setstacksize&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thread, &amp;attr, threadFunction, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_join</span>(thread, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁线程属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_attr_destroy</span>(&amp;attr) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_attr_destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用__asan_unpoison_memory_region屏蔽某处内存检查</title>
      <link href="/2024/07/22/%E4%BD%BF%E7%94%A8-asan-unpoison-memory-region%E5%B1%8F%E8%94%BD%E6%9F%90%E5%A4%84%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5/"/>
      <url>/2024/07/22/%E4%BD%BF%E7%94%A8-asan-unpoison-memory-region%E5%B1%8F%E8%94%BD%E6%9F%90%E5%A4%84%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p><code>__asan_unpoison_memory_region</code> 是 AddressSanitizer (ASan) 库中的一个函数。ASan 是一个用于检测内存错误的工具，主要用于 C 和 C++ 程序开发者。<code>__asan_unpoison_memory_region</code> 的作用是标记一段内存区域为“未污染”状态，这意味着这段内存可以被访问且不会触发 ASan 的错误报告。</p><span id="more"></span><p>具体来说，这个函数通常用于以下场景：</p><ol><li>在内存被分配后但未初始化之前，标记该区域为未污染，以便在初始化期间可以安全访问。</li><li>当程序知道某段内存区域将被合法访问时，预先标记该区域为未污染，以避免误报。</li></ol><p>函数原型通常如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __asan_unpoison_memory_region(<span class="type">void</span> *addr, <span class="type">size_t</span> size);</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li><code>addr</code>：内存区域的起始地址。</li><li><code>size</code>：内存区域的大小（以字节为单位）。</li></ul><p>通过调用这个函数，开发者可以更精细地控制 ASan 的内存监控行为，减少误报，提高调试效率。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UTF编码内存角度比较.md</title>
      <link href="/2024/07/11/UTF%E7%BC%96%E7%A0%81%E5%86%85%E5%AD%98%E8%A7%92%E5%BA%A6%E6%AF%94%E8%BE%83-md/"/>
      <url>/2024/07/11/UTF%E7%BC%96%E7%A0%81%E5%86%85%E5%AD%98%E8%A7%92%E5%BA%A6%E6%AF%94%E8%BE%83-md/</url>
      
        <content type="html"><![CDATA[<p>UTF-8、UTF-16 和 UTF-32 是三种不同的 Unicode 编码方式，它们在表示字符时占用的字节数各不相同。具体如下：</p><ol><li><strong>UTF-8</strong>：<ul><li>UTF-8 是一种可变长度的编码方式，每个字符占用 1 到 4 个字节。</li><li>具体字节数取决于字符的 Unicode 码点：<ul><li>U+0000 至 U+007F（基本拉丁字母）占 1 个字节。</li><li>U+0080 至 U+07FF 占 2 个字节。</li><li>U+0800 至 U+FFFF 占 3 个字节。</li><li>U+10000 至 U+10FFFF 占 4 个字节。</li></ul></li></ul></li></ol><span id="more"></span><ol start="2"><li><p><strong>UTF-16</strong>：</p><ul><li>UTF-16 也是一种可变长度的编码方式，每个字符占用 2 或 4 个字节。</li><li>具体字节数取决于字符的 Unicode 码点：<ul><li>U+0000 至 U+FFFF（基本多语言平面，BMP）占 2 个字节。</li><li>U+10000 至 U+10FFFF（辅助平面）占 4 个字节（使用一对代理项，即高位代理项和低位代理项，每个占 2 个字节）。</li></ul></li></ul></li><li><p><strong>UTF-32</strong>：</p><ul><li>UTF-32 是一种固定长度的编码方式，每个字符占用 4 个字节。</li><li>无论字符的 Unicode 码点是多少，每个字符始终占用 4 个字节。</li></ul></li></ol><p>总结：</p><ul><li><strong>UTF-8</strong>：1 到 4 个字节，具体取决于字符。</li><li><strong>UTF-16</strong>：2 或 4 个字节，具体取决于字符。</li><li><strong>UTF-32</strong>：固定 4 个字节。</li></ul><p>这三种编码方式各有优缺点。UTF-8 是最常用的编码方式，因其对 ASCII 字符的高效编码（仅占 1 个字节），节省空间且向后兼容 ASCII。UTF-16 在处理基本多语言平面字符时相对高效，但对于包括大量辅助平面字符的文本，可能会占用更多空间。UTF-32 最简单，但由于每个字符固定占用 4 个字节，通常会占用更多的存储空间。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SDF实现CornerRadius</title>
      <link href="/2023/12/28/SDF%E5%AE%9E%E7%8E%B0CornerRadius/"/>
      <url>/2023/12/28/SDF%E5%AE%9E%E7%8E%B0CornerRadius/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍如何使用SDF（Signed Distance Field）实现圆角效果。</p><!-- 内容待补充 -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>lamda 初始化捕获用法</title>
      <link href="/2023/12/27/lamda-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8D%95%E8%8E%B7%E7%94%A8%E6%B3%95/"/>
      <url>/2023/12/27/lamda-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8D%95%E8%8E%B7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍C++ Lambda表达式的初始化捕获用法。</p><!-- 内容待补充 -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tag dispatch</title>
      <link href="/2023/12/24/tag-dispatch/"/>
      <url>/2023/12/24/tag-dispatch/</url>
      
        <content type="html"><![CDATA[<h4 id="对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string"><a href="#对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string" class="headerlink" title="对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string"></a>对于short类型来说，会优先匹配通用引用版本的重载，导致无法构造string</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> TagDispatch &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; temp;</span><br><span class="line">    temp.<span class="built_in">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called fun(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called fun(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(std::forward&lt;T&gt;(params));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fwd</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">//suc</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fwd</span>(a);     <span class="comment">//suc</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">short</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//fwd(b);     //failed, 匹配到了通用引用函数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;    </span><br><span class="line">    TagDispatch::<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="使用TagDispath，来解决匹配的问题"><a href="#使用TagDispath，来解决匹配的问题" class="headerlink" title="使用TagDispath，来解决匹配的问题"></a>使用TagDispath，来解决匹配的问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> TagDispatch &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(T&amp;&amp; params, std::false_type)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; temp;</span><br><span class="line">    temp.<span class="built_in">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called fun(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a, std::true_type)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called fun(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp; params)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun2</span>(std::forward&lt;T&gt;(params), std::is_integral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fwd</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">//suc</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fwd</span>(a);     <span class="comment">//suc</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">short</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">fwd</span>(b);     <span class="comment">//succeed, 匹配到了通用引用函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable-if来限制模板的匹配"><a href="#针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable-if来限制模板的匹配" class="headerlink" title="针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配"></a>针对函数的构造函数，使用通用引用重载，主要解决思路是通过enable_if来限制模板的匹配</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;</span><br><span class="line">            !std::is_base_of&lt;Person, std::<span class="type">decay_t</span>&lt;T&gt;&gt;::value    <span class="comment">// 防止调用拷贝和移动构造函数，并且考虑了子类</span></span><br><span class="line">            &amp;&amp;                                                  <span class="comment">// decay,移除指针引用和cv修饰符</span></span><br><span class="line">            !std::is_integral&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class="line">        &gt;</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; params) &#123;</span><br><span class="line">        std::vector&lt;std::string&gt; temp;</span><br><span class="line">        temp.<span class="built_in">emplace_back</span>(std::forward&lt;T&gt;(params));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Person(T&amp;&amp; params)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Person(int a)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testCtrOverload</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(b)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>smoothStep实现</title>
      <link href="/2023/12/22/smoothStep%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/12/22/smoothStep%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍smoothStep函数的实现原理和应用。</p><!-- 内容待补充 -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模板规则推导</title>
      <link href="/2023/12/21/%E6%A8%A1%E6%9D%BF%E8%A7%84%E5%88%99%E6%8E%A8%E5%AF%BC/"/>
      <url>/2023/12/21/%E6%A8%A1%E6%9D%BF%E8%A7%84%E5%88%99%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="模板推导规则"><a href="#模板推导规则" class="headerlink" title="模板推导规则"></a>模板推导规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void passByRefFun(T&amp; val) &#123; &#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void passByUniRefFun(T&amp;&amp; val) &#123; &#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void passByValueFun(T val) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void fun3(int&amp; a) &#123; &#125;</span><br><span class="line">void fun3(int&amp;&amp; a) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 0;          //a int</span><br><span class="line">    const int b = a;    //b const int</span><br><span class="line">    const int&amp; c = a;   //c const int&amp;</span><br><span class="line">    </span><br><span class="line">    passByRefFun(a);    // int&amp;</span><br><span class="line">    passByRefFun(b);    // const int&amp;</span><br><span class="line">    passByRefFun(c);    // const int&amp;</span><br><span class="line">    //passByRefFun(27);   // 报错</span><br><span class="line">    </span><br><span class="line">    passByUniRefFun(a); // int&amp;</span><br><span class="line">    passByUniRefFun(b); // const int&amp;</span><br><span class="line">    passByUniRefFun(c); // const int&amp;</span><br><span class="line">    passByUniRefFun(27); // int&amp;&amp;</span><br><span class="line">    </span><br><span class="line">    passByValueFun(a);  // int</span><br><span class="line">    passByValueFun(b);  // int</span><br><span class="line">    passByValueFun(c);  // int</span><br><span class="line">    passByValueFun(27); // int</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        int&amp;&amp; a = 10;</span><br><span class="line">        fun3(a);            // called void fun3(int&amp; a)</span><br><span class="line">        fun3(std::move(a)); // called void fun3(int&amp;&amp; a)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h3><p>SFINAE（Substitution Failure Is Not An Error）是 C++ 中的一个重要概念，主要用于模板编程。它的意思是，当模板参数替换导致错误时，编译器不会将其视为错误，而是会继续查找其他可能的匹配。这使得我们可以在模板中进行条件编译，选择合适的重载或特化</p><p>SFINAE 的优势<br>条件编译：可以根据类型特征选择不同的实现，增强代码的灵活性和可重用性。<br>避免编译错误：当模板参数替换导致错误时，编译器不会将其视为错误，而是继续查找其他匹配的模板。<br>类型安全：通过类型特征，可以确保只有符合条件的类型才能使用特定的模板实现。</p><p>SFINAE 是 C++ 模板编程中的一个强大工具，允许开发者根据类型特征选择合适的模板特化或重载。通过结合 std::enable_if 和类型特征，开发者可以编写更灵活和安全的代码。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>电子书目录</title>
      <link href="/2022/12/25/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/12/25/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="渲染整理"><a href="#渲染整理" class="headerlink" title="渲染整理"></a>渲染整理</h2><h4 id="开放世界的场景管理"><a href="#开放世界的场景管理" class="headerlink" title="开放世界的场景管理"></a>开放世界的场景管理</h4><pre><code>1. 切成tile2. 数据分级LOD3. 根据天顶角，调整远平面，裁剪数据</code></pre><span id="more"></span><h4 id="游戏引擎分层架构"><a href="#游戏引擎分层架构" class="headerlink" title="游戏引擎分层架构"></a>游戏引擎分层架构</h4><pre><code>1. EditorLayer2. FuntionLayer    1. Rendering    2. Animation    3. Camera    4. Physics    5. Script3. ResourceLayer4. CoreLayer    1. threadPoolManagement    2. memoryPool    3. mathLibrary5. PlatformLayer    1. RHI</code></pre><h4 id="Renderable"><a href="#Renderable" class="headerlink" title="Renderable"></a>Renderable</h4><pre><code>1. shader    1. vs,fs    2. macro2. RenderState3. MVP 4. Texture5. DrawImp</code></pre><h4 id="渲染效果"><a href="#渲染效果" class="headerlink" title="渲染效果"></a>渲染效果</h4><pre><code>1. 前向渲染      1. PBR      2. 布林冯模型2. 阴影shadowMap：    1. 根据相机的位置，对整个场景，绘制出深度图，表示光的可见性    2. 渲染时，将相机位置变化到光源位置，计算深度值与shadowmap进行比较，从而决定绘制的亮度3. 楼的倒影    1. 矩阵楼块插入地面    2. 模板测试，只有地面和水才绘制4. AO5. 聚光灯效果6. UV动画</code></pre><h4 id="技术点提炼"><a href="#技术点提炼" class="headerlink" title="技术点提炼"></a>技术点提炼</h4><pre><code>1. 楼块    1. 切成小块    2. 柔化圆角    3. 贴UV2. 3d瓦片绘制    1. 瓦片的加载，与cache    2. 非实施例渲染，按材质进行分类渲染    3. 实例化渲染，动态计算lod进行渲染3. 模型渲染    1. PBR渲染    2. 非PBR渲染</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++ 可变参数模板</title>
      <link href="/2022/12/11/c-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/12/11/c-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="可变模版参数-variadic-templates"><a href="#可变模版参数-variadic-templates" class="headerlink" title="可变模版参数(variadic templates)"></a>可变模版参数(variadic templates)</h3><p>可以对参数进行高度泛化，标识0到任意个数参数</p><span id="more"></span><h4 id="两种展开形式"><a href="#两种展开形式" class="headerlink" title="两种展开形式"></a>两种展开形式</h4><ol><li>使用特化的终止函数结合递归</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//终止函数</span><br><span class="line">int multiply()</span><br><span class="line">&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//递归展开</span><br><span class="line">template &lt;typename T, typename ...Args&gt;</span><br><span class="line">int multiply(T&amp;&amp; t, Args&amp;&amp; ...arg)</span><br><span class="line">&#123;</span><br><span class="line">    return t * multiply(arg...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; multiply(3, 4, 5) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; multiply() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用逗号表达式<br>初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc… )，最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class F, class... Args&gt;void expand(const F&amp; f, Args&amp;&amp;...args)</span><br><span class="line">&#123;</span><br><span class="line">  //这里用到了完美转发，关于完美转发，读者可以参考笔者在上一期程序员中的文章《通过4行代码看右值引用》</span><br><span class="line">  initializer_list&lt;int&gt;&#123;(f(std::forward&lt; Args&gt;(args)),0)...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    expand([](int i) &#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;, 1,2,3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h3><p>为了编写处理不同数量实参的函数，如果参数类型相同，可以使用initializer_list， 如果实参类型不同，使用可变参数模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct myclass &#123;</span><br><span class="line">    myclass(int,int)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;myclass constructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    myclass(initializer_list&lt;int&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;myclass initializer_list constructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    auto il = &#123;10, 20, 30&#125;;</span><br><span class="line">    </span><br><span class="line">    myclass foo &#123;10,20&#125;;  // calls initializer_list constructor</span><br><span class="line">    myclass bar (10,20);  // calls first constructo</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++继承权限</title>
      <link href="/2022/12/04/c-%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90/"/>
      <url>/2022/12/04/c-%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<ol><li><p>继承有三种权限，public，proteced，private，默认不写是private</p></li><li><p>权限的最低是public，其次是protected，最高private</p></li><li><p>继承方式代表是父类属性在当前类中的最低呈现</p></li><li><p>父类中的privated属性在子类中不可访问</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL模板测试流程</title>
      <link href="/2022/11/08/OpenGL%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/11/08/OpenGL%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="模板测试流程"><a href="#模板测试流程" class="headerlink" title="模板测试流程"></a>模板测试流程</h3><span id="more"></span><p>不考虑earlyZ的情况下，fragment执行后，进行模板测试，通过后，进入深度测试</p><h4 id="模板测试一般使用流程："><a href="#模板测试一般使用流程：" class="headerlink" title="模板测试一般使用流程："></a>模板测试一般使用流程：</h4><pre><code>1. 启用模板缓冲写入2. 渲染物体，更新模板缓冲3. 禁用模板缓冲写入4. 渲染其他物体，根据模板缓冲内容决定是否丢弃片段</code></pre><h5 id="使用模板测试绘制物体轮廓的例子"><a href="#使用模板测试绘制物体轮廓的例子" class="headerlink" title="使用模板测试绘制物体轮廓的例子"></a>使用模板测试绘制物体轮廓的例子</h5><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glStencilMask();</span><br><span class="line">glStencilFunc(GLenum func, GLint ref, GLuint mask);</span><br><span class="line">glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);</span><br></pre></td></tr></table></figure>1. 开启模板测试和深度测试2. 第一次render pass，主要是绘制，并写入模板    1. 开启模板测试和深度测试    2. glStencilMask(0xFF);    3. glStencilOp(keep, keep, replace);    4. glStencilFunc(always, 1, 0xFF);    5. 绘制物体3. 第二次render pass, 放大物体，通过模板测试剔除非边缘像素    1. 将物体缩放变大    2. 关闭深度测试 //因为这里的边缘不需要有拓扑关系    3. 关闭模板写入glStencilMask(0x00);    4. glStencilFunc(not_equal, 1, 0xFF);    5. 绘制物体</code></pre><h3 id="关于OpenGL里面的Mask"><a href="#关于OpenGL里面的Mask" class="headerlink" title="关于OpenGL里面的Mask"></a>关于OpenGL里面的Mask</h3><pre><code>1. 写入颜色是，r，g，b，a 分别与对应的mask，进行&amp;运算后写入2. depth也是同样道理，如果设置成true，就是允许写入，设置成false，不允许写入3. stencil的Mask，是0xFF~0x00，之间的256个数，一般设置是0xFF，允许任意值写入，0x00是不允许写入</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>trivially copyable 拷贝不变</title>
      <link href="/2022/10/25/trivially-copyable-%E6%8B%B7%E8%B4%9D%E4%B8%8D%E5%8F%98/"/>
      <url>/2022/10/25/trivially-copyable-%E6%8B%B7%E8%B4%9D%E4%B8%8D%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍C++中trivially copyable概念及其应用。</p><!-- 内容待补充 -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实现完美转发</title>
      <link href="/2022/10/23/C++%E5%AE%9E%E7%8E%B0%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
      <url>/2022/10/23/C++%E5%AE%9E%E7%8E%B0%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是完美转发？"><a href="#什么是完美转发？" class="headerlink" title="什么是完美转发？"></a>什么是完美转发？</h3><span id="more"></span><h4 id="在理解什么是完美转发之前，需要知道什么是万能引用"><a href="#在理解什么是完美转发之前，需要知道什么是万能引用" class="headerlink" title="在理解什么是完美转发之前，需要知道什么是万能引用?"></a>在理解什么是完美转发之前，需要知道什么是万能引用?</h4><p>在模板推导过程中，使用T&amp;&amp; a,这时候，并不是类型T的右值引用，而是万能引用，如果a是左值，这时候，就是一个左值引用，如果a是右值，这时候就是一个右值引用，具体原理是发生引用折叠。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    Add(4, 5); // a，b的类型会被推导成int&amp;&amp;</span><br><span class="line">    int a = 0;</span><br><span class="line">    int b = 0;</span><br><span class="line">    Add(a, b); // a，b的类型会被推导成int&amp;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据参数的具体类型，来实例化模板，准确的生成左值引用和右值引用的实例，这就是万能引用</p><h4 id="万能引用遇到的问题？"><a href="#万能引用遇到的问题？" class="headerlink" title="万能引用遇到的问题？"></a>万能引用遇到的问题？</h4><p>上面的例子中，Add函数参数虽然是类型是右值引用，但是值确实左值，导致函数内继续使用调用其他函数时，参数类型由右值变成左值，也就是无法将右值引用这个类型继续转发.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void AddImp(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class="line">    AddImp(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    Add(4, 5);</span><br><span class="line">    int a = 0;</span><br><span class="line">    int b = 0;</span><br><span class="line">    Add(a, b);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决方案-std-forward"><a href="#解决方案-std-forward" class="headerlink" title="解决方案: std::forward"></a>解决方案: std::forward<T></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Add(T&amp;&amp; a, T&amp;&amp; b) &#123;</span><br><span class="line">    AddImp(std::forward&lt;T&gt;(a), std::forward&lt;T&gt;(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>std::forward的具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Tp&gt;</span><br><span class="line">_Tp&amp;&amp; forward(typename remove_reference&lt;_Tp&gt;::type&amp; __t) </span><br><span class="line">&#123;</span><br><span class="line">  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体分析一下，也是通过引用折叠来实现</p><ol><li>如果_Tp的类型是int&amp;， 通过引用折叠 int&amp; &amp;&amp; 折叠后是左值引用int&amp;</li><li>如果_Tp的类型是int&amp;&amp;， 通过引用折叠 int&amp;&amp; &amp;&amp; 折叠后是int&amp;&amp;</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>add Image</title>
      <link href="/2022/09/25/add-Image/"/>
      <url>/2022/09/25/add-Image/</url>
      
        <content type="html"><![CDATA[<p>###测试插入一张图片</p><p><img src="/2022/09/25/add-Image/sharedptr1.png"></p><p>test end</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 11 智能指针</title>
      <link href="/2022/09/25/C++-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2022/09/25/C++-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="share-ptr使用"><a href="#share-ptr使用" class="headerlink" title="share_ptr使用"></a>share_ptr使用</h3><span id="more"></span><h4 id="sharet-ptr构造函数和std-make-share-的区别"><a href="#sharet-ptr构造函数和std-make-share-的区别" class="headerlink" title="sharet_ptr构造函数和std::make_share 的区别"></a>sharet_ptr<T>构造函数和std::make_share<T> 的区别</h4><ol><li>两个堆内存和一个堆内存，std::make_share效率更高</li><li></li></ol><h3 id="weak-ptr使用"><a href="#weak-ptr使用" class="headerlink" title="weak_ptr使用"></a>weak_ptr使用</h3><ol><li>expired(),返回指向对堆对象是否释放</li><li>use_count,share_ptr的强引用计数</li><li>lock，返回share_ptr，如果释放，返回空</li><li></li></ol><h3 id="share-ptr线程安全话题"><a href="#share-ptr线程安全话题" class="headerlink" title="share_ptr线程安全话题"></a>share_ptr线程安全话题</h3><ol><li>share_ptr引用计数本身是线程安全的</li><li>一个share_ptr对象，在多个线程操作，不能保证线程安全</li><li>share_ptr指向的对象本身，进行操作时，也无法保证线程安全，完全取决于指向对象是否线程安全</li></ol><h3 id="stl容器多线程安全时的性能考虑"><a href="#stl容器多线程安全时的性能考虑" class="headerlink" title="stl容器多线程安全时的性能考虑"></a>stl容器多线程安全时的性能考虑</h3><h3 id="code使用"><a href="#code使用" class="headerlink" title="code使用"></a>code使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;Person&gt; person1;</span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;Person&gt; person2(nullptr);</span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;Person&gt; person3(new Person(10));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Person&gt; person4 = std::make_shared&lt;Person&gt;(5); //效率更高，内存分布在一起</span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;Person&gt; person5(std::move(person3)); // person3无法再使用</span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;Person&gt; arary(new Person[10], deletePersonArray);</span><br><span class="line">    </span><br><span class="line">    weak_ptr&lt;Person&gt; weak_Person = person5;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;Person&gt; person6 = person5;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    person5.reset();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    person6.reset();</span><br><span class="line">    </span><br><span class="line">    if (weak_Person.expired()) &#123;</span><br><span class="line">        cout &lt;&lt; weak_Person.use_count() &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        auto shareptr = weak_Person.lock();</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; shareptr &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 右值引用</title>
      <link href="/2022/09/18/C++%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>/2022/09/18/C++%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是右值？"><a href="#1-什么是右值？" class="headerlink" title="1. 什么是右值？"></a>1. 什么是右值？</h3><p>有名称，可以取地址的值，是左值。<br>没有名称，不能取地址的值，就是右值，另外类似函数返回值这种临时变量，定义为将亡值，也是右值。<br>c++11中，所有的值，必属于左值，将亡值，和纯右值。</p><span id="more"></span><h3 id="2-左值引用，右值引用"><a href="#2-左值引用，右值引用" class="headerlink" title="2. 左值引用，右值引用"></a>2. 左值引用，右值引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    int a = 0; //ok</span><br><span class="line">    </span><br><span class="line">    int&amp; b = a; //ok,左值引用</span><br><span class="line">    int&amp; c = 0; // not ok,左值引用无法引用右值</span><br><span class="line">    </span><br><span class="line">    const int&amp; d = 0; // ok，常左值引用，可以绑定右值</span><br><span class="line">    const int&amp; e = a; // ok，常左值引用，可以绑定左值</span><br><span class="line">    </span><br><span class="line">    int&amp;&amp; f = 0;//ok 右值引用绑定右值</span><br><span class="line">    const int &amp;&amp; g = 0; // ok,常右值引用可以绑定右值</span><br><span class="line">    //但是实际上没有意义，因为绑定的右值无法修改，一般右值引用是为了实现移动语义，降低copy消耗</span><br><span class="line">    </span><br><span class="line">    int&amp;&amp; h = a;//not ok，右值引用无法绑定左值</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左值引用，只能绑定左值<br>常左值引用，可以绑定常量左值，右值，非常量左值和右值<br>右值引用，只能绑定非常量右值<br>常右值引用，可以绑定常量右值，非常量右值</p><h3 id="3-讨论右值引用，要注意排除返回值优化"><a href="#3-讨论右值引用，要注意排除返回值优化" class="headerlink" title="3. 讨论右值引用，要注意排除返回值优化"></a>3. 讨论右值引用，要注意排除返回值优化</h3><p>如果关闭返回值优化，可以参考<br><a href="https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO">https://www.yhspy.com/2019/09/01/C-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E4%B9%8B-RVO-%E4%B8%8E-NRVO</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Person GetPerson()&#123;</span><br><span class="line">    return Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person person = GetPerson();</span><br><span class="line">    person.print();</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     一共执行三次构造</span><br><span class="line">    1 Person()默认构造函数</span><br><span class="line">    2 GetPerson函数返回时，生成临时对象，调用移动构造函数</span><br><span class="line">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class="line">     */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Person&amp;&amp; GetPerson()&#123;</span><br><span class="line">    return Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person person = GetPerson();</span><br><span class="line">    person.print();</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     一共执行两次次构造，这种写法是错的，会有warnning</span><br><span class="line">     Returning reference to local temporary object</span><br><span class="line">    1 Person()默认构造函数</span><br><span class="line">    2 右值引用，引用了已经析构的临时对象</span><br><span class="line">    3 使用临时对象，构造person，调用移动构造函数</span><br><span class="line">     */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-函数返回值，如果没有写左值引用，就是临时变量属于右值"><a href="#4-函数返回值，如果没有写左值引用，就是临时变量属于右值" class="headerlink" title="4. 函数返回值，如果没有写左值引用，就是临时变量属于右值"></a>4. 函数返回值，如果没有写左值引用，就是临时变量属于右值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person GetPerson()&#123;</span><br><span class="line">    return Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    Person person1 = GetPerson(); //调用一次构造，两次次移动构造</span><br><span class="line">    </span><br><span class="line">    Person&amp;&amp; person2 = GetPerson(); //调用一次构造，一次移动构造</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解上面person1和person2的区别，person1是根据临时变量构造了一个新的对象<br>person2是直接对临时变量的右值引用</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const Person&amp; GetPerson1()&#123;</span><br><span class="line">    return Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&amp;&amp; GetPerson2()&#123;</span><br><span class="line">    return Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种写法都是错误的，返回的是临时变量的引用，可以编译通过，但是有警告</p><p><code>Returning reference to local temporary object</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++中operator的重载</title>
      <link href="/2022/09/18/C++%E4%B8%ADoperator%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
      <url>/2022/09/18/C++%E4%B8%ADoperator%E7%9A%84%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="两种函数允许编译器进行隐士类型转换"><a href="#两种函数允许编译器进行隐士类型转换" class="headerlink" title="两种函数允许编译器进行隐士类型转换"></a>两种函数允许编译器进行隐士类型转换</h2><ol><li>单一参数调用成功的constructors</li><li>隐士转换操作符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Ration &#123;</span><br><span class="line">public:</span><br><span class="line">    //1 隐士构造函数</span><br><span class="line">    Ration(int a) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //2 隐士类型转换函数</span><br><span class="line">    operator double() const &#123;</span><br><span class="line">        return 5.0f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Ration ration(1);</span><br><span class="line">    cout &lt;&lt; ration &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="如何阻止构造函数发生不期望的隐士类型转换"><a href="#如何阻止构造函数发生不期望的隐士类型转换" class="headerlink" title="如何阻止构造函数发生不期望的隐士类型转换"></a>如何阻止构造函数发生不期望的隐士类型转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Ration &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Ration(int a) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Ration ration(1);</span><br><span class="line">    </span><br><span class="line">    //构造函数声明为explicit 阻止隐士类型转换 ration == 2 会编译报错</span><br><span class="line">    if (ration == 2) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。"><a href="#重载操作符可以在globe-scope或者class-scope中进行，但是切记不要重载-amp-amp-操作符，-原因是改变了短路运算的语义，变成函数调用。" class="headerlink" title="重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。"></a>重载操作符可以在globe scope或者class scope中进行，但是切记不要重载 &amp;&amp; || 操作符， 原因是改变了短路运算的语义，变成函数调用。</h3><h4 id="这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。"><a href="#这里还有一个细节，c-中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。" class="headerlink" title="这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。"></a>这里还有一个细节，c++中并未明确定义函数调用动作中各参数的评估顺序，而短路运算是从左到右的。</h4><p>###重载(),当重载 () 时，不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Ration &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Ration(int a) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int operator() (int a , int b, int c)</span><br><span class="line">    &#123;</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int operator() (int a , int b)</span><br><span class="line">    &#123;</span><br><span class="line">        return 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Ration ration(1);</span><br><span class="line">    ration(1, 2, 3);</span><br><span class="line">    ration(1, 3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 构造函数</title>
      <link href="/2022/09/18/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2022/09/18/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="C-构造函数"><a href="#C-构造函数" class="headerlink" title="C++ 构造函数"></a>C++ 构造函数</h2><ol><li>默认构造</li><li>copy构造</li><li>移动构造</li><li>operator= 赋值函数</li></ol><span id="more"></span><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>对于赋值函数和copy构造函数来说，直接实现实现const的版本即可，如果参数不是const，会调用const，只有实现了非const的参数，才会调用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Person() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Person(const Person&amp; Person) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person(Person&amp;&amp; Person) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person&amp; operator=(const Person&amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>对于构造函数，copy构造函数和移动构造函数来说，只要实现其中任何一个，剩余其他的，编译器就不会帮助生成。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//    Person() &#123;</span><br><span class="line">//        cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;</span><br><span class="line">//    &#125;;</span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">//    Person(const Person&amp; Person) &#123;</span><br><span class="line">//        cout &lt;&lt; &quot;Person(Person&amp; Person)&quot; &lt;&lt; endl;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    Person(Person&amp;&amp; Person) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person(Person&amp;&amp; Person)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person&amp; operator=(const Person&amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;operator=(const Person&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person person; //编译报错，找不到匹配的构造函数</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS运行时消息转发</title>
      <link href="/2017/12/14/iOS-MessageForwarding/"/>
      <url>/2017/12/14/iOS-MessageForwarding/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近读了一遍apple 文档，对于iOS运行时消息转发机制发现有些细节还是理解有所偏差，写此文章加深理解</p></blockquote><span id="more"></span><h3 id="iOS-方法调用探讨"><a href="#iOS-方法调用探讨" class="headerlink" title="iOS 方法调用探讨"></a>iOS 方法调用探讨</h3><p>这个话题还要从OC是一门动态语言说起，OC的动态性体现在编译和链接期，并没有直接绑定函数调用关系，编译器将方法调用转成objc_msgSend(receiver, selector, arg1, arg2, …)方法这种方式</p><p>在运行时，通过isa对象通过从子类到父类的方法查找，找到具体的函数入口进行调用，这其中还包括cache等机制，这里不在赘述，这次主要讨论的是Dynamic Method Resolution和Message Forwarding</p><p>如果调用的Seletor在类的方法列表中找不到，以实例对象的方法为例，将进入如下流程：</p><p><img src="https://oh144b0ji.qnssl.com/OC%20runTime.jpg" alt="image.png"></p><p>主要流程可以总结为，先进入消息动态处理流程，再进入消息转发流程</p><p>1.消息动态处理流程：resloveInstanceMethod中可以通过class_addMethod为此对象动态添加方法，这样就使该对象正常响应此方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123;</span><br><span class="line">  </span><br><span class="line">    if (aSEL == @selector(notFoundFunctiion)) &#123;</span><br><span class="line">        </span><br><span class="line">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    需要注意的是，不仅[self notFoundFunctiion]会触发这里，在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self respondsToSelector:@selector(notFoundFunctiion)]</span><br></pre></td></tr></table></figure><p>​    这句代码中，同样会触发消息动态处理流程，这和后面讲的消息转发有很大区别。</p><p>2.如果上面的消息处理流程返回NO，那么就会进入消息转发流程</p><p>可以将此消息转发给另外一个对象进行执行。首先进入的是forwardingTargetForSelector，这里可以返回一个可以响应此消息的对象，如果仍然返回nil，就会进入methodSignatureForSelector和forwardInvocation的流程，其实这两种方式本质的意义相同，只不过一个是通过另外的对象selector调用，一个是通过invocation的方式调用，但是要注意，这里的selector对于原来的对象来讲，respondsToSelector返回为NO</p><h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">Objective-C Runtime Programming Guide</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOSCALayer的presentLayer那点事</title>
      <link href="/2017/11/12/CALayer%E7%9A%84presentLayer%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
      <url>/2017/11/12/CALayer%E7%9A%84presentLayer%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近开发过程中遇到的一个问题，要求在一个View的动画过程中，获取它的实时位置，这里讲如何解决</p></blockquote><span id="more"></span><h3 id="动画过程中，如何获取它的实时位置"><a href="#动画过程中，如何获取它的实时位置" class="headerlink" title="动画过程中，如何获取它的实时位置"></a>动画过程中，如何获取它的实时位置</h3><p>这个话题涉及对CALayer的理解和使用</p><p>CALayer内部系统维护着三种LayerTree，分别为modelLayer，presentLayer和renderLayer，renderLayer为系统渲染时内部维护，对于开发者来讲是透明不可见的，这里指讨论modelLayer和presentLayer</p><ul><li>modelLayer 实际上就是通常操作的layer，我们可以修改这个layer的各种属性，可以理解这个layer只保存数据</li><li>presentLayer 是当使用CoreAnimation做动画时，每一帧动的位置都可以从这个layer中读取到，我们可以通过下面的代码来测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">UIView* view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class="line"></span><br><span class="line">    view.backgroundColor = [UIColor redColor];</span><br><span class="line"></span><br><span class="line">    [self.view addSubview:view];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class="line"></span><br><span class="line">    [UIView animateWithDuration:10 animations:^&#123;</span><br><span class="line"></span><br><span class="line">        view.frame = CGRectMake(200, 100, 100, 100);</span><br><span class="line">        </span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">    </span><br><span class="line">        NSLog(@&quot;model   Layeer = %@&quot;, NSStringFromCGRect([view.layer modelLayer].frame));</span><br><span class="line">        NSLog(@&quot;present Layeer = %@&quot;, NSStringFromCGRect([view.layer presentationLayer].frame));</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过控制台日志可以分析看到，presentLayer在没有做动画的时候是nil，在有动画时才有数值，并且是实时的view的位置</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac环境下安装Ruby</title>
      <link href="/2017/09/19/MacOS%E4%B8%8Bruby%E5%AE%89%E8%A3%85/"/>
      <url>/2017/09/19/MacOS%E4%B8%8Bruby%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="使用rvm来安装ruby"><a href="#使用rvm来安装ruby" class="headerlink" title="使用rvm来安装ruby"></a>使用rvm来安装ruby</h2><h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L get.rvm.io | bash -s stable  </span><br></pre></td></tr></table></figure><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.bashrc $ source ~/.bash_profile$ rvm -v  </span><br><span class="line">$ source ~/.bash_profile  </span><br><span class="line">$ rvm -v  </span><br></pre></td></tr></table></figure><h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm list known  </span><br></pre></td></tr></table></figure><h3 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm install 2.2.0  </span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="如果Step4失败，可以进行如下尝试"><a href="#如果Step4失败，可以进行如下尝试" class="headerlink" title="如果Step4失败，可以进行如下尝试"></a>如果Step4失败，可以进行如下尝试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami):admin /usr/local</span><br><span class="line">cd /usr/local</span><br><span class="line">git remote set-url origin git://mirrors.ustc.edu.cn/brew.git</span><br><span class="line">brew update</span><br><span class="line">sudo chown root:wheel /usr/local</span><br><span class="line">rvm install 2.2.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS11模拟器运行OpenGL相关程序卡顿</title>
      <link href="/2017/09/19/iOS11%20Simulator%20OpenGL%20Slowly/"/>
      <url>/2017/09/19/iOS11%20Simulator%20OpenGL%20Slowly/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近升级Xcode9.0后发现模拟器上运行OpenGL程序非常卡顿，查了一下原因，原来是苹果的一处bug</p></blockquote><span id="more"></span><h3 id="具体的解决方案是"><a href="#具体的解决方案是" class="headerlink" title="具体的解决方案是"></a>具体的解决方案是</h3><p>替换此路径下的文件用附件文件，替换此路径下文件即可</p><p><em>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib</em>  </p><p><a href="http://ox0sey9ue.bkt.clouddn.com/libCoreVMClient.dylib">libCoreVMClient.dylib下载链接</a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://forums.developer.apple.com/thread/83570">苹果开发者论坛</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS不受用户手动修改时间的影响的计时技术</title>
      <link href="/2017/09/17/iOS%E5%87%86%E7%A1%AE%E8%AE%A1%E6%97%B6/"/>
      <url>/2017/09/17/iOS%E5%87%86%E7%A1%AE%E8%AE%A1%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="iOS不受用户手动修改时间的影响的计时技术"><a href="#iOS不受用户手动修改时间的影响的计时技术" class="headerlink" title="iOS不受用户手动修改时间的影响的计时技术"></a>iOS不受用户手动修改时间的影响的计时技术</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><span id="more"></span><p>这几天的项目中，要求实现一个用户计时的功能，其中遇到了经理了几种技术方法，分别是利用NSTimer，NSDate，都有各自的问题，Timer计时不够精准，以及需要程序在后台执行，NSDate会受到用户修改系统时间，而导致计时不准，最后找到了一种完美的解决方案</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>直接说最终方案</p><p><code>[[NSProcessInfo processInfo] systemUptime];</code></p><p>这个函数返回的是开机到当前的时间，秒数为单位，并且<strong>不受系统时钟的影响</strong>，在一些需要准确记录时间长度的场景里，配合Timer非常适合，解决了前沿描述的所有痛点.</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://developer.apple.com/documentation/foundation/nsprocessinfo/1414553-systemuptime?language=objc">苹果接口文档</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS手势事件分发原理</title>
      <link href="/2017/07/01/iOS%E6%89%8B%E5%8A%BF%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%8E%9F%E7%90%86/"/>
      <url>/2017/07/01/iOS%E6%89%8B%E5%8A%BF%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>HitTest的主要目的就是找到对于UIEvent的响应者，本文实现代码是根据apple文档描述的一种猜测实现，帮助大家理解原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event&#123;</span><br><span class="line">    </span><br><span class="line">    //apple文档描述，不接受事件的情况</span><br><span class="line">    if (self.userInteractionEnabled == NO || self.isHidden == YES || self.alpha &lt; 0.01) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果当前View包含此Point</span><br><span class="line">    if ([self pointInside:point withEvent:event]) &#123;</span><br><span class="line">        </span><br><span class="line">        //遍历子View，这里注意要从后往前遍历，因为后面的是越靠近用户的</span><br><span class="line">        for (NSInteger i=self.subviews.count-1; i&gt;=0; i--) &#123;</span><br><span class="line">            </span><br><span class="line">            UIView* subView = [self.subviews objectAtIndex:i];</span><br><span class="line">            </span><br><span class="line">            //将父View的Point转换成子View坐标系的Point</span><br><span class="line">            CGPoint pointInSubView = [subView convertPoint:point fromView:self];</span><br><span class="line">            </span><br><span class="line">            //递归子View调用HitTest:</span><br><span class="line">            UIView* resultView = [subView hitTest:pointInSubView withEvent:event];</span><br><span class="line">            </span><br><span class="line">            //找到了子View可以响应</span><br><span class="line">            if (resultView) &#123;</span><br><span class="line">                return resultView;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //没有找到可以响应的子View，返回自己</span><br><span class="line">        return self;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //返回nil，告诉上一级自己无法响应此事件</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>流程图总结</p><p><img src="http://upload-images.jianshu.io/upload_images/2042621-dcfdbeeda6c9ce40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tweak心得</title>
      <link href="/2017/03/07/tweak%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2017/03/07/tweak%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="1-关于ssh"><a href="#1-关于ssh" class="headerlink" title="1 关于ssh"></a>1 关于ssh</h3><p>一般形式 ssh <a href="mailto:&#114;&#x6f;&#111;&#x74;&#64;&#49;&#x39;&#50;&#46;&#49;&#x36;&#56;&#46;&#x32;&#x2e;&#49;&#x37;">&#114;&#x6f;&#111;&#x74;&#64;&#49;&#x39;&#50;&#46;&#49;&#x36;&#56;&#46;&#x32;&#x2e;&#49;&#x37;</a>或者ssh <a href="mailto:&#109;&#111;&#x62;&#x69;&#108;&#101;&#64;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#x38;&#46;&#50;&#x2e;&#49;&#55;">&#109;&#111;&#x62;&#x69;&#108;&#101;&#64;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#x38;&#46;&#50;&#x2e;&#49;&#55;</a></p><span id="more"></span><p>root和mobile分别为iOS上默认用户，alpine是默认密码</p><p>可以通过ssh-gen 分别在Mac和iOS上生成密钥对，然后将Mac上的公钥拷贝到手机上，这样配之后，每次ssh不会再提示输入密码</p><h3 id="2-scp-source-dest"><a href="#2-scp-source-dest" class="headerlink" title="2 scp source dest"></a>2 scp source dest</h3><p>一般为</p><p>scp ~/123.txt <a href="mailto:&#x6d;&#111;&#98;&#x69;&#108;&#101;&#64;&#x31;&#x39;&#50;&#x2e;&#49;&#54;&#x38;&#x2e;&#x32;&#46;&#49;&#x37;">&#x6d;&#111;&#98;&#x69;&#108;&#101;&#64;&#x31;&#x39;&#50;&#x2e;&#49;&#54;&#x38;&#x2e;&#x32;&#46;&#49;&#x37;</a>:/usr/bin</p><h3 id="3-Makefile"><a href="#3-Makefile" class="headerlink" title="3 Makefile"></a>3 Makefile</h3><p>可以配置手机的IP，framework，arch等参数</p><p>THEOS_DEVICE_IP = 192.168.31.202<br>ARCHS = armv7 arm64<br>TARGET = iphone:latest:8.0</p><p>iOSREGreetings_FRAMEWORKS = UIKit </p><h3 id="4-关于bundleID"><a href="#4-关于bundleID" class="headerlink" title="4 关于bundleID"></a>4 关于bundleID</h3><p>.plist中的bundle就是你想hook的程序的bundleID</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tweak环境搭建</title>
      <link href="/2017/03/07/tweak%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/03/07/tweak%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="0-设置环境变量-export-THEOS-opt-theos"><a href="#0-设置环境变量-export-THEOS-opt-theos" class="headerlink" title="0 设置环境变量 export THEOS=/opt/theos"></a>0 设置环境变量 export THEOS=/opt/theos</h3><p>可以设置~/.zshrc中添加，修改后用source命令重新加载</p><span id="more"></span><h3 id="1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下"><a href="#1下载theos（-jailbreak目录下已经下载过），放在-opt-theos下" class="headerlink" title="1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下"></a>1下载theos（~/jailbreak目录下已经下载过），放在/opt/theos下</h3><h3 id="2-下载ldid，放到-opt-theos-bin下"><a href="#2-下载ldid，放到-opt-theos-bin下" class="headerlink" title="2 下载ldid，放到/opt/theos/bin下"></a>2 下载ldid，放到/opt/theos/bin下</h3><p>sudo chmod 777 /opt/theos/bin/ldid</p><h3 id="3-配置CydiaSubstrate"><a href="#3-配置CydiaSubstrate" class="headerlink" title="3 配置CydiaSubstrate"></a>3 配置CydiaSubstrate</h3><p>在Cydia中安装CydiaSbustrate，然后scp 讲iPhone上的 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 拷贝到Mac /opt/theos/lib/下，并重命名为libsubstrate.dylib</p><p>并将头文件substrate.h也scp 到/opt/theos/include下</p><p>sudo /opt/theos/bin/bootstrap.sh substrate</p><h3 id="4-将dm-pl重命名为dpkg-deb，cp到-opt-bin"><a href="#4-将dm-pl重命名为dpkg-deb，cp到-opt-bin" class="headerlink" title="4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/"></a>4 将dm.pl重命名为dpkg-deb，cp到/opt/bin/</h3><p>suodo chmod 777 /opt/bin/dpkg-deb</p><p>基本就搭建完成，可以练习创建工程</p><p>/opt/theos/bin/nic.pl</p><p>然后进行make package </p><p>make package install</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纹理贴图</title>
      <link href="/2017/01/03/OpenGL-%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/"/>
      <url>/2017/01/03/OpenGL-%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>1 VertexShader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">attribute vec2 TexCoordIn; // New</span><br><span class="line">varying vec2 TexCoordOut; // New</span><br><span class="line"></span><br><span class="line">void main(void) &#123; </span><br><span class="line">    DestinationColor = SourceColor; </span><br><span class="line">    gl_Position = Projection * Modelview * Position;</span><br><span class="line">    TexCoordOut = TexCoordIn; // New</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>2 FragmentShader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">varying lowp vec4 DestinationColor;</span><br><span class="line">varying lowp vec2 TexCoordOut; // New</span><br><span class="line">uniform sampler2D Texture; // New</span><br><span class="line"></span><br><span class="line">void main(void) &#123;</span><br><span class="line">    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 将图片资源转换成位图数据，绑定到对应纹理ID中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ (GLuint)createTextureWithImage:(UIImage *)image&#123;</span><br><span class="line">    </span><br><span class="line">    //转换为CGImage，获取图片基本参数</span><br><span class="line">    CGImageRef cgImageRef = [image CGImage];</span><br><span class="line">    GLuint width = (GLuint)CGImageGetWidth(cgImageRef);</span><br><span class="line">    GLuint height = (GLuint)CGImageGetHeight(cgImageRef);</span><br><span class="line">    CGRect rect = CGRectMake(0, 0, width, height);</span><br><span class="line">    </span><br><span class="line">    //绘制图片</span><br><span class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    void *imageData = malloc(width * height * 4);</span><br><span class="line">    CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace,kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line">    CGContextTranslateCTM(context, 0, height);</span><br><span class="line">    CGContextScaleCTM(context, 1.0f, -1.0f);</span><br><span class="line">    CGColorSpaceRelease(colorSpace);</span><br><span class="line">    CGContextClearRect(context, rect);</span><br><span class="line">    CGContextDrawImage(context, rect, cgImageRef);</span><br><span class="line">    </span><br><span class="line">    GLuint textureID;</span><br><span class="line">    glGenTextures(1, &amp;textureID);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, textureID);</span><br><span class="line">    </span><br><span class="line">    //纹理一些设置，可有可无</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    </span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);</span><br><span class="line">    </span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, 0);</span><br><span class="line">    </span><br><span class="line">    //释放内存</span><br><span class="line">    CGContextRelease(context);</span><br><span class="line">    free(imageData);</span><br><span class="line">    </span><br><span class="line">    return textureID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 绘制时使用纹理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">//载入纹理</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, _textTureId);</span><br><span class="line"></span><br><span class="line">glUniform1i(_textureSlot, 0);</span><br><span class="line"></span><br><span class="line">const GLfloat texCoords[] = &#123;</span><br><span class="line">    0, 0,//左下</span><br><span class="line">    1, 0,//右下</span><br><span class="line">    0, 1,//左上</span><br><span class="line">    1, 1,//右上</span><br><span class="line">&#125;;</span><br><span class="line">glVertexAttribPointer(_textureCoordsSlot, 2, GL_FLOAT, GL_FALSE, 0, texCoords);</span><br><span class="line">glEnableVertexAttribArray(_textureCoordsSlot);</span><br></pre></td></tr></table></figure><p>5 关于纹理坐标</p>]]></content>
      
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光照学习</title>
      <link href="/2017/01/02/OpenGL-%E5%85%89%E7%85%A7%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/01/02/OpenGL-%E5%85%89%E7%85%A7%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1 发射光（emission）：物体本身发的光，如果物体不发光，一般无此属性</p><span id="more"></span><p>2 环境光（ambient）：在环境中充分散射的光，光线在物体表面各个方向均匀泛射在openGL中，全局光强度为（0.2，0.2，0.2，1.0）</p><p>3 漫反射光（diffuse）：关于来自某个方向，但是在物体表面向各个方向反射</p><p>4 镜面高光：光线来自某一个特定的方向，然后在物体表面，以一个特定方向反射出去，在OpenGL中，镜面反射的强度，可以通过光泽度（shiness）来调节</p><h3 id="光的计算："><a href="#光的计算：" class="headerlink" title="光的计算："></a>光的计算：</h3><p>1 发射光计算：发射颜色=物体的发射材质颜色</p><p>2 环境光计算</p><p>环境颜色 = 光源的环境光颜色*物体的环境材质颜色</p><p>3 漫反射计算：</p><p>漫反射颜色=光源的漫反射光颜色 * 物体的漫反射材质颜色 * DiffuseFactor</p><p>其中DiffuseFactor = max（0，dot（N，L））</p><p>dot表示两个向量夹角的cos</p><p>4 镜面反射：</p><p>镜面反射颜色 = 光源的镜面光颜色 * 物体的镜面材质颜色 * SpecularFactor</p><p>SpecularFactor = power（max（0， dot（N，H）），shininess）</p><p>H = normalise（L+E）</p>]]></content>
      
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VBO</title>
      <link href="/2017/01/02/OpenGL-VBO/"/>
      <url>/2017/01/02/OpenGL-VBO/</url>
      
        <content type="html"><![CDATA[<h3 id="VBO的目的："><a href="#VBO的目的：" class="headerlink" title="VBO的目的："></a>VBO的目的：</h3><p>主要是为了提高效率，减少在CPU向GPU中传输数据，直接在GPU上申请内存空间</p><span id="more"></span><p>两种target分别是GL_ARRAY_BUFFER和GL_ELEMENT_ARRAY_BUFFER</p><p>分别对应顶点数据和索引</p><p>使用glVertexAttribPointer和glDrawElements的流程和以前大致保持一致，区别在于，最后一个参数不是传指针了，而是传bindBuffer的偏移量</p><h3 id="VBO使用的大概流程："><a href="#VBO使用的大概流程：" class="headerlink" title="VBO使用的大概流程："></a>VBO使用的大概流程：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//获取一个操作句柄</span><br><span class="line">glGenBuffers(1, &amp;_vertexBuffer);</span><br><span class="line">//设置缓存对象类型，数据缓存对象，还是元素缓存对象，通俗的说就是数组还是索引</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class="line">//分配内存空间</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">在绘制代码Draw时，可以使用，绘制代码与正常并无冥想差别</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class="line">glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 7*sizeof(float), 0);</span><br><span class="line">glEnableVertexAttribArray(_positionSlot);</span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _triangleIndexBuffer);</span><br><span class="line">glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_BYTE, 0);</span><br><span class="line"></span><br><span class="line">//可以在清理时，释放VBO</span><br><span class="line">glDeleteBuffers(1, &amp;_vertexBuffer);</span><br><span class="line">_vertexBuffer = 0;</span><br><span class="line"></span><br><span class="line">glDeleteBuffers(1, &amp;_triangleIndexBuffer);</span><br><span class="line">_triangleIndexBuffer = 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniform和attribute区别</title>
      <link href="/2016/12/30/OpenGL-uniform%E5%92%8Cattribute/"/>
      <url>/2016/12/30/OpenGL-uniform%E5%92%8Cattribute/</url>
      
        <content type="html"><![CDATA[<h4 id="简单对比一下"><a href="#简单对比一下" class="headerlink" title="简单对比一下"></a>简单对比一下</h4><p>attribute，可以理解为顶点的属性，表示顶点的输入数据，只在顶点着色器中使用</p><span id="more"></span><p>uniform，可以简单理解为向着色器中传递matrix等数据，这个是在着色器中是只读的，并且在两个着色器中都可以使用</p><p>使用上的区别：</p><p>1 获取指针，分别使用glGetAttribLocation和glGetUniformLocation方法</p><p>2 设置值时，分别使用glVertexAttribPointer和glUniformMatrix4fv，注意使用glVertexAttribPointer和glEnableVertexAttribArray需要配合使用，而glUniformMatrix4fv无此限制</p><p>3 使用矩阵时，一般先LoadIdentity，然后进行平移，旋转和缩放，glDrawElements与顶点着色器可以理解为一一对应，也就是说，可以设置matrix1，传入shader的modelView中，然后glDrawElements，接下来可以再设置matrix2，再传入modelView中，再进行glDrawElements</p>]]></content>
      
      
      
        <tags>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opengl iOS创建OpenGL环境绘制一个简单三角形</title>
      <link href="/2016/12/30/OpenGL-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%92%8C%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2/"/>
      <url>/2016/12/30/OpenGL-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%92%8C%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="EAGLView创建要点"><a href="#EAGLView创建要点" class="headerlink" title="EAGLView创建要点"></a>EAGLView创建要点</h3><p>1 EAGLView的layer为CAEAGLLayer，设置kEAGLDrawablePropertyRetainedBacking和kEAGLDrawablePropertyColorFormat属性</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupLayer&#123;</span><br><span class="line"></span><br><span class="line">    CAEAGLLayer* layer = (CAEAGLLayer*)self.layer;</span><br><span class="line">    </span><br><span class="line">    layer.opaque = YES;</span><br><span class="line">    </span><br><span class="line">    layer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@(NO), kEAGLDrawablePropertyRetainedBacking,</span><br><span class="line">                                kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2  创建EAGLContext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br></pre></td></tr></table></figure><p>3  加载着着色器程序，获取到着色器变量的索引，此过程，大致可分为：</p><p>a获取着色器源文件，创建shader，编译</p><p>b创建program，attachShader，link，useProgram</p><p>c从program，通过名字获取着色器中变量的索引(后续可以向着色器中传递参数)</p><p>这里有一点需要注意，此过程的前提，一定是已经设置了EAGLContext的currentContext</p><p>4 每一帧绘制流程</p><p>在外面使用CADisplayLink来控制播放帧率，每一帧的绘制流程就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawFrame&#123;</span><br><span class="line"></span><br><span class="line">    [_eaglView setFramebuffer];</span><br><span class="line">    </span><br><span class="line">    [_eaglView draw];</span><br><span class="line">    </span><br><span class="line">    [_eaglView presentFramebuffer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5 关于frameBuffetObject的创建和释放</p><p>前提：context确保设置</p><p>流程大致是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (void)createBuffer&#123;</span><br><span class="line">    </span><br><span class="line">    [self checkContext];</span><br><span class="line">    </span><br><span class="line">    glGenRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class="line">    </span><br><span class="line">    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class="line">    </span><br><span class="line">    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];</span><br><span class="line">    </span><br><span class="line">    glGenFramebuffers(1, &amp;_frameBuffer);</span><br><span class="line">    </span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class="line">    </span><br><span class="line">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</span><br><span class="line">    GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)deleteBuffer&#123;</span><br><span class="line"></span><br><span class="line">    [self checkContext];</span><br><span class="line">    </span><br><span class="line">    glDeleteRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class="line">    </span><br><span class="line">    _colorRenderBuffer = 0;</span><br><span class="line">    </span><br><span class="line">    glDeleteFramebuffers(1, &amp;_frameBuffer);</span><br><span class="line">    </span><br><span class="line">    _frameBuffer = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFramebuffer</span><br><span class="line">&#123;</span><br><span class="line">    if ([self checkContext])</span><br><span class="line">    &#123;</span><br><span class="line">        if (!_frameBuffer)&#123;</span><br><span class="line">            [self createBuffer];</span><br><span class="line">        &#125;</span><br><span class="line">        glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)presentFramebuffer</span><br><span class="line">&#123;</span><br><span class="line">    BOOL success = FALSE;</span><br><span class="line">    </span><br><span class="line">    if ([self checkContext])</span><br><span class="line">    &#123;</span><br><span class="line">        glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class="line">        </span><br><span class="line">        success = [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class="line">    &#125;</span><br><span class="line">    return success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6 关于绘制三角形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)draw&#123;</span><br><span class="line">    //设置背景颜色为绿色</span><br><span class="line">    glClearColor(0, 1.0, 0,1.0);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    //设置管区域大小</span><br><span class="line">    glViewport(0, 0, self.frame.size.width, self.frame.size.height);</span><br><span class="line">    </span><br><span class="line">    GLfloat vertices[] = &#123;</span><br><span class="line">        0.0f,  0.5f, 0.0f,</span><br><span class="line">        -0.5f, -0.5f, 0.0f,</span><br><span class="line">        0.5f,  -0.5f, 0.0f &#125;;</span><br><span class="line">    //设置着色器中的vPositon</span><br><span class="line">    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, 0, vertices);</span><br><span class="line">    //使上一步的设置生效</span><br><span class="line">    glEnableVertexAttribArray(_positionSlot);</span><br><span class="line">    //绘制三角形</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> openGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CALayer opaque</title>
      <link href="/2016/12/30/CALayer-opaque/"/>
      <url>/2016/12/30/CALayer-opaque/</url>
      
        <content type="html"><![CDATA[<h3 id="颜色合成公式"><a href="#颜色合成公式" class="headerlink" title="颜色合成公式"></a>颜色合成公式</h3><p><strong>R = S + D * ( 1 – Sa )</strong></p><p> <img src="/Users/baidu/Downloads/20130819170332968.png" alt="20130819170332968"></p><p>其中，R表示混合结果的颜色，S是源颜色(位于上层的红色图层一)，D是目标颜色(位于下层的绿色图层二)，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。</p><p>设置opaque相当于是设置了Sa=1，此时R = S，省去了GPU的计算</p><p>注意：设置opaque为YES时，要确保alpha为1.0f，否则结果不可预期</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CALayer属性positon和anchor</title>
      <link href="/2016/10/26/CALayer%E5%B1%9E%E6%80%A7positon%E5%92%8Canchor/"/>
      <url>/2016/10/26/CALayer%E5%B1%9E%E6%80%A7positon%E5%92%8Canchor/</url>
      
        <content type="html"><![CDATA[<h3 id="CALayer-的frame，bounds-position和anchor"><a href="#CALayer-的frame，bounds-position和anchor" class="headerlink" title="CALayer 的frame，bounds, position和anchor"></a>CALayer 的frame，bounds, position和anchor</h3><span id="more"></span><p>frame描述的是在父layer上的坐标和尺寸</p><p>bounds是类似于View的bounds</p><p>anchor描述的是做动画时，比如旋转时的中心点，以某个点旋转，默认时（0.5，0.5）左上点是（0，0），右下点是（1，1）</p><p>position描述的是anchor的在父layer的坐标</p><p>举例来说，一个View的Frame是（40，40，100，100）</p><p>那么layer的frame是（40，40，100，100）</p><p>bound是（0，0，100，100）</p><p>position是：（140，140）</p><p>position计算：</p><p>pos.x = origin.x + anchor.x*size.with</p><p>pos.y = origin.y + anchor.y*size.height</p><p>如果想修改anchor,一定要同时修改position，才能保证位置不变，否则，单独修改position或者anchor，根据上面公式会导致layer位置发生变化</p><p>如果想修改anchor，而不影响layer移动，只需修改完成后，再设置一次layer的frame即可</p><pre><code>CGRect oldFrame = _redView.frame;_redView.layer.anchorPoint = CGPointMake(0.5, 1);_redView.frame = oldFrame;</code></pre><p>注意，position并不适用这一点</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么build apple watch app</title>
      <link href="/2016/10/26/How%20to%20build%20Apple%20Watch%20App/"/>
      <url>/2016/10/26/How%20to%20build%20Apple%20Watch%20App/</url>
      
        <content type="html"><![CDATA[<h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>在IphoneCom 的Embedded Binaries中添加Watch.app</p><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>Run IphoneCom</p><h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h3><p>run WachApp</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
