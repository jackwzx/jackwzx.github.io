---
title: Depth24Stencil8介绍
date: 2025-12-10 12:49:16
published: true
tags:
---

直接回答你的问题：**不是浮点型**。

`Depth24Stencil8` (通常在 OpenGL 中对应 `GL_DEPTH24_STENCIL8`，在 DirectX/Vulkan 中对应 `D24_UNORM_S8_UINT`) 中的 **Depth24** 部分，存储的是 **无符号归一化整型 (Unsigned Normalized Integer, UNORM)**。

以下是关于其存储机制、精度和与浮点型区别的详细说明：

### 1. 存储机制 (UNORM)

*   **数据类型**：24位无符号整数 (24-bit Unsigned Integer)。
*   **数值范围**：整数范围是 $[0, 2^{24} - 1]$，即 $[0, 16,777,215]$。
*   **映射关系**：
    硬件会将这个整数线性映射到逻辑上的 $[0.0, 1.0]$ 浮点范围。
    *   整数 `0` $\rightarrow$ 逻辑深度 `0.0` (通常是 Near Plane)
    *   整数 `16,777,215` (`0xFFFFFF`) $\rightarrow$ 逻辑深度 `1.0` (通常是 Far Plane)

### 2. 精度分析

*   **线性分布**：由于它是定点整数，它在 $[0, 1]$ 范围内的精度分布是**均匀**的。
*   **精度值**：最小可分辨的深度差（Precision）为 $\frac{1}{2^{24} - 1} \approx 0.00000006$。
*   **非线性投影的问题**：
    虽然存储格式是均匀分布的，但经过透视投影（Perspective Projection）后的 $Z$ 值（$1/Z$ 关系）是非线性的。这导致在近处（Near）深度值变化剧烈，占用大量整数范围；而在远处（Far）深度值变化微小，大量物体挤在同一个整数数值上，容易产生 **Z-Fighting（深度冲突）**。

### 3. 为什么不是浮点型？

如果你想要浮点型的深度缓冲，你需要使用 **`Depth32F`** (或 `D32F_S8`) 格式。

*   **Depth24 (Integer)**: 就像把一把尺子刻度均匀分成 1600 万份。
*   **Depth32F (Float)**: 使用 IEEE 754 标准。它的精度分布是**非均匀**的（靠近 0 的地方精度极高，靠近 1 的地方精度较低）。
    *   *有趣的事实*：32位浮点数 (`float`) 的尾数（Mantissa）部分是 **23位**。这意味着在 $[0.5, 1.0]$ 区间内，`Depth32F` 的有效精度其实略低于 `Depth24`。
    *   但在 **Reverse-Z (反向Z缓冲)** 技术中，`Depth32F` 是绝配。因为浮点数的精度分布特性（靠近0精度高）正好完美抵消了透视投影的非线性特性（远处Z值分布密），从而实现近乎完美的深度精度。

### 4. 总结与建议

| 格式 | Depth24Stencil8 | Depth32F_Stencil8 |
| :--- | :--- | :--- |
| **深度存储类型** | **定点整数 (UNORM)** | **浮点数 (Float)** |
| **位宽** | 24 bits | 32 bits |
| **模版 (Stencil)** | 8 bits | 8 bits |
| **主要用途** | 传统渲染，兼容性好，带宽较低 | 高精度渲染，**Reverse-Z** 必备 |
| **带宽占用** | 32 bits/pixel (紧凑打包) | 64 bits/pixel (通常分开或补齐) |

**结论：**
如果你的 framebuffer 格式是 `D24S8`，那么显卡里存的就是一个**整数**。如果你需要浮点深度带来的精度优势（特别是做大场景或 Reverse-Z），请切换到 `D32F` 格式。
