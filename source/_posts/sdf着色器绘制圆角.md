---
title: sdf着色器绘制圆角
date: 2025-12-01 21:06:48
published: false
tags:
---

```
vec4 mask = vec4(step(sx, 0.0) * step(0.0, sy),     // LT
                 step(0.0, sx) * step(0.0, sy),     // RT
                 step(sx, 0.0) * step(sy, 0.0),     // LB
                 step(0.0, sx) * step(sy, 0.0));    // RB

float curR = dot(radii, mask);  // true radius
vec2 ap = abs(relativeP);
vec2 q  = ap - halfSize + vec2(curR);

// round rect由内到外的"连续距离场"，没有inside会导致边界+内部返回sdf(0)-->alpha(0.5);
float outside = length(max(q, 0.0));
float inside  = min(max(q.x, q.y), 0.0);
return outside + inside - curR;
```

这段代码是一段 **GLSL 片段着色器（Fragment Shader）** 的核心逻辑，用于绘制一个**支持四个角不同半径的圆角矩形**。

它采用了 **SDF（Signed Distance Field，有符号距离场）** 技术，而不是传统的纹理贴图或网格构建。这种方法的优点是能够无限放大而不失真，并且自带平滑的抗锯齿效果。

以下是对这段代码的详细逻辑分析：

### 1. 核心变量定义

*   **`uniform vec2 halfSize`**: 矩形半尺寸（宽的一半，高的一半）。这是 SDF 计算中常用的基准，因为基于中心对称的计算通常使用半长。
*   **`uniform vec4 radii`**: 四个角的圆角半径，分别对应 左上(LT)、右上(RT)、左下(LB)、右下(RB)。
*   **`in vec2 P_f`**: 当前像素点在局部坐标系中的位置。

---

### 2. 函数 `SDF_RoundRect4` 解析（核心算法）

这个函数计算当前像素点 `pos` 到圆角矩形边缘的**有符号距离**。
*   **负值**：在矩形内部。
*   **零**：在矩形边缘。
*   **正值**：在矩形外部。

#### A. 象限判断与半径选择
```glsl
vec2 relativeP = pos - halfSize; // 将坐标原点尝试偏移（作者意图可能是为了确定相对方位）
float sx = sign(relativeP.x);
float sy = sign(relativeP.y);

vec4 mask = vec4(step(sx, 0.0) * step(0.0, sy), ... ); // 生成掩码
float curR = dot(radii, mask);  // 获取当前角的半径
```
*   **逻辑**：代码试图通过 `sign`（符号函数）和 `step`（阶跃函数）来判断当前像素位于矩形的哪个象限（左上、右上、左下、右下）。
*   **目的**：避免使用效率较低的 `if-else` 分支语句。通过构建一个 `mask`（例如 `vec4(0, 1, 0, 0)`），利用点积 `dot` 一次性选出当前象限对应的圆角半径 `curR`。

#### B. 坐标折叠与对称计算
```glsl
vec2 ap = abs(relativeP);
vec2 q  = ap - halfSize + vec2(curR);
```
*   **逻辑**：利用矩形的对称性，将所有计算折叠到第一象限处理（`abs`）。
*   **几何含义**：
    *   `q` 代表了相对于“内缩矩形”（原矩形宽高各减去圆角半径）的距离向量。
    *   这是标准 SDF 圆角矩形公式的变形，意在将圆角问题转化为“点到直角矩形的距离减去半径”。

#### C. 距离场合成（Inside + Outside）
```glsl
float outside = length(max(q, 0.0));
float inside  = min(max(q.x, q.y), 0.0);
return outside + inside - curR;
```
这是 SDF 算法中最精彩的部分，作者注释提到“由内到外的连续距离场”：

1.  **`outside` (外部距离)**：
    *   `max(q, 0.0)`：如果点在内缩矩形范围内，分量归零；如果在外部，保留正值。
    *   `length(...)`：计算到内缩矩形拐角的欧几里得距离。
    *   这处理了圆角区域的圆弧形状和直线边缘的外部区域。

2.  **`inside` (内部距离)**：
    *   `min(max(q.x, q.y), 0.0)`：这是一个巧妙的计算，用于获取点在矩形内部时，距离最近边缘的负距离。如果不加这一行，SDF 在矩形内部会由于 `length` 的性质变成 0 或正值，导致无法填充颜色。

3.  **`- curR` (半径修正)**：
    *   前面计算的是到“尖角”内缩矩形的距离，最后减去半径 `curR`，将距离场向外扩张，从而形成圆角。

---

### 3. 函数 `get_roundrect_alpha` 解析（抗锯齿）

```glsl
float get_roundrect_alpha(vec2 pos)
{
    float d = SDF_RoundRect4(pos);
    // d <= -0.5  → alpha = 1
    return clamp(0.5 - d, 0.0, 1.0);
}
```
*   **目的**：将距离值 `d` 转换为透明度（Alpha），实现边缘的平滑过渡（AA，Anti-Aliasing）。
*   **原理**：
    *   我们希望边缘在 `d = 0` 处。
    *   为了抗锯齿，通常在 `[-0.5, 0.5]` 的像素距离范围内进行插值。
    *   当 `d = -0.5` (内部 0.5 像素)，`0.5 - (-0.5) = 1.0`（完全不透明）。
    *   当 `d = 0.5` (外部 0.5 像素)，`0.5 - 0.5 = 0.0`（完全透明）。
    *   `clamp` 限制结果在 0 到 1 之间，去除了距离场远处的数值。

---

### 4. `main` 函数解析（输出）

```glsl
void main()
{
    // 计算形状 alpha，并乘以全局淡入淡出系数 fadingAlpha
    float alpha = get_roundrect_alpha(P_f) * fadingAlpha;
    
    // 获取源颜色并应用 alpha
    fragColor = fetch_color() * alpha;
}
```
*   **组合**：将计算出的几何形状 Alpha 与纹理/纯色（`fetch_color`）结合。
*   **预乘 Alpha**：`fetch_color() * alpha` 这种写法暗示可能是标准混合模式，或者是为了输出预乘 Alpha 格式的颜色。

### 总结

这段代码通过 **数学建模** 定义了几何形状，而不是通过绘图指令。
1.  **无分支优化**：使用 `step` 和 `dot` 替代 `if` 选择半径，对 GPU 友好。
2.  **完美的圆角**：基于距离场计算，理论上圆角非常平滑。
3.  **正确的内部填充**：显式计算 `inside` 距离，确保矩形内部也是实心的（alpha=1），而不仅仅是画一个框。

**代码的设计意图**是创建一个通用的、高性能的 UI 圆角矩形渲染器，能够处理四个角半径不一致的情况（例如聊天气泡、部分圆角的卡片）。




这几行代码确实是 SDF（有符号距离场）中最抽象、最“数学味”的部分。不看图或者不代入数据，光看符号很容易晕。

我们用**“坐标系变换”**和**“三个具体点”**来把这几行代码拆解开。

### 1. 场景设定（我们就在这个设定下算）

假设我们要画一个这样的圆角矩形：
*   **矩形半大小 (`halfSize`)**: `(100, 50)` —— 也就是宽200，高100。
*   **圆角半径 (`curR`)**: `10`。

关键代码公式：
`vec2 q = ap - halfSize + vec2(curR);`

这个公式的几何含义是：**把坐标原点移动到了“圆角圆心的位置”**。
*   原本边缘在 `100`。
*   圆角圆心在 `100 - 10 = 90`。
*   `q` 算的是：**当前点相对于（圆角圆心）的偏移量**。

我们选三个点来代入计算，看看 `q`、`outside`、`inside` 分别发生了什么。

---

### 情况 A：在矩形外部，对着圆角（斜向外）
**点位置 (`ap`)**: `(105, 55)`
*   直觉：这个点在右上角圆角的斜上方，离圆心有一定距离。

**第一步：算 q**
$$q = (105, 55) - (100, 50) + (10, 10)$$
$$q = (5, 5) + (10, 10)$$
$$q = (15, 15)$$
> **解读**：相对于圆角圆心（90, 40），这个点在右边 15，上边 15 的位置。

**第二步：算 outside (外部距离)**
`outside = length(max(q, 0.0))`
*   `max((15, 15), 0.0)` 还是 `(15, 15)`（因为都在正方向）。
*   `length(15, 15)` ≈ **21.21**。
> **解读**：这是点到圆心的直线距离。

**第三步：算 inside (内部距离)**
`inside = min(max(q.x, q.y), 0.0)`
*   `max(15, 15)` 是 15。
*   `min(15, 0.0)` 是 **0**。
> **解读**：因为点在外面，所以内部“负距离”贡献为 0。

**第四步：最终结果**
`result = outside + inside - curR`
$$result = 21.21 + 0 - 10 = 11.21$$
> **结论**：距离表面 11.21 像素。这是**正数**，说明在矩形**外**，完全正确。

---

### 情况 B：在矩形内部（很靠里）
**点位置 (`ap`)**: `(50, 20)`
*   直觉：这个点完全在矩形肚子里。

**第一步：算 q**
$$q = (50, 20) - (100, 50) + (10, 10)$$
$$q = (-50, -30) + (10, 10)$$
$$q = (-40, -20)$$
> **解读**：相对于圆角圆心（90, 40），这个点在左边 40，下边 20 的位置。注意全是**负数**。

**第二步：算 outside (外部距离)**
`outside = length(max(q, 0.0))`
*   `max((-40, -20), 0.0)` 变成了 `(0, 0)`。
*   `length(0, 0)` = **0**。
> **解读**：因为点在圆心构成的内盒子里，所以它对“外部距离”没有贡献。

**第三步：算 inside (内部距离)**
`inside = min(max(q.x, q.y), 0.0)`
*   `max(-40, -20)` 是 -20（选那个离 0 最近的，也就是离边缘最近的）。
*   `min(-20, 0.0)` 是 **-20**。
> **解读**：这里算出了点距离最近的“内盒边缘”的距离。

**第四步：最终结果**
`result = outside + inside - curR`
$$result = 0 + (-20) - 10 = -30$$
> **结论**：距离表面 -30 像素。这是**负数**，说明在**内部**。
> 为什么是 -30？
> *   点 y=20。
> *   矩形上边缘 y=50。
> *   距离边缘 30。结果正确！

---

### 情况 C：在矩形右侧外部，但对着直边（不是圆角）
**点位置 (`ap`)**: `(105, 20)`
*   直觉：在右边框外面一点点，应该只算 x 轴距离。

**第一步：算 q**
$$q = (105, 20) - (100, 50) + (10, 10)$$
$$q = (5, -30) + (10, 10)$$
$$q = (15, -20)$$
> **解读**：x 轴在圆心右边 15，y 轴在圆心下边 20。**一正一负**。

**第二步：算 outside (外部距离)**
`outside = length(max(q, 0.0))`
*   `max((15, -20), 0.0)` 变成了 `(15, 0)`（负数被抹平了）。
*   `length(15, 0)` = **15**。
> **解读**：只计算向外突出的分量长度。

**第三步：算 inside (内部距离)**
`inside = min(max(q.x, q.y), 0.0)`
*   `max(15, -20)` 是 15。
*   `min(15, 0.0)` 是 **0**。
> **解读**：因为有一个分量突出来了（正数），所以它不算在“内部”。

**第四步：最终结果**
`result = outside + inside - curR`
$$result = 15 + 0 - 10 = 5$$
> **结论**：距离表面 5 像素。
> *   点 x=105。
> *   矩形右边缘 x=100。
> *   距离确实是 5。正确！

---

### 总结：为什么要搞这么复杂？

这几行代码其实把空间切成了**三个逻辑区域**，用一套公式统一处理：

1.  **两轴都为正 (q > 0)**：**圆角区域**。
    *   `outside` 生效（算勾股定理）。
    *   `inside` 失效。
    *   结果：`距离圆心的距离 - 半径`。
2.  **两轴都为负 (q < 0)**：**矩形内部**。
    *   `outside` 失效。
    *   `inside` 生效（找最近的边）。
    *   结果：`内部负距离 - 半径`。
3.  **一正一负**：**直边外侧**。
    *   `outside` 生效（但只算正的那一轴，相当于直线距离）。
    *   `inside` 失效。
    *   结果：`直线距离 - 半径`。

**最核心的魔法在于 `- curR`：**
它把前面计算出的“到内缩盒子的距离”，统一向外推了一个半径。
*   对于圆角，它是把点（圆心）推成了一个圆。
*   对于直边，它是把线段推成了一个长方形。

如果没有 `inside` 那一行，你会发现**情况 B**（内部点）的结果会变成 `-10`（因为 `outside` 是0，`inside` 缺失，只剩 `-curR`）。这意味着矩形内部所有点的距离都是 -10，导致整个内部 alpha 值一样，无法正确表达“越靠近中心越实心”或者做描边效果。