---
title: 偏轴投影
date: 2025-12-14 15:06:02
published: false
tags:
---

这是一个非常专业且有趣的问题。在计算机图形学中，标准的投影矩阵通常是**视锥体对称（Symmetric Frustum）**的，即视野中心正对着屏幕中心。

如果你修改投影矩阵，使得视线中心（Eye看向的Center）不显示在屏幕正中心，而是偏上（例如高度 0.75 的位置），这被称为**非对称投影（Asymmetric Projection）**或**偏轴投影（Off-axis Projection）**。

在摄影领域，这对应着**移轴镜头（Tilt-Shift Lens）**中的“Shift”功能。

以下是关于如何实现、效果对比以及会遇到的潜在问题的详细分析。

---

### 1. 原理：如何通过投影矩阵实现？

标准的透视投影矩阵（如 `gluPerspective` 生成的）假定 $Top = -Bottom$ 且 $Right = -Left$。
要实现非对称投影，你需要使用通用的视锥体构建函数（如 `glFrustum`），手动设置 `Left, Right, Bottom, Top`。

标准的透视投影矩阵第三列是：
$$
\begin{bmatrix}
... & 0 & \frac{r+l}{r-l} & 0 \\
... & \frac{2n}{t-b} & \frac{t+b}{t-b} & 0 \\
... & ... & ... & ... \\
... & ... & -1 & 0
\end{bmatrix}
$$

*   **对称时**：$t = -b$，所以 $\frac{t+b}{t-b} = 0$。物体(0,0,z) 投影到屏幕中心 (0,0)。
*   **非对称时**：如果你想让中心点出现在屏幕上方（比如 NDC 坐标 $y=0.5$），你需要调整 $t$ 和 $b$ 的值，使得 $\frac{t+b}{t-b}$ 等于你想要的偏移量。

**简单来说：** 如果你想把中心物体移到屏幕上方，你需要把视锥体的“底边 ($b$)”设得更长，“顶边 ($t$)”设得更短（绝对值），相当于把视口向下“拉长”了，或者说相机像窗户一样向上“平移”了。

---

### 2. 这样做会有哪些问题和现象？

虽然技术上完全可行（VR渲染和拼接屏经常这么用），但通过修改投影矩阵（移轴）和通过旋转相机（Pitch）来实现这一目标，效果截然不同，会带来以下问题：

#### A. 视觉效果差异（最重要）

*   **垂直线条保持平行（无透视收敛）：**
    *   **旋转相机 (Look Up)：** 如果你抬头看高处，建筑物会产生“三点透视”，垂直线条会向头顶汇聚（变窄）。
    *   **修改投影矩阵 (Shift)：** 此时相机的朝向（View Matrix）其实是水平的，你只是裁切了视野。**垂直于地面的线条在屏幕上依然是垂直的**，不会汇聚。
    *   **结果：** 这在建筑可视化中是优点（看起来很正），但在第一人称游戏或模拟中，如果偏移量过大，画面边缘会显得被剧烈“拉伸”或“剪切”（Shearing），给人一种不自然的拉扯感。

#### B. 光照与反射异常

*   **镜面高光（Specular）：** 光照计算通常依赖于 `ViewDir`（视线方向）。在非对称投影中，屏幕中心的像素对应的视线方向不再是相机的正前方（Forward Vector），而是斜着的。虽然数学上是正确的，但如果Shader中有些简化算法假设“屏幕中心就是相机朝向”，高光位置就会偏。
*   **屏幕空间反射（SSR）：** 许多SSR算法假设投影是中心对称的，偏轴投影可能导致反射采样位置偏移，需要修改算法以考虑 Principal Point Offset（主点偏移）。

#### C. 后处理特效（Post-Processing）失效

很多屏幕后处理特效默认屏幕中心是 $(0.5, 0.5)$ UV坐标。
*   **径向模糊（Radial Blur）/ 晕影（Vignette）：** 默认会以屏幕物理中心为圆心。但你的“视觉中心”已经移到了屏幕上方。结果就是晕影还是围着屏幕中心黑，而不是围着你的主角黑，看起来非常奇怪。
*   **解决方法：** 你必须重写Shader，将特效的中心点参数暴露出来，并设置为你的偏移值。

#### D. 剔除（Culling）与包围盒

*   **视锥体剔除（Frustum Culling）：** 大多数游戏引擎的剔除算法构建视锥体时，能够处理非对称矩阵。但如果你使用了简化的“圆锥体剔除”或者假设视场角是上下对称的算法，就会导致物体过早消失或该消失的没消失。

#### E. 交互与射线检测（Raycasting）

*   **鼠标拾取：** 也就是从屏幕点击位置发射射线。
    *   通常公式是：`Screen -> NDC -> View -> World`。
    *   只要你正确使用了逆矩阵（Inverse Projection Matrix）进行计算，结果是对的。
    *   但如果你手动计算射线（例如 `RayDir = normalize(Forward + Right*x + Up*y)`），这种简单的假设公式会**彻底失效**，必须考虑矩阵中的偏移项 $(C_x, C_y)$。

#### F. 分辨率分布不均

*   如果你将中心移到屏幕高度 0.75，意味着屏幕下半部分展示了原本视野下半部分的内容，加上原本被裁掉的一大块地面。
*   这会导致屏幕下方对纹理采样的密度发生变化，可能在某些角度下加剧锯齿或纹理模糊。

---

### 3. 总结与建议

**场景分析：**
如果你现在的需求是：**“玩家虽然看着前方，但UI面板挡住了下面一半，所以我想让玩家关注的视界中心上移”**。

*   **方案一：修改投影矩阵（移轴）**
    *   **优点**：垂直线条不歪，相机实际上没转头，适合UI布局调整或建筑展示。
    *   **缺点**：边缘拉伸感重，后处理需要改，射线计算要小心。
    *   **适用**：策略游戏、建筑漫游、VR（必定是非对称）、偏轴的显示器配置。

*   **方案二：旋转相机（LookAt 调整）**
    *   **做法**：让相机真的往上看一点（Pitch 增加）。
    *   **优点**：符合人类颈部运动直觉，透视自然，所有标准算法兼容。
    *   **缺点**：垂直线条会歪（产生三点透视）。
    *   **适用**：FPS、TPS、动作游戏。

**结论：**
如果只是为了简单的“中心上移”，通常**推荐方案二（旋转相机）**，除非你非常在意“垂直线条必须垂直”这种建筑摄影美学，或者你在做特殊的显示设备适配，否则非对称投影带来的Shader和交互维护成本通常高于收益。
