---
title: 地图float误差分析
date: 2025-1-02 14:00:00
published: false
tags: 
  - 线性代数
  - 3D图形学
  - 计算机图形学
  - 数学
  - OpenGL
categories: 
  - 计算机图形学
  - 数学基础
---



          
**问题概述**
- 使用墨卡托（Web Mercator，EPSG:3857）坐标时，世界坐标量级很大（±2.0037e7 米）。在着色器里即便使用 `highp float`，当把大坐标直接参与变换或叠加上比例尺 `scale = 2^level` 后，浮点的有效位不足会导致明显的量化误差与抖动。
- 你给出的 `LevelToScale(level) = 2^level` 随比例尺线性增大屏幕空间量级，放大了浮点误差的可见影响。

**精度与误差模型**
- `float` 的相对精度由尾数位数决定：
  - `fp16`（很多移动 GPU 的 fragment highp 实际为 16 位）：尾数约 10 位，有效相对精度 ≈ `2^-10 ≈ 9.77e-4`。
  - `fp32`（典型 vertex highp）：尾数 23 位，有效相对精度 ≈ `2^-23 ≈ 1.19e-7`。
- 浮点误差在“大数+小数”的混合运算中最致命。用“世界级大坐标（米/世界像素）+ 局部小偏移（像素/米）”时，小偏移会被吞没或量化成大步长。

**不同比例尺下的最低精度问题（两种角度）**
- 用“世界像素坐标”做运算（`world_pixels = 256 * 2^level`），以像素误差衡量：
  - `fp16` 像素 ULP ≈ `world_pixels * 2^-10 = 256 * 2^level / 1024 = 0.25 * 2^level` 像素。
    - 要 ≤ 0.5 像素，需 `0.25 * 2^level ≤ 0.5` → `level ≤ 1`。超过 1 级就会出现明显抖动。
  - `fp32` 像素 ULP ≈ `world_pixels * 2^-23 = 256 * 2^level / 8388608 ≈ 3.05e-5 * 2^level` 像素。
    - `level = 22` 时 ≈ `3.05e-5 * 4,194,304 ≈ 128` 像素，仍远超阈值。
- 用“世界米坐标”做运算（墨卡托范围约 `|x| ≤ 2e7 m`），以屏幕像素误差衡量：
  - `fp16` 绝对 ULP ≈ `|x| * 2^-10 ≈ 2e7 * 9.77e-4 ≈ 2e4 m`。在赤道处 `level=22` 的分辨率 ≈ `0.037 m/px`，像素误差 ≈ `2e4 / 0.037 ≈ 5.4e5 px`。
  - `fp32` 绝对 ULP ≈ `|x| * 2^-23 ≈ 2e7 * 1.19e-7 ≈ 2.38 m`，对应像素误差 ≈ `2.38 / 0.037 ≈ 64 px`。
- 结论：无论 `fp16` 还是 `fp32`，只要直接在着色器里使用“世界级大坐标 × 大比例尺”，在中高缩放级别都会明显失真。必须降低参与运算的数值量级。

**核心思路：把“大数”变“小数”再运算**
- 原点重定位（rebase to local/tile space）
  - 顶点坐标以瓦片/局部空间（如 `0..256`）传入着色器，避免大数参与。
  - 相机中心（地图中心）在 CPU 侧参与，着色器只处理“顶点相对中心的小偏移”。
- 双浮编码（double → high/low float 传递）
  - 把 `double` 分解成两个 `float`（高/低）分别传给着色器，在 shader 中用 Kahan-like 合并，显著提升有效位数。
  - 对中心/偏移/矩阵的关键项使用高低拆分，避免直接用单个大 `float`。
- 两阶段变换
  - 先在 CPU 做“大数部分”的变换（例如把世界中心平移到零点），shader 只做局部缩放旋转。
- 分级坐标设计
  - 把 `scale = 2^level` 只用于把局部坐标（如瓦片内像素）映射到屏幕，不要乘在世界米坐标上。

**示例实现要点**
- CPU：保持大数用 `double`，把中心/矩阵项拆分传给 GPU
  - `LevelToScale(level)` 用 `double` 没问题，但传给 shader 时用分解或缩放后的局部值。
- 顶点着色器（示意）使用局部坐标与双浮中心：
  ```glsl
  // uniforms：中心点高/低（世界像素或世界米，选一种且保持一致）
  uniform highp vec2 u_center_high;
  uniform highp vec2 u_center_low;
  uniform mediump float u_scale;   // 局部缩放（如 tile 内）

  in mediump vec2 a_localPos;      // 局部顶点（如 0..256 内）
  // 局部位置与中心结合，避免直接操作世界级大数
  highp vec2 localToWorld(highp vec2 centerH, highp vec2 centerL, mediump vec2 local) {
      // 先用高位，再加低位，减少量化误差
      return (centerH - floor(centerH)) // 若需要，可做进一步 rebase
           + centerL
           + vec2(local);
  }

  void main() {
      highp vec2 worldPos = localToWorld(u_center_high, u_center_low, a_localPos);
      // 屏幕变换只对小数（局部）应用 u_scale
      // 通常还会乘以 MVP，这里省略
      gl_Position = ...; // 组合 worldPos 与投影/视图矩阵（建议矩阵也拆分）
  }
  ```
- 双浮拆分（CPU 侧示意）
  ```cpp
  inline void splitDouble(double v, float& hi, float& lo) {
      // 经典拆分法，提高精度（常用常数 2^12+1 或 2^13+1）
      const double c = (1 << 12) + 1;
      double t = c * v;
      double hi_d = t - (t - v);
      hi = static_cast<float>(hi_d);
      lo = static_cast<float>(v - hi_d);
  }
  ```

**实践建议**
- 顶点管线用 `highp`，片元尽量用 `mediump`/`lowp`（颜色、UV 等），把精度放在真正需要的位置。
- 所有参与大坐标或大比例尺的 uniform（如中心、矩阵）都用“重定位 + 拆分”的策略，避免直接把大数塞给 shader。
- 传入的坐标统一选择一种空间（世界米或世界像素）且在 CPU/Shader 的每一步都保持一致的单位，避免混用导致误差难以追踪。
- 对 keypath（如大比例尺级别 ≥ 18）做专门的路径：强制局部坐标（tile space）＋中心平移，禁绝世界坐标参与。

**与 `LevelToScale` 的关系**
- `LevelToScale(level) = 2^level` 在 CPU 侧作为逻辑比例尺非常合理。
- 不要把这个 `scale` 直接乘在世界级大坐标上再丢进 shader；应先把坐标重定位为局部小值（或拆分高低位），在 shader 中只对小值应用缩放。
- 若必须在 shader 使用 `scale`，请确保它只作用于局部坐标（量级 ≤ 数百），这样即使在 `fp16` 下，误差也维持在 ≤ 0.25 像素量级，不会可见。

如果你愿意，我可以根据你现有渲染路径，给出“中心平移＋双浮拆分”的具体代码改造点，把误差在高比例尺下压到不可见水平。
        




          
**结论公式**
- 定义
  - `z`：地图缩放级别（瓦片 256px，世界像素宽度 `W = 256 * 2^z`）
  - `m`：浮点尾数位数（`float32` 为 23，`float16` 为 10）
  - 误差阈值：以屏幕空间 ≤ 0.5 像素为“可接受”
- 像素误差（直接在着色器用世界像素坐标时的最小步长）
  - `ε_px(z; m) = 256 * 2^z / 2^m = 2^(z - (m - 8))`
  - 达到 ≤ 0.5 像素的最大可用级别：`z_max = m - 9`
    - `float32`：`z_max = 14`
    - `float16`：`z_max = 1`
- 米误差（墨卡托赤道处，米/像素 `mpp(z) = 156543.03392 / 2^z`）
  - `ε_m(z; m) = ε_px(z; m) * mpp(z) = 156543.03392 * 2^(8 - m)`（与级别 `z` 无关）
    - `float32`：`ε_m ≈ 156543.03392 / 32768 ≈ 4.777 m`
    - `float16`：`ε_m ≈ 156543.03392 / 4 ≈ 39135.758 m ≈ 39.136 km`
  - 非赤道处乘以 `cos(纬度)`：`ε_m(z; m, φ) = 156543.03392 * cos(φ) * 2^(8 - m)`

**关键数值表（z=18/19/20）**
- 直接在着色器中使用“世界像素坐标”的量化误差（不做重定位/拆分）
- 米误差为赤道处，其他纬度乘 `cos(φ)`

| 级别 z | 世界像素宽度 W = 256·2^z | float32 像素误差 ε_px | float32 米误差 ε_m | float16 像素误差 ε_px | float16 米误差 ε_m |
|--------|---------------------------|------------------------|--------------------|----------------------|--------------------|
| 18     | 67,108,864                | 8 px                   | ≈ 4.777 m          | 65,536 px            | ≈ 39.136 km        |
| 19     | 134,217,728               | 16 px                  | ≈ 4.777 m          | 131,072 px           | ≈ 39.136 km        |
| 20     | 268,435,456               | 32 px                  | ≈ 4.777 m          | 262,144 px           | ≈ 39.136 km        |

**解读与建议**
- 直接把“大数”的世界像素坐标传入 shader，会导致：
  - `float32` 在高倍率下像素量化显著（z=20 时 32px），米误差常数约 4.78m（赤道）。
  - `float16` 完全不可用（动辄数万像素、几十公里的误差）。
- 若目标是高等级下亚像素/米级精度，必须降低参与运算的数值量级：
  - 在 CPU 做“中心重定位”，shader 只处理局部坐标（如 tile 内 `0..256`）。
  - 对大数 uniform（中心、矩阵项）用“双浮拆分”（double→高/低两个 float）并在 shader 合并。
  - 让 `scale = 2^z` 仅作用于局部小坐标，不要与世界级大坐标相乘后再进 shader。

如果你需要，我可以把这套公式和表格整理进你当前的《地图float误差分析.md》，并补充“重定位与双浮拆分”的示例代码片段。






          
**结论**
- 在 z=20 时，用 float32 表示“局部坐标”范围 10 km 的误差约 0.008 像素；范围 100 km 的误差约 0.08 像素，均可忽略。前提是：shader 只处理局部小坐标（重定位到相机/瓦片中心），不要把它们直接加到世界级大坐标上。
- 若用 fp16 表示局部坐标，在 z=20 时 10 km 的误差约 65 像素、100 km 约 654 像素，严重不可用。
- 如果直接在 shader 里操作世界级大坐标（≈2×10^7 m），即使用 float32，在 z=20 时也会产生约 16 像素的量化误差；必须做“中心重定位/高低位拆分”。

**计算公式**
- 赤道处米/像素：`mpp(z) = 156543.03392 / 2^z`。
- 局部坐标量级为 `R` 米时的像素误差（仅受该局部值的量化影响）：
  - `ε_px(R, z; m) = R * 2^-m / mpp(z)`，其中 `m=23` 为 float32、`m=10` 为 fp16。
- 误差阈值设为 ≤ 0.5 像素时，局部坐标可用的最大范围：
  - `R_max(z; m) = 0.5 * mpp(z) * 2^m`
  - float32：`R_max_32(z) = 156543.03392 * 2^(22 - z)` 米
  - fp16：`R_max_16(z) = 156543.03392 * 2^(9 - z)` 米

**z=20 的数值示例**
- `mpp(20) ≈ 0.1492910708 m/px`
- 局部范围 10 km（`R=10,000 m`）：
  - float32：`ε_px ≈ 10000 * 2^-23 / 0.149291 ≈ 0.008 px`
  - fp16：`ε_px ≈ 10000 * 2^-10 / 0.149291 ≈ 65 px`
- 局部范围 100 km（`R=100,000 m`）：
  - float32：`ε_px ≈ 0.08 px`
  - fp16：`ε_px ≈ 654 px`
- z=20 的最大可用局部范围（误差≤0.5 px）：
  - float32：`R_max_32(20) ≈ 156543.03392 * 2^2 ≈ 626,172 m`（约 626 km）
  - fp16：`R_max_16(20) ≈ 156543.03392 * 2^-11 ≈ 76.44 m`

**小表（赤道；误差≤0.5 像素的最大局部范围）**
- 你关心的 z=20 为重点，同时给出相邻级别便于对比

| 级别 z | mpp(z) [m/px] | R_max_32 [m] | R_max_16 [m] |
|--------|----------------|--------------|--------------|
| 18     | 0.597164283    | 2,504,689    | 305.75       |
| 19     | 0.298582142    | 1,252,344    | 152.87       |
| 20     | 0.149291071    | 626,172      | 76.44        |
| 21     | 0.074645535    | 313,086      | 38.22        |
| 22     | 0.037322768    | 156,543      | 19.11        |

**使用建议**
- 在 z=20，若你“立即定点坐标 x,y 在 ±100000（米）范围内”，只要使用 float32 并将坐标重定位为局部坐标（相机或瓦片中心为原点），误差约 0.08 像素，可直接使用。
- 避免将局部偏移与“世界级大中心（≈2×10^7 m）”用单精度直接相加；请在 CPU 侧做中心平移或用 double→两段 float（高/低位）传给 shader，再在 shader 合并，以免小偏移被吞没。
        
