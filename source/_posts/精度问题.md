---
title: 精度问题
published: false
date: 2025-10-20 10:47:29
tags:
---



          
**问题拆解**
- 大范围坐标（如墨卡托 EPSG:3857，范围约 ±2.0038e7 米）用 `float` 直接渲染会失去子米级精度，出现抖动。
- 采用“相对原点”是标准解：CPU 用 `double` 存世界坐标和相机中心，GPU 只接收相机相对的小范围偏移（`float`），从而把数值量级压小，恢复精度。
- 是否“相对原点”足够，关键在于把世界空间误差映射到屏幕像素，并与可接受的像素抖动预算对比。

**精度基础**
- `float` 有约 24 位有效位，机器精度 `ε_float ≈ 1.19e−7`（相对误差）；误差上界 ≈ `ε_float * |值的量级|`。
- `double` 有约 53 位有效位，`ε_double ≈ 1.11e−16`，在渲染前的世界变换用它可以忽略精度问题。
- 不做相对原点时，`|值|≈2e7` 米，`float` 误差 ≈ 2e7 * 1e−7 ≈ 2 米；在高倍缩放下对应十几像素的抖动，不可接受。
- 做相对原点时，若局部偏移控制在 10 km 内，`float` 误差 ≈ 1e4 * 1e−7 ≈ 1.0e−3 米（约 1 毫米），通常可接受。

**墨卡托屏幕比例（Meters per Pixel）**
- 地面分辨率（每像素多少米）：
  - `mpp(φ, z) = 156543.03392 * cos(φ) / 2^z`，φ 为纬度（弧度），z 为缩放级别（256 像素瓦片）。
- 示例（赤道 φ≈0）：
  - `z=20` 时 `mpp ≈ 0.149 m/px`；在 60° 纬度处乘以 `cos(60°)=0.5`，约 `0.075 m/px`。

**评估方法（分析法）**
- 设相机相对原点后的局部坐标最大量级为 `L`（米），用 `float` 的世界空间误差上界：
  - `ε_world ≈ ε_float * L ≈ 1.19e−7 * L`
- 映射到屏幕像素误差：
  - `ε_px ≈ ε_world / mpp(φ, z)`
- 判断标准（举例）：
  - 若静态边界允许 ≤0.25 px 抖动，需满足 `ε_px ≤ 0.25`。
- 结论样例：
  - 若 `L=10,000m`，在 `z=20`、`φ=60°`，`mpp≈0.075`，则 `ε_px ≈ (1e−7*1e4)/0.075 ≈ 0.013 px`，满足。
  - 若不做相对原点、`L≈2e7m`，同条件 `ε_px ≈ (1e−7*2e7)/0.075 ≈ 26.7 px`，不满足。

**评估方法（实测法）**
- 屏幕抖动测试：
  - 固定一个世界点（double），每帧用当前相机计算其屏幕位置。
  - 相机做亚像素级平移（例如 0.1 px 的等效世界移动），记录该点的屏幕位置序列。
  - 计算帧间差的标准差/最大偏差，若超阈值（比如 0.25 px），说明精度不足。
- 变焦与纬度扫测：
  - 在多纬度、多缩放级下重复测试，找出最坏情况；常见最坏在高缩放且高纬度。

**推荐策略**
- 世界侧（CPU）
  - 所有经纬度与墨卡托投影使用 `double`。
  - 每帧或在相机移动超过阈值时做“Origin Rebasing”：`origin_double = camera_world_pos_double`。
  - 顶点位置用 `local_offset_float = (world_double − origin_double)` 下发到 GPU。
- GPU 侧
  - 顶点着色器用 `highp float`（移动端），变换矩阵尽量用 `float` 且源于 `double` 计算结果。
  - 需要超高精度时采用“hi/lo 拆分”（Cesium RTC 技术）：把 `double` 拆为两个 `float` 份额（高/低），在着色器中相加。
- 辅助
  - 深度精度：高缩放下用“反转 Z + 远近裁剪合理设置”，或 Logarithmic Depth，避免 Z-fighting 造成的抖动。
  - 邻接瓦片边界：对齐和量化顶点边界，避免浮点舍入导致裂缝。
  - 排序/合并：避免对浮点做精确相等比较，使用量化或 epsilon。

**快速判定函数示例（C++）**
- 评估 `float` 在相对原点后的像素误差是否满足阈值：
- 说明：`tileSize=256`；返回是否满足误差预算。
- 代码片段：
  ```
  #include <cmath>

  inline double metersPerPixel(double latitudeRadians, int zoom) {
      return 156543.03392 * std::cos(latitudeRadians) / std::pow(2.0, zoom);
  }

  inline double floatWorldErrorPx(double localExtentMeters, double latitudeRadians, int zoom) {
      constexpr double epsFloat = 1.1920928955078125e-7; // 2^-23, 相对误差上界
      const double mpp = metersPerPixel(latitudeRadians, zoom);
      const double epsWorld = epsFloat * localExtentMeters;
      return epsWorld / mpp;
  }

  inline bool precisionOkForRendering(double localExtentMeters, double latitudeRadians, int zoom,
                                      double pixelJitterBudget = 0.25) {
      return floatWorldErrorPx(localExtentMeters, latitudeRadians, zoom) <= pixelJitterBudget;
  }
  ```
- 用法示例：
  - `precisionOkForRendering(10000.0, latRad, 20)` 若返回 true，说明在 z=20、局部范围 10 km 下，使用 `float` + 相对原点满足 0.25 px 抖动预算。

**实践建议**
- 把“相对原点的局部范围上限”设为几公里～几十公里，根据你目标缩放级别和抖动预算求得。
- 在更高缩放或高纬度场景下，适当缩小局部范围或增加“hi/lo 拆分”。
- 记录一次评估结果：对你的产品常用纬度与缩放（例如 `z=16–22`）跑表，得到一张“局部范围上限 vs. 误差预算”的表，作为工程参数。

如果你提供具体的纬度范围、常用缩放级以及期望抖动阈值，我可以基于这些参数给出“相对原点局部范围的建议上限”，以及是否需要 hi/lo 技术。
        
